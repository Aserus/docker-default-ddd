var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __moduleCache = /* @__PURE__ */ new WeakMap;
var __toCommonJS = (from) => {
  var entry = __moduleCache.get(from), desc;
  if (entry)
    return entry;
  entry = __defProp({}, "__esModule", { value: true });
  if (from && typeof from === "object" || typeof from === "function")
    __getOwnPropNames(from).map((key) => !__hasOwnProp.call(entry, key) && __defProp(entry, key, {
      get: () => from[key],
      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
    }));
  __moduleCache.set(from, entry);
  return entry;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS((exports, module) => {
  function reusify(Constructor) {
    var head = new Constructor;
    var tail = head;
    function get() {
      var current = head;
      if (current.next) {
        head = current.next;
      } else {
        head = new Constructor;
        tail = head;
      }
      current.next = null;
      return current;
    }
    function release(obj) {
      tail.next = obj;
      tail = obj;
    }
    return {
      get,
      release
    };
  }
  module.exports = reusify;
});

// node_modules/fastq/queue.js
var require_queue = __commonJS((exports, module) => {
  var reusify = require_reusify();
  function fastqueue(context, worker, _concurrency) {
    if (typeof context === "function") {
      _concurrency = worker;
      worker = context;
      context = null;
    }
    if (!(_concurrency >= 1)) {
      throw new Error("fastqueue concurrency must be equal to or greater than 1");
    }
    var cache = reusify(Task);
    var queueHead = null;
    var queueTail = null;
    var _running = 0;
    var errorHandler = null;
    var self2 = {
      push,
      drain: noop,
      saturated: noop,
      pause,
      paused: false,
      get concurrency() {
        return _concurrency;
      },
      set concurrency(value) {
        if (!(value >= 1)) {
          throw new Error("fastqueue concurrency must be equal to or greater than 1");
        }
        _concurrency = value;
        if (self2.paused)
          return;
        for (;queueHead && _running < _concurrency; ) {
          _running++;
          release();
        }
      },
      running,
      resume,
      idle,
      length,
      getQueue,
      unshift,
      empty: noop,
      kill,
      killAndDrain,
      error
    };
    return self2;
    function running() {
      return _running;
    }
    function pause() {
      self2.paused = true;
    }
    function length() {
      var current = queueHead;
      var counter = 0;
      while (current) {
        current = current.next;
        counter++;
      }
      return counter;
    }
    function getQueue() {
      var current = queueHead;
      var tasks = [];
      while (current) {
        tasks.push(current.value);
        current = current.next;
      }
      return tasks;
    }
    function resume() {
      if (!self2.paused)
        return;
      self2.paused = false;
      if (queueHead === null) {
        _running++;
        release();
        return;
      }
      for (;queueHead && _running < _concurrency; ) {
        _running++;
        release();
      }
    }
    function idle() {
      return _running === 0 && self2.length() === 0;
    }
    function push(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running >= _concurrency || self2.paused) {
        if (queueTail) {
          queueTail.next = current;
          queueTail = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function unshift(value, done) {
      var current = cache.get();
      current.context = context;
      current.release = release;
      current.value = value;
      current.callback = done || noop;
      current.errorHandler = errorHandler;
      if (_running >= _concurrency || self2.paused) {
        if (queueHead) {
          current.next = queueHead;
          queueHead = current;
        } else {
          queueHead = current;
          queueTail = current;
          self2.saturated();
        }
      } else {
        _running++;
        worker.call(context, current.value, current.worked);
      }
    }
    function release(holder) {
      if (holder) {
        cache.release(holder);
      }
      var next = queueHead;
      if (next && _running <= _concurrency) {
        if (!self2.paused) {
          if (queueTail === queueHead) {
            queueTail = null;
          }
          queueHead = next.next;
          next.next = null;
          worker.call(context, next.value, next.worked);
          if (queueTail === null) {
            self2.empty();
          }
        } else {
          _running--;
        }
      } else if (--_running === 0) {
        self2.drain();
      }
    }
    function kill() {
      queueHead = null;
      queueTail = null;
      self2.drain = noop;
    }
    function killAndDrain() {
      queueHead = null;
      queueTail = null;
      self2.drain();
      self2.drain = noop;
    }
    function error(handler) {
      errorHandler = handler;
    }
  }
  function noop() {}
  function Task() {
    this.value = null;
    this.callback = noop;
    this.next = null;
    this.release = noop;
    this.context = null;
    this.errorHandler = null;
    var self2 = this;
    this.worked = function worked(err, result) {
      var callback = self2.callback;
      var errorHandler = self2.errorHandler;
      var val = self2.value;
      self2.value = null;
      self2.callback = noop;
      if (self2.errorHandler) {
        errorHandler(err, val);
      }
      callback.call(self2.context, err, result);
      self2.release(self2);
    };
  }
  function queueAsPromised(context, worker, _concurrency) {
    if (typeof context === "function") {
      _concurrency = worker;
      worker = context;
      context = null;
    }
    function asyncWrapper(arg, cb) {
      worker.call(this, arg).then(function(res) {
        cb(null, res);
      }, cb);
    }
    var queue = fastqueue(context, asyncWrapper, _concurrency);
    var pushCb = queue.push;
    var unshiftCb = queue.unshift;
    queue.push = push;
    queue.unshift = unshift;
    queue.drained = drained;
    return queue;
    function push(value) {
      var p = new Promise(function(resolve, reject) {
        pushCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
      p.catch(noop);
      return p;
    }
    function unshift(value) {
      var p = new Promise(function(resolve, reject) {
        unshiftCb(value, function(err, result) {
          if (err) {
            reject(err);
            return;
          }
          resolve(result);
        });
      });
      p.catch(noop);
      return p;
    }
    function drained() {
      var p = new Promise(function(resolve) {
        process.nextTick(function() {
          if (queue.idle()) {
            resolve();
          } else {
            var previousDrain = queue.drain;
            queue.drain = function() {
              if (typeof previousDrain === "function")
                previousDrain();
              resolve();
              queue.drain = previousDrain;
            };
          }
        });
      });
      return p;
    }
  }
  module.exports = fastqueue;
  module.exports.promise = queueAsPromised;
});

// node:events
var exports_events = {};
__export(exports_events, {
  prototype: () => P,
  once: () => M,
  default: () => A,
  EventEmitter: () => o
});
function x(t) {
  console && console.warn && console.warn(t);
}
function o() {
  o.init.call(this);
}
function v(t) {
  if (typeof t != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
}
function m(t) {
  return t._maxListeners === undefined ? o.defaultMaxListeners : t._maxListeners;
}
function y(t, e, n, r) {
  var i, f, s;
  if (v(n), f = t._events, f === undefined ? (f = t._events = Object.create(null), t._eventsCount = 0) : (f.newListener !== undefined && (t.emit("newListener", e, n.listener ? n.listener : n), f = t._events), s = f[e]), s === undefined)
    s = f[e] = n, ++t._eventsCount;
  else if (typeof s == "function" ? s = f[e] = r ? [n, s] : [s, n] : r ? s.unshift(n) : s.push(n), i = m(t), i > 0 && s.length > i && !s.warned) {
    s.warned = true;
    var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = t, u.type = e, u.count = s.length, x(u);
  }
  return t;
}
function C() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function g(t, e, n) {
  var r = { fired: false, wrapFn: undefined, target: t, type: e, listener: n }, i = C.bind(r);
  return i.listener = n, r.wrapFn = i, i;
}
function _(t, e, n) {
  var r = t._events;
  if (r === undefined)
    return [];
  var i = r[e];
  return i === undefined ? [] : typeof i == "function" ? n ? [i.listener || i] : [i] : n ? R(i) : b(i, i.length);
}
function w(t) {
  var e = this._events;
  if (e !== undefined) {
    var n = e[t];
    if (typeof n == "function")
      return 1;
    if (n !== undefined)
      return n.length;
  }
  return 0;
}
function b(t, e) {
  for (var n = new Array(e), r = 0;r < e; ++r)
    n[r] = t[r];
  return n;
}
function j(t, e) {
  for (;e + 1 < t.length; e++)
    t[e] = t[e + 1];
  t.pop();
}
function R(t) {
  for (var e = new Array(t.length), n = 0;n < e.length; ++n)
    e[n] = t[n].listener || t[n];
  return e;
}
function M(t, e) {
  return new Promise(function(n, r) {
    function i(s) {
      t.removeListener(e, f), r(s);
    }
    function f() {
      typeof t.removeListener == "function" && t.removeListener("error", i), n([].slice.call(arguments));
    }
    E(t, e, f, { once: true }), e !== "error" && N(t, i, { once: true });
  });
}
function N(t, e, n) {
  typeof t.on == "function" && E(t, "error", e, n);
}
function E(t, e, n, r) {
  if (typeof t.on == "function")
    r.once ? t.once(e, n) : t.on(e, n);
  else if (typeof t.addEventListener == "function")
    t.addEventListener(e, function i(f) {
      r.once && t.removeEventListener(e, i), n(f);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
}
var a, d, l, L, h = 10, A, P;
var init_events = __esm(() => {
  a = typeof Reflect == "object" ? Reflect : null;
  d = a && typeof a.apply == "function" ? a.apply : function(e, n, r) {
    return Function.prototype.apply.call(e, n, r);
  };
  a && typeof a.ownKeys == "function" ? l = a.ownKeys : Object.getOwnPropertySymbols ? l = function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  } : l = function(e) {
    return Object.getOwnPropertyNames(e);
  };
  L = Number.isNaN || function(e) {
    return e !== e;
  };
  o.EventEmitter = o;
  o.prototype._events = undefined;
  o.prototype._eventsCount = 0;
  o.prototype._maxListeners = undefined;
  Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
    return h;
  }, set: function(t) {
    if (typeof t != "number" || t < 0 || L(t))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
    h = t;
  } });
  o.init = function() {
    (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
  };
  o.prototype.setMaxListeners = function(e) {
    if (typeof e != "number" || e < 0 || L(e))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  };
  o.prototype.getMaxListeners = function() {
    return m(this);
  };
  o.prototype.emit = function(e) {
    for (var n = [], r = 1;r < arguments.length; r++)
      n.push(arguments[r]);
    var i = e === "error", f = this._events;
    if (f !== undefined)
      i = i && f.error === undefined;
    else if (!i)
      return false;
    if (i) {
      var s;
      if (n.length > 0 && (s = n[0]), s instanceof Error)
        throw s;
      var u = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
      throw u.context = s, u;
    }
    var c = f[e];
    if (c === undefined)
      return false;
    if (typeof c == "function")
      d(c, this, n);
    else
      for (var p = c.length, O = b(c, p), r = 0;r < p; ++r)
        d(O[r], this, n);
    return true;
  };
  o.prototype.addListener = function(e, n) {
    return y(this, e, n, false);
  };
  o.prototype.on = o.prototype.addListener;
  o.prototype.prependListener = function(e, n) {
    return y(this, e, n, true);
  };
  o.prototype.once = function(e, n) {
    return v(n), this.on(e, g(this, e, n)), this;
  };
  o.prototype.prependOnceListener = function(e, n) {
    return v(n), this.prependListener(e, g(this, e, n)), this;
  };
  o.prototype.removeListener = function(e, n) {
    var r, i, f, s, u;
    if (v(n), i = this._events, i === undefined)
      return this;
    if (r = i[e], r === undefined)
      return this;
    if (r === n || r.listener === n)
      --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, r.listener || n));
    else if (typeof r != "function") {
      for (f = -1, s = r.length - 1;s >= 0; s--)
        if (r[s] === n || r[s].listener === n) {
          u = r[s].listener, f = s;
          break;
        }
      if (f < 0)
        return this;
      f === 0 ? r.shift() : j(r, f), r.length === 1 && (i[e] = r[0]), i.removeListener !== undefined && this.emit("removeListener", e, u || n);
    }
    return this;
  };
  o.prototype.off = o.prototype.removeListener;
  o.prototype.removeAllListeners = function(e) {
    var n, r, i;
    if (r = this._events, r === undefined)
      return this;
    if (r.removeListener === undefined)
      return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : r[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete r[e]), this;
    if (arguments.length === 0) {
      var f = Object.keys(r), s;
      for (i = 0;i < f.length; ++i)
        s = f[i], s !== "removeListener" && this.removeAllListeners(s);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if (n = r[e], typeof n == "function")
      this.removeListener(e, n);
    else if (n !== undefined)
      for (i = n.length - 1;i >= 0; i--)
        this.removeListener(e, n[i]);
    return this;
  };
  o.prototype.listeners = function(e) {
    return _(this, e, true);
  };
  o.prototype.rawListeners = function(e) {
    return _(this, e, false);
  };
  o.listenerCount = function(t, e) {
    return typeof t.listenerCount == "function" ? t.listenerCount(e) : w.call(t, e);
  };
  o.prototype.listenerCount = w;
  o.prototype.eventNames = function() {
    return this._eventsCount > 0 ? l(this._events) : [];
  };
  A = o;
  P = o.prototype;
});

// node:util
var exports_util = {};
__export(exports_util, {
  default: () => so,
  TextEncoder: () => st,
  TextDecoder: () => ct
});
var pt, dr, lt, gt, dt, bt, p = (r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), At = (r, e) => {
  for (var t in e)
    dr(r, t, { get: e[t], enumerable: true });
}, gr = (r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o2 of gt(e))
      !bt.call(r, o2) && o2 !== t && dr(r, o2, { get: () => e[o2], enumerable: !(n = lt(e, o2)) || n.enumerable });
  return r;
}, F = (r, e, t) => (gr(r, e, "default"), t && gr(t, e, "default")), mt = (r, e, t) => (t = r != null ? pt(dt(r)) : {}, gr(e || !r || !r.__esModule ? dr(t, "default", { value: r, enumerable: true }) : t, r)), br, N2, Zr, Kr, V, re, H, ce, Y, Ae, Se, Pe, Fr, Br, Ur, Rr, qe, rt, tt, nt, yt, E2, st, ct, so;
var init_util = __esm(() => {
  pt = Object.create;
  dr = Object.defineProperty;
  lt = Object.getOwnPropertyDescriptor;
  gt = Object.getOwnPropertyNames;
  dt = Object.getPrototypeOf;
  bt = Object.prototype.hasOwnProperty;
  br = p((po, Vr) => {
    Vr.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var e = {}, t = Symbol("test"), n = Object(t);
      if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return false;
      var o2 = 42;
      e[t] = o2;
      for (t in e)
        return false;
      if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
        return false;
      var i = Object.getOwnPropertySymbols(e);
      if (i.length !== 1 || i[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a2 = Object.getOwnPropertyDescriptor(e, t);
        if (a2.value !== o2 || a2.enumerable !== true)
          return false;
      }
      return true;
    };
  });
  N2 = p((lo, Jr) => {
    var ht = br();
    Jr.exports = function() {
      return ht() && !!Symbol.toStringTag;
    };
  });
  Zr = p((go, Hr) => {
    var Lr = typeof Symbol < "u" && Symbol, St = br();
    Hr.exports = function() {
      return typeof Lr != "function" || typeof Symbol != "function" || typeof Lr("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : St();
    };
  });
  Kr = p((bo, Yr) => {
    var vt = "Function.prototype.bind called on incompatible ", Ar = Array.prototype.slice, Ot = Object.prototype.toString, jt = "[object Function]";
    Yr.exports = function(e) {
      var t = this;
      if (typeof t != "function" || Ot.call(t) !== jt)
        throw new TypeError(vt + t);
      for (var n = Ar.call(arguments, 1), o2, i = function() {
        if (this instanceof o2) {
          var g2 = t.apply(this, n.concat(Ar.call(arguments)));
          return Object(g2) === g2 ? g2 : this;
        } else
          return t.apply(e, n.concat(Ar.call(arguments)));
      }, a2 = Math.max(0, t.length - n.length), f = [], c = 0;c < a2; c++)
        f.push("$" + c);
      if (o2 = Function("binder", "return function (" + f.join(",") + "){ return binder.apply(this,arguments); }")(i), t.prototype) {
        var l2 = function() {};
        l2.prototype = t.prototype, o2.prototype = new l2, l2.prototype = null;
      }
      return o2;
    };
  });
  V = p((Ao, Qr) => {
    var Pt = Kr();
    Qr.exports = Function.prototype.bind || Pt;
  });
  re = p((mo, Xr) => {
    var wt = V();
    Xr.exports = wt.call(Function.call, Object.prototype.hasOwnProperty);
  });
  H = p((ho, ie) => {
    var s, x2 = SyntaxError, oe = Function, U = TypeError, mr = function(r) {
      try {
        return oe('"use strict"; return (' + r + ").constructor;")();
      } catch {}
    }, v2 = Object.getOwnPropertyDescriptor;
    if (v2)
      try {
        v2({}, "");
      } catch {
        v2 = null;
      }
    var hr = function() {
      throw new U;
    }, Et = v2 ? function() {
      try {
        return arguments.callee, hr;
      } catch {
        try {
          return v2(arguments, "callee").get;
        } catch {
          return hr;
        }
      }
    }() : hr, I = Zr()(), m2 = Object.getPrototypeOf || function(r) {
      return r.__proto__;
    }, B = {}, Tt = typeof Uint8Array > "u" ? s : m2(Uint8Array), O = { "%AggregateError%": typeof AggregateError > "u" ? s : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? s : ArrayBuffer, "%ArrayIteratorPrototype%": I ? m2([][Symbol.iterator]()) : s, "%AsyncFromSyncIteratorPrototype%": s, "%AsyncFunction%": B, "%AsyncGenerator%": B, "%AsyncGeneratorFunction%": B, "%AsyncIteratorPrototype%": B, "%Atomics%": typeof Atomics > "u" ? s : Atomics, "%BigInt%": typeof BigInt > "u" ? s : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? s : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? s : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? s : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? s : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? s : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? s : FinalizationRegistry, "%Function%": oe, "%GeneratorFunction%": B, "%Int8Array%": typeof Int8Array > "u" ? s : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? s : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? s : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": I ? m2(m2([][Symbol.iterator]())) : s, "%JSON%": typeof JSON == "object" ? JSON : s, "%Map%": typeof Map > "u" ? s : Map, "%MapIteratorPrototype%": typeof Map > "u" || !I ? s : m2(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? s : Promise, "%Proxy%": typeof Proxy > "u" ? s : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? s : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? s : Set, "%SetIteratorPrototype%": typeof Set > "u" || !I ? s : m2(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? s : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": I ? m2(""[Symbol.iterator]()) : s, "%Symbol%": I ? Symbol : s, "%SyntaxError%": x2, "%ThrowTypeError%": Et, "%TypedArray%": Tt, "%TypeError%": U, "%Uint8Array%": typeof Uint8Array > "u" ? s : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? s : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? s : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? s : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? s : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? s : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? s : WeakSet };
    try {
      null.error;
    } catch (r) {
      ee = m2(m2(r)), O["%Error.prototype%"] = ee;
    }
    var ee, Ft = function r(e) {
      var t;
      if (e === "%AsyncFunction%")
        t = mr("async function () {}");
      else if (e === "%GeneratorFunction%")
        t = mr("function* () {}");
      else if (e === "%AsyncGeneratorFunction%")
        t = mr("async function* () {}");
      else if (e === "%AsyncGenerator%") {
        var n = r("%AsyncGeneratorFunction%");
        n && (t = n.prototype);
      } else if (e === "%AsyncIteratorPrototype%") {
        var o2 = r("%AsyncGenerator%");
        o2 && (t = m2(o2.prototype));
      }
      return O[e] = t, t;
    }, te = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, C2 = V(), J = re(), It = C2.call(Function.call, Array.prototype.concat), Bt = C2.call(Function.apply, Array.prototype.splice), ne = C2.call(Function.call, String.prototype.replace), L2 = C2.call(Function.call, String.prototype.slice), Ut = C2.call(Function.call, RegExp.prototype.exec), xt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Dt = /\\(\\)?/g, Rt = function(e) {
      var t = L2(e, 0, 1), n = L2(e, -1);
      if (t === "%" && n !== "%")
        throw new x2("invalid intrinsic syntax, expected closing `%`");
      if (n === "%" && t !== "%")
        throw new x2("invalid intrinsic syntax, expected opening `%`");
      var o2 = [];
      return ne(e, xt, function(i, a2, f, c) {
        o2[o2.length] = f ? ne(c, Dt, "$1") : a2 || i;
      }), o2;
    }, kt = function(e, t) {
      var n = e, o2;
      if (J(te, n) && (o2 = te[n], n = "%" + o2[0] + "%"), J(O, n)) {
        var i = O[n];
        if (i === B && (i = Ft(n)), typeof i > "u" && !t)
          throw new U("intrinsic " + e + " exists, but is not available. Please file an issue!");
        return { alias: o2, name: n, value: i };
      }
      throw new x2("intrinsic " + e + " does not exist!");
    };
    ie.exports = function(e, t) {
      if (typeof e != "string" || e.length === 0)
        throw new U("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof t != "boolean")
        throw new U('"allowMissing" argument must be a boolean');
      if (Ut(/^%?[^%]*%?$/, e) === null)
        throw new x2("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var n = Rt(e), o2 = n.length > 0 ? n[0] : "", i = kt("%" + o2 + "%", t), a2 = i.name, f = i.value, c = false, l2 = i.alias;
      l2 && (o2 = l2[0], Bt(n, It([0, 1], l2)));
      for (var g2 = 1, S = true;g2 < n.length; g2 += 1) {
        var d2 = n[g2], T = L2(d2, 0, 1), _2 = L2(d2, -1);
        if ((T === '"' || T === "'" || T === "`" || _2 === '"' || _2 === "'" || _2 === "`") && T !== _2)
          throw new x2("property names with quotes must have matching quotes");
        if ((d2 === "constructor" || !S) && (c = true), o2 += "." + d2, a2 = "%" + o2 + "%", J(O, a2))
          f = O[a2];
        else if (f != null) {
          if (!(d2 in f)) {
            if (!t)
              throw new U("base intrinsic for " + e + " exists, but the property is not available.");
            return;
          }
          if (v2 && g2 + 1 >= n.length) {
            var z = v2(f, d2);
            S = !!z, S && "get" in z && !("originalValue" in z.get) ? f = z.get : f = f[d2];
          } else
            S = J(f, d2), f = f[d2];
          S && !c && (O[a2] = f);
        }
      }
      return f;
    };
  });
  ce = p((So, Z) => {
    var Sr = V(), D = H(), ue = D("%Function.prototype.apply%"), ye = D("%Function.prototype.call%"), se = D("%Reflect.apply%", true) || Sr.call(ye, ue), ae = D("%Object.getOwnPropertyDescriptor%", true), j2 = D("%Object.defineProperty%", true), Mt = D("%Math.max%");
    if (j2)
      try {
        j2({}, "a", { value: 1 });
      } catch {
        j2 = null;
      }
    Z.exports = function(e) {
      var t = se(Sr, ye, arguments);
      if (ae && j2) {
        var n = ae(t, "length");
        n.configurable && j2(t, "length", { value: 1 + Mt(0, e.length - (arguments.length - 1)) });
      }
      return t;
    };
    var fe = function() {
      return se(Sr, ue, arguments);
    };
    j2 ? j2(Z.exports, "apply", { value: fe }) : Z.exports.apply = fe;
  });
  Y = p((vo, ge) => {
    var pe = H(), le = ce(), Nt = le(pe("String.prototype.indexOf"));
    ge.exports = function(e, t) {
      var n = pe(e, !!t);
      return typeof n == "function" && Nt(e, ".prototype.") > -1 ? le(n) : n;
    };
  });
  Ae = p((Oo, be) => {
    var Ct = N2()(), $t = Y(), vr = $t("Object.prototype.toString"), K = function(e) {
      return Ct && e && typeof e == "object" && Symbol.toStringTag in e ? false : vr(e) === "[object Arguments]";
    }, de = function(e) {
      return K(e) ? true : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && vr(e) !== "[object Array]" && vr(e.callee) === "[object Function]";
    }, qt = function() {
      return K(arguments);
    }();
    K.isLegacyArguments = de;
    be.exports = qt ? K : de;
  });
  Se = p((jo, he) => {
    var Gt = Object.prototype.toString, Wt = Function.prototype.toString, _t = /^\s*(?:function)?\*/, me = N2()(), Or = Object.getPrototypeOf, zt = function() {
      if (!me)
        return false;
      try {
        return Function("return function*() {}")();
      } catch {}
    }, jr;
    he.exports = function(e) {
      if (typeof e != "function")
        return false;
      if (_t.test(Wt.call(e)))
        return true;
      if (!me) {
        var t = Gt.call(e);
        return t === "[object GeneratorFunction]";
      }
      if (!Or)
        return false;
      if (typeof jr > "u") {
        var n = zt();
        jr = n ? Or(n) : false;
      }
      return Or(e) === jr;
    };
  });
  Pe = p((Po, je) => {
    var Oe = Function.prototype.toString, R2 = typeof Reflect == "object" && Reflect !== null && Reflect.apply, wr, Q;
    if (typeof R2 == "function" && typeof Object.defineProperty == "function")
      try {
        wr = Object.defineProperty({}, "length", { get: function() {
          throw Q;
        } }), Q = {}, R2(function() {
          throw 42;
        }, null, wr);
      } catch (r) {
        r !== Q && (R2 = null);
      }
    else
      R2 = null;
    var Vt = /^\s*class\b/, Er = function(e) {
      try {
        var t = Oe.call(e);
        return Vt.test(t);
      } catch {
        return false;
      }
    }, Pr = function(e) {
      try {
        return Er(e) ? false : (Oe.call(e), true);
      } catch {
        return false;
      }
    }, X = Object.prototype.toString, Jt = "[object Object]", Lt = "[object Function]", Ht = "[object GeneratorFunction]", Zt = "[object HTMLAllCollection]", Yt = "[object HTML document.all class]", Kt = "[object HTMLCollection]", Qt = typeof Symbol == "function" && !!Symbol.toStringTag, Xt = !(0 in [,]), Tr = function() {
      return false;
    };
    typeof document == "object" && (ve = document.all, X.call(ve) === X.call(document.all) && (Tr = function(e) {
      if ((Xt || !e) && (typeof e > "u" || typeof e == "object"))
        try {
          var t = X.call(e);
          return (t === Zt || t === Yt || t === Kt || t === Jt) && e("") == null;
        } catch {}
      return false;
    }));
    var ve;
    je.exports = R2 ? function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      try {
        R2(e, null, wr);
      } catch (t) {
        if (t !== Q)
          return false;
      }
      return !Er(e) && Pr(e);
    } : function(e) {
      if (Tr(e))
        return true;
      if (!e || typeof e != "function" && typeof e != "object")
        return false;
      if (Qt)
        return Pr(e);
      if (Er(e))
        return false;
      var t = X.call(e);
      return t !== Lt && t !== Ht && !/^\[object HTML/.test(t) ? false : Pr(e);
    };
  });
  Fr = p((wo, Ee) => {
    var rn = Pe(), en = Object.prototype.toString, we = Object.prototype.hasOwnProperty, tn = function(e, t, n) {
      for (var o2 = 0, i = e.length;o2 < i; o2++)
        we.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
    }, nn = function(e, t, n) {
      for (var o2 = 0, i = e.length;o2 < i; o2++)
        n == null ? t(e.charAt(o2), o2, e) : t.call(n, e.charAt(o2), o2, e);
    }, on = function(e, t, n) {
      for (var o2 in e)
        we.call(e, o2) && (n == null ? t(e[o2], o2, e) : t.call(n, e[o2], o2, e));
    }, an = function(e, t, n) {
      if (!rn(t))
        throw new TypeError("iterator must be a function");
      var o2;
      arguments.length >= 3 && (o2 = n), en.call(e) === "[object Array]" ? tn(e, t, o2) : typeof e == "string" ? nn(e, t, o2) : on(e, t, o2);
    };
    Ee.exports = an;
  });
  Br = p((Eo, Te) => {
    var Ir = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], fn = typeof globalThis > "u" ? global : globalThis;
    Te.exports = function() {
      for (var e = [], t = 0;t < Ir.length; t++)
        typeof fn[Ir[t]] == "function" && (e[e.length] = Ir[t]);
      return e;
    };
  });
  Ur = p((To, Fe) => {
    var un = H(), rr = un("%Object.getOwnPropertyDescriptor%", true);
    if (rr)
      try {
        rr([], "length");
      } catch {
        rr = null;
      }
    Fe.exports = rr;
  });
  Rr = p((Fo, De) => {
    var Ie = Fr(), yn = Br(), Dr = Y(), sn = Dr("Object.prototype.toString"), Be = N2()(), er = Ur(), cn = typeof globalThis > "u" ? global : globalThis, Ue = yn(), pn = Dr("Array.prototype.indexOf", true) || function(e, t) {
      for (var n = 0;n < e.length; n += 1)
        if (e[n] === t)
          return n;
      return -1;
    }, ln = Dr("String.prototype.slice"), xe = {}, xr = Object.getPrototypeOf;
    Be && er && xr && Ie(Ue, function(r) {
      var e = new cn[r];
      if (Symbol.toStringTag in e) {
        var t = xr(e), n = er(t, Symbol.toStringTag);
        if (!n) {
          var o2 = xr(t);
          n = er(o2, Symbol.toStringTag);
        }
        xe[r] = n.get;
      }
    });
    var gn = function(e) {
      var t = false;
      return Ie(xe, function(n, o2) {
        if (!t)
          try {
            t = n.call(e) === o2;
          } catch {}
      }), t;
    };
    De.exports = function(e) {
      if (!e || typeof e != "object")
        return false;
      if (!Be || !(Symbol.toStringTag in e)) {
        var t = ln(sn(e), 8, -1);
        return pn(Ue, t) > -1;
      }
      return er ? gn(e) : false;
    };
  });
  qe = p((Io, $e) => {
    var ke = Fr(), dn = Br(), Me = Y(), kr = Ur(), bn = Me("Object.prototype.toString"), Ne = N2()(), Re = typeof globalThis > "u" ? global : globalThis, An = dn(), mn = Me("String.prototype.slice"), Ce = {}, Mr = Object.getPrototypeOf;
    Ne && kr && Mr && ke(An, function(r) {
      if (typeof Re[r] == "function") {
        var e = new Re[r];
        if (Symbol.toStringTag in e) {
          var t = Mr(e), n = kr(t, Symbol.toStringTag);
          if (!n) {
            var o2 = Mr(t);
            n = kr(o2, Symbol.toStringTag);
          }
          Ce[r] = n.get;
        }
      }
    });
    var hn = function(e) {
      var t = false;
      return ke(Ce, function(n, o2) {
        if (!t)
          try {
            var i = n.call(e);
            i === o2 && (t = i);
          } catch {}
      }), t;
    }, Sn = Rr();
    $e.exports = function(e) {
      return Sn(e) ? !Ne || !(Symbol.toStringTag in e) ? mn(bn(e), 8, -1) : hn(e) : false;
    };
  });
  rt = p((u) => {
    var vn = Ae(), On = Se(), A2 = qe(), Ge = Rr();
    function k(r) {
      return r.call.bind(r);
    }
    var We = typeof BigInt < "u", _e = typeof Symbol < "u", b2 = k(Object.prototype.toString), jn = k(Number.prototype.valueOf), Pn = k(String.prototype.valueOf), wn = k(Boolean.prototype.valueOf);
    We && (ze = k(BigInt.prototype.valueOf));
    var ze;
    _e && (Ve = k(Symbol.prototype.valueOf));
    var Ve;
    function q(r, e) {
      if (typeof r != "object")
        return false;
      try {
        return e(r), true;
      } catch {
        return false;
      }
    }
    u.isArgumentsObject = vn;
    u.isGeneratorFunction = On;
    u.isTypedArray = Ge;
    function En(r) {
      return typeof Promise < "u" && r instanceof Promise || r !== null && typeof r == "object" && typeof r.then == "function" && typeof r.catch == "function";
    }
    u.isPromise = En;
    function Tn(r) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(r) : Ge(r) || Le(r);
    }
    u.isArrayBufferView = Tn;
    function Fn(r) {
      return A2(r) === "Uint8Array";
    }
    u.isUint8Array = Fn;
    function In(r) {
      return A2(r) === "Uint8ClampedArray";
    }
    u.isUint8ClampedArray = In;
    function Bn(r) {
      return A2(r) === "Uint16Array";
    }
    u.isUint16Array = Bn;
    function Un(r) {
      return A2(r) === "Uint32Array";
    }
    u.isUint32Array = Un;
    function xn(r) {
      return A2(r) === "Int8Array";
    }
    u.isInt8Array = xn;
    function Dn(r) {
      return A2(r) === "Int16Array";
    }
    u.isInt16Array = Dn;
    function Rn(r) {
      return A2(r) === "Int32Array";
    }
    u.isInt32Array = Rn;
    function kn(r) {
      return A2(r) === "Float32Array";
    }
    u.isFloat32Array = kn;
    function Mn(r) {
      return A2(r) === "Float64Array";
    }
    u.isFloat64Array = Mn;
    function Nn(r) {
      return A2(r) === "BigInt64Array";
    }
    u.isBigInt64Array = Nn;
    function Cn(r) {
      return A2(r) === "BigUint64Array";
    }
    u.isBigUint64Array = Cn;
    function tr(r) {
      return b2(r) === "[object Map]";
    }
    tr.working = typeof Map < "u" && tr(new Map);
    function $n(r) {
      return typeof Map > "u" ? false : tr.working ? tr(r) : r instanceof Map;
    }
    u.isMap = $n;
    function nr(r) {
      return b2(r) === "[object Set]";
    }
    nr.working = typeof Set < "u" && nr(new Set);
    function qn(r) {
      return typeof Set > "u" ? false : nr.working ? nr(r) : r instanceof Set;
    }
    u.isSet = qn;
    function or(r) {
      return b2(r) === "[object WeakMap]";
    }
    or.working = typeof WeakMap < "u" && or(new WeakMap);
    function Gn(r) {
      return typeof WeakMap > "u" ? false : or.working ? or(r) : r instanceof WeakMap;
    }
    u.isWeakMap = Gn;
    function Cr(r) {
      return b2(r) === "[object WeakSet]";
    }
    Cr.working = typeof WeakSet < "u" && Cr(new WeakSet);
    function Wn(r) {
      return Cr(r);
    }
    u.isWeakSet = Wn;
    function ir(r) {
      return b2(r) === "[object ArrayBuffer]";
    }
    ir.working = typeof ArrayBuffer < "u" && ir(new ArrayBuffer);
    function Je(r) {
      return typeof ArrayBuffer > "u" ? false : ir.working ? ir(r) : r instanceof ArrayBuffer;
    }
    u.isArrayBuffer = Je;
    function ar(r) {
      return b2(r) === "[object DataView]";
    }
    ar.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ar(new DataView(new ArrayBuffer(1), 0, 1));
    function Le(r) {
      return typeof DataView > "u" ? false : ar.working ? ar(r) : r instanceof DataView;
    }
    u.isDataView = Le;
    var Nr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : undefined;
    function $(r) {
      return b2(r) === "[object SharedArrayBuffer]";
    }
    function He(r) {
      return typeof Nr > "u" ? false : (typeof $.working > "u" && ($.working = $(new Nr)), $.working ? $(r) : r instanceof Nr);
    }
    u.isSharedArrayBuffer = He;
    function _n(r) {
      return b2(r) === "[object AsyncFunction]";
    }
    u.isAsyncFunction = _n;
    function zn(r) {
      return b2(r) === "[object Map Iterator]";
    }
    u.isMapIterator = zn;
    function Vn(r) {
      return b2(r) === "[object Set Iterator]";
    }
    u.isSetIterator = Vn;
    function Jn(r) {
      return b2(r) === "[object Generator]";
    }
    u.isGeneratorObject = Jn;
    function Ln(r) {
      return b2(r) === "[object WebAssembly.Module]";
    }
    u.isWebAssemblyCompiledModule = Ln;
    function Ze(r) {
      return q(r, jn);
    }
    u.isNumberObject = Ze;
    function Ye(r) {
      return q(r, Pn);
    }
    u.isStringObject = Ye;
    function Ke(r) {
      return q(r, wn);
    }
    u.isBooleanObject = Ke;
    function Qe(r) {
      return We && q(r, ze);
    }
    u.isBigIntObject = Qe;
    function Xe(r) {
      return _e && q(r, Ve);
    }
    u.isSymbolObject = Xe;
    function Hn(r) {
      return Ze(r) || Ye(r) || Ke(r) || Qe(r) || Xe(r);
    }
    u.isBoxedPrimitive = Hn;
    function Zn(r) {
      return typeof Uint8Array < "u" && (Je(r) || He(r));
    }
    u.isAnyArrayBuffer = Zn;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(r) {
      Object.defineProperty(u, r, { enumerable: false, value: function() {
        throw new Error(r + " is not supported in userland");
      } });
    });
  });
  tt = p((Uo, et) => {
    et.exports = function(e) {
      return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
    };
  });
  nt = p((xo, $r) => {
    typeof Object.create == "function" ? $r.exports = function(e, t) {
      t && (e.super_ = t, e.prototype = Object.create(t.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : $r.exports = function(e, t) {
      if (t) {
        e.super_ = t;
        var n = function() {};
        n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;
      }
    };
  });
  yt = p((y2) => {
    var ot = Object.getOwnPropertyDescriptors || function(e) {
      for (var t = Object.keys(e), n = {}, o2 = 0;o2 < t.length; o2++)
        n[t[o2]] = Object.getOwnPropertyDescriptor(e, t[o2]);
      return n;
    }, Yn = /%[sdj%]/g;
    y2.format = function(r) {
      if (!lr(r)) {
        for (var e = [], t = 0;t < arguments.length; t++)
          e.push(h2(arguments[t]));
        return e.join(" ");
      }
      for (var t = 1, n = arguments, o2 = n.length, i = String(r).replace(Yn, function(f) {
        if (f === "%%")
          return "%";
        if (t >= o2)
          return f;
        switch (f) {
          case "%s":
            return String(n[t++]);
          case "%d":
            return Number(n[t++]);
          case "%j":
            try {
              return JSON.stringify(n[t++]);
            } catch {
              return "[Circular]";
            }
          default:
            return f;
        }
      }), a2 = n[t];t < o2; a2 = n[++t])
        pr(a2) || !M2(a2) ? i += " " + a2 : i += " " + h2(a2);
      return i;
    };
    y2.deprecate = function(r, e) {
      if (typeof process < "u" && process.noDeprecation === true)
        return r;
      if (typeof process > "u")
        return function() {
          return y2.deprecate(r, e).apply(this, arguments);
        };
      var t = false;
      function n() {
        if (!t) {
          if (process.throwDeprecation)
            throw new Error(e);
          process.traceDeprecation ? console.trace(e) : console.error(e), t = true;
        }
        return r.apply(this, arguments);
      }
      return n;
    };
    var fr = {}, it = /^$/;
    process.env.NODE_DEBUG && (ur = process.env.NODE_DEBUG, ur = ur.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), it = new RegExp("^" + ur + "$", "i"));
    var ur;
    y2.debuglog = function(r) {
      if (r = r.toUpperCase(), !fr[r])
        if (it.test(r)) {
          var e = process.pid;
          fr[r] = function() {
            var t = y2.format.apply(y2, arguments);
            console.error("%s %d: %s", r, e, t);
          };
        } else
          fr[r] = function() {};
      return fr[r];
    };
    function h2(r, e) {
      var t = { seen: [], stylize: Qn };
      return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), _r(e) ? t.showHidden = e : e && y2._extend(t, e), w2(t.showHidden) && (t.showHidden = false), w2(t.depth) && (t.depth = 2), w2(t.colors) && (t.colors = false), w2(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = Kn), sr(t, r, t.depth);
    }
    y2.inspect = h2;
    h2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
    h2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    function Kn(r, e) {
      var t = h2.styles[e];
      return t ? "\x1B[" + h2.colors[t][0] + "m" + r + "\x1B[" + h2.colors[t][1] + "m" : r;
    }
    function Qn(r, e) {
      return r;
    }
    function Xn(r) {
      var e = {};
      return r.forEach(function(t, n) {
        e[t] = true;
      }), e;
    }
    function sr(r, e, t) {
      if (r.customInspect && e && yr(e.inspect) && e.inspect !== y2.inspect && !(e.constructor && e.constructor.prototype === e)) {
        var n = e.inspect(t, r);
        return lr(n) || (n = sr(r, n, t)), n;
      }
      var o2 = ro(r, e);
      if (o2)
        return o2;
      var i = Object.keys(e), a2 = Xn(i);
      if (r.showHidden && (i = Object.getOwnPropertyNames(e)), W(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
        return qr(e);
      if (i.length === 0) {
        if (yr(e)) {
          var f = e.name ? ": " + e.name : "";
          return r.stylize("[Function" + f + "]", "special");
        }
        if (G(e))
          return r.stylize(RegExp.prototype.toString.call(e), "regexp");
        if (cr(e))
          return r.stylize(Date.prototype.toString.call(e), "date");
        if (W(e))
          return qr(e);
      }
      var c = "", l2 = false, g2 = ["{", "}"];
      if (at(e) && (l2 = true, g2 = ["[", "]"]), yr(e)) {
        var S = e.name ? ": " + e.name : "";
        c = " [Function" + S + "]";
      }
      if (G(e) && (c = " " + RegExp.prototype.toString.call(e)), cr(e) && (c = " " + Date.prototype.toUTCString.call(e)), W(e) && (c = " " + qr(e)), i.length === 0 && (!l2 || e.length == 0))
        return g2[0] + c + g2[1];
      if (t < 0)
        return G(e) ? r.stylize(RegExp.prototype.toString.call(e), "regexp") : r.stylize("[Object]", "special");
      r.seen.push(e);
      var d2;
      return l2 ? d2 = eo(r, e, t, a2, i) : d2 = i.map(function(T) {
        return Wr(r, e, t, a2, T, l2);
      }), r.seen.pop(), to(d2, c, g2);
    }
    function ro(r, e) {
      if (w2(e))
        return r.stylize("undefined", "undefined");
      if (lr(e)) {
        var t = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return r.stylize(t, "string");
      }
      if (ft(e))
        return r.stylize("" + e, "number");
      if (_r(e))
        return r.stylize("" + e, "boolean");
      if (pr(e))
        return r.stylize("null", "null");
    }
    function qr(r) {
      return "[" + Error.prototype.toString.call(r) + "]";
    }
    function eo(r, e, t, n, o2) {
      for (var i = [], a2 = 0, f = e.length;a2 < f; ++a2)
        ut(e, String(a2)) ? i.push(Wr(r, e, t, n, String(a2), true)) : i.push("");
      return o2.forEach(function(c) {
        c.match(/^\d+$/) || i.push(Wr(r, e, t, n, c, true));
      }), i;
    }
    function Wr(r, e, t, n, o2, i) {
      var a2, f, c;
      if (c = Object.getOwnPropertyDescriptor(e, o2) || { value: e[o2] }, c.get ? c.set ? f = r.stylize("[Getter/Setter]", "special") : f = r.stylize("[Getter]", "special") : c.set && (f = r.stylize("[Setter]", "special")), ut(n, o2) || (a2 = "[" + o2 + "]"), f || (r.seen.indexOf(c.value) < 0 ? (pr(t) ? f = sr(r, c.value, null) : f = sr(r, c.value, t - 1), f.indexOf(`
`) > -1 && (i ? f = f.split(`
`).map(function(l2) {
        return "  " + l2;
      }).join(`
`).slice(2) : f = `
` + f.split(`
`).map(function(l2) {
        return "   " + l2;
      }).join(`
`))) : f = r.stylize("[Circular]", "special")), w2(a2)) {
        if (i && o2.match(/^\d+$/))
          return f;
        a2 = JSON.stringify("" + o2), a2.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a2 = a2.slice(1, -1), a2 = r.stylize(a2, "name")) : (a2 = a2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a2 = r.stylize(a2, "string"));
      }
      return a2 + ": " + f;
    }
    function to(r, e, t) {
      var n = 0, o2 = r.reduce(function(i, a2) {
        return n++, a2.indexOf(`
`) >= 0 && n++, i + a2.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return o2 > 60 ? t[0] + (e === "" ? "" : e + `
 `) + " " + r.join(`,
  `) + " " + t[1] : t[0] + e + " " + r.join(", ") + " " + t[1];
    }
    y2.types = rt();
    function at(r) {
      return Array.isArray(r);
    }
    y2.isArray = at;
    function _r(r) {
      return typeof r == "boolean";
    }
    y2.isBoolean = _r;
    function pr(r) {
      return r === null;
    }
    y2.isNull = pr;
    function no(r) {
      return r == null;
    }
    y2.isNullOrUndefined = no;
    function ft(r) {
      return typeof r == "number";
    }
    y2.isNumber = ft;
    function lr(r) {
      return typeof r == "string";
    }
    y2.isString = lr;
    function oo(r) {
      return typeof r == "symbol";
    }
    y2.isSymbol = oo;
    function w2(r) {
      return r === undefined;
    }
    y2.isUndefined = w2;
    function G(r) {
      return M2(r) && zr(r) === "[object RegExp]";
    }
    y2.isRegExp = G;
    y2.types.isRegExp = G;
    function M2(r) {
      return typeof r == "object" && r !== null;
    }
    y2.isObject = M2;
    function cr(r) {
      return M2(r) && zr(r) === "[object Date]";
    }
    y2.isDate = cr;
    y2.types.isDate = cr;
    function W(r) {
      return M2(r) && (zr(r) === "[object Error]" || r instanceof Error);
    }
    y2.isError = W;
    y2.types.isNativeError = W;
    function yr(r) {
      return typeof r == "function";
    }
    y2.isFunction = yr;
    function io(r) {
      return r === null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || typeof r == "symbol" || typeof r > "u";
    }
    y2.isPrimitive = io;
    y2.isBuffer = tt();
    function zr(r) {
      return Object.prototype.toString.call(r);
    }
    function Gr(r) {
      return r < 10 ? "0" + r.toString(10) : r.toString(10);
    }
    var ao = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function fo() {
      var r = new Date, e = [Gr(r.getHours()), Gr(r.getMinutes()), Gr(r.getSeconds())].join(":");
      return [r.getDate(), ao[r.getMonth()], e].join(" ");
    }
    y2.log = function() {
      console.log("%s - %s", fo(), y2.format.apply(y2, arguments));
    };
    y2.inherits = nt();
    y2._extend = function(r, e) {
      if (!e || !M2(e))
        return r;
      for (var t = Object.keys(e), n = t.length;n--; )
        r[t[n]] = e[t[n]];
      return r;
    };
    function ut(r, e) {
      return Object.prototype.hasOwnProperty.call(r, e);
    }
    var P2 = typeof Symbol < "u" ? Symbol("util.promisify.custom") : undefined;
    y2.promisify = function(e) {
      if (typeof e != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (P2 && e[P2]) {
        var t = e[P2];
        if (typeof t != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, P2, { value: t, enumerable: false, writable: false, configurable: true }), t;
      }
      function t() {
        for (var n, o2, i = new Promise(function(c, l2) {
          n = c, o2 = l2;
        }), a2 = [], f = 0;f < arguments.length; f++)
          a2.push(arguments[f]);
        a2.push(function(c, l2) {
          c ? o2(c) : n(l2);
        });
        try {
          e.apply(this, a2);
        } catch (c) {
          o2(c);
        }
        return i;
      }
      return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), P2 && Object.defineProperty(t, P2, { value: t, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t, ot(e));
    };
    y2.promisify.custom = P2;
    function uo(r, e) {
      if (!r) {
        var t = new Error("Promise was rejected with a falsy value");
        t.reason = r, r = t;
      }
      return e(r);
    }
    function yo(r) {
      if (typeof r != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function e() {
        for (var t = [], n = 0;n < arguments.length; n++)
          t.push(arguments[n]);
        var o2 = t.pop();
        if (typeof o2 != "function")
          throw new TypeError("The last argument must be of type Function");
        var i = this, a2 = function() {
          return o2.apply(i, arguments);
        };
        r.apply(this, t).then(function(f) {
          process.nextTick(a2.bind(null, null, f));
        }, function(f) {
          process.nextTick(uo.bind(null, f, a2));
        });
      }
      return Object.setPrototypeOf(e, Object.getPrototypeOf(r)), Object.defineProperties(e, ot(r)), e;
    }
    y2.callbackify = yo;
  });
  E2 = {};
  At(E2, { TextDecoder: () => ct, TextEncoder: () => st, default: () => so });
  F(E2, mt(yt()));
  st = globalThis.TextEncoder;
  ct = globalThis.TextDecoder;
  so = { TextEncoder: st, TextDecoder: ct };
});

// node_modules/@fastify/error/index.js
var require_error = __commonJS((exports, module) => {
  var { format } = (init_util(), __toCommonJS(exports_util));
  function toString() {
    return `${this.name} [${this.code}]: ${this.message}`;
  }
  var FastifyGenericErrorSymbol = Symbol.for("fastify-error-generic");
  function createError(code, message, statusCode = 500, Base = Error, captureStackTrace = createError.captureStackTrace) {
    const shouldCreateFastifyGenericError = code === FastifyGenericErrorSymbol;
    if (shouldCreateFastifyGenericError) {
      code = "FST_ERR";
    }
    if (!code)
      throw new Error("Fastify error code must not be empty");
    if (!message)
      throw new Error("Fastify error message must not be empty");
    code = code.toUpperCase();
    !statusCode && (statusCode = undefined);
    const FastifySpecificErrorSymbol = Symbol.for(`fastify-error ${code}`);
    function FastifyError(...args) {
      if (!new.target) {
        return new FastifyError(...args);
      }
      this.code = code;
      this.name = "FastifyError";
      this.statusCode = statusCode;
      const lastElement = args.length - 1;
      if (lastElement !== -1 && args[lastElement] && typeof args[lastElement] === "object" && "cause" in args[lastElement]) {
        this.cause = args.pop().cause;
      }
      this.message = format(message, ...args);
      Error.stackTraceLimit && captureStackTrace && Error.captureStackTrace(this, FastifyError);
    }
    FastifyError.prototype = Object.create(Base.prototype, {
      constructor: {
        value: FastifyError,
        enumerable: false,
        writable: true,
        configurable: true
      },
      [FastifyGenericErrorSymbol]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: false
      },
      [FastifySpecificErrorSymbol]: {
        value: true,
        enumerable: false,
        writable: false,
        configurable: false
      }
    });
    if (shouldCreateFastifyGenericError) {
      Object.defineProperty(FastifyError, Symbol.hasInstance, {
        value(instance) {
          return instance && instance[FastifyGenericErrorSymbol];
        },
        configurable: false,
        writable: false,
        enumerable: false
      });
    } else {
      Object.defineProperty(FastifyError, Symbol.hasInstance, {
        value(instance) {
          return instance && instance[FastifySpecificErrorSymbol];
        },
        configurable: false,
        writable: false,
        enumerable: false
      });
    }
    FastifyError.prototype[Symbol.toStringTag] = "Error";
    FastifyError.prototype.toString = toString;
    return FastifyError;
  }
  createError.captureStackTrace = true;
  var FastifyErrorConstructor = createError(FastifyGenericErrorSymbol, "Fastify Error", 500, Error);
  module.exports = createError;
  module.exports.FastifyError = FastifyErrorConstructor;
  module.exports.default = createError;
  module.exports.createError = createError;
});

// node_modules/avvio/lib/errors.js
var require_errors = __commonJS((exports, module) => {
  var { createError } = require_error();
  module.exports = {
    AVV_ERR_EXPOSE_ALREADY_DEFINED: createError("AVV_ERR_EXPOSE_ALREADY_DEFINED", "'%s' is already defined, specify an expose option for '%s'"),
    AVV_ERR_ATTRIBUTE_ALREADY_DEFINED: createError("AVV_ERR_ATTRIBUTE_ALREADY_DEFINED", "'%s' is already defined"),
    AVV_ERR_CALLBACK_NOT_FN: createError("AVV_ERR_CALLBACK_NOT_FN", "Callback for '%s' hook is not a function. Received: '%s'"),
    AVV_ERR_PLUGIN_NOT_VALID: createError("AVV_ERR_PLUGIN_NOT_VALID", "Plugin must be a function or a promise. Received: '%s'"),
    AVV_ERR_ROOT_PLG_BOOTED: createError("AVV_ERR_ROOT_PLG_BOOTED", "Root plugin has already booted"),
    AVV_ERR_PARENT_PLG_LOADED: createError("AVV_ERR_PARENT_PLG_LOADED", "Impossible to load '%s' plugin because the parent '%s' was already loaded"),
    AVV_ERR_READY_TIMEOUT: createError("AVV_ERR_READY_TIMEOUT", "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise"),
    AVV_ERR_PLUGIN_EXEC_TIMEOUT: createError("AVV_ERR_PLUGIN_EXEC_TIMEOUT", "Plugin did not start in time: '%s'. You may have forgotten to call 'done' function or to resolve a Promise")
  };
});

// node_modules/avvio/lib/symbols.js
var require_symbols = __commonJS((exports, module) => {
  var kAvvio = Symbol("avvio.Boot");
  var kIsOnCloseHandler = Symbol("isOnCloseHandler");
  var kThenifyDoNotWrap = Symbol("avvio.ThenifyDoNotWrap");
  var kUntrackNode = Symbol("avvio.TimeTree.untrackNode");
  var kTrackNode = Symbol("avvio.TimeTree.trackNode");
  var kGetParent = Symbol("avvio.TimeTree.getParent");
  var kGetNode = Symbol("avvio.TimeTree.getNode");
  var kAddNode = Symbol("avvio.TimeTree.addNode");
  var kPluginMeta = Symbol.for("plugin-meta");
  module.exports = {
    kAvvio,
    kIsOnCloseHandler,
    kThenifyDoNotWrap,
    kUntrackNode,
    kTrackNode,
    kGetParent,
    kGetNode,
    kAddNode,
    kPluginMeta
  };
});

// node_modules/avvio/lib/time-tree.js
var require_time_tree = __commonJS((exports, module) => {
  var {
    kUntrackNode,
    kTrackNode,
    kGetParent,
    kGetNode,
    kAddNode
  } = require_symbols();

  class TimeTree {
    constructor() {
      this.root = null;
      this.tableId = new Map;
      this.tableLabel = new Map;
    }
    [kTrackNode](node) {
      this.tableId.set(node.id, node);
      if (this.tableLabel.has(node.label)) {
        this.tableLabel.get(node.label).push(node);
      } else {
        this.tableLabel.set(node.label, [node]);
      }
    }
    [kUntrackNode](node) {
      this.tableId.delete(node.id);
      const labelNode = this.tableLabel.get(node.label);
      labelNode.pop();
      if (labelNode.length === 0) {
        this.tableLabel.delete(node.label);
      }
    }
    [kGetParent](parent) {
      if (parent === null) {
        return null;
      } else if (this.tableLabel.has(parent)) {
        const parentNode = this.tableLabel.get(parent);
        return parentNode[parentNode.length - 1];
      } else {
        return null;
      }
    }
    [kGetNode](nodeId) {
      return this.tableId.get(nodeId);
    }
    [kAddNode](parent, label, start) {
      const parentNode = this[kGetParent](parent);
      const isRoot = parentNode === null;
      if (isRoot) {
        this.root = {
          parent: null,
          id: "root",
          label,
          nodes: [],
          start,
          stop: null,
          diff: -1
        };
        this[kTrackNode](this.root);
        return this.root.id;
      }
      const nodeId = `${label}-${Math.random()}`;
      const childNode = {
        parent,
        id: nodeId,
        label,
        nodes: [],
        start,
        stop: null,
        diff: -1
      };
      parentNode.nodes.push(childNode);
      this[kTrackNode](childNode);
      return nodeId;
    }
    start(parent, label, start = Date.now()) {
      return this[kAddNode](parent, label, start);
    }
    stop(nodeId, stop = Date.now()) {
      const node = this[kGetNode](nodeId);
      if (node) {
        node.stop = stop;
        node.diff = node.stop - node.start || 0;
        this[kUntrackNode](node);
      }
    }
    toJSON() {
      return Object.assign({}, this.root);
    }
    prettyPrint() {
      return prettyPrintTimeTree(this.toJSON());
    }
  }
  function prettyPrintTimeTree(obj, prefix = "") {
    let result = prefix;
    const nodesCount = obj.nodes.length;
    const lastIndex = nodesCount - 1;
    result += `${obj.label} ${obj.diff} ms
`;
    for (let i = 0;i < nodesCount; ++i) {
      const node = obj.nodes[i];
      const prefix_ = prefix + (i === lastIndex ? "  " : "│ ");
      result += prefix;
      result += i === lastIndex ? "└─" : "├─";
      result += node.nodes.length === 0 ? "─ " : "┬ ";
      result += prettyPrintTimeTree(node, prefix_).slice(prefix.length + 2);
    }
    return result;
  }
  module.exports = {
    TimeTree
  };
});

// node_modules/avvio/lib/debug.js
var require_debug = __commonJS((exports, module) => {
  var { debuglog } = (init_util(), __toCommonJS(exports_util));
  var debug = debuglog("avvio");
  module.exports = {
    debug
  };
});

// node_modules/avvio/lib/create-promise.js
var require_create_promise = __commonJS((exports, module) => {
  function createPromise() {
    const obj = {
      resolve: null,
      reject: null,
      promise: null
    };
    obj.promise = new Promise((resolve, reject) => {
      obj.resolve = resolve;
      obj.reject = reject;
    });
    return obj;
  }
  module.exports = {
    createPromise
  };
});

// node_modules/avvio/lib/get-plugin-name.js
var require_get_plugin_name = __commonJS((exports, module) => {
  var { kPluginMeta } = require_symbols();
  function getPluginName(plugin, options) {
    if (plugin[kPluginMeta] && plugin[kPluginMeta].name) {
      return plugin[kPluginMeta].name;
    }
    if (options && options.name) {
      return options.name;
    }
    if (plugin.name) {
      return plugin.name;
    } else {
      return plugin.toString().split(`
`).slice(0, 2).map((s) => s.trim()).join(" -- ");
    }
  }
  module.exports = {
    getPluginName
  };
});

// node_modules/avvio/lib/is-promise-like.js
var require_is_promise_like = __commonJS((exports, module) => {
  function isPromiseLike(maybePromiseLike) {
    return maybePromiseLike !== null && typeof maybePromiseLike === "object" && typeof maybePromiseLike.then === "function";
  }
  module.exports = {
    isPromiseLike
  };
});

// node_modules/avvio/lib/plugin.js
var require_plugin = __commonJS((exports, module) => {
  var { EventEmitter } = (init_events(), __toCommonJS(exports_events));
  var { inherits } = (init_util(), __toCommonJS(exports_util));
  var { debug } = require_debug();
  var { createPromise } = require_create_promise();
  var { AVV_ERR_PLUGIN_EXEC_TIMEOUT } = require_errors();
  var { getPluginName } = require_get_plugin_name();
  var { isPromiseLike } = require_is_promise_like();
  function Plugin(queue, func, options, isAfter, timeout) {
    this.queue = queue;
    this.func = func;
    this.options = options;
    this.isAfter = isAfter;
    this.timeout = timeout;
    this.started = false;
    this.name = getPluginName(func, options);
    this.queue.pause();
    this._error = null;
    this.loaded = false;
    this._promise = null;
    this.startTime = null;
  }
  inherits(Plugin, EventEmitter);
  Plugin.prototype.exec = function(server, callback) {
    debug("exec", this.name);
    this.server = server;
    const func = this.func;
    const name = this.name;
    let completed = false;
    this.options = typeof this.options === "function" ? this.options(this.server) : this.options;
    let timer = null;
    const done = (execErr) => {
      if (completed) {
        debug("loading complete", name);
        return;
      }
      this._error = execErr;
      if (execErr) {
        debug("exec errored", name);
      } else {
        debug("exec completed", name);
      }
      completed = true;
      if (timer) {
        clearTimeout(timer);
      }
      callback(execErr);
    };
    if (this.timeout > 0) {
      debug("setting up timeout", name, this.timeout);
      timer = setTimeout(function() {
        debug("timed out", name);
        timer = null;
        const readyTimeoutErr = new AVV_ERR_PLUGIN_EXEC_TIMEOUT(name);
        readyTimeoutErr.fn = func;
        done(readyTimeoutErr);
      }, this.timeout);
    }
    this.started = true;
    this.startTime = Date.now();
    this.emit("start", this.server ? this.server.name : null, this.name, Date.now());
    const maybePromiseLike = func(this.server, this.options, done);
    if (isPromiseLike(maybePromiseLike)) {
      debug("exec: resolving promise", name);
      maybePromiseLike.then(() => process.nextTick(done), (e) => process.nextTick(done, e));
    } else if (func.length < 3) {
      done();
    }
  };
  Plugin.prototype.loadedSoFar = function() {
    debug("loadedSoFar", this.name);
    if (this.loaded) {
      return Promise.resolve();
    }
    const setup = () => {
      this.server.after((afterErr, callback) => {
        this._error = afterErr;
        this.queue.pause();
        if (this._promise) {
          if (afterErr) {
            debug("rejecting promise", this.name, afterErr);
            this._promise.reject(afterErr);
          } else {
            debug("resolving promise", this.name);
            this._promise.resolve();
          }
          this._promise = null;
        }
        process.nextTick(callback, afterErr);
      });
      this.queue.resume();
    };
    let res;
    if (!this._promise) {
      this._promise = createPromise();
      res = this._promise.promise;
      if (!this.server) {
        this.on("start", setup);
      } else {
        setup();
      }
    } else {
      res = Promise.resolve();
    }
    return res;
  };
  Plugin.prototype.enqueue = function(plugin, callback) {
    debug("enqueue", this.name, plugin.name);
    this.emit("enqueue", this.server ? this.server.name : null, this.name, Date.now());
    this.queue.push(plugin, callback);
  };
  Plugin.prototype.finish = function(err, callback) {
    debug("finish", this.name, err);
    const done = () => {
      if (this.loaded) {
        return;
      }
      debug("loaded", this.name);
      this.emit("loaded", this.server ? this.server.name : null, this.name, Date.now());
      this.loaded = true;
      callback(err);
    };
    if (err) {
      if (this._promise) {
        this._promise.reject(err);
        this._promise = null;
      }
      done();
      return;
    }
    const check = () => {
      debug("check", this.name, this.queue.length(), this.queue.running(), this._promise);
      if (this.queue.length() === 0 && this.queue.running() === 0) {
        if (this._promise) {
          const wrap = () => {
            debug("wrap");
            queueMicrotask(check);
          };
          this._promise.resolve();
          this._promise.promise.then(wrap, wrap);
          this._promise = null;
        } else {
          done();
        }
      } else {
        debug("delayed", this.name);
        this.queue.drain = () => {
          debug("drain", this.name);
          this.queue.drain = noop;
          queueMicrotask(check);
        };
      }
    };
    queueMicrotask(check);
    this.queue.resume();
  };
  function noop() {}
  module.exports = {
    Plugin
  };
});

// node_modules/avvio/lib/validate-plugin.js
var require_validate_plugin = __commonJS((exports, module) => {
  var { AVV_ERR_PLUGIN_NOT_VALID } = require_errors();
  function validatePlugin(maybePlugin) {
    if (!(maybePlugin && (typeof maybePlugin === "function" || typeof maybePlugin.then === "function"))) {
      if (Array.isArray(maybePlugin)) {
        throw new AVV_ERR_PLUGIN_NOT_VALID("array");
      } else if (maybePlugin === null) {
        throw new AVV_ERR_PLUGIN_NOT_VALID("null");
      } else {
        throw new AVV_ERR_PLUGIN_NOT_VALID(typeof maybePlugin);
      }
    }
  }
  module.exports = {
    validatePlugin
  };
});

// node_modules/avvio/lib/is-bundled-or-typescript-plugin.js
var require_is_bundled_or_typescript_plugin = __commonJS((exports, module) => {
  function isBundledOrTypescriptPlugin(maybeBundledOrTypescriptPlugin) {
    return maybeBundledOrTypescriptPlugin !== null && typeof maybeBundledOrTypescriptPlugin === "object" && typeof maybeBundledOrTypescriptPlugin.default === "function";
  }
  module.exports = {
    isBundledOrTypescriptPlugin
  };
});

// node_modules/avvio/lib/thenify.js
var require_thenify = __commonJS((exports, module) => {
  var { debug } = require_debug();
  var { kThenifyDoNotWrap } = require_symbols();
  function thenify() {
    if (this.booted) {
      debug("thenify returning undefined because we are already booted");
      return;
    }
    if (this[kThenifyDoNotWrap]) {
      this[kThenifyDoNotWrap] = false;
      return;
    }
    debug("thenify");
    return (resolve, reject) => {
      const p2 = this._loadRegistered();
      return p2.then(() => {
        this[kThenifyDoNotWrap] = true;
        return resolve(this._server);
      }, reject);
    };
  }
  module.exports = {
    thenify
  };
});

// node_modules/avvio/lib/execute-with-thenable.js
var require_execute_with_thenable = __commonJS((exports, module) => {
  var { isPromiseLike } = require_is_promise_like();
  var { kAvvio } = require_symbols();
  function executeWithThenable(func, args, callback) {
    const result = func.apply(func, args);
    if (isPromiseLike(result) && !result[kAvvio]) {
      result.then(() => process.nextTick(callback), (error) => process.nextTick(callback, error));
    } else if (callback) {
      process.nextTick(callback);
    }
  }
  module.exports = {
    executeWithThenable
  };
});

// node_modules/avvio/boot.js
var require_boot = __commonJS((exports, module) => {
  var fastq = require_queue();
  var EE = (init_events(), __toCommonJS(exports_events)).EventEmitter;
  var inherits = (init_util(), __toCommonJS(exports_util)).inherits;
  var {
    AVV_ERR_EXPOSE_ALREADY_DEFINED,
    AVV_ERR_CALLBACK_NOT_FN,
    AVV_ERR_ROOT_PLG_BOOTED,
    AVV_ERR_READY_TIMEOUT,
    AVV_ERR_ATTRIBUTE_ALREADY_DEFINED
  } = require_errors();
  var {
    kAvvio,
    kIsOnCloseHandler
  } = require_symbols();
  var { TimeTree } = require_time_tree();
  var { Plugin } = require_plugin();
  var { debug } = require_debug();
  var { validatePlugin } = require_validate_plugin();
  var { isBundledOrTypescriptPlugin } = require_is_bundled_or_typescript_plugin();
  var { isPromiseLike } = require_is_promise_like();
  var { thenify } = require_thenify();
  var { executeWithThenable } = require_execute_with_thenable();
  function Boot(server, opts, done) {
    if (typeof server === "function" && arguments.length === 1) {
      done = server;
      opts = {};
      server = null;
    }
    if (typeof opts === "function") {
      done = opts;
      opts = {};
    }
    opts = opts || {};
    opts.autostart = opts.autostart !== false;
    opts.timeout = Number(opts.timeout) || 0;
    opts.expose = opts.expose || {};
    if (!new.target) {
      return new Boot(server, opts, done);
    }
    this._server = server || this;
    this._opts = opts;
    if (server) {
      this._expose();
    }
    this._current = [];
    this._error = null;
    this._lastUsed = null;
    this.setMaxListeners(0);
    if (done) {
      this.once("start", done);
    }
    this.started = false;
    this.booted = false;
    this.pluginTree = new TimeTree;
    this._readyQ = fastq(this, callWithCbOrNextTick, 1);
    this._readyQ.pause();
    this._readyQ.drain = () => {
      this.emit("start");
      this._readyQ.drain = noop;
    };
    this._closeQ = fastq(this, closeWithCbOrNextTick, 1);
    this._closeQ.pause();
    this._closeQ.drain = () => {
      this.emit("close");
      this._closeQ.drain = noop;
    };
    this._doStart = null;
    const instance = this;
    this._root = new Plugin(fastq(this, this._loadPluginNextTick, 1), function root(server2, opts2, done2) {
      instance._doStart = done2;
      opts2.autostart && instance.start();
    }, opts, false, 0);
    this._trackPluginLoading(this._root);
    this._loadPlugin(this._root, (err) => {
      debug("root plugin ready");
      try {
        this.emit("preReady");
        this._root = null;
      } catch (preReadyError) {
        err = err || this._error || preReadyError;
      }
      if (err) {
        this._error = err;
        if (this._readyQ.length() === 0) {
          throw err;
        }
      } else {
        this.booted = true;
      }
      this._readyQ.resume();
    });
  }
  inherits(Boot, EE);
  Boot.prototype.start = function() {
    this.started = true;
    process.nextTick(this._doStart);
    return this;
  };
  Boot.prototype.override = function(server, func, opts) {
    return server;
  };
  Boot.prototype[kAvvio] = true;
  Boot.prototype.use = function(plugin, opts) {
    this._lastUsed = this._addPlugin(plugin, opts, false);
    return this;
  };
  Boot.prototype._loadRegistered = function() {
    const plugin = this._current[0];
    const weNeedToStart = !this.started && !this.booted;
    if (weNeedToStart) {
      process.nextTick(() => this._root.queue.resume());
    }
    if (!plugin) {
      return Promise.resolve();
    }
    return plugin.loadedSoFar();
  };
  Object.defineProperty(Boot.prototype, "then", { get: thenify });
  Boot.prototype._addPlugin = function(pluginFn, opts, isAfter) {
    if (isBundledOrTypescriptPlugin(pluginFn)) {
      pluginFn = pluginFn.default;
    }
    validatePlugin(pluginFn);
    opts = opts || {};
    if (this.booted) {
      throw new AVV_ERR_ROOT_PLG_BOOTED;
    }
    const current = this._current[0];
    let timeout = this._opts.timeout;
    if (!current.loaded && current.timeout > 0) {
      const delta = Date.now() - current.startTime;
      timeout = current.timeout - (delta + 3);
    }
    const plugin = new Plugin(fastq(this, this._loadPluginNextTick, 1), pluginFn, opts, isAfter, timeout);
    this._trackPluginLoading(plugin);
    if (current.loaded) {
      throw new Error(plugin.name, current.name);
    }
    current.enqueue(plugin, (err) => {
      err && (this._error = err);
    });
    return plugin;
  };
  Boot.prototype._expose = function _expose() {
    const instance = this;
    const server = instance._server;
    const {
      use: useKey = "use",
      after: afterKey = "after",
      ready: readyKey = "ready",
      onClose: onCloseKey = "onClose",
      close: closeKey = "close"
    } = this._opts.expose;
    if (server[useKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(useKey, "use");
    }
    server[useKey] = function(fn, opts) {
      instance.use(fn, opts);
      return this;
    };
    if (server[afterKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(afterKey, "after");
    }
    server[afterKey] = function(func) {
      if (typeof func !== "function") {
        return instance._loadRegistered();
      }
      instance.after(encapsulateThreeParam(func, this));
      return this;
    };
    if (server[readyKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(readyKey, "ready");
    }
    server[readyKey] = function(func) {
      if (func && typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(readyKey, typeof func);
      }
      return instance.ready(func ? encapsulateThreeParam(func, this) : undefined);
    };
    if (server[onCloseKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(onCloseKey, "onClose");
    }
    server[onCloseKey] = function(func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(onCloseKey, typeof func);
      }
      instance.onClose(encapsulateTwoParam(func, this));
      return this;
    };
    if (server[closeKey]) {
      throw new AVV_ERR_EXPOSE_ALREADY_DEFINED(closeKey, "close");
    }
    server[closeKey] = function(func) {
      if (func && typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN(closeKey, typeof func);
      }
      if (func) {
        instance.close(encapsulateThreeParam(func, this));
        return this;
      }
      return instance.close();
    };
    if (server.then) {
      throw new AVV_ERR_ATTRIBUTE_ALREADY_DEFINED("then");
    }
    Object.defineProperty(server, "then", { get: thenify.bind(instance) });
    server[kAvvio] = true;
  };
  Boot.prototype.after = function(func) {
    if (!func) {
      return this._loadRegistered();
    }
    this._addPlugin(_after.bind(this), {}, true);
    function _after(s, opts, done) {
      callWithCbOrNextTick.call(this, func, done);
    }
    return this;
  };
  Boot.prototype.onClose = function(func) {
    if (typeof func !== "function") {
      throw new AVV_ERR_CALLBACK_NOT_FN("onClose", typeof func);
    }
    func[kIsOnCloseHandler] = true;
    this._closeQ.unshift(func, (err) => {
      err && (this._error = err);
    });
    return this;
  };
  Boot.prototype.close = function(func) {
    let promise;
    if (func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("close", typeof func);
      }
    } else {
      promise = new Promise(function(resolve, reject) {
        func = function(err) {
          if (err) {
            return reject(err);
          }
          resolve();
        };
      });
    }
    this.ready(() => {
      this._error = null;
      this._closeQ.push(func);
      process.nextTick(this._closeQ.resume.bind(this._closeQ));
    });
    return promise;
  };
  Boot.prototype.ready = function(func) {
    if (func) {
      if (typeof func !== "function") {
        throw new AVV_ERR_CALLBACK_NOT_FN("ready", typeof func);
      }
      this._readyQ.push(func);
      queueMicrotask(this.start.bind(this));
      return;
    }
    return new Promise((resolve, reject) => {
      this._readyQ.push(readyPromiseCB);
      this.start();
      const relativeContext = this._current[0].server;
      function readyPromiseCB(err, context, done) {
        if (err) {
          reject(err);
        } else {
          resolve(relativeContext);
        }
        process.nextTick(done);
      }
    });
  };
  Boot.prototype._trackPluginLoading = function(plugin) {
    const parentName = this._current[0]?.name || null;
    plugin.once("start", (serverName, funcName, time) => {
      const nodeId = this.pluginTree.start(parentName || null, funcName, time);
      plugin.once("loaded", (serverName2, funcName2, time2) => {
        this.pluginTree.stop(nodeId, time2);
      });
    });
  };
  Boot.prototype.prettyPrint = function() {
    return this.pluginTree.prettyPrint();
  };
  Boot.prototype.toJSON = function() {
    return this.pluginTree.toJSON();
  };
  Boot.prototype._loadPlugin = function(plugin, callback) {
    const instance = this;
    if (isPromiseLike(plugin.func)) {
      plugin.func.then((fn) => {
        if (typeof fn.default === "function") {
          fn = fn.default;
        }
        plugin.func = fn;
        this._loadPlugin(plugin, callback);
      }, callback);
      return;
    }
    const last = instance._current[0];
    instance._current.unshift(plugin);
    if (instance._error && !plugin.isAfter) {
      debug("skipping loading of plugin as instance errored and it is not an after", plugin.name);
      process.nextTick(execCallback);
      return;
    }
    let server = last && last.server || instance._server;
    if (!plugin.isAfter) {
      try {
        server = instance.override(server, plugin.func, plugin.options);
      } catch (overrideErr) {
        debug("override errored", plugin.name);
        return execCallback(overrideErr);
      }
    }
    plugin.exec(server, execCallback);
    function execCallback(err) {
      plugin.finish(err, (err2) => {
        instance._current.shift();
        callback(err2);
      });
    }
  };
  Boot.prototype._loadPluginNextTick = function(plugin, callback) {
    process.nextTick(this._loadPlugin.bind(this), plugin, callback);
  };
  function noop() {}
  function callWithCbOrNextTick(func, cb) {
    const context = this._server;
    const err = this._error;
    this._error = null;
    if (func.length === 0) {
      this._error = err;
      executeWithThenable(func, [], cb);
    } else if (func.length === 1) {
      executeWithThenable(func, [err], cb);
    } else {
      if (this._opts.timeout === 0) {
        const wrapCb = (err2) => {
          this._error = err2;
          cb(this._error);
        };
        if (func.length === 2) {
          func(err, wrapCb);
        } else {
          func(err, context, wrapCb);
        }
      } else {
        timeoutCall.call(this, func, err, context, cb);
      }
    }
  }
  function timeoutCall(func, rootErr, context, cb) {
    const name = func.unwrappedName ?? func.name;
    debug("setting up ready timeout", name, this._opts.timeout);
    let timer = setTimeout(() => {
      debug("timed out", name);
      timer = null;
      const toutErr = new AVV_ERR_READY_TIMEOUT(name);
      toutErr.fn = func;
      this._error = toutErr;
      cb(toutErr);
    }, this._opts.timeout);
    if (func.length === 2) {
      func(rootErr, timeoutCb.bind(this));
    } else {
      func(rootErr, context, timeoutCb.bind(this));
    }
    function timeoutCb(err) {
      if (timer) {
        clearTimeout(timer);
        this._error = err;
        cb(this._error);
      } else {}
    }
  }
  function closeWithCbOrNextTick(func, cb) {
    const context = this._server;
    const isOnCloseHandler = func[kIsOnCloseHandler];
    if (func.length === 0 || func.length === 1) {
      let promise;
      if (isOnCloseHandler) {
        promise = func(context);
      } else {
        promise = func(this._error);
      }
      if (promise && typeof promise.then === "function") {
        debug("resolving close/onClose promise");
        promise.then(() => process.nextTick(cb), (e) => process.nextTick(cb, e));
      } else {
        process.nextTick(cb);
      }
    } else if (func.length === 2) {
      if (isOnCloseHandler) {
        func(context, cb);
      } else {
        func(this._error, cb);
      }
    } else {
      if (isOnCloseHandler) {
        func(context, cb);
      } else {
        func(this._error, context, cb);
      }
    }
  }
  function encapsulateTwoParam(func, that) {
    return _encapsulateTwoParam.bind(that);
    function _encapsulateTwoParam(context, cb) {
      let res;
      if (func.length === 0) {
        res = func();
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 1) {
        res = func(this);
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else {
        func(this, cb);
      }
    }
  }
  function encapsulateThreeParam(func, that) {
    const wrapped = _encapsulateThreeParam.bind(that);
    wrapped.unwrappedName = func.name;
    return wrapped;
    function _encapsulateThreeParam(err, cb) {
      let res;
      if (!func) {
        process.nextTick(cb);
      } else if (func.length === 0) {
        res = func();
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb, err);
          }, cb);
        } else {
          process.nextTick(cb, err);
        }
      } else if (func.length === 1) {
        res = func(err);
        if (res && res.then) {
          res.then(function() {
            process.nextTick(cb);
          }, cb);
        } else {
          process.nextTick(cb);
        }
      } else if (func.length === 2) {
        func(err, cb);
      } else {
        func(err, this, cb);
      }
    }
  }
  module.exports = Boot;
});

// node:http
var exports_http = {};
__export(exports_http, {
  request: () => ou,
  globalAgent: () => lu,
  get: () => au,
  default: () => iu,
  STATUS_CODES: () => hu,
  METHODS: () => cu,
  IncomingMessage: () => fu,
  ClientRequest: () => su,
  Agent: () => uu
});
function oe(e) {
  throw new RangeError($s[e]);
}
function Gs(e, t) {
  let r = [], n = e.length;
  for (;n--; )
    r[n] = t(e[n]);
  return r;
}
function yi(e, t) {
  let r = e.split("@"), n = "";
  r.length > 1 && (n = r[0] + "@", e = r[1]), e = e.replace(Ws, ".");
  let i = e.split("."), o2 = Gs(i, t).join(".");
  return n + o2;
}
function dr2(e) {
  let t = [], r = 0, n = e.length;
  for (;r < n; ) {
    let i = e.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      let o2 = e.charCodeAt(r++);
      (o2 & 64512) == 56320 ? t.push(((i & 1023) << 10) + (o2 & 1023) + 65536) : (t.push(i), r--);
    } else
      t.push(i);
  }
  return t;
}
var Gi, ke, Ki, Vi, Yi, Xi, vr = (e, t) => () => (e && (t = e(e = 0)), t), b2 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Er = (e, t) => {
  for (var r in t)
    ke(e, r, { get: t[r], enumerable: true });
}, xr = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Vi(t))
      !Xi.call(e, i) && i !== r && ke(e, i, { get: () => t[i], enumerable: !(n = Ki(t, i)) || n.enumerable });
  return e;
}, Rr2 = (e, t, r) => (r = e != null ? Gi(Yi(e)) : {}, xr(t || !e || !e.__esModule ? ke(r, "default", { value: e, enumerable: true }) : r, e)), dt2 = (e) => xr(ke({}, "__esModule", { value: true }), e), gt2, Q, bt2, _t, qr, Dr, _e, Lt, an, Ft, fe, Nt, pn, Dt, ue, Sn, Bn, Kt, Qe, Vt, et, On, Nn, Ht, ir, zn, ti, ar, ur, fi, li, ci, _i, pi, js, Hs, Ws, $s, hr, K, cr, gi, Ks, di, wi, pr, yr, mi, bi, Vs, Ys, vi, xi, Si, Ni, Di, Hi, _r, iu, ou, au, su, fu, uu, lu, hu, cu;
var init_http = __esm(() => {
  Gi = Object.create;
  ke = Object.defineProperty;
  Ki = Object.getOwnPropertyDescriptor;
  Vi = Object.getOwnPropertyNames;
  Yi = Object.getPrototypeOf;
  Xi = Object.prototype.hasOwnProperty;
  gt2 = b2((N3) => {
    N3.fetch = Ce(global.fetch) && Ce(global.ReadableStream);
    N3.writableStream = Ce(global.WritableStream);
    N3.abortController = Ce(global.AbortController);
    var J;
    function pt2() {
      if (J !== undefined)
        return J;
      if (global.XMLHttpRequest) {
        J = new global.XMLHttpRequest;
        try {
          J.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch {
          J = null;
        }
      } else
        J = null;
      return J;
    }
    function yt2(e) {
      var t = pt2();
      if (!t)
        return false;
      try {
        return t.responseType = e, t.responseType === e;
      } catch {}
      return false;
    }
    N3.arraybuffer = N3.fetch || yt2("arraybuffer");
    N3.msstream = !N3.fetch && yt2("ms-stream");
    N3.mozchunkedarraybuffer = !N3.fetch && yt2("moz-chunked-arraybuffer");
    N3.overrideMimeType = N3.fetch || (pt2() ? Ce(pt2().overrideMimeType) : false);
    function Ce(e) {
      return typeof e == "function";
    }
    J = null;
  });
  Q = b2((Rf, wt) => {
    typeof Object.create == "function" ? wt.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : wt.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var n = function() {};
        n.prototype = r.prototype, t.prototype = new n, t.prototype.constructor = t;
      }
    };
  });
  bt2 = b2((Sf, mt2) => {
    var ye = typeof Reflect == "object" ? Reflect : null, Sr = ye && typeof ye.apply == "function" ? ye.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, je;
    ye && typeof ye.ownKeys == "function" ? je = ye.ownKeys : Object.getOwnPropertySymbols ? je = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : je = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function zi(e) {
      console && console.warn && console.warn(e);
    }
    var Ar = Number.isNaN || function(t) {
      return t !== t;
    };
    function x2() {
      x2.init.call(this);
    }
    mt2.exports = x2;
    mt2.exports.once = eo;
    x2.EventEmitter = x2;
    x2.prototype._events = undefined;
    x2.prototype._eventsCount = 0;
    x2.prototype._maxListeners = undefined;
    var Tr = 10;
    function He(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(x2, "defaultMaxListeners", { enumerable: true, get: function() {
      return Tr;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || Ar(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      Tr = e;
    } });
    x2.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    x2.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || Ar(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Br2(e) {
      return e._maxListeners === undefined ? x2.defaultMaxListeners : e._maxListeners;
    }
    x2.prototype.getMaxListeners = function() {
      return Br2(this);
    };
    x2.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var a2;
        if (r.length > 0 && (a2 = r[0]), a2 instanceof Error)
          throw a2;
        var s = new Error("Unhandled error." + (a2 ? " (" + a2.message + ")" : ""));
        throw s.context = a2, s;
      }
      var u = o2[t];
      if (u === undefined)
        return false;
      if (typeof u == "function")
        Sr(u, this, r);
      else
        for (var l2 = u.length, h2 = Or(u, l2), n = 0;n < l2; ++n)
          Sr(h2[n], this, r);
      return true;
    };
    function Cr(e, t, r, n) {
      var i, o2, a2;
      if (He(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), a2 = o2[t]), a2 === undefined)
        a2 = o2[t] = r, ++e._eventsCount;
      else if (typeof a2 == "function" ? a2 = o2[t] = n ? [r, a2] : [a2, r] : n ? a2.unshift(r) : a2.push(r), i = Br2(e), i > 0 && a2.length > i && !a2.warned) {
        a2.warned = true;
        var s = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        s.name = "MaxListenersExceededWarning", s.emitter = e, s.type = t, s.count = a2.length, zi(s);
      }
      return e;
    }
    x2.prototype.addListener = function(t, r) {
      return Cr(this, t, r, false);
    };
    x2.prototype.on = x2.prototype.addListener;
    x2.prototype.prependListener = function(t, r) {
      return Cr(this, t, r, true);
    };
    function Zi() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ir(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = Zi.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    x2.prototype.once = function(t, r) {
      return He(r), this.on(t, Ir(this, t, r)), this;
    };
    x2.prototype.prependOnceListener = function(t, r) {
      return He(r), this.prependListener(t, Ir(this, t, r)), this;
    };
    x2.prototype.removeListener = function(t, r) {
      var n, i, o2, a2, s;
      if (He(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, a2 = n.length - 1;a2 >= 0; a2--)
          if (n[a2] === r || n[a2].listener === r) {
            s = n[a2].listener, o2 = a2;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : Ji(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, s || r);
      }
      return this;
    };
    x2.prototype.off = x2.prototype.removeListener;
    x2.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), a2;
        for (i = 0;i < o2.length; ++i)
          a2 = o2[i], a2 !== "removeListener" && this.removeAllListeners(a2);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Lr(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? Qi(i) : Or(i, i.length);
    }
    x2.prototype.listeners = function(t) {
      return Lr(this, t, true);
    };
    x2.prototype.rawListeners = function(t) {
      return Lr(this, t, false);
    };
    x2.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Mr.call(e, t);
    };
    x2.prototype.listenerCount = Mr;
    function Mr(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    x2.prototype.eventNames = function() {
      return this._eventsCount > 0 ? je(this._events) : [];
    };
    function Or(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function Ji(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function Qi(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function eo(e, t) {
      return new Promise(function(r, n) {
        function i(a2) {
          e.removeListener(t, o2), n(a2);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        Fr2(e, t, o2, { once: true }), t !== "error" && to(e, i, { once: true });
      });
    }
    function to(e, t, r) {
      typeof e.on == "function" && Fr2(e, "error", t, r);
    }
    function Fr2(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  _t = b2((Tf, Nr) => {
    Nr.exports = bt2().EventEmitter;
  });
  qr = b2((We) => {
    We.byteLength = no;
    We.toByteArray = oo;
    We.fromByteArray = fo;
    var H2 = [], U = [], ro = typeof Uint8Array < "u" ? Uint8Array : Array, vt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ae = 0, Ur2 = vt.length;ae < Ur2; ++ae)
      H2[ae] = vt[ae], U[vt.charCodeAt(ae)] = ae;
    var ae, Ur2;
    U[45] = 62;
    U[95] = 63;
    function Pr(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function no(e) {
      var t = Pr(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function io(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function oo(e) {
      var t, r = Pr(e), n = r[0], i = r[1], o2 = new ro(io(e, n, i)), a2 = 0, s = i > 0 ? n - 4 : n, u;
      for (u = 0;u < s; u += 4)
        t = U[e.charCodeAt(u)] << 18 | U[e.charCodeAt(u + 1)] << 12 | U[e.charCodeAt(u + 2)] << 6 | U[e.charCodeAt(u + 3)], o2[a2++] = t >> 16 & 255, o2[a2++] = t >> 8 & 255, o2[a2++] = t & 255;
      return i === 2 && (t = U[e.charCodeAt(u)] << 2 | U[e.charCodeAt(u + 1)] >> 4, o2[a2++] = t & 255), i === 1 && (t = U[e.charCodeAt(u)] << 10 | U[e.charCodeAt(u + 1)] << 4 | U[e.charCodeAt(u + 2)] >> 2, o2[a2++] = t >> 8 & 255, o2[a2++] = t & 255), o2;
    }
    function ao(e) {
      return H2[e >> 18 & 63] + H2[e >> 12 & 63] + H2[e >> 6 & 63] + H2[e & 63];
    }
    function so2(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(ao(n));
      return i.join("");
    }
    function fo(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, a2 = 0, s = r - n;a2 < s; a2 += o2)
        i.push(so2(e, a2, a2 + o2 > s ? s : a2 + o2));
      return n === 1 ? (t = e[r - 1], i.push(H2[t >> 2] + H2[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(H2[t >> 10] + H2[t >> 4 & 63] + H2[t << 2 & 63] + "=")), i.join("");
    }
  });
  Dr = b2((Et) => {
    Et.read = function(e, t, r, n, i) {
      var o2, a2, s = i * 8 - n - 1, u = (1 << s) - 1, l2 = u >> 1, h2 = -7, c = r ? i - 1 : 0, d2 = r ? -1 : 1, p2 = e[t + c];
      for (c += d2, o2 = p2 & (1 << -h2) - 1, p2 >>= -h2, h2 += s;h2 > 0; o2 = o2 * 256 + e[t + c], c += d2, h2 -= 8)
        ;
      for (a2 = o2 & (1 << -h2) - 1, o2 >>= -h2, h2 += n;h2 > 0; a2 = a2 * 256 + e[t + c], c += d2, h2 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l2;
      else {
        if (o2 === u)
          return a2 ? NaN : (p2 ? -1 : 1) * (1 / 0);
        a2 = a2 + Math.pow(2, n), o2 = o2 - l2;
      }
      return (p2 ? -1 : 1) * a2 * Math.pow(2, o2 - n);
    };
    Et.write = function(e, t, r, n, i, o2) {
      var a2, s, u, l2 = o2 * 8 - i - 1, h2 = (1 << l2) - 1, c = h2 >> 1, d2 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p2 = n ? 0 : o2 - 1, g2 = n ? 1 : -1, E3 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a2 = h2) : (a2 = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -a2)) < 1 && (a2--, u *= 2), a2 + c >= 1 ? t += d2 / u : t += d2 * Math.pow(2, 1 - c), t * u >= 2 && (a2++, u /= 2), a2 + c >= h2 ? (s = 0, a2 = h2) : a2 + c >= 1 ? (s = (t * u - 1) * Math.pow(2, i), a2 = a2 + c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, i), a2 = 0));i >= 8; e[r + p2] = s & 255, p2 += g2, s /= 256, i -= 8)
        ;
      for (a2 = a2 << i | s, l2 += i;l2 > 0; e[r + p2] = a2 & 255, p2 += g2, a2 /= 256, l2 -= 8)
        ;
      e[r + p2 - g2] |= E3 * 128;
    };
  });
  _e = b2((be) => {
    var xt = qr(), we = Dr(), kr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    be.Buffer = f;
    be.SlowBuffer = yo;
    be.INSPECT_MAX_BYTES = 50;
    var $e = 2147483647;
    be.kMaxLength = $e;
    f.TYPED_ARRAY_SUPPORT = uo();
    !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function uo() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(f.prototype, "parent", { enumerable: true, get: function() {
      if (!!f.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(f.prototype, "offset", { enumerable: true, get: function() {
      if (!!f.isBuffer(this))
        return this.byteOffset;
    } });
    function X(e) {
      if (e > $e)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, f.prototype), t;
    }
    function f(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return At2(e);
      }
      return $r(e, t, r);
    }
    f.poolSize = 8192;
    function $r(e, t, r) {
      if (typeof e == "string")
        return ho(e, t);
      if (ArrayBuffer.isView(e))
        return co(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (W(e, ArrayBuffer) || e && W(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (W(e, SharedArrayBuffer) || e && W(e.buffer, SharedArrayBuffer)))
        return St(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return f.from(n, t, r);
      let i = po(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return f.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    f.from = function(e, t, r) {
      return $r(e, t, r);
    };
    Object.setPrototypeOf(f.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(f, Uint8Array);
    function Gr(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function lo(e, t, r) {
      return Gr(e), e <= 0 ? X(e) : t !== undefined ? typeof r == "string" ? X(e).fill(t, r) : X(e).fill(t) : X(e);
    }
    f.alloc = function(e, t, r) {
      return lo(e, t, r);
    };
    function At2(e) {
      return Gr(e), X(e < 0 ? 0 : Bt(e) | 0);
    }
    f.allocUnsafe = function(e) {
      return At2(e);
    };
    f.allocUnsafeSlow = function(e) {
      return At2(e);
    };
    function ho(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !f.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = Kr2(e, t) | 0, n = X(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Rt(e) {
      let t = e.length < 0 ? 0 : Bt(e.length) | 0, r = X(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function co(e) {
      if (W(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return St(t.buffer, t.byteOffset, t.byteLength);
      }
      return Rt(e);
    }
    function St(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, f.prototype), n;
    }
    function po(e) {
      if (f.isBuffer(e)) {
        let t = Bt(e.length) | 0, r = X(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || It(e.length) ? X(0) : Rt(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Rt(e.data);
    }
    function Bt(e) {
      if (e >= $e)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + $e.toString(16) + " bytes");
      return e | 0;
    }
    function yo(e) {
      return +e != e && (e = 0), f.alloc(+e);
    }
    f.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== f.prototype;
    };
    f.compare = function(t, r) {
      if (W(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)), W(r, Uint8Array) && (r = f.from(r, r.offset, r.byteLength)), !f.isBuffer(t) || !f.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, a2 = Math.min(n, i);o2 < a2; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    f.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    f.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return f.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = f.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let a2 = t[n];
        if (W(a2, Uint8Array))
          o2 + a2.length > i.length ? (f.isBuffer(a2) || (a2 = f.from(a2)), a2.copy(i, o2)) : Uint8Array.prototype.set.call(i, a2, o2);
        else if (f.isBuffer(a2))
          a2.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += a2.length;
      }
      return i;
    };
    function Kr2(e, t) {
      if (f.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || W(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Tt(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return tn(e).length;
          default:
            if (i)
              return n ? -1 : Tt(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    f.byteLength = Kr2;
    function go(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return To(this, t, r);
          case "utf8":
          case "utf-8":
            return Yr(this, t, r);
          case "ascii":
            return Ro(this, t, r);
          case "latin1":
          case "binary":
            return So(this, t, r);
          case "base64":
            return Eo(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ao(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    f.prototype._isBuffer = true;
    function se(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    f.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        se(this, r, r + 1);
      return this;
    };
    f.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        se(this, r, r + 3), se(this, r + 1, r + 2);
      return this;
    };
    f.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        se(this, r, r + 7), se(this, r + 1, r + 6), se(this, r + 2, r + 5), se(this, r + 3, r + 4);
      return this;
    };
    f.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? Yr(this, 0, t) : go.apply(this, arguments);
    };
    f.prototype.toLocaleString = f.prototype.toString;
    f.prototype.equals = function(t) {
      if (!f.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : f.compare(this, t) === 0;
    };
    f.prototype.inspect = function() {
      let t = "", r = be.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    kr && (f.prototype[kr] = f.prototype.inspect);
    f.prototype.compare = function(t, r, n, i, o2) {
      if (W(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)), !f.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let a2 = o2 - i, s = n - r, u = Math.min(a2, s), l2 = this.slice(i, o2), h2 = t.slice(r, n);
      for (let c = 0;c < u; ++c)
        if (l2[c] !== h2[c]) {
          a2 = l2[c], s = h2[c];
          break;
        }
      return a2 < s ? -1 : s < a2 ? 1 : 0;
    };
    function Vr(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, It(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = f.from(t, n)), f.isBuffer(t))
        return t.length === 0 ? -1 : jr(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : jr(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function jr(e, t, r, n, i) {
      let o2 = 1, a2 = e.length, s = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, a2 /= 2, s /= 2, r /= 2;
      }
      function u(h2, c) {
        return o2 === 1 ? h2[c] : h2.readUInt16BE(c * o2);
      }
      let l2;
      if (i) {
        let h2 = -1;
        for (l2 = r;l2 < a2; l2++)
          if (u(e, l2) === u(t, h2 === -1 ? 0 : l2 - h2)) {
            if (h2 === -1 && (h2 = l2), l2 - h2 + 1 === s)
              return h2 * o2;
          } else
            h2 !== -1 && (l2 -= l2 - h2), h2 = -1;
      } else
        for (r + s > a2 && (r = a2 - s), l2 = r;l2 >= 0; l2--) {
          let h2 = true;
          for (let c = 0;c < s; c++)
            if (u(e, l2 + c) !== u(t, c)) {
              h2 = false;
              break;
            }
          if (h2)
            return l2;
        }
      return -1;
    }
    f.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    f.prototype.indexOf = function(t, r, n) {
      return Vr(this, t, r, n, true);
    };
    f.prototype.lastIndexOf = function(t, r, n) {
      return Vr(this, t, r, n, false);
    };
    function wo(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let a2;
      for (a2 = 0;a2 < n; ++a2) {
        let s = parseInt(t.substr(a2 * 2, 2), 16);
        if (It(s))
          return a2;
        e[r + a2] = s;
      }
      return a2;
    }
    function mo(e, t, r, n) {
      return Ge(Tt(t, e.length - r), e, r, n);
    }
    function bo(e, t, r, n) {
      return Ge(Lo(t), e, r, n);
    }
    function _o(e, t, r, n) {
      return Ge(tn(t), e, r, n);
    }
    function vo(e, t, r, n) {
      return Ge(Mo(t, e.length - r), e, r, n);
    }
    f.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let a2 = false;
      for (;; )
        switch (i) {
          case "hex":
            return wo(this, t, r, n);
          case "utf8":
          case "utf-8":
            return mo(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return bo(this, t, r, n);
          case "base64":
            return _o(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return vo(this, t, r, n);
          default:
            if (a2)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), a2 = true;
        }
    };
    f.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Eo(e, t, r) {
      return t === 0 && r === e.length ? xt.fromByteArray(e) : xt.fromByteArray(e.slice(t, r));
    }
    function Yr(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], a2 = null, s = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + s <= r) {
          let u, l2, h2, c;
          switch (s) {
            case 1:
              o2 < 128 && (a2 = o2);
              break;
            case 2:
              u = e[i + 1], (u & 192) === 128 && (c = (o2 & 31) << 6 | u & 63, c > 127 && (a2 = c));
              break;
            case 3:
              u = e[i + 1], l2 = e[i + 2], (u & 192) === 128 && (l2 & 192) === 128 && (c = (o2 & 15) << 12 | (u & 63) << 6 | l2 & 63, c > 2047 && (c < 55296 || c > 57343) && (a2 = c));
              break;
            case 4:
              u = e[i + 1], l2 = e[i + 2], h2 = e[i + 3], (u & 192) === 128 && (l2 & 192) === 128 && (h2 & 192) === 128 && (c = (o2 & 15) << 18 | (u & 63) << 12 | (l2 & 63) << 6 | h2 & 63, c > 65535 && c < 1114112 && (a2 = c));
          }
        }
        a2 === null ? (a2 = 65533, s = 1) : a2 > 65535 && (a2 -= 65536, n.push(a2 >>> 10 & 1023 | 55296), a2 = 56320 | a2 & 1023), n.push(a2), i += s;
      }
      return xo(n);
    }
    var Hr = 4096;
    function xo(e) {
      let t = e.length;
      if (t <= Hr)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += Hr));
      return r;
    }
    function Ro(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function So(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function To(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += Oo[e[o2]];
      return i;
    }
    function Ao(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    f.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, f.prototype), i;
    };
    function C2(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    f.prototype.readUintLE = f.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C2(t, r, this.length);
      let i = this[t], o2 = 1, a2 = 0;
      for (;++a2 < r && (o2 *= 256); )
        i += this[t + a2] * o2;
      return i;
    };
    f.prototype.readUintBE = f.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C2(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    f.prototype.readUint8 = f.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || C2(t, 1, this.length), this[t];
    };
    f.prototype.readUint16LE = f.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || C2(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    f.prototype.readUint16BE = f.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || C2(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    f.prototype.readUint32LE = f.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || C2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    f.prototype.readUint32BE = f.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || C2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    f.prototype.readBigUInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    f.prototype.readBigUInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    f.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C2(t, r, this.length);
      let i = this[t], o2 = 1, a2 = 0;
      for (;++a2 < r && (o2 *= 256); )
        i += this[t + a2] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    f.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || C2(t, r, this.length);
      let i = r, o2 = 1, a2 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        a2 += this[t + --i] * o2;
      return o2 *= 128, a2 >= o2 && (a2 -= Math.pow(2, 8 * r)), a2;
    };
    f.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || C2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    f.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || C2(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || C2(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || C2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    f.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || C2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    f.prototype.readBigInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    f.prototype.readBigInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ie(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    f.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || C2(t, 4, this.length), we.read(this, t, true, 23, 4);
    };
    f.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || C2(t, 4, this.length), we.read(this, t, false, 23, 4);
    };
    f.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || C2(t, 8, this.length), we.read(this, t, true, 52, 8);
    };
    f.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || C2(t, 8, this.length), we.read(this, t, false, 52, 8);
    };
    function O(e, t, r, n, i, o2) {
      if (!f.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    f.prototype.writeUintLE = f.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s = Math.pow(2, 8 * n) - 1;
        O(this, t, r, n, s, 0);
      }
      let o2 = 1, a2 = 0;
      for (this[r] = t & 255;++a2 < n && (o2 *= 256); )
        this[r + a2] = t / o2 & 255;
      return r + n;
    };
    f.prototype.writeUintBE = f.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s = Math.pow(2, 8 * n) - 1;
        O(this, t, r, n, s, 0);
      }
      let o2 = n - 1, a2 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a2 *= 256); )
        this[r + o2] = t / a2 & 255;
      return r + n;
    };
    f.prototype.writeUint8 = f.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function Xr(e, t, r, n, i) {
      en(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, r;
    }
    function zr(e, t, r, n, i) {
      en(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = a2, a2 = a2 >> 8, e[r + 2] = a2, a2 = a2 >> 8, e[r + 1] = a2, a2 = a2 >> 8, e[r] = a2, r + 8;
    }
    f.prototype.writeBigUInt64LE = ee(function(t, r = 0) {
      return Xr(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f.prototype.writeBigUInt64BE = ee(function(t, r = 0) {
      return zr(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u = Math.pow(2, 8 * n - 1);
        O(this, t, r, n, u - 1, -u);
      }
      let o2 = 0, a2 = 1, s = 0;
      for (this[r] = t & 255;++o2 < n && (a2 *= 256); )
        t < 0 && s === 0 && this[r + o2 - 1] !== 0 && (s = 1), this[r + o2] = (t / a2 >> 0) - s & 255;
      return r + n;
    };
    f.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u = Math.pow(2, 8 * n - 1);
        O(this, t, r, n, u - 1, -u);
      }
      let o2 = n - 1, a2 = 1, s = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a2 *= 256); )
        t < 0 && s === 0 && this[r + o2 + 1] !== 0 && (s = 1), this[r + o2] = (t / a2 >> 0) - s & 255;
      return r + n;
    };
    f.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    f.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    f.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    f.prototype.writeBigInt64LE = ee(function(t, r = 0) {
      return Xr(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    f.prototype.writeBigInt64BE = ee(function(t, r = 0) {
      return zr(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Zr2(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function Jr(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Zr2(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), we.write(e, t, r, n, 23, 4), r + 4;
    }
    f.prototype.writeFloatLE = function(t, r, n) {
      return Jr(this, t, r, true, n);
    };
    f.prototype.writeFloatBE = function(t, r, n) {
      return Jr(this, t, r, false, n);
    };
    function Qr(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || Zr2(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), we.write(e, t, r, n, 52, 8), r + 8;
    }
    f.prototype.writeDoubleLE = function(t, r, n) {
      return Qr(this, t, r, true, n);
    };
    f.prototype.writeDoubleBE = function(t, r, n) {
      return Qr(this, t, r, false, n);
    };
    f.prototype.copy = function(t, r, n, i) {
      if (!f.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    f.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !f.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let a2 = t.charCodeAt(0);
          (i === "utf8" && a2 < 128 || i === "latin1") && (t = a2);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let a2 = f.isBuffer(t) ? t : f.from(t, i), s = a2.length;
        if (s === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = a2[o2 % s];
      }
      return this;
    };
    var ge = {};
    function Ct(e, t, r) {
      ge[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    Ct("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Ct("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    Ct("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Wr(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = Wr(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function Wr(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function Bo(e, t, r) {
      me(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ie(t, e.length - (r + 1));
    }
    function en(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let a2 = typeof t == "bigint" ? "n" : "", s;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? s = `>= 0${a2} and < 2${a2} ** ${(o2 + 1) * 8}${a2}` : s = `>= -(2${a2} ** ${(o2 + 1) * 8 - 1}${a2}) and < 2 ** ${(o2 + 1) * 8 - 1}${a2}` : s = `>= ${t}${a2} and <= ${r}${a2}`, new ge.ERR_OUT_OF_RANGE("value", s, e);
      }
      Bo(n, i, o2);
    }
    function me(e, t) {
      if (typeof e != "number")
        throw new ge.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ie(e, t, r) {
      throw Math.floor(e) !== e ? (me(e, r), new ge.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new ge.ERR_BUFFER_OUT_OF_BOUNDS : new ge.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var Co = /[^+/0-9A-Za-z-_]/g;
    function Io(e) {
      if (e = e.split("=")[0], e = e.trim().replace(Co, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Tt(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let a2 = 0;a2 < n; ++a2) {
        if (r = e.charCodeAt(a2), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (a2 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function Lo(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Mo(e, t) {
      let r, n, i, o2 = [];
      for (let a2 = 0;a2 < e.length && !((t -= 2) < 0); ++a2)
        r = e.charCodeAt(a2), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function tn(e) {
      return xt.toByteArray(Io(e));
    }
    function Ge(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function W(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function It(e) {
      return e !== e;
    }
    var Oo = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function ee(e) {
      return typeof BigInt > "u" ? Fo : e;
    }
    function Fo() {
      throw new Error("BigInt not supported");
    }
  });
  Lt = b2(() => {});
  an = b2((Of, on) => {
    function rn(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function No(e) {
      for (var t = 1;t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? rn(Object(r), true).forEach(function(n) {
          Uo(e, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : rn(Object(r)).forEach(function(n) {
          Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return e;
    }
    function Uo(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    function Po(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function nn(e, t) {
      for (var r = 0;r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function qo(e, t, r) {
      return t && nn(e.prototype, t), r && nn(e, r), e;
    }
    var Do = _e(), Ke = Do.Buffer, ko = Lt(), Mt = ko.inspect, jo = Mt && Mt.custom || "inspect";
    function Ho(e, t, r) {
      Ke.prototype.copy.call(e, t, r);
    }
    on.exports = function() {
      function e() {
        Po(this, e), this.head = null, this.tail = null, this.length = 0;
      }
      return qo(e, [{ key: "push", value: function(r) {
        var n = { data: r, next: null };
        this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var n = { data: r, next: this.head };
        this.length === 0 && (this.tail = n), this.head = n, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var n = this.head, i = "" + n.data;n = n.next; )
          i += r + n.data;
        return i;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return Ke.alloc(0);
        for (var n = Ke.allocUnsafe(r >>> 0), i = this.head, o2 = 0;i; )
          Ho(i.data, n, o2), o2 += i.data.length, i = i.next;
        return n;
      } }, { key: "consume", value: function(r, n) {
        var i;
        return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var n = this.head, i = 1, o2 = n.data;
        for (r -= o2.length;n = n.next; ) {
          var a2 = n.data, s = r > a2.length ? a2.length : r;
          if (s === a2.length ? o2 += a2 : o2 += a2.slice(0, r), r -= s, r === 0) {
            s === a2.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = a2.slice(s));
            break;
          }
          ++i;
        }
        return this.length -= i, o2;
      } }, { key: "_getBuffer", value: function(r) {
        var n = Ke.allocUnsafe(r), i = this.head, o2 = 1;
        for (i.data.copy(n), r -= i.data.length;i = i.next; ) {
          var a2 = i.data, s = r > a2.length ? a2.length : r;
          if (a2.copy(n, n.length - r, 0, s), r -= s, r === 0) {
            s === a2.length ? (++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = a2.slice(s));
            break;
          }
          ++o2;
        }
        return this.length -= o2, n;
      } }, { key: jo, value: function(r, n) {
        return Mt(this, No({}, n, { depth: 0, customInspect: false }));
      } }]), e;
    }();
  });
  Ft = b2((Ff, fn) => {
    function Wo(e, t) {
      var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
      return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(Ot, this, e)) : process.nextTick(Ot, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(o2) {
        !t && o2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Ve, r) : (r._writableState.errorEmitted = true, process.nextTick(sn, r, o2)) : process.nextTick(sn, r, o2) : t ? (process.nextTick(Ve, r), t(o2)) : process.nextTick(Ve, r);
      }), this);
    }
    function sn(e, t) {
      Ot(e, t), Ve(e);
    }
    function Ve(e) {
      e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function $o() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function Ot(e, t) {
      e.emit("error", t);
    }
    function Go(e, t) {
      var { _readableState: r, _writableState: n } = e;
      r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    fn.exports = { destroy: Wo, undestroy: $o, errorOrDestroy: Go };
  });
  fe = b2((Nf, hn) => {
    function Ko(e, t) {
      e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var ln = {};
    function P2(e, t, r) {
      r || (r = Error);
      function n(o2, a2, s) {
        return typeof t == "string" ? t : t(o2, a2, s);
      }
      var i = function(o2) {
        Ko(a2, o2);
        function a2(s, u, l2) {
          return o2.call(this, n(s, u, l2)) || this;
        }
        return a2;
      }(r);
      i.prototype.name = r.name, i.prototype.code = e, ln[e] = i;
    }
    function un(e, t) {
      if (Array.isArray(e)) {
        var r = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
      } else
        return "of ".concat(t, " ").concat(String(e));
    }
    function Vo(e, t, r) {
      return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function Yo(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function Xo(e, t, r) {
      return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
    }
    P2("ERR_INVALID_OPT_VALUE", function(e, t) {
      return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    P2("ERR_INVALID_ARG_TYPE", function(e, t, r) {
      var n;
      typeof t == "string" && Vo(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      var i;
      if (Yo(e, " argument"))
        i = "The ".concat(e, " ").concat(n, " ").concat(un(t, "type"));
      else {
        var o2 = Xo(e, ".") ? "property" : "argument";
        i = 'The "'.concat(e, '" ').concat(o2, " ").concat(n, " ").concat(un(t, "type"));
      }
      return i += ". Received type ".concat(typeof r), i;
    }, TypeError);
    P2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    P2("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
      return "The " + e + " method is not implemented";
    });
    P2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    P2("ERR_STREAM_DESTROYED", function(e) {
      return "Cannot call " + e + " after a stream was destroyed";
    });
    P2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    P2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    P2("ERR_STREAM_WRITE_AFTER_END", "write after end");
    P2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    P2("ERR_UNKNOWN_ENCODING", function(e) {
      return "Unknown encoding: " + e;
    }, TypeError);
    P2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    hn.exports.codes = ln;
  });
  Nt = b2((Uf, cn) => {
    var zo = fe().codes.ERR_INVALID_OPT_VALUE;
    function Zo(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function Jo(e, t, r, n) {
      var i = Zo(t, n, r);
      if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
          var o2 = n ? r : "highWaterMark";
          throw new zo(o2, i);
        }
        return Math.floor(i);
      }
      return e.objectMode ? 16 : 16 * 1024;
    }
    cn.exports = { getHighWaterMark: Jo };
  });
  pn = b2((Pf, dn) => {
    dn.exports = Qo;
    function Qo(e, t) {
      if (Ut("noDeprecation"))
        return e;
      var r = false;
      function n() {
        if (!r) {
          if (Ut("throwDeprecation"))
            throw new Error(t);
          Ut("traceDeprecation") ? console.trace(t) : console.warn(t), r = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    }
    function Ut(e) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var t = global.localStorage[e];
      return t == null ? false : String(t).toLowerCase() === "true";
    }
  });
  Dt = b2((qf, _n) => {
    _n.exports = A2;
    function gn(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        Ta(t, e);
      };
    }
    var ve;
    A2.WritableState = Me;
    var ea = { deprecate: pn() }, wn = _t(), Xe = _e().Buffer, ta = global.Uint8Array || function() {};
    function ra(e) {
      return Xe.from(e);
    }
    function na(e) {
      return Xe.isBuffer(e) || e instanceof ta;
    }
    var qt = Ft(), ia = Nt(), oa = ia.getHighWaterMark, te = fe().codes, aa = te.ERR_INVALID_ARG_TYPE, sa = te.ERR_METHOD_NOT_IMPLEMENTED, fa = te.ERR_MULTIPLE_CALLBACK, ua = te.ERR_STREAM_CANNOT_PIPE, la = te.ERR_STREAM_DESTROYED, ha = te.ERR_STREAM_NULL_VALUES, ca = te.ERR_STREAM_WRITE_AFTER_END, da = te.ERR_UNKNOWN_ENCODING, Ee = qt.errorOrDestroy;
    Q()(A2, wn);
    function pa() {}
    function Me(e, t, r) {
      ve = ve || ue(), e = e || {}, typeof r != "boolean" && (r = t instanceof ve), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = oa(this, e, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var n = e.decodeStrings === false;
      this.decodeStrings = !n, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
        va(t, i);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new gn(this);
    }
    Me.prototype.getBuffer = function() {
      for (var t = this.bufferedRequest, r = [];t; )
        r.push(t), t = t.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Me.prototype, "buffer", { get: ea.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {}
    })();
    var Ye;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ye = Function.prototype[Symbol.hasInstance], Object.defineProperty(A2, Symbol.hasInstance, { value: function(t) {
      return Ye.call(this, t) ? true : this !== A2 ? false : t && t._writableState instanceof Me;
    } })) : Ye = function(t) {
      return t instanceof this;
    };
    function A2(e) {
      ve = ve || ue();
      var t = this instanceof ve;
      if (!t && !Ye.call(A2, this))
        return new A2(e);
      this._writableState = new Me(e, this, t), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), wn.call(this);
    }
    A2.prototype.pipe = function() {
      Ee(this, new ua);
    };
    function ya(e, t) {
      var r = new ca;
      Ee(e, r), process.nextTick(t, r);
    }
    function ga(e, t, r, n) {
      var i;
      return r === null ? i = new ha : typeof r != "string" && !t.objectMode && (i = new aa("chunk", ["string", "Buffer"], r)), i ? (Ee(e, i), process.nextTick(n, i), false) : true;
    }
    A2.prototype.write = function(e, t, r) {
      var n = this._writableState, i = false, o2 = !n.objectMode && na(e);
      return o2 && !Xe.isBuffer(e) && (e = ra(e)), typeof t == "function" && (r = t, t = null), o2 ? t = "buffer" : t || (t = n.defaultEncoding), typeof r != "function" && (r = pa), n.ending ? ya(this, r) : (o2 || ga(this, n, e, r)) && (n.pendingcb++, i = ma(this, n, o2, e, t, r)), i;
    };
    A2.prototype.cork = function() {
      this._writableState.corked++;
    };
    A2.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && mn(this, e));
    };
    A2.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1))
        throw new da(t);
      return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(A2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function wa(e, t, r) {
      return !e.objectMode && e.decodeStrings !== false && typeof t == "string" && (t = Xe.from(t, r)), t;
    }
    Object.defineProperty(A2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function ma(e, t, r, n, i, o2) {
      if (!r) {
        var a2 = wa(t, n, i);
        n !== a2 && (r = true, i = "buffer", n = a2);
      }
      var s = t.objectMode ? 1 : n.length;
      t.length += s;
      var u = t.length < t.highWaterMark;
      if (u || (t.needDrain = true), t.writing || t.corked) {
        var l2 = t.lastBufferedRequest;
        t.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o2, next: null }, l2 ? l2.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
      } else
        Pt(e, t, false, s, n, i, o2);
      return u;
    }
    function Pt(e, t, r, n, i, o2, a2) {
      t.writelen = n, t.writecb = a2, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new la("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function ba(e, t, r, n, i) {
      --t.pendingcb, r ? (process.nextTick(i, n), process.nextTick(Le, e, t), e._writableState.errorEmitted = true, Ee(e, n)) : (i(n), e._writableState.errorEmitted = true, Ee(e, n), Le(e, t));
    }
    function _a(e) {
      e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function va(e, t) {
      var r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function")
        throw new fa;
      if (_a(r), t)
        ba(e, r, n, t, i);
      else {
        var o2 = bn(r) || e.destroyed;
        !o2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && mn(e, r), n ? process.nextTick(yn, e, r, o2, i) : yn(e, r, o2, i);
      }
    }
    function yn(e, t, r, n) {
      r || Ea(e, t), t.pendingcb--, n(), Le(e, t);
    }
    function Ea(e, t) {
      t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));
    }
    function mn(e, t) {
      t.bufferProcessing = true;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount, i = new Array(n), o2 = t.corkedRequestsFree;
        o2.entry = r;
        for (var a2 = 0, s = true;r; )
          i[a2] = r, r.isBuf || (s = false), r = r.next, a2 += 1;
        i.allBuffers = s, Pt(e, t, true, t.length, i, "", o2.finish), t.pendingcb++, t.lastBufferedRequest = null, o2.next ? (t.corkedRequestsFree = o2.next, o2.next = null) : t.corkedRequestsFree = new gn(t), t.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: u, encoding: l2, callback: h2 } = r, c = t.objectMode ? 1 : u.length;
          if (Pt(e, t, false, c, u, l2, h2), r = r.next, t.bufferedRequestCount--, t.writing)
            break;
        }
        r === null && (t.lastBufferedRequest = null);
      }
      t.bufferedRequest = r, t.bufferProcessing = false;
    }
    A2.prototype._write = function(e, t, r) {
      r(new sa("_write()"));
    };
    A2.prototype._writev = null;
    A2.prototype.end = function(e, t, r) {
      var n = this._writableState;
      return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || Sa(this, n, r), this;
    };
    Object.defineProperty(A2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function bn(e) {
      return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function xa(e, t) {
      e._final(function(r) {
        t.pendingcb--, r && Ee(e, r), t.prefinished = true, e.emit("prefinish"), Le(e, t);
      });
    }
    function Ra(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = true, process.nextTick(xa, e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Le(e, t) {
      var r = bn(t);
      if (r && (Ra(e, t), t.pendingcb === 0 && (t.finished = true, e.emit("finish"), t.autoDestroy))) {
        var n = e._readableState;
        (!n || n.autoDestroy && n.endEmitted) && e.destroy();
      }
      return r;
    }
    function Sa(e, t, r) {
      t.ending = true, Le(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = true, e.writable = false;
    }
    function Ta(e, t, r) {
      var n = e.entry;
      for (e.entry = null;n; ) {
        var i = n.callback;
        t.pendingcb--, i(r), n = n.next;
      }
      t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(A2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(t) {
      !this._writableState || (this._writableState.destroyed = t);
    } });
    A2.prototype.destroy = qt.destroy;
    A2.prototype._undestroy = qt.undestroy;
    A2.prototype._destroy = function(e, t) {
      t(e);
    };
  });
  ue = b2((Df, En) => {
    var Aa = Object.keys || function(e) {
      var t = [];
      for (var r in e)
        t.push(r);
      return t;
    };
    En.exports = $;
    var vn = Ht(), jt = Dt();
    Q()($, vn);
    for (kt = Aa(jt.prototype), ze = 0;ze < kt.length; ze++)
      Ze = kt[ze], $.prototype[Ze] || ($.prototype[Ze] = jt.prototype[Ze]);
    var kt, Ze, ze;
    function $(e) {
      if (!(this instanceof $))
        return new $(e);
      vn.call(this, e), jt.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Ba)));
    }
    Object.defineProperty($.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ba() {
      this._writableState.ended || process.nextTick(Ca, this);
    }
    function Ca(e) {
      e.end();
    }
    Object.defineProperty($.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(t) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } });
  });
  Sn = b2((Wt, Rn) => {
    var Je = _e(), G = Je.Buffer;
    function xn(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    G.from && G.alloc && G.allocUnsafe && G.allocUnsafeSlow ? Rn.exports = Je : (xn(Je, Wt), Wt.Buffer = le);
    function le(e, t, r) {
      return G(e, t, r);
    }
    le.prototype = Object.create(G.prototype);
    xn(G, le);
    le.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return G(e, t, r);
    };
    le.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = G(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    le.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return G(e);
    };
    le.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return Je.SlowBuffer(e);
    };
  });
  Bn = b2((An) => {
    var Gt = Sn().Buffer, Tn = Gt.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function Ia(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function La(e) {
      var t = Ia(e);
      if (typeof t != "string" && (Gt.isEncoding === Tn || !Tn(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    An.StringDecoder = Oe;
    function Oe(e) {
      this.encoding = La(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = Pa, this.end = qa, t = 4;
          break;
        case "utf8":
          this.fillLast = Fa, t = 4;
          break;
        case "base64":
          this.text = Da, this.end = ka, t = 3;
          break;
        default:
          this.write = ja, this.end = Ha;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Gt.allocUnsafe(t);
    }
    Oe.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Oe.prototype.end = Ua;
    Oe.prototype.text = Na;
    Oe.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function $t(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Ma(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = $t(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = $t(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = $t(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function Oa(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function Fa(e) {
      var t = this.lastTotal - this.lastNeed, r = Oa(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Na(e, t) {
      var r = Ma(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function Ua(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function Pa(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function qa(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Da(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function ka(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function ja(e) {
      return e.toString(this.encoding);
    }
    function Ha(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Kt = {};
  Er(Kt, { StringDecoder: () => Qe.StringDecoder, default: () => Qe.StringDecoder });
  Vt = vr(() => {
    Qe = Rr2(Bn());
  });
  et = b2((jf, Ln) => {
    var Cn = fe().codes.ERR_STREAM_PREMATURE_CLOSE;
    function Wa(e) {
      var t = false;
      return function() {
        if (!t) {
          t = true;
          for (var r = arguments.length, n = new Array(r), i = 0;i < r; i++)
            n[i] = arguments[i];
          e.apply(this, n);
        }
      };
    }
    function $a() {}
    function Ga(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function In(e, t, r) {
      if (typeof t == "function")
        return In(e, null, t);
      t || (t = {}), r = Wa(r || $a);
      var n = t.readable || t.readable !== false && e.readable, i = t.writable || t.writable !== false && e.writable, o2 = function() {
        e.writable || s();
      }, a2 = e._writableState && e._writableState.finished, s = function() {
        i = false, a2 = true, n || r.call(e);
      }, u = e._readableState && e._readableState.endEmitted, l2 = function() {
        n = false, u = true, i || r.call(e);
      }, h2 = function(g2) {
        r.call(e, g2);
      }, c = function() {
        var g2;
        if (n && !u)
          return (!e._readableState || !e._readableState.ended) && (g2 = new Cn), r.call(e, g2);
        if (i && !a2)
          return (!e._writableState || !e._writableState.ended) && (g2 = new Cn), r.call(e, g2);
      }, d2 = function() {
        e.req.on("finish", s);
      };
      return Ga(e) ? (e.on("complete", s), e.on("abort", c), e.req ? d2() : e.on("request", d2)) : i && !e._writableState && (e.on("end", o2), e.on("close", o2)), e.on("end", l2), e.on("finish", s), t.error !== false && e.on("error", h2), e.on("close", c), function() {
        e.removeListener("complete", s), e.removeListener("abort", c), e.removeListener("request", d2), e.req && e.req.removeListener("finish", s), e.removeListener("end", o2), e.removeListener("close", o2), e.removeListener("finish", s), e.removeListener("end", l2), e.removeListener("error", h2), e.removeListener("close", c);
      };
    }
    Ln.exports = In;
  });
  On = b2((Hf, Mn) => {
    var tt2;
    function re2(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    var Ka = et(), ne = Symbol("lastResolve"), he = Symbol("lastReject"), Fe = Symbol("error"), rt2 = Symbol("ended"), ce2 = Symbol("lastPromise"), Yt = Symbol("handlePromise"), de = Symbol("stream");
    function ie(e, t) {
      return { value: e, done: t };
    }
    function Va(e) {
      var t = e[ne];
      if (t !== null) {
        var r = e[de].read();
        r !== null && (e[ce2] = null, e[ne] = null, e[he] = null, t(ie(r, false)));
      }
    }
    function Ya(e) {
      process.nextTick(Va, e);
    }
    function Xa(e, t) {
      return function(r, n) {
        e.then(function() {
          if (t[rt2]) {
            r(ie(undefined, true));
            return;
          }
          t[Yt](r, n);
        }, n);
      };
    }
    var za = Object.getPrototypeOf(function() {}), Za = Object.setPrototypeOf((tt2 = { get stream() {
      return this[de];
    }, next: function() {
      var t = this, r = this[Fe];
      if (r !== null)
        return Promise.reject(r);
      if (this[rt2])
        return Promise.resolve(ie(undefined, true));
      if (this[de].destroyed)
        return new Promise(function(a2, s) {
          process.nextTick(function() {
            t[Fe] ? s(t[Fe]) : a2(ie(undefined, true));
          });
        });
      var n = this[ce2], i;
      if (n)
        i = new Promise(Xa(n, this));
      else {
        var o2 = this[de].read();
        if (o2 !== null)
          return Promise.resolve(ie(o2, false));
        i = new Promise(this[Yt]);
      }
      return this[ce2] = i, i;
    } }, re2(tt2, Symbol.asyncIterator, function() {
      return this;
    }), re2(tt2, "return", function() {
      var t = this;
      return new Promise(function(r, n) {
        t[de].destroy(null, function(i) {
          if (i) {
            n(i);
            return;
          }
          r(ie(undefined, true));
        });
      });
    }), tt2), za), Ja = function(t) {
      var r, n = Object.create(Za, (r = {}, re2(r, de, { value: t, writable: true }), re2(r, ne, { value: null, writable: true }), re2(r, he, { value: null, writable: true }), re2(r, Fe, { value: null, writable: true }), re2(r, rt2, { value: t._readableState.endEmitted, writable: true }), re2(r, Yt, { value: function(o2, a2) {
        var s = n[de].read();
        s ? (n[ce2] = null, n[ne] = null, n[he] = null, o2(ie(s, false))) : (n[ne] = o2, n[he] = a2);
      }, writable: true }), r));
      return n[ce2] = null, Ka(t, function(i) {
        if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var o2 = n[he];
          o2 !== null && (n[ce2] = null, n[ne] = null, n[he] = null, o2(i)), n[Fe] = i;
          return;
        }
        var a2 = n[ne];
        a2 !== null && (n[ce2] = null, n[ne] = null, n[he] = null, a2(ie(undefined, true))), n[rt2] = true;
      }), t.on("readable", Ya.bind(null, n)), n;
    };
    Mn.exports = Ja;
  });
  Nn = b2((Wf, Fn) => {
    Fn.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  Ht = b2((Gf, Gn) => {
    Gn.exports = _2;
    var xe;
    _2.ReadableState = Dn;
    var $f = bt2().EventEmitter, qn = function(t, r) {
      return t.listeners(r).length;
    }, Ue = _t(), nt2 = _e().Buffer, Qa = global.Uint8Array || function() {};
    function es(e) {
      return nt2.from(e);
    }
    function ts(e) {
      return nt2.isBuffer(e) || e instanceof Qa;
    }
    var Xt = Lt(), w2;
    Xt && Xt.debuglog ? w2 = Xt.debuglog("stream") : w2 = function() {};
    var rs = an(), rr = Ft(), ns = Nt(), is = ns.getHighWaterMark, it = fe().codes, os = it.ERR_INVALID_ARG_TYPE, as = it.ERR_STREAM_PUSH_AFTER_EOF, ss = it.ERR_METHOD_NOT_IMPLEMENTED, fs = it.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Re, zt, Zt;
    Q()(_2, Ue);
    var Ne = rr.errorOrDestroy, Jt = ["error", "close", "destroy", "pause", "resume"];
    function us(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    function Dn(e, t, r) {
      xe = xe || ue(), e = e || {}, typeof r != "boolean" && (r = t instanceof xe), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = is(this, e, "readableHighWaterMark", r), this.buffer = new rs, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (Re || (Re = (Vt(), dt2(Kt)).StringDecoder), this.decoder = new Re(e.encoding), this.encoding = e.encoding);
    }
    function _2(e) {
      if (xe = xe || ue(), !(this instanceof _2))
        return new _2(e);
      var t = this instanceof xe;
      this._readableState = new Dn(e, this, t), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), Ue.call(this);
    }
    Object.defineProperty(_2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } });
    _2.prototype.destroy = rr.destroy;
    _2.prototype._undestroy = rr.undestroy;
    _2.prototype._destroy = function(e, t) {
      t(e);
    };
    _2.prototype.push = function(e, t) {
      var r = this._readableState, n;
      return r.objectMode ? n = true : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = nt2.from(e, t), t = ""), n = true), kn(this, e, t, false, n);
    };
    _2.prototype.unshift = function(e) {
      return kn(this, e, null, true, false);
    };
    function kn(e, t, r, n, i) {
      w2("readableAddChunk", t);
      var o2 = e._readableState;
      if (t === null)
        o2.reading = false, cs(e, o2);
      else {
        var a2;
        if (i || (a2 = ls(o2, t)), a2)
          Ne(e, a2);
        else if (o2.objectMode || t && t.length > 0)
          if (typeof t != "string" && !o2.objectMode && Object.getPrototypeOf(t) !== nt2.prototype && (t = es(t)), n)
            o2.endEmitted ? Ne(e, new fs) : Qt(e, o2, t, true);
          else if (o2.ended)
            Ne(e, new as);
          else {
            if (o2.destroyed)
              return false;
            o2.reading = false, o2.decoder && !r ? (t = o2.decoder.write(t), o2.objectMode || t.length !== 0 ? Qt(e, o2, t, false) : tr(e, o2)) : Qt(e, o2, t, false);
          }
        else
          n || (o2.reading = false, tr(e, o2));
      }
      return !o2.ended && (o2.length < o2.highWaterMark || o2.length === 0);
    }
    function Qt(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ot(e)), tr(e, t);
    }
    function ls(e, t) {
      var r;
      return !ts(t) && typeof t != "string" && t !== undefined && !e.objectMode && (r = new os("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
    }
    _2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    _2.prototype.setEncoding = function(e) {
      Re || (Re = (Vt(), dt2(Kt)).StringDecoder);
      var t = new Re(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, n = "";r !== null; )
        n += t.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
    };
    var Un = 1073741824;
    function hs(e) {
      return e >= Un ? e = Un : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Pn(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = hs(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = true, 0));
    }
    _2.prototype.read = function(e) {
      w2("read", e), e = parseInt(e, 10);
      var t = this._readableState, r = e;
      if (e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return w2("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? er(this) : ot(this), null;
      if (e = Pn(e, t), e === 0 && t.ended)
        return t.length === 0 && er(this), null;
      var n = t.needReadable;
      w2("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, w2("length less than watermark", n)), t.ended || t.reading ? (n = false, w2("reading or ended", n)) : n && (w2("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true), this._read(t.highWaterMark), t.sync = false, t.reading || (e = Pn(r, t)));
      var i;
      return e > 0 ? i = Wn(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && er(this)), i !== null && this.emit("data", i), i;
    };
    function cs(e, t) {
      if (w2("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? ot(e) : (t.needReadable = false, t.emittedReadable || (t.emittedReadable = true, jn(e)));
      }
    }
    function ot(e) {
      var t = e._readableState;
      w2("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (w2("emitReadable", t.flowing), t.emittedReadable = true, process.nextTick(jn, e));
    }
    function jn(e) {
      var t = e._readableState;
      w2("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, nr(e);
    }
    function tr(e, t) {
      t.readingMore || (t.readingMore = true, process.nextTick(ds, e, t));
    }
    function ds(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        var r = t.length;
        if (w2("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    _2.prototype._read = function(e) {
      Ne(this, new ss("_read()"));
    };
    _2.prototype.pipe = function(e, t) {
      var r = this, n = this._readableState;
      switch (n.pipesCount) {
        case 0:
          n.pipes = e;
          break;
        case 1:
          n.pipes = [n.pipes, e];
          break;
        default:
          n.pipes.push(e);
          break;
      }
      n.pipesCount += 1, w2("pipe count=%d opts=%j", n.pipesCount, t);
      var i = (!t || t.end !== false) && e !== process.stdout && e !== process.stderr, o2 = i ? s : E3;
      n.endEmitted ? process.nextTick(o2) : r.once("end", o2), e.on("unpipe", a2);
      function a2(v2, m2) {
        w2("onunpipe"), v2 === r && m2 && m2.hasUnpiped === false && (m2.hasUnpiped = true, h2());
      }
      function s() {
        w2("onend"), e.end();
      }
      var u = ps(r);
      e.on("drain", u);
      var l2 = false;
      function h2() {
        w2("cleanup"), e.removeListener("close", p2), e.removeListener("finish", g2), e.removeListener("drain", u), e.removeListener("error", d2), e.removeListener("unpipe", a2), r.removeListener("end", s), r.removeListener("end", E3), r.removeListener("data", c), l2 = true, n.awaitDrain && (!e._writableState || e._writableState.needDrain) && u();
      }
      r.on("data", c);
      function c(v2) {
        w2("ondata");
        var m2 = e.write(v2);
        w2("dest.write", m2), m2 === false && ((n.pipesCount === 1 && n.pipes === e || n.pipesCount > 1 && $n(n.pipes, e) !== -1) && !l2 && (w2("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
      }
      function d2(v2) {
        w2("onerror", v2), E3(), e.removeListener("error", d2), qn(e, "error") === 0 && Ne(e, v2);
      }
      us(e, "error", d2);
      function p2() {
        e.removeListener("finish", g2), E3();
      }
      e.once("close", p2);
      function g2() {
        w2("onfinish"), e.removeListener("close", p2), E3();
      }
      e.once("finish", g2);
      function E3() {
        w2("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), n.flowing || (w2("pipe resume"), r.resume()), e;
    };
    function ps(e) {
      return function() {
        var r = e._readableState;
        w2("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && qn(e, "data") && (r.flowing = true, nr(e));
      };
    }
    _2.prototype.unpipe = function(e) {
      var t = this._readableState, r = { hasUnpiped: false };
      if (t.pipesCount === 0)
        return this;
      if (t.pipesCount === 1)
        return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = false, e && e.emit("unpipe", this, r), this);
      if (!e) {
        var { pipes: n, pipesCount: i } = t;
        t.pipes = null, t.pipesCount = 0, t.flowing = false;
        for (var o2 = 0;o2 < i; o2++)
          n[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var a2 = $n(t.pipes, e);
      return a2 === -1 ? this : (t.pipes.splice(a2, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    _2.prototype.on = function(e, t) {
      var r = Ue.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, w2("on readable", n.length, n.reading), n.length ? ot(this) : n.reading || process.nextTick(ys, this)), r;
    };
    _2.prototype.addListener = _2.prototype.on;
    _2.prototype.removeListener = function(e, t) {
      var r = Ue.prototype.removeListener.call(this, e, t);
      return e === "readable" && process.nextTick(Hn, this), r;
    };
    _2.prototype.removeAllListeners = function(e) {
      var t = Ue.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && process.nextTick(Hn, this), t;
    };
    function Hn(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = true : e.listenerCount("data") > 0 && e.resume();
    }
    function ys(e) {
      w2("readable nexttick read 0"), e.read(0);
    }
    _2.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (w2("resume"), e.flowing = !e.readableListening, gs(this, e)), e.paused = false, this;
    };
    function gs(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, process.nextTick(ws, e, t));
    }
    function ws(e, t) {
      w2("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), nr(e), t.flowing && !t.reading && e.read(0);
    }
    _2.prototype.pause = function() {
      return w2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (w2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function nr(e) {
      var t = e._readableState;
      for (w2("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    _2.prototype.wrap = function(e) {
      var t = this, r = this._readableState, n = false;
      e.on("end", function() {
        if (w2("wrapped end"), r.decoder && !r.ended) {
          var a2 = r.decoder.end();
          a2 && a2.length && t.push(a2);
        }
        t.push(null);
      }), e.on("data", function(a2) {
        if (w2("wrapped data"), r.decoder && (a2 = r.decoder.write(a2)), !(r.objectMode && a2 == null) && !(!r.objectMode && (!a2 || !a2.length))) {
          var s = t.push(a2);
          s || (n = true, e.pause());
        }
      });
      for (var i in e)
        this[i] === undefined && typeof e[i] == "function" && (this[i] = function(s) {
          return function() {
            return e[s].apply(e, arguments);
          };
        }(i));
      for (var o2 = 0;o2 < Jt.length; o2++)
        e.on(Jt[o2], this.emit.bind(this, Jt[o2]));
      return this._read = function(a2) {
        w2("wrapped _read", a2), n && (n = false, e.resume());
      }, this;
    };
    typeof Symbol == "function" && (_2.prototype[Symbol.asyncIterator] = function() {
      return zt === undefined && (zt = On()), zt(this);
    });
    Object.defineProperty(_2.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(_2.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(_2.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } });
    _2._fromList = Wn;
    Object.defineProperty(_2.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wn(e, t) {
      if (t.length === 0)
        return null;
      var r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function er(e) {
      var t = e._readableState;
      w2("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, process.nextTick(ms, t, e));
    }
    function ms(e, t) {
      if (w2("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t.readable = false, t.emit("end"), e.autoDestroy)) {
        var r = t._writableState;
        (!r || r.autoDestroy && r.finished) && t.destroy();
      }
    }
    typeof Symbol == "function" && (_2.from = function(e, t) {
      return Zt === undefined && (Zt = Nn()), Zt(_2, e, t);
    });
    function $n(e, t) {
      for (var r = 0, n = e.length;r < n; r++)
        if (e[r] === t)
          return r;
      return -1;
    }
  });
  ir = b2((Kf, Vn) => {
    Vn.exports = z;
    var at = fe().codes, bs = at.ERR_METHOD_NOT_IMPLEMENTED, _s = at.ERR_MULTIPLE_CALLBACK, vs = at.ERR_TRANSFORM_ALREADY_TRANSFORMING, Es = at.ERR_TRANSFORM_WITH_LENGTH_0, st2 = ue();
    Q()(z, st2);
    function xs(e, t) {
      var r = this._transformState;
      r.transforming = false;
      var n = r.writecb;
      if (n === null)
        return this.emit("error", new _s);
      r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
      var i = this._readableState;
      i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
    function z(e) {
      if (!(this instanceof z))
        return new z(e);
      st2.call(this, e), this._transformState = { afterTransform: xs.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Rs);
    }
    function Rs() {
      var e = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
        Kn(e, t, r);
      }) : Kn(this, null, null);
    }
    z.prototype.push = function(e, t) {
      return this._transformState.needTransform = false, st2.prototype.push.call(this, e, t);
    };
    z.prototype._transform = function(e, t, r) {
      r(new bs("_transform()"));
    };
    z.prototype._write = function(e, t, r) {
      var n = this._transformState;
      if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
      }
    };
    z.prototype._read = function(e) {
      var t = this._transformState;
      t.writechunk !== null && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
    };
    z.prototype._destroy = function(e, t) {
      st2.prototype._destroy.call(this, e, function(r) {
        t(r);
      });
    };
    function Kn(e, t, r) {
      if (t)
        return e.emit("error", t);
      if (r != null && e.push(r), e._writableState.length)
        throw new Es;
      if (e._transformState.transforming)
        throw new vs;
      return e.push(null);
    }
  });
  zn = b2((Vf, Xn) => {
    Xn.exports = Pe2;
    var Yn = ir();
    Q()(Pe2, Yn);
    function Pe2(e) {
      if (!(this instanceof Pe2))
        return new Pe2(e);
      Yn.call(this, e);
    }
    Pe2.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  ti = b2((Yf, ei) => {
    var or;
    function Ss(e) {
      var t = false;
      return function() {
        t || (t = true, e.apply(undefined, arguments));
      };
    }
    var Qn = fe().codes, Ts = Qn.ERR_MISSING_ARGS, As = Qn.ERR_STREAM_DESTROYED;
    function Zn(e) {
      if (e)
        throw e;
    }
    function Bs(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Cs(e, t, r, n) {
      n = Ss(n);
      var i = false;
      e.on("close", function() {
        i = true;
      }), or === undefined && (or = et()), or(e, { readable: t, writable: r }, function(a2) {
        if (a2)
          return n(a2);
        i = true, n();
      });
      var o2 = false;
      return function(a2) {
        if (!i && !o2) {
          if (o2 = true, Bs(e))
            return e.abort();
          if (typeof e.destroy == "function")
            return e.destroy();
          n(a2 || new As("pipe"));
        }
      };
    }
    function Jn(e) {
      e();
    }
    function Is(e, t) {
      return e.pipe(t);
    }
    function Ls(e) {
      return !e.length || typeof e[e.length - 1] != "function" ? Zn : e.pop();
    }
    function Ms() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      var n = Ls(t);
      if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
        throw new Ts("streams");
      var i, o2 = t.map(function(a2, s) {
        var u = s < t.length - 1, l2 = s > 0;
        return Cs(a2, u, l2, function(h2) {
          i || (i = h2), h2 && o2.forEach(Jn), !u && (o2.forEach(Jn), n(i));
        });
      });
      return t.reduce(Is);
    }
    ei.exports = Ms;
  });
  ar = b2((q, ri) => {
    q = ri.exports = Ht();
    q.Stream = q;
    q.Readable = q;
    q.Writable = Dt();
    q.Duplex = ue();
    q.Transform = ir();
    q.PassThrough = zn();
    q.finished = et();
    q.pipeline = ti();
  });
  ur = b2((fr) => {
    var ni = gt2(), Os = Q(), ii = ar(), ft = fr.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, sr = fr.IncomingMessage = function(e, t, r, n) {
      var i = this;
      if (ii.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
        process.nextTick(function() {
          i.emit("close");
        });
      }), r === "fetch") {
        let c = function() {
          a2.read().then(function(d2) {
            if (!i._destroyed) {
              if (n(d2.done), d2.done) {
                i.push(null);
                return;
              }
              i.push(Buffer.from(d2.value)), c();
            }
          }).catch(function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          });
        };
        var h2 = c;
        if (i._fetchResponse = t, i.url = t.url, i.statusCode = t.status, i.statusMessage = t.statusText, t.headers.forEach(function(d2, p2) {
          i.headers[p2.toLowerCase()] = d2, i.rawHeaders.push(p2, d2);
        }), ni.writableStream) {
          var o2 = new WritableStream({ write: function(d2) {
            return n(false), new Promise(function(p2, g2) {
              i._destroyed ? g2() : i.push(Buffer.from(d2)) ? p2() : i._resumeFetch = p2;
            });
          }, close: function() {
            n(true), i._destroyed || i.push(null);
          }, abort: function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          } });
          try {
            t.body.pipeTo(o2).catch(function(d2) {
              n(true), i._destroyed || i.emit("error", d2);
            });
            return;
          } catch {}
        }
        var a2 = t.body.getReader();
        c();
      } else {
        i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
        var s = e.getAllResponseHeaders().split(/\r?\n/);
        if (s.forEach(function(c) {
          var d2 = c.match(/^([^:]+):\s*(.*)/);
          if (d2) {
            var p2 = d2[1].toLowerCase();
            p2 === "set-cookie" ? (i.headers[p2] === undefined && (i.headers[p2] = []), i.headers[p2].push(d2[2])) : i.headers[p2] !== undefined ? i.headers[p2] += ", " + d2[2] : i.headers[p2] = d2[2], i.rawHeaders.push(d2[1], d2[2]);
          }
        }), i._charset = "x-user-defined", !ni.overrideMimeType) {
          var u = i.rawHeaders["mime-type"];
          if (u) {
            var l2 = u.match(/;\s*charset=([^;])(;|$)/);
            l2 && (i._charset = l2[1].toLowerCase());
          }
          i._charset || (i._charset = "utf-8");
        }
      }
    };
    Os(sr, ii.Readable);
    sr.prototype._read = function() {
      var e = this, t = e._resumeFetch;
      t && (e._resumeFetch = null, t());
    };
    sr.prototype._onXHRProgress = function(e) {
      var t = this, r = t._xhr, n = null;
      switch (t._mode) {
        case "text":
          if (n = r.responseText, n.length > t._pos) {
            var i = n.substr(t._pos);
            if (t._charset === "x-user-defined") {
              for (var o2 = Buffer.alloc(i.length), a2 = 0;a2 < i.length; a2++)
                o2[a2] = i.charCodeAt(a2) & 255;
              t.push(o2);
            } else
              t.push(i, t._charset);
            t._pos = n.length;
          }
          break;
        case "arraybuffer":
          if (r.readyState !== ft.DONE || !r.response)
            break;
          n = r.response, t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "moz-chunked-arraybuffer":
          if (n = r.response, r.readyState !== ft.LOADING || !n)
            break;
          t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "ms-stream":
          if (n = r.response, r.readyState !== ft.LOADING)
            break;
          var s = new global.MSStreamReader;
          s.onprogress = function() {
            s.result.byteLength > t._pos && (t.push(Buffer.from(new Uint8Array(s.result.slice(t._pos)))), t._pos = s.result.byteLength);
          }, s.onload = function() {
            e(true), t.push(null);
          }, s.readAsArrayBuffer(n);
          break;
      }
      t._xhr.readyState === ft.DONE && t._mode !== "ms-stream" && (e(true), t.push(null));
    };
  });
  fi = b2((zf, si) => {
    var pe = gt2(), Fs = Q(), ai = ur(), lr = ar(), Ns = ai.IncomingMessage, oi = ai.readyStates;
    function Us(e, t) {
      return pe.fetch && t ? "fetch" : pe.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : pe.msstream ? "ms-stream" : pe.arraybuffer && e ? "arraybuffer" : "text";
    }
    var M2 = si.exports = function(e) {
      var t = this;
      lr.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(i) {
        t.setHeader(i, e.headers[i]);
      });
      var r, n = true;
      if (e.mode === "disable-fetch" || "requestTimeout" in e && !pe.abortController)
        n = false, r = true;
      else if (e.mode === "prefer-streaming")
        r = false;
      else if (e.mode === "allow-wrong-content-type")
        r = !pe.overrideMimeType;
      else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
        r = true;
      else
        throw new Error("Invalid value for opts.mode");
      t._mode = Us(r, n), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
        t._onFinish();
      });
    };
    Fs(M2, lr.Writable);
    M2.prototype.setHeader = function(e, t) {
      var r = this, n = e.toLowerCase();
      qs.indexOf(n) === -1 && (r._headers[n] = { name: e, value: t });
    };
    M2.prototype.getHeader = function(e) {
      var t = this._headers[e.toLowerCase()];
      return t ? t.value : null;
    };
    M2.prototype.removeHeader = function(e) {
      var t = this;
      delete t._headers[e.toLowerCase()];
    };
    M2.prototype._onFinish = function() {
      var e = this;
      if (!e._destroyed) {
        var t = e._opts;
        "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
        var r = e._headers, n = null;
        t.method !== "GET" && t.method !== "HEAD" && (n = new Blob(e._body, { type: (r["content-type"] || {}).value || "" }));
        var i = [];
        if (Object.keys(r).forEach(function(u) {
          var l2 = r[u].name, h2 = r[u].value;
          Array.isArray(h2) ? h2.forEach(function(c) {
            i.push([l2, c]);
          }) : i.push([l2, h2]);
        }), e._mode === "fetch") {
          var o2 = null;
          if (pe.abortController) {
            var a2 = new AbortController;
            o2 = a2.signal, e._fetchAbortController = a2, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = global.setTimeout(function() {
              e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
            }, t.requestTimeout));
          }
          global.fetch(e._opts.url, { method: e._opts.method, headers: i, body: n || undefined, mode: "cors", credentials: t.withCredentials ? "include" : "same-origin", signal: o2 }).then(function(u) {
            e._fetchResponse = u, e._resetTimers(false), e._connect();
          }, function(u) {
            e._resetTimers(true), e._destroyed || e.emit("error", u);
          });
        } else {
          var s = e._xhr = new global.XMLHttpRequest;
          try {
            s.open(e._opts.method, e._opts.url, true);
          } catch (u) {
            process.nextTick(function() {
              e.emit("error", u);
            });
            return;
          }
          "responseType" in s && (s.responseType = e._mode), "withCredentials" in s && (s.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in s && s.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (s.timeout = t.requestTimeout, s.ontimeout = function() {
            e.emit("requestTimeout");
          }), i.forEach(function(u) {
            s.setRequestHeader(u[0], u[1]);
          }), e._response = null, s.onreadystatechange = function() {
            switch (s.readyState) {
              case oi.LOADING:
              case oi.DONE:
                e._onXHRProgress();
                break;
            }
          }, e._mode === "moz-chunked-arraybuffer" && (s.onprogress = function() {
            e._onXHRProgress();
          }), s.onerror = function() {
            e._destroyed || (e._resetTimers(true), e.emit("error", new Error("XHR error")));
          };
          try {
            s.send(n);
          } catch (u) {
            process.nextTick(function() {
              e.emit("error", u);
            });
            return;
          }
        }
      }
    };
    function Ps(e) {
      try {
        var t = e.status;
        return t !== null && t !== 0;
      } catch {
        return false;
      }
    }
    M2.prototype._onXHRProgress = function() {
      var e = this;
      e._resetTimers(false), !(!Ps(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
    };
    M2.prototype._connect = function() {
      var e = this;
      e._destroyed || (e._response = new Ns(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
        e.emit("error", t);
      }), e.emit("response", e._response));
    };
    M2.prototype._write = function(e, t, r) {
      var n = this;
      n._body.push(e), r();
    };
    M2.prototype._resetTimers = function(e) {
      var t = this;
      global.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (global.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = global.setTimeout(function() {
        t.emit("timeout");
      }, t._socketTimeout));
    };
    M2.prototype.abort = M2.prototype.destroy = function(e) {
      var t = this;
      t._destroyed = true, t._resetTimers(true), t._response && (t._response._destroyed = true), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
    };
    M2.prototype.end = function(e, t, r) {
      var n = this;
      typeof e == "function" && (r = e, e = undefined), lr.Writable.prototype.end.call(n, e, t, r);
    };
    M2.prototype.setTimeout = function(e, t) {
      var r = this;
      t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(false);
    };
    M2.prototype.flushHeaders = function() {};
    M2.prototype.setNoDelay = function() {};
    M2.prototype.setSocketKeepAlive = function() {};
    var qs = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  });
  li = b2((Zf, ui) => {
    ui.exports = ks;
    var Ds = Object.prototype.hasOwnProperty;
    function ks() {
      for (var e = {}, t = 0;t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r)
          Ds.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }
  });
  ci = b2((Jf, hi) => {
    hi.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
  });
  _i = {};
  Er(_i, { decode: () => pr, default: () => Ys, encode: () => yr, toASCII: () => bi, toUnicode: () => mi, ucs2decode: () => dr2, ucs2encode: () => gi });
  vi = vr(() => {
    pi = "-", js = /^xn--/, Hs = /[^\0-\x7F]/, Ws = /[\x2E\u3002\uFF0E\uFF61]/g, $s = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, hr = 36 - 1, K = Math.floor, cr = String.fromCharCode;
    gi = (e) => String.fromCodePoint(...e), Ks = function(e) {
      return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : 36;
    }, di = function(e, t) {
      return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
    }, wi = function(e, t, r) {
      let n = 0;
      for (e = r ? K(e / 700) : e >> 1, e += K(e / t);e > hr * 26 >> 1; n += 36)
        e = K(e / hr);
      return K(n + (hr + 1) * e / (e + 38));
    }, pr = function(e) {
      let t = [], r = e.length, n = 0, i = 128, o2 = 72, a2 = e.lastIndexOf(pi);
      a2 < 0 && (a2 = 0);
      for (let s = 0;s < a2; ++s)
        e.charCodeAt(s) >= 128 && oe("not-basic"), t.push(e.charCodeAt(s));
      for (let s = a2 > 0 ? a2 + 1 : 0;s < r; ) {
        let u = n;
        for (let h2 = 1, c = 36;; c += 36) {
          s >= r && oe("invalid-input");
          let d2 = Ks(e.charCodeAt(s++));
          d2 >= 36 && oe("invalid-input"), d2 > K((2147483647 - n) / h2) && oe("overflow"), n += d2 * h2;
          let p2 = c <= o2 ? 1 : c >= o2 + 26 ? 26 : c - o2;
          if (d2 < p2)
            break;
          let g2 = 36 - p2;
          h2 > K(2147483647 / g2) && oe("overflow"), h2 *= g2;
        }
        let l2 = t.length + 1;
        o2 = wi(n - u, l2, u == 0), K(n / l2) > 2147483647 - i && oe("overflow"), i += K(n / l2), n %= l2, t.splice(n++, 0, i);
      }
      return String.fromCodePoint(...t);
    }, yr = function(e) {
      let t = [];
      e = dr2(e);
      let r = e.length, n = 128, i = 0, o2 = 72;
      for (let u of e)
        u < 128 && t.push(cr(u));
      let a2 = t.length, s = a2;
      for (a2 && t.push(pi);s < r; ) {
        let u = 2147483647;
        for (let h2 of e)
          h2 >= n && h2 < u && (u = h2);
        let l2 = s + 1;
        u - n > K((2147483647 - i) / l2) && oe("overflow"), i += (u - n) * l2, n = u;
        for (let h2 of e)
          if (h2 < n && ++i > 2147483647 && oe("overflow"), h2 === n) {
            let c = i;
            for (let d2 = 36;; d2 += 36) {
              let p2 = d2 <= o2 ? 1 : d2 >= o2 + 26 ? 26 : d2 - o2;
              if (c < p2)
                break;
              let g2 = c - p2, E3 = 36 - p2;
              t.push(cr(di(p2 + g2 % E3, 0))), c = K(g2 / E3);
            }
            t.push(cr(di(c, 0))), o2 = wi(i, l2, s === a2), i = 0, ++s;
          }
        ++i, ++n;
      }
      return t.join("");
    }, mi = function(e) {
      return yi(e, function(t) {
        return js.test(t) ? pr(t.slice(4).toLowerCase()) : t;
      });
    }, bi = function(e) {
      return yi(e, function(t) {
        return Hs.test(t) ? "xn--" + yr(t) : t;
      });
    }, Vs = { version: "2.1.0", ucs2: { decode: dr2, encode: gi }, decode: pr, encode: yr, toASCII: bi, toUnicode: mi }, Ys = Vs;
  });
  xi = b2((Qf, Ei) => {
    Ei.exports = { isString: function(e) {
      return typeof e == "string";
    }, isObject: function(e) {
      return typeof e == "object" && e !== null;
    }, isNull: function(e) {
      return e === null;
    }, isNullOrUndefined: function(e) {
      return e == null;
    } };
  });
  Si = b2((eu, Ri) => {
    var Xs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, zs = Object.keys || function() {
      var e = Object.prototype.hasOwnProperty, t = !{ toString: null }.propertyIsEnumerable("toString"), r = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], n = r.length;
      return function(i) {
        if (typeof i != "function" && ((typeof i > "u" ? "undefined" : Xs(i)) !== "object" || i === null))
          throw new TypeError("Object.keys called on non-object");
        var o2 = [], a2, s;
        for (a2 in i)
          e.call(i, a2) && o2.push(a2);
        if (t)
          for (s = 0;s < n; s++)
            e.call(i, r[s]) && o2.push(r[s]);
        return o2;
      };
    }();
    Ri.exports = zs;
  });
  Ni = b2((tu, Fi) => {
    var Li = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, lt2 = Fi.exports = { unescapeBuffer: ef, unescape: Oi, escape: rf, stringify: Bi, encode: Bi, parse: Ii, decode: Ii }, Zs = _e().Buffer, Js = Si(), Qs = function(t) {
      return Object.prototype.toString.call(t) === "[object Array]";
    }, Ti = function(t, r, n) {
      var i;
      if (t == null)
        throw new TypeError('"arr" is null or not defined');
      var o2 = Object(t), a2 = o2.length >>> 0;
      if (a2 === 0)
        return -1;
      var s = n | 0;
      if (s >= a2)
        return -1;
      for (i = Math.max(s >= 0 ? s : a2 - Math.abs(s), 0);i < a2; ) {
        if (i in o2 && o2[i] === r)
          return i;
        i++;
      }
      return -1;
    };
    function Mi() {}
    Mi.prototype = Object.create ? Object.create(null) : {};
    var Ai = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    function ef(e, t) {
      for (var r = Zs.allocUnsafe(e.length), n = 0, i, o2, a2, s, u = 0, l2 = 0;; u++) {
        if (u < e.length)
          s = e.charCodeAt(u);
        else {
          n > 0 && (r[l2++] = 37, n === 2 && (r[l2++] = a2));
          break;
        }
        switch (n) {
          case 0:
            switch (s) {
              case 37:
                i = 0, o2 = 0, n = 1;
                break;
              case 43:
                t && (s = 32);
              default:
                r[l2++] = s;
                break;
            }
            break;
          case 1:
            if (a2 = s, i = Ai[s], !(i >= 0)) {
              r[l2++] = 37, r[l2++] = s, n = 0;
              break;
            }
            n = 2;
            break;
          case 2:
            if (n = 0, o2 = Ai[s], !(o2 >= 0)) {
              r[l2++] = 37, r[l2++] = a2, r[l2++] = s;
              break;
            }
            r[l2++] = 16 * i + o2;
            break;
        }
      }
      return r.slice(0, l2);
    }
    function Oi(e, t) {
      try {
        return decodeURIComponent(e);
      } catch {
        return lt2.unescapeBuffer(e, t).toString();
      }
    }
    var k = [];
    for (Se2 = 0;Se2 < 256; ++Se2)
      k[Se2] = "%" + ((Se2 < 16 ? "0" : "") + Se2.toString(16)).toUpperCase();
    var Se2, tf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0];
    function rf(e) {
      typeof e != "string" && ((typeof e > "u" ? "undefined" : Li(e)) === "object" ? e = String(e) : e += "");
      for (var t = "", r = 0, n = 0;n < e.length; ++n) {
        var i = e.charCodeAt(n);
        if (i < 128) {
          if (tf[i] === 1)
            continue;
          r < n && (t += e.slice(r, n)), r = n + 1, t += k[i];
          continue;
        }
        if (r < n && (t += e.slice(r, n)), i < 2048) {
          r = n + 1, t += k[192 | i >> 6] + k[128 | i & 63];
          continue;
        }
        if (i < 55296 || i >= 57344) {
          r = n + 1, t += k[224 | i >> 12] + k[128 | i >> 6 & 63] + k[128 | i & 63];
          continue;
        }
        ++n;
        var o2;
        if (n < e.length)
          o2 = e.charCodeAt(n) & 1023;
        else
          throw new URIError("URI malformed");
        r = n + 1, i = 65536 + ((i & 1023) << 10 | o2), t += k[240 | i >> 18] + k[128 | i >> 12 & 63] + k[128 | i >> 6 & 63] + k[128 | i & 63];
      }
      return r === 0 ? e : r < e.length ? t + e.slice(r) : t;
    }
    function gr2(e) {
      return typeof e == "string" ? e : typeof e == "number" && isFinite(e) ? "" + e : typeof e == "boolean" ? e ? "true" : "false" : "";
    }
    function Bi(e, t, r, n) {
      t = t || "&", r = r || "=";
      var i = lt2.escape;
      if (n && typeof n.encodeURIComponent == "function" && (i = n.encodeURIComponent), e !== null && (typeof e > "u" ? "undefined" : Li(e)) === "object") {
        for (var o2 = Js(e), a2 = o2.length, s = a2 - 1, u = "", l2 = 0;l2 < a2; ++l2) {
          var h2 = o2[l2], c = e[h2], d2 = i(gr2(h2)) + r;
          if (Qs(c)) {
            for (var p2 = c.length, g2 = p2 - 1, E3 = 0;E3 < p2; ++E3)
              u += d2 + i(gr2(c[E3])), E3 < g2 && (u += t);
            p2 && l2 < s && (u += t);
          } else
            u += d2 + i(gr2(c)), l2 < s && (u += t);
        }
        return u;
      }
      return "";
    }
    function Ci(e) {
      if (e.length === 0)
        return [];
      if (e.length === 1)
        return [e.charCodeAt(0)];
      for (var t = [], r = 0;r < e.length; ++r)
        t[t.length] = e.charCodeAt(r);
      return t;
    }
    var nf = [38], of = [61];
    function Ii(e, t, r, n) {
      var i = new Mi;
      if (typeof e != "string" || e.length === 0)
        return i;
      var o2 = t ? Ci(t + "") : nf, a2 = r ? Ci(r + "") : of, s = o2.length, u = a2.length, l2 = 1000;
      n && typeof n.maxKeys == "number" && (l2 = n.maxKeys > 0 ? n.maxKeys : -1);
      var h2 = lt2.unescape;
      n && typeof n.decodeURIComponent == "function" && (h2 = n.decodeURIComponent);
      for (var c = h2 !== Oi, d2 = [], p2 = 0, g2 = 0, E3 = 0, v2 = 0, m2 = "", y2 = "", R2 = c, I = c, T = 0, S = 0;S < e.length; ++S) {
        var B = e.charCodeAt(S);
        if (B === o2[E3]) {
          if (++E3 === s) {
            var F2 = S - E3 + 1;
            if (v2 < u ? g2 < F2 && (m2 += e.slice(g2, F2)) : g2 < F2 && (y2 += e.slice(g2, F2)), R2 && (m2 = ut(m2, h2)), I && (y2 = ut(y2, h2)), m2 || y2 || g2 - p2 > s || S === 0)
              if (Ti(d2, m2) === -1)
                i[m2] = y2, d2[d2.length] = m2;
              else {
                var L2 = i[m2] || "";
                L2.pop ? L2[L2.length] = y2 : L2 && (i[m2] = [L2, y2]);
              }
            else
              S === 1 && delete i[m2];
            if (--l2 === 0)
              break;
            R2 = I = c, T = 0, m2 = y2 = "", p2 = g2, g2 = S + 1, E3 = v2 = 0;
          }
          continue;
        } else
          E3 = 0, I || (B === 37 ? T = 1 : T > 0 && (B >= 48 && B <= 57 || B >= 65 && B <= 70 || B >= 97 && B <= 102) ? ++T === 3 && (I = true) : T = 0);
        if (v2 < u)
          if (B === a2[v2]) {
            if (++v2 === u) {
              var Y2 = S - v2 + 1;
              g2 < Y2 && (m2 += e.slice(g2, Y2)), T = 0, g2 = S + 1;
            }
            continue;
          } else
            v2 = 0, R2 || (B === 37 ? T = 1 : T > 0 && (B >= 48 && B <= 57 || B >= 65 && B <= 70 || B >= 97 && B <= 102) ? ++T === 3 && (R2 = true) : T = 0);
        B === 43 && (v2 < u ? (g2 < S && (m2 += e.slice(g2, S)), m2 += "%20", R2 = true) : (g2 < S && (y2 += e.slice(g2, S)), y2 += "%20", I = true), g2 = S + 1);
      }
      if (l2 !== 0 && (g2 < e.length || v2 > 0))
        if (g2 < e.length && (v2 < u ? m2 += e.slice(g2) : E3 < s && (y2 += e.slice(g2))), R2 && (m2 = ut(m2, h2)), I && (y2 = ut(y2, h2)), Ti(d2, m2) === -1)
          i[m2] = y2, d2[d2.length] = m2;
        else {
          var Z = i[m2];
          Z.pop ? Z[Z.length] = y2 : i[m2] = [Z, y2];
        }
      return i;
    }
    function ut(e, t) {
      try {
        return t(e);
      } catch {
        return lt2.unescape(e, true);
      }
    }
  });
  Di = b2((Ae2) => {
    var af = (vi(), dt2(_i)), V2 = xi();
    Ae2.parse = qe2;
    Ae2.resolve = gf;
    Ae2.resolveObject = wf;
    Ae2.format = yf;
    Ae2.Url = D;
    function D() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var sf = /^([a-z0-9.+-]+:)/i, ff = /:[0-9]*$/, uf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, lf = ["<", ">", '"', "`", " ", "\r", `
`, "\t"], hf = ["{", "}", "|", "\\", "^", "`"].concat(lf), wr = ["'"].concat(hf), Ui = ["%", "/", "?", ";", "#"].concat(wr), Pi = ["/", "?", "#"], cf = 255, qi = /^[+a-z0-9A-Z_-]{0,63}$/, df = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, pf = { javascript: true, "javascript:": true }, mr = { javascript: true, "javascript:": true }, Te = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, br2 = Ni();
    function qe2(e, t, r) {
      if (e && V2.isObject(e) && e instanceof D)
        return e;
      var n = new D;
      return n.parse(e, t, r), n;
    }
    D.prototype.parse = function(e, t, r) {
      if (!V2.isString(e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
      var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o2 = e.split(i), a2 = /\\/g;
      o2[0] = o2[0].replace(a2, "/"), e = o2.join(i);
      var s = e;
      if (s = s.trim(), !r && e.split("#").length === 1) {
        var u = uf.exec(s);
        if (u)
          return this.path = s, this.href = s, this.pathname = u[1], u[2] ? (this.search = u[2], t ? this.query = br2.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
      }
      var l2 = sf.exec(s);
      if (l2) {
        l2 = l2[0];
        var h2 = l2.toLowerCase();
        this.protocol = h2, s = s.substr(l2.length);
      }
      if (r || l2 || s.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var c = s.substr(0, 2) === "//";
        c && !(l2 && mr[l2]) && (s = s.substr(2), this.slashes = true);
      }
      if (!mr[l2] && (c || l2 && !Te[l2])) {
        for (var d2 = -1, p2 = 0;p2 < Pi.length; p2++) {
          var g2 = s.indexOf(Pi[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        var E3, v2;
        d2 === -1 ? v2 = s.lastIndexOf("@") : v2 = s.lastIndexOf("@", d2), v2 !== -1 && (E3 = s.slice(0, v2), s = s.slice(v2 + 1), this.auth = decodeURIComponent(E3)), d2 = -1;
        for (var p2 = 0;p2 < Ui.length; p2++) {
          var g2 = s.indexOf(Ui[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        d2 === -1 && (d2 = s.length), this.host = s.slice(0, d2), s = s.slice(d2), this.parseHost(), this.hostname = this.hostname || "";
        var m2 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!m2)
          for (var y2 = this.hostname.split(/\./), p2 = 0, R2 = y2.length;p2 < R2; p2++) {
            var I = y2[p2];
            if (!!I && !I.match(qi)) {
              for (var T = "", S = 0, B = I.length;S < B; S++)
                I.charCodeAt(S) > 127 ? T += "x" : T += I[S];
              if (!T.match(qi)) {
                var F2 = y2.slice(0, p2), L2 = y2.slice(p2 + 1), Y2 = I.match(df);
                Y2 && (F2.push(Y2[1]), L2.unshift(Y2[2])), L2.length && (s = "/" + L2.join(".") + s), this.hostname = F2.join(".");
                break;
              }
            }
          }
        this.hostname.length > cf ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m2 || (this.hostname = af.toASCII(this.hostname));
        var Z = this.port ? ":" + this.port : "", Wi = this.hostname || "";
        this.host = Wi + Z, this.href += this.host, m2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s[0] !== "/" && (s = "/" + s));
      }
      if (!pf[h2])
        for (var p2 = 0, R2 = wr.length;p2 < R2; p2++) {
          var Be = wr[p2];
          if (s.indexOf(Be) !== -1) {
            var ht = encodeURIComponent(Be);
            ht === Be && (ht = escape(Be)), s = s.split(Be).join(ht);
          }
        }
      var ct2 = s.indexOf("#");
      ct2 !== -1 && (this.hash = s.substr(ct2), s = s.slice(0, ct2));
      var De = s.indexOf("?");
      if (De !== -1 ? (this.search = s.substr(De), this.query = s.substr(De + 1), t && (this.query = br2.parse(this.query)), s = s.slice(0, De)) : t && (this.search = "", this.query = {}), s && (this.pathname = s), Te[h2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Z = this.pathname || "", $i = this.search || "";
        this.path = Z + $i;
      }
      return this.href = this.format(), this;
    };
    function yf(e) {
      return V2.isString(e) && (e = qe2(e)), e instanceof D ? e.format() : D.prototype.format.call(e);
    }
    D.prototype.format = function() {
      var e = this.auth || "";
      e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
      var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = false, o2 = "";
      this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && V2.isObject(this.query) && Object.keys(this.query).length && (o2 = br2.stringify(this.query));
      var a2 = this.search || o2 && "?" + o2 || "";
      return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Te[t]) && i !== false ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a2 && a2.charAt(0) !== "?" && (a2 = "?" + a2), r = r.replace(/[?#]/g, function(s) {
        return encodeURIComponent(s);
      }), a2 = a2.replace("#", "%23"), t + i + r + a2 + n;
    };
    function gf(e, t) {
      return qe2(e, false, true).resolve(t);
    }
    D.prototype.resolve = function(e) {
      return this.resolveObject(qe2(e, false, true)).format();
    };
    function wf(e, t) {
      return e ? qe2(e, false, true).resolveObject(t) : t;
    }
    D.prototype.resolveObject = function(e) {
      if (V2.isString(e)) {
        var t = new D;
        t.parse(e, false, true), e = t;
      }
      for (var r = new D, n = Object.keys(this), i = 0;i < n.length; i++) {
        var o2 = n[i];
        r[o2] = this[o2];
      }
      if (r.hash = e.hash, e.href === "")
        return r.href = r.format(), r;
      if (e.slashes && !e.protocol) {
        for (var a2 = Object.keys(e), s = 0;s < a2.length; s++) {
          var u = a2[s];
          u !== "protocol" && (r[u] = e[u]);
        }
        return Te[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
      }
      if (e.protocol && e.protocol !== r.protocol) {
        if (!Te[e.protocol]) {
          for (var l2 = Object.keys(e), h2 = 0;h2 < l2.length; h2++) {
            var c = l2[h2];
            r[c] = e[c];
          }
          return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !mr[e.protocol]) {
          for (var R2 = (e.pathname || "").split("/");R2.length && !(e.host = R2.shift()); )
            ;
          e.host || (e.host = ""), e.hostname || (e.hostname = ""), R2[0] !== "" && R2.unshift(""), R2.length < 2 && R2.unshift(""), r.pathname = R2.join("/");
        } else
          r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
          var d2 = r.pathname || "", p2 = r.search || "";
          r.path = d2 + p2;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
      }
      var g2 = r.pathname && r.pathname.charAt(0) === "/", E3 = e.host || e.pathname && e.pathname.charAt(0) === "/", v2 = E3 || g2 || r.host && e.pathname, m2 = v2, y2 = r.pathname && r.pathname.split("/") || [], R2 = e.pathname && e.pathname.split("/") || [], I = r.protocol && !Te[r.protocol];
      if (I && (r.hostname = "", r.port = null, r.host && (y2[0] === "" ? y2[0] = r.host : y2.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (R2[0] === "" ? R2[0] = e.host : R2.unshift(e.host)), e.host = null), v2 = v2 && (R2[0] === "" || y2[0] === "")), E3)
        r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, y2 = R2;
      else if (R2.length)
        y2 || (y2 = []), y2.pop(), y2 = y2.concat(R2), r.search = e.search, r.query = e.query;
      else if (!V2.isNullOrUndefined(e.search)) {
        if (I) {
          r.hostname = r.host = y2.shift();
          var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
          T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
        }
        return r.search = e.search, r.query = e.query, (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
      }
      if (!y2.length)
        return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
      for (var S = y2.slice(-1)[0], B = (r.host || e.host || y2.length > 1) && (S === "." || S === "..") || S === "", F2 = 0, L2 = y2.length;L2 >= 0; L2--)
        S = y2[L2], S === "." ? y2.splice(L2, 1) : S === ".." ? (y2.splice(L2, 1), F2++) : F2 && (y2.splice(L2, 1), F2--);
      if (!v2 && !m2)
        for (;F2--; F2)
          y2.unshift("..");
      v2 && y2[0] !== "" && (!y2[0] || y2[0].charAt(0) !== "/") && y2.unshift(""), B && y2.join("/").substr(-1) !== "/" && y2.push("");
      var Y2 = y2[0] === "" || y2[0] && y2[0].charAt(0) === "/";
      if (I) {
        r.hostname = r.host = Y2 ? "" : y2.length ? y2.shift() : "";
        var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
        T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
      }
      return v2 = v2 || r.host && y2.length, v2 && !Y2 && y2.unshift(""), y2.length ? r.pathname = y2.join("/") : (r.pathname = null, r.path = null), (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    };
    D.prototype.parseHost = function() {
      var e = this.host, t = ff.exec(e);
      t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
    };
  });
  Hi = b2((ji) => {
    var ki = fi(), mf = ur(), bf = li(), _f = ci(), vf = Di(), j2 = ji;
    j2.request = function(e, t) {
      typeof e == "string" ? e = vf.parse(e) : e = bf(e);
      var r = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", n = e.protocol || r, i = e.hostname || e.host, o2 = e.port, a2 = e.path || "/";
      i && i.indexOf(":") !== -1 && (i = "[" + i + "]"), e.url = (i ? n + "//" + i : "") + (o2 ? ":" + o2 : "") + a2, e.method = (e.method || "GET").toUpperCase(), e.headers = e.headers || {};
      var s = new ki(e);
      return t && s.on("response", t), s;
    };
    j2.get = function(t, r) {
      var n = j2.request(t, r);
      return n.end(), n;
    };
    j2.ClientRequest = ki;
    j2.IncomingMessage = mf.IncomingMessage;
    j2.Agent = function() {};
    j2.Agent.defaultMaxSockets = 4;
    j2.globalAgent = new j2.Agent;
    j2.STATUS_CODES = _f;
    j2.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  });
  _r = Rr2(Hi());
  iu = _r.default;
  ({ request: ou, get: au, ClientRequest: su, IncomingMessage: fu, Agent: uu, globalAgent: lu, STATUS_CODES: hu, METHODS: cu } = _r.default);
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/fastify/lib/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  var keys = {
    kAvvioBoot: Symbol("fastify.avvioBoot"),
    kChildren: Symbol("fastify.children"),
    kServerBindings: Symbol("fastify.serverBindings"),
    kBodyLimit: Symbol("fastify.bodyLimit"),
    kSupportedHTTPMethods: Symbol("fastify.acceptedHTTPMethods"),
    kRoutePrefix: Symbol("fastify.routePrefix"),
    kLogLevel: Symbol("fastify.logLevel"),
    kLogSerializers: Symbol("fastify.logSerializers"),
    kHooks: Symbol("fastify.hooks"),
    kContentTypeParser: Symbol("fastify.contentTypeParser"),
    kState: Symbol("fastify.state"),
    kOptions: Symbol("fastify.options"),
    kDisableRequestLogging: Symbol("fastify.disableRequestLogging"),
    kPluginNameChain: Symbol("fastify.pluginNameChain"),
    kRouteContext: Symbol("fastify.context"),
    kGenReqId: Symbol("fastify.genReqId"),
    kHttp2ServerSessions: Symbol("fastify.http2ServerSessions"),
    kSchemaController: Symbol("fastify.schemaController"),
    kSchemaHeaders: Symbol("headers-schema"),
    kSchemaParams: Symbol("params-schema"),
    kSchemaQuerystring: Symbol("querystring-schema"),
    kSchemaBody: Symbol("body-schema"),
    kSchemaResponse: Symbol("response-schema"),
    kSchemaErrorFormatter: Symbol("fastify.schemaErrorFormatter"),
    kSchemaVisited: Symbol("fastify.schemas.visited"),
    kRequest: Symbol("fastify.Request"),
    kRequestPayloadStream: Symbol("fastify.RequestPayloadStream"),
    kRequestAcceptVersion: Symbol("fastify.RequestAcceptVersion"),
    kRequestCacheValidateFns: Symbol("fastify.request.cache.validateFns"),
    kRequestOriginalUrl: Symbol("fastify.request.originalUrl"),
    kFourOhFour: Symbol("fastify.404"),
    kCanSetNotFoundHandler: Symbol("fastify.canSetNotFoundHandler"),
    kFourOhFourLevelInstance: Symbol("fastify.404LogLevelInstance"),
    kFourOhFourContext: Symbol("fastify.404ContextKey"),
    kDefaultJsonParse: Symbol("fastify.defaultJSONParse"),
    kReply: Symbol("fastify.Reply"),
    kReplySerializer: Symbol("fastify.reply.serializer"),
    kReplyIsError: Symbol("fastify.reply.isError"),
    kReplyHeaders: Symbol("fastify.reply.headers"),
    kReplyTrailers: Symbol("fastify.reply.trailers"),
    kReplyHasStatusCode: Symbol("fastify.reply.hasStatusCode"),
    kReplyHijacked: Symbol("fastify.reply.hijacked"),
    kReplyStartTime: Symbol("fastify.reply.startTime"),
    kReplyNextErrorHandler: Symbol("fastify.reply.nextErrorHandler"),
    kReplyEndTime: Symbol("fastify.reply.endTime"),
    kReplyErrorHandlerCalled: Symbol("fastify.reply.errorHandlerCalled"),
    kReplyIsRunningOnErrorHook: Symbol("fastify.reply.isRunningOnErrorHook"),
    kReplySerializerDefault: Symbol("fastify.replySerializerDefault"),
    kReplyCacheSerializeFns: Symbol("fastify.reply.cache.serializeFns"),
    kTestInternals: Symbol("fastify.testInternals"),
    kErrorHandler: Symbol("fastify.errorHandler"),
    kErrorHandlerAlreadySet: Symbol("fastify.errorHandlerAlreadySet"),
    kChildLoggerFactory: Symbol("fastify.childLoggerFactory"),
    kHasBeenDecorated: Symbol("fastify.hasBeenDecorated"),
    kKeepAliveConnections: Symbol("fastify.keepAliveConnections"),
    kRouteByFastify: Symbol("fastify.routeByFastify")
  };
  module.exports = keys;
});

// node:https
var exports_https = {};
__export(exports_https, {
  default: () => Cf
});
function oe2(e) {
  throw new RangeError(Zs[e]);
}
function Js(e, t) {
  let r = [], n = e.length;
  for (;n--; )
    r[n] = t(e[n]);
  return r;
}
function vi2(e, t) {
  let r = e.split("@"), n = "";
  r.length > 1 && (n = r[0] + "@", e = r[1]), e = e.replace(zs, ".");
  let i = e.split("."), o2 = Js(i, t).join(".");
  return n + o2;
}
function _r2(e) {
  let t = [], r = 0, n = e.length;
  for (;r < n; ) {
    let i = e.charCodeAt(r++);
    if (i >= 55296 && i <= 56319 && r < n) {
      let o2 = e.charCodeAt(r++);
      (o2 & 64512) == 56320 ? t.push(((i & 1023) << 10) + (o2 & 1023) + 65536) : (t.push(i), r--);
    } else
      t.push(i);
  }
  return t;
}
var Ji, He, Qi, eo, to, ro, Cr = (e, t) => () => (e && (t = e(e = 0)), t), b3 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), mt2 = (e, t) => {
  for (var r in t)
    He(e, r, { get: t[r], enumerable: true });
}, We = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of eo(t))
      !ro.call(e, i) && i !== r && He(e, i, { get: () => t[i], enumerable: !(n = Qi(t, i)) || n.enumerable });
  return e;
}, $e = (e, t, r) => (We(e, t, "default"), r && We(r, t, "default")), bt3 = (e, t, r) => (r = e != null ? Ji(to(e)) : {}, We(t || !e || !e.__esModule ? He(r, "default", { value: e, enumerable: true }) : r, e)), _t2 = (e) => We(He({}, "__esModule", { value: true }), e), xt, Q2, Tt, At2, $r, Gr, _e2, qt, cn, jt, fe2, Wt, _n, Kt2, ue2, Ln, Fn, Qt, nt2, er, it, Dn, jn, Xt, hr2, ri, si, dr3, gr2, pi2, gi2, mi2, Ti, _i2, Ys2, Xs, zs, Zs, mr, K2, br2, Ei, Qs, bi2, xi2, vr2, Er2, Ri, Si2, ef, tf, Ai, Ii, Li, ji, Ar, Vi2, Ir, ke2, Cf;
var init_https = __esm(() => {
  Ji = Object.create;
  He = Object.defineProperty;
  Qi = Object.getOwnPropertyDescriptor;
  eo = Object.getOwnPropertyNames;
  to = Object.getPrototypeOf;
  ro = Object.prototype.hasOwnProperty;
  xt = b3((N3) => {
    N3.fetch = Ie(global.fetch) && Ie(global.ReadableStream);
    N3.writableStream = Ie(global.WritableStream);
    N3.abortController = Ie(global.AbortController);
    var J;
    function vt() {
      if (J !== undefined)
        return J;
      if (global.XMLHttpRequest) {
        J = new global.XMLHttpRequest;
        try {
          J.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch {
          J = null;
        }
      } else
        J = null;
      return J;
    }
    function Et(e) {
      var t = vt();
      if (!t)
        return false;
      try {
        return t.responseType = e, t.responseType === e;
      } catch {}
      return false;
    }
    N3.arraybuffer = N3.fetch || Et("arraybuffer");
    N3.msstream = !N3.fetch && Et("ms-stream");
    N3.mozchunkedarraybuffer = !N3.fetch && Et("moz-chunked-arraybuffer");
    N3.overrideMimeType = N3.fetch || (vt() ? Ie(vt().overrideMimeType) : false);
    function Ie(e) {
      return typeof e == "function";
    }
    J = null;
  });
  Q2 = b3((Of, Rt) => {
    typeof Object.create == "function" ? Rt.exports = function(t, r) {
      r && (t.super_ = r, t.prototype = Object.create(r.prototype, { constructor: { value: t, enumerable: false, writable: true, configurable: true } }));
    } : Rt.exports = function(t, r) {
      if (r) {
        t.super_ = r;
        var n = function() {};
        n.prototype = r.prototype, t.prototype = new n, t.prototype.constructor = t;
      }
    };
  });
  Tt = b3((Ff, St) => {
    var ye = typeof Reflect == "object" ? Reflect : null, Lr = ye && typeof ye.apply == "function" ? ye.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, Ge;
    ye && typeof ye.ownKeys == "function" ? Ge = ye.ownKeys : Object.getOwnPropertySymbols ? Ge = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : Ge = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function no(e) {
      console && console.warn && console.warn(e);
    }
    var Or = Number.isNaN || function(t) {
      return t !== t;
    };
    function x2() {
      x2.init.call(this);
    }
    St.exports = x2;
    St.exports.once = so2;
    x2.EventEmitter = x2;
    x2.prototype._events = undefined;
    x2.prototype._eventsCount = 0;
    x2.prototype._maxListeners = undefined;
    var Mr = 10;
    function Ke(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(x2, "defaultMaxListeners", { enumerable: true, get: function() {
      return Mr;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || Or(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      Mr = e;
    } });
    x2.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    x2.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || Or(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Fr2(e) {
      return e._maxListeners === undefined ? x2.defaultMaxListeners : e._maxListeners;
    }
    x2.prototype.getMaxListeners = function() {
      return Fr2(this);
    };
    x2.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var a2;
        if (r.length > 0 && (a2 = r[0]), a2 instanceof Error)
          throw a2;
        var s = new Error("Unhandled error." + (a2 ? " (" + a2.message + ")" : ""));
        throw s.context = a2, s;
      }
      var u = o2[t];
      if (u === undefined)
        return false;
      if (typeof u == "function")
        Lr(u, this, r);
      else
        for (var l2 = u.length, h2 = Dr2(u, l2), n = 0;n < l2; ++n)
          Lr(h2[n], this, r);
      return true;
    };
    function Nr(e, t, r, n) {
      var i, o2, a2;
      if (Ke(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), a2 = o2[t]), a2 === undefined)
        a2 = o2[t] = r, ++e._eventsCount;
      else if (typeof a2 == "function" ? a2 = o2[t] = n ? [r, a2] : [a2, r] : n ? a2.unshift(r) : a2.push(r), i = Fr2(e), i > 0 && a2.length > i && !a2.warned) {
        a2.warned = true;
        var s = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        s.name = "MaxListenersExceededWarning", s.emitter = e, s.type = t, s.count = a2.length, no(s);
      }
      return e;
    }
    x2.prototype.addListener = function(t, r) {
      return Nr(this, t, r, false);
    };
    x2.prototype.on = x2.prototype.addListener;
    x2.prototype.prependListener = function(t, r) {
      return Nr(this, t, r, true);
    };
    function io() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ur2(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = io.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    x2.prototype.once = function(t, r) {
      return Ke(r), this.on(t, Ur2(this, t, r)), this;
    };
    x2.prototype.prependOnceListener = function(t, r) {
      return Ke(r), this.prependListener(t, Ur2(this, t, r)), this;
    };
    x2.prototype.removeListener = function(t, r) {
      var n, i, o2, a2, s;
      if (Ke(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, a2 = n.length - 1;a2 >= 0; a2--)
          if (n[a2] === r || n[a2].listener === r) {
            s = n[a2].listener, o2 = a2;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : oo(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, s || r);
      }
      return this;
    };
    x2.prototype.off = x2.prototype.removeListener;
    x2.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), a2;
        for (i = 0;i < o2.length; ++i)
          a2 = o2[i], a2 !== "removeListener" && this.removeAllListeners(a2);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Pr(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? ao(i) : Dr2(i, i.length);
    }
    x2.prototype.listeners = function(t) {
      return Pr(this, t, true);
    };
    x2.prototype.rawListeners = function(t) {
      return Pr(this, t, false);
    };
    x2.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : qr2.call(e, t);
    };
    x2.prototype.listenerCount = qr2;
    function qr2(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    x2.prototype.eventNames = function() {
      return this._eventsCount > 0 ? Ge(this._events) : [];
    };
    function Dr2(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function oo(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function ao(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function so2(e, t) {
      return new Promise(function(r, n) {
        function i(a2) {
          e.removeListener(t, o2), n(a2);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        kr(e, t, o2, { once: true }), t !== "error" && fo(e, i, { once: true });
      });
    }
    function fo(e, t, r) {
      typeof e.on == "function" && kr(e, "error", t, r);
    }
    function kr(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  At2 = b3((Nf, jr) => {
    jr.exports = Tt().EventEmitter;
  });
  $r = b3((Ve) => {
    Ve.byteLength = lo;
    Ve.toByteArray = co;
    Ve.fromByteArray = go;
    var W = [], U = [], uo = typeof Uint8Array < "u" ? Uint8Array : Array, Bt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ae = 0, Wr = Bt.length;ae < Wr; ++ae)
      W[ae] = Bt[ae], U[Bt.charCodeAt(ae)] = ae;
    var ae, Wr;
    U[45] = 62;
    U[95] = 63;
    function Hr(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function lo(e) {
      var t = Hr(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function ho(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function co(e) {
      var t, r = Hr(e), n = r[0], i = r[1], o2 = new uo(ho(e, n, i)), a2 = 0, s = i > 0 ? n - 4 : n, u;
      for (u = 0;u < s; u += 4)
        t = U[e.charCodeAt(u)] << 18 | U[e.charCodeAt(u + 1)] << 12 | U[e.charCodeAt(u + 2)] << 6 | U[e.charCodeAt(u + 3)], o2[a2++] = t >> 16 & 255, o2[a2++] = t >> 8 & 255, o2[a2++] = t & 255;
      return i === 2 && (t = U[e.charCodeAt(u)] << 2 | U[e.charCodeAt(u + 1)] >> 4, o2[a2++] = t & 255), i === 1 && (t = U[e.charCodeAt(u)] << 10 | U[e.charCodeAt(u + 1)] << 4 | U[e.charCodeAt(u + 2)] >> 2, o2[a2++] = t >> 8 & 255, o2[a2++] = t & 255), o2;
    }
    function po(e) {
      return W[e >> 18 & 63] + W[e >> 12 & 63] + W[e >> 6 & 63] + W[e & 63];
    }
    function yo(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(po(n));
      return i.join("");
    }
    function go(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, a2 = 0, s = r - n;a2 < s; a2 += o2)
        i.push(yo(e, a2, a2 + o2 > s ? s : a2 + o2));
      return n === 1 ? (t = e[r - 1], i.push(W[t >> 2] + W[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(W[t >> 10] + W[t >> 4 & 63] + W[t << 2 & 63] + "=")), i.join("");
    }
  });
  Gr = b3((It) => {
    It.read = function(e, t, r, n, i) {
      var o2, a2, s = i * 8 - n - 1, u = (1 << s) - 1, l2 = u >> 1, h2 = -7, c = r ? i - 1 : 0, d2 = r ? -1 : 1, p2 = e[t + c];
      for (c += d2, o2 = p2 & (1 << -h2) - 1, p2 >>= -h2, h2 += s;h2 > 0; o2 = o2 * 256 + e[t + c], c += d2, h2 -= 8)
        ;
      for (a2 = o2 & (1 << -h2) - 1, o2 >>= -h2, h2 += n;h2 > 0; a2 = a2 * 256 + e[t + c], c += d2, h2 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l2;
      else {
        if (o2 === u)
          return a2 ? NaN : (p2 ? -1 : 1) * (1 / 0);
        a2 = a2 + Math.pow(2, n), o2 = o2 - l2;
      }
      return (p2 ? -1 : 1) * a2 * Math.pow(2, o2 - n);
    };
    It.write = function(e, t, r, n, i, o2) {
      var a2, s, u, l2 = o2 * 8 - i - 1, h2 = (1 << l2) - 1, c = h2 >> 1, d2 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p2 = n ? 0 : o2 - 1, g2 = n ? 1 : -1, E3 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (s = isNaN(t) ? 1 : 0, a2 = h2) : (a2 = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -a2)) < 1 && (a2--, u *= 2), a2 + c >= 1 ? t += d2 / u : t += d2 * Math.pow(2, 1 - c), t * u >= 2 && (a2++, u /= 2), a2 + c >= h2 ? (s = 0, a2 = h2) : a2 + c >= 1 ? (s = (t * u - 1) * Math.pow(2, i), a2 = a2 + c) : (s = t * Math.pow(2, c - 1) * Math.pow(2, i), a2 = 0));i >= 8; e[r + p2] = s & 255, p2 += g2, s /= 256, i -= 8)
        ;
      for (a2 = a2 << i | s, l2 += i;l2 > 0; e[r + p2] = a2 & 255, p2 += g2, a2 /= 256, l2 -= 8)
        ;
      e[r + p2 - g2] |= E3 * 128;
    };
  });
  _e2 = b3((be) => {
    var Ct = $r(), we = Gr(), Kr2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    be.Buffer = f;
    be.SlowBuffer = Eo;
    be.INSPECT_MAX_BYTES = 50;
    var Ye = 2147483647;
    be.kMaxLength = Ye;
    f.TYPED_ARRAY_SUPPORT = wo();
    !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function wo() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(f.prototype, "parent", { enumerable: true, get: function() {
      if (!!f.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(f.prototype, "offset", { enumerable: true, get: function() {
      if (!!f.isBuffer(this))
        return this.byteOffset;
    } });
    function X(e) {
      if (e > Ye)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, f.prototype), t;
    }
    function f(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Ft2(e);
      }
      return zr(e, t, r);
    }
    f.poolSize = 8192;
    function zr(e, t, r) {
      if (typeof e == "string")
        return bo(e, t);
      if (ArrayBuffer.isView(e))
        return _o(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (H2(e, ArrayBuffer) || e && H2(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (H2(e, SharedArrayBuffer) || e && H2(e.buffer, SharedArrayBuffer)))
        return Mt(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return f.from(n, t, r);
      let i = vo(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return f.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    f.from = function(e, t, r) {
      return zr(e, t, r);
    };
    Object.setPrototypeOf(f.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(f, Uint8Array);
    function Zr2(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function mo(e, t, r) {
      return Zr2(e), e <= 0 ? X(e) : t !== undefined ? typeof r == "string" ? X(e).fill(t, r) : X(e).fill(t) : X(e);
    }
    f.alloc = function(e, t, r) {
      return mo(e, t, r);
    };
    function Ft2(e) {
      return Zr2(e), X(e < 0 ? 0 : Nt2(e) | 0);
    }
    f.allocUnsafe = function(e) {
      return Ft2(e);
    };
    f.allocUnsafeSlow = function(e) {
      return Ft2(e);
    };
    function bo(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !f.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = Jr(e, t) | 0, n = X(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Lt2(e) {
      let t = e.length < 0 ? 0 : Nt2(e.length) | 0, r = X(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function _o(e) {
      if (H2(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Mt(t.buffer, t.byteOffset, t.byteLength);
      }
      return Lt2(e);
    }
    function Mt(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, f.prototype), n;
    }
    function vo(e) {
      if (f.isBuffer(e)) {
        let t = Nt2(e.length) | 0, r = X(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Pt(e.length) ? X(0) : Lt2(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Lt2(e.data);
    }
    function Nt2(e) {
      if (e >= Ye)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Ye.toString(16) + " bytes");
      return e | 0;
    }
    function Eo(e) {
      return +e != e && (e = 0), f.alloc(+e);
    }
    f.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== f.prototype;
    };
    f.compare = function(t, r) {
      if (H2(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)), H2(r, Uint8Array) && (r = f.from(r, r.offset, r.byteLength)), !f.isBuffer(t) || !f.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, a2 = Math.min(n, i);o2 < a2; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    f.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    f.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return f.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = f.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let a2 = t[n];
        if (H2(a2, Uint8Array))
          o2 + a2.length > i.length ? (f.isBuffer(a2) || (a2 = f.from(a2)), a2.copy(i, o2)) : Uint8Array.prototype.set.call(i, a2, o2);
        else if (f.isBuffer(a2))
          a2.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += a2.length;
      }
      return i;
    };
    function Jr(e, t) {
      if (f.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || H2(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Ot(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return fn(e).length;
          default:
            if (i)
              return n ? -1 : Ot(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    f.byteLength = Jr;
    function xo(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return Oo(this, t, r);
          case "utf8":
          case "utf-8":
            return en(this, t, r);
          case "ascii":
            return Lo(this, t, r);
          case "latin1":
          case "binary":
            return Mo(this, t, r);
          case "base64":
            return Io(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Fo(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    f.prototype._isBuffer = true;
    function se(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    f.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        se(this, r, r + 1);
      return this;
    };
    f.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        se(this, r, r + 3), se(this, r + 1, r + 2);
      return this;
    };
    f.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        se(this, r, r + 7), se(this, r + 1, r + 6), se(this, r + 2, r + 5), se(this, r + 3, r + 4);
      return this;
    };
    f.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? en(this, 0, t) : xo.apply(this, arguments);
    };
    f.prototype.toLocaleString = f.prototype.toString;
    f.prototype.equals = function(t) {
      if (!f.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : f.compare(this, t) === 0;
    };
    f.prototype.inspect = function() {
      let t = "", r = be.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    Kr2 && (f.prototype[Kr2] = f.prototype.inspect);
    f.prototype.compare = function(t, r, n, i, o2) {
      if (H2(t, Uint8Array) && (t = f.from(t, t.offset, t.byteLength)), !f.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let a2 = o2 - i, s = n - r, u = Math.min(a2, s), l2 = this.slice(i, o2), h2 = t.slice(r, n);
      for (let c = 0;c < u; ++c)
        if (l2[c] !== h2[c]) {
          a2 = l2[c], s = h2[c];
          break;
        }
      return a2 < s ? -1 : s < a2 ? 1 : 0;
    };
    function Qr(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Pt(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = f.from(t, n)), f.isBuffer(t))
        return t.length === 0 ? -1 : Vr(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : Vr(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Vr(e, t, r, n, i) {
      let o2 = 1, a2 = e.length, s = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, a2 /= 2, s /= 2, r /= 2;
      }
      function u(h2, c) {
        return o2 === 1 ? h2[c] : h2.readUInt16BE(c * o2);
      }
      let l2;
      if (i) {
        let h2 = -1;
        for (l2 = r;l2 < a2; l2++)
          if (u(e, l2) === u(t, h2 === -1 ? 0 : l2 - h2)) {
            if (h2 === -1 && (h2 = l2), l2 - h2 + 1 === s)
              return h2 * o2;
          } else
            h2 !== -1 && (l2 -= l2 - h2), h2 = -1;
      } else
        for (r + s > a2 && (r = a2 - s), l2 = r;l2 >= 0; l2--) {
          let h2 = true;
          for (let c = 0;c < s; c++)
            if (u(e, l2 + c) !== u(t, c)) {
              h2 = false;
              break;
            }
          if (h2)
            return l2;
        }
      return -1;
    }
    f.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    f.prototype.indexOf = function(t, r, n) {
      return Qr(this, t, r, n, true);
    };
    f.prototype.lastIndexOf = function(t, r, n) {
      return Qr(this, t, r, n, false);
    };
    function Ro(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let a2;
      for (a2 = 0;a2 < n; ++a2) {
        let s = parseInt(t.substr(a2 * 2, 2), 16);
        if (Pt(s))
          return a2;
        e[r + a2] = s;
      }
      return a2;
    }
    function So(e, t, r, n) {
      return Xe(Ot(t, e.length - r), e, r, n);
    }
    function To(e, t, r, n) {
      return Xe(qo(t), e, r, n);
    }
    function Ao(e, t, r, n) {
      return Xe(fn(t), e, r, n);
    }
    function Bo(e, t, r, n) {
      return Xe(Do(t, e.length - r), e, r, n);
    }
    f.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let a2 = false;
      for (;; )
        switch (i) {
          case "hex":
            return Ro(this, t, r, n);
          case "utf8":
          case "utf-8":
            return So(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return To(this, t, r, n);
          case "base64":
            return Ao(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Bo(this, t, r, n);
          default:
            if (a2)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), a2 = true;
        }
    };
    f.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Io(e, t, r) {
      return t === 0 && r === e.length ? Ct.fromByteArray(e) : Ct.fromByteArray(e.slice(t, r));
    }
    function en(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], a2 = null, s = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + s <= r) {
          let u, l2, h2, c;
          switch (s) {
            case 1:
              o2 < 128 && (a2 = o2);
              break;
            case 2:
              u = e[i + 1], (u & 192) === 128 && (c = (o2 & 31) << 6 | u & 63, c > 127 && (a2 = c));
              break;
            case 3:
              u = e[i + 1], l2 = e[i + 2], (u & 192) === 128 && (l2 & 192) === 128 && (c = (o2 & 15) << 12 | (u & 63) << 6 | l2 & 63, c > 2047 && (c < 55296 || c > 57343) && (a2 = c));
              break;
            case 4:
              u = e[i + 1], l2 = e[i + 2], h2 = e[i + 3], (u & 192) === 128 && (l2 & 192) === 128 && (h2 & 192) === 128 && (c = (o2 & 15) << 18 | (u & 63) << 12 | (l2 & 63) << 6 | h2 & 63, c > 65535 && c < 1114112 && (a2 = c));
          }
        }
        a2 === null ? (a2 = 65533, s = 1) : a2 > 65535 && (a2 -= 65536, n.push(a2 >>> 10 & 1023 | 55296), a2 = 56320 | a2 & 1023), n.push(a2), i += s;
      }
      return Co(n);
    }
    var Yr = 4096;
    function Co(e) {
      let t = e.length;
      if (t <= Yr)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += Yr));
      return r;
    }
    function Lo(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function Mo(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function Oo(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += ko[e[o2]];
      return i;
    }
    function Fo(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    f.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, f.prototype), i;
    };
    function I(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    f.prototype.readUintLE = f.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I(t, r, this.length);
      let i = this[t], o2 = 1, a2 = 0;
      for (;++a2 < r && (o2 *= 256); )
        i += this[t + a2] * o2;
      return i;
    };
    f.prototype.readUintBE = f.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    f.prototype.readUint8 = f.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || I(t, 1, this.length), this[t];
    };
    f.prototype.readUint16LE = f.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || I(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    f.prototype.readUint16BE = f.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || I(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    f.prototype.readUint32LE = f.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || I(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    f.prototype.readUint32BE = f.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || I(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    f.prototype.readBigUInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    f.prototype.readBigUInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    f.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I(t, r, this.length);
      let i = this[t], o2 = 1, a2 = 0;
      for (;++a2 < r && (o2 *= 256); )
        i += this[t + a2] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    f.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || I(t, r, this.length);
      let i = r, o2 = 1, a2 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        a2 += this[t + --i] * o2;
      return o2 *= 128, a2 >= o2 && (a2 -= Math.pow(2, 8 * r)), a2;
    };
    f.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || I(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    f.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || I(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || I(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    f.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || I(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    f.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || I(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    f.prototype.readBigInt64LE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    f.prototype.readBigInt64BE = ee(function(t) {
      t = t >>> 0, me(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ce(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    f.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || I(t, 4, this.length), we.read(this, t, true, 23, 4);
    };
    f.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || I(t, 4, this.length), we.read(this, t, false, 23, 4);
    };
    f.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || I(t, 8, this.length), we.read(this, t, true, 52, 8);
    };
    f.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || I(t, 8, this.length), we.read(this, t, false, 52, 8);
    };
    function O(e, t, r, n, i, o2) {
      if (!f.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    f.prototype.writeUintLE = f.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s = Math.pow(2, 8 * n) - 1;
        O(this, t, r, n, s, 0);
      }
      let o2 = 1, a2 = 0;
      for (this[r] = t & 255;++a2 < n && (o2 *= 256); )
        this[r + a2] = t / o2 & 255;
      return r + n;
    };
    f.prototype.writeUintBE = f.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let s = Math.pow(2, 8 * n) - 1;
        O(this, t, r, n, s, 0);
      }
      let o2 = n - 1, a2 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a2 *= 256); )
        this[r + o2] = t / a2 & 255;
      return r + n;
    };
    f.prototype.writeUint8 = f.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function tn(e, t, r, n, i) {
      sn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, a2 = a2 >> 8, e[r++] = a2, r;
    }
    function rn(e, t, r, n, i) {
      sn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let a2 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = a2, a2 = a2 >> 8, e[r + 2] = a2, a2 = a2 >> 8, e[r + 1] = a2, a2 = a2 >> 8, e[r] = a2, r + 8;
    }
    f.prototype.writeBigUInt64LE = ee(function(t, r = 0) {
      return tn(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f.prototype.writeBigUInt64BE = ee(function(t, r = 0) {
      return rn(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    f.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u = Math.pow(2, 8 * n - 1);
        O(this, t, r, n, u - 1, -u);
      }
      let o2 = 0, a2 = 1, s = 0;
      for (this[r] = t & 255;++o2 < n && (a2 *= 256); )
        t < 0 && s === 0 && this[r + o2 - 1] !== 0 && (s = 1), this[r + o2] = (t / a2 >> 0) - s & 255;
      return r + n;
    };
    f.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let u = Math.pow(2, 8 * n - 1);
        O(this, t, r, n, u - 1, -u);
      }
      let o2 = n - 1, a2 = 1, s = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (a2 *= 256); )
        t < 0 && s === 0 && this[r + o2 + 1] !== 0 && (s = 1), this[r + o2] = (t / a2 >> 0) - s & 255;
      return r + n;
    };
    f.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    f.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    f.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    f.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    f.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    f.prototype.writeBigInt64LE = ee(function(t, r = 0) {
      return tn(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    f.prototype.writeBigInt64BE = ee(function(t, r = 0) {
      return rn(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function nn(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function on(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || nn(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), we.write(e, t, r, n, 23, 4), r + 4;
    }
    f.prototype.writeFloatLE = function(t, r, n) {
      return on(this, t, r, true, n);
    };
    f.prototype.writeFloatBE = function(t, r, n) {
      return on(this, t, r, false, n);
    };
    function an2(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || nn(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), we.write(e, t, r, n, 52, 8), r + 8;
    }
    f.prototype.writeDoubleLE = function(t, r, n) {
      return an2(this, t, r, true, n);
    };
    f.prototype.writeDoubleBE = function(t, r, n) {
      return an2(this, t, r, false, n);
    };
    f.prototype.copy = function(t, r, n, i) {
      if (!f.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    f.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !f.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let a2 = t.charCodeAt(0);
          (i === "utf8" && a2 < 128 || i === "latin1") && (t = a2);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let a2 = f.isBuffer(t) ? t : f.from(t, i), s = a2.length;
        if (s === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = a2[o2 % s];
      }
      return this;
    };
    var ge = {};
    function Ut(e, t, r) {
      ge[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    Ut("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    Ut("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    Ut("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = Xr(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = Xr(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function Xr(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function No(e, t, r) {
      me(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ce(t, e.length - (r + 1));
    }
    function sn(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let a2 = typeof t == "bigint" ? "n" : "", s;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? s = `>= 0${a2} and < 2${a2} ** ${(o2 + 1) * 8}${a2}` : s = `>= -(2${a2} ** ${(o2 + 1) * 8 - 1}${a2}) and < 2 ** ${(o2 + 1) * 8 - 1}${a2}` : s = `>= ${t}${a2} and <= ${r}${a2}`, new ge.ERR_OUT_OF_RANGE("value", s, e);
      }
      No(n, i, o2);
    }
    function me(e, t) {
      if (typeof e != "number")
        throw new ge.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ce(e, t, r) {
      throw Math.floor(e) !== e ? (me(e, r), new ge.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new ge.ERR_BUFFER_OUT_OF_BOUNDS : new ge.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var Uo = /[^+/0-9A-Za-z-_]/g;
    function Po(e) {
      if (e = e.split("=")[0], e = e.trim().replace(Uo, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Ot(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let a2 = 0;a2 < n; ++a2) {
        if (r = e.charCodeAt(a2), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (a2 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function qo(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Do(e, t) {
      let r, n, i, o2 = [];
      for (let a2 = 0;a2 < e.length && !((t -= 2) < 0); ++a2)
        r = e.charCodeAt(a2), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function fn(e) {
      return Ct.toByteArray(Po(e));
    }
    function Xe(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function H2(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Pt(e) {
      return e !== e;
    }
    var ko = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function ee(e) {
      return typeof BigInt > "u" ? jo : e;
    }
    function jo() {
      throw new Error("BigInt not supported");
    }
  });
  qt = b3(() => {});
  cn = b3((Wf, hn) => {
    function un(e, t) {
      var r = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        t && (n = n.filter(function(i) {
          return Object.getOwnPropertyDescriptor(e, i).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function Wo(e) {
      for (var t = 1;t < arguments.length; t++) {
        var r = arguments[t] != null ? arguments[t] : {};
        t % 2 ? un(Object(r), true).forEach(function(n) {
          Ho(e, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : un(Object(r)).forEach(function(n) {
          Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return e;
    }
    function Ho(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    function $o(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function ln(e, t) {
      for (var r = 0;r < t.length; r++) {
        var n = t[r];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function Go(e, t, r) {
      return t && ln(e.prototype, t), r && ln(e, r), e;
    }
    var Ko = _e2(), ze = Ko.Buffer, Vo = qt(), Dt2 = Vo.inspect, Yo = Dt2 && Dt2.custom || "inspect";
    function Xo(e, t, r) {
      ze.prototype.copy.call(e, t, r);
    }
    hn.exports = function() {
      function e() {
        $o(this, e), this.head = null, this.tail = null, this.length = 0;
      }
      return Go(e, [{ key: "push", value: function(r) {
        var n = { data: r, next: null };
        this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var n = { data: r, next: this.head };
        this.length === 0 && (this.tail = n), this.head = n, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var n = this.head, i = "" + n.data;n = n.next; )
          i += r + n.data;
        return i;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ze.alloc(0);
        for (var n = ze.allocUnsafe(r >>> 0), i = this.head, o2 = 0;i; )
          Xo(i.data, n, o2), o2 += i.data.length, i = i.next;
        return n;
      } }, { key: "consume", value: function(r, n) {
        var i;
        return r < this.head.data.length ? (i = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? i = this.shift() : i = n ? this._getString(r) : this._getBuffer(r), i;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var n = this.head, i = 1, o2 = n.data;
        for (r -= o2.length;n = n.next; ) {
          var a2 = n.data, s = r > a2.length ? a2.length : r;
          if (s === a2.length ? o2 += a2 : o2 += a2.slice(0, r), r -= s, r === 0) {
            s === a2.length ? (++i, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = a2.slice(s));
            break;
          }
          ++i;
        }
        return this.length -= i, o2;
      } }, { key: "_getBuffer", value: function(r) {
        var n = ze.allocUnsafe(r), i = this.head, o2 = 1;
        for (i.data.copy(n), r -= i.data.length;i = i.next; ) {
          var a2 = i.data, s = r > a2.length ? a2.length : r;
          if (a2.copy(n, n.length - r, 0, s), r -= s, r === 0) {
            s === a2.length ? (++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = a2.slice(s));
            break;
          }
          ++o2;
        }
        return this.length -= o2, n;
      } }, { key: Yo, value: function(r, n) {
        return Dt2(this, Wo({}, n, { depth: 0, customInspect: false }));
      } }]), e;
    }();
  });
  jt = b3((Hf, pn2) => {
    function zo(e, t) {
      var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
      return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(kt, this, e)) : process.nextTick(kt, this, e)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e || null, function(o2) {
        !t && o2 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Ze, r) : (r._writableState.errorEmitted = true, process.nextTick(dn, r, o2)) : process.nextTick(dn, r, o2) : t ? (process.nextTick(Ze, r), t(o2)) : process.nextTick(Ze, r);
      }), this);
    }
    function dn(e, t) {
      kt(e, t), Ze(e);
    }
    function Ze(e) {
      e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
    }
    function Zo() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function kt(e, t) {
      e.emit("error", t);
    }
    function Jo(e, t) {
      var { _readableState: r, _writableState: n } = e;
      r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
    }
    pn2.exports = { destroy: zo, undestroy: Zo, errorOrDestroy: Jo };
  });
  fe2 = b3(($f, wn) => {
    function Qo(e, t) {
      e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
    }
    var gn = {};
    function P2(e, t, r) {
      r || (r = Error);
      function n(o2, a2, s) {
        return typeof t == "string" ? t : t(o2, a2, s);
      }
      var i = function(o2) {
        Qo(a2, o2);
        function a2(s, u, l2) {
          return o2.call(this, n(s, u, l2)) || this;
        }
        return a2;
      }(r);
      i.prototype.name = r.name, i.prototype.code = e, gn[e] = i;
    }
    function yn(e, t) {
      if (Array.isArray(e)) {
        var r = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
      } else
        return "of ".concat(t, " ").concat(String(e));
    }
    function ea(e, t, r) {
      return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
    }
    function ta(e, t, r) {
      return (r === undefined || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
    }
    function ra(e, t, r) {
      return typeof r != "number" && (r = 0), r + t.length > e.length ? false : e.indexOf(t, r) !== -1;
    }
    P2("ERR_INVALID_OPT_VALUE", function(e, t) {
      return 'The value "' + t + '" is invalid for option "' + e + '"';
    }, TypeError);
    P2("ERR_INVALID_ARG_TYPE", function(e, t, r) {
      var n;
      typeof t == "string" && ea(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
      var i;
      if (ta(e, " argument"))
        i = "The ".concat(e, " ").concat(n, " ").concat(yn(t, "type"));
      else {
        var o2 = ra(e, ".") ? "property" : "argument";
        i = 'The "'.concat(e, '" ').concat(o2, " ").concat(n, " ").concat(yn(t, "type"));
      }
      return i += ". Received type ".concat(typeof r), i;
    }, TypeError);
    P2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    P2("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
      return "The " + e + " method is not implemented";
    });
    P2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    P2("ERR_STREAM_DESTROYED", function(e) {
      return "Cannot call " + e + " after a stream was destroyed";
    });
    P2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    P2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    P2("ERR_STREAM_WRITE_AFTER_END", "write after end");
    P2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    P2("ERR_UNKNOWN_ENCODING", function(e) {
      return "Unknown encoding: " + e;
    }, TypeError);
    P2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    wn.exports.codes = gn;
  });
  Wt = b3((Gf, mn) => {
    var na = fe2().codes.ERR_INVALID_OPT_VALUE;
    function ia(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function oa(e, t, r, n) {
      var i = ia(t, n, r);
      if (i != null) {
        if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
          var o2 = n ? r : "highWaterMark";
          throw new na(o2, i);
        }
        return Math.floor(i);
      }
      return e.objectMode ? 16 : 16 * 1024;
    }
    mn.exports = { getHighWaterMark: oa };
  });
  _n = b3((Kf, bn) => {
    bn.exports = aa;
    function aa(e, t) {
      if (Ht2("noDeprecation"))
        return e;
      var r = false;
      function n() {
        if (!r) {
          if (Ht2("throwDeprecation"))
            throw new Error(t);
          Ht2("traceDeprecation") ? console.trace(t) : console.warn(t), r = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    }
    function Ht2(e) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var t = global.localStorage[e];
      return t == null ? false : String(t).toLowerCase() === "true";
    }
  });
  Kt2 = b3((Vf, Tn) => {
    Tn.exports = A2;
    function En(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        Oa(t, e);
      };
    }
    var ve;
    A2.WritableState = Me;
    var sa = { deprecate: _n() }, xn = At2(), Qe2 = _e2().Buffer, fa = global.Uint8Array || function() {};
    function ua(e) {
      return Qe2.from(e);
    }
    function la(e) {
      return Qe2.isBuffer(e) || e instanceof fa;
    }
    var Gt = jt(), ha = Wt(), ca = ha.getHighWaterMark, te = fe2().codes, da = te.ERR_INVALID_ARG_TYPE, pa = te.ERR_METHOD_NOT_IMPLEMENTED, ya = te.ERR_MULTIPLE_CALLBACK, ga = te.ERR_STREAM_CANNOT_PIPE, wa = te.ERR_STREAM_DESTROYED, ma = te.ERR_STREAM_NULL_VALUES, ba = te.ERR_STREAM_WRITE_AFTER_END, _a = te.ERR_UNKNOWN_ENCODING, Ee = Gt.errorOrDestroy;
    Q2()(A2, xn);
    function va() {}
    function Me(e, t, r) {
      ve = ve || ue2(), e = e || {}, typeof r != "boolean" && (r = t instanceof ve), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = ca(this, e, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var n = e.decodeStrings === false;
      this.decodeStrings = !n, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(i) {
        Ba(t, i);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new En(this);
    }
    Me.prototype.getBuffer = function() {
      for (var t = this.bufferedRequest, r = [];t; )
        r.push(t), t = t.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Me.prototype, "buffer", { get: sa.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {}
    })();
    var Je;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Je = Function.prototype[Symbol.hasInstance], Object.defineProperty(A2, Symbol.hasInstance, { value: function(t) {
      return Je.call(this, t) ? true : this !== A2 ? false : t && t._writableState instanceof Me;
    } })) : Je = function(t) {
      return t instanceof this;
    };
    function A2(e) {
      ve = ve || ue2();
      var t = this instanceof ve;
      if (!t && !Je.call(A2, this))
        return new A2(e);
      this._writableState = new Me(e, this, t), this.writable = true, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final)), xn.call(this);
    }
    A2.prototype.pipe = function() {
      Ee(this, new ga);
    };
    function Ea(e, t) {
      var r = new ba;
      Ee(e, r), process.nextTick(t, r);
    }
    function xa(e, t, r, n) {
      var i;
      return r === null ? i = new ma : typeof r != "string" && !t.objectMode && (i = new da("chunk", ["string", "Buffer"], r)), i ? (Ee(e, i), process.nextTick(n, i), false) : true;
    }
    A2.prototype.write = function(e, t, r) {
      var n = this._writableState, i = false, o2 = !n.objectMode && la(e);
      return o2 && !Qe2.isBuffer(e) && (e = ua(e)), typeof t == "function" && (r = t, t = null), o2 ? t = "buffer" : t || (t = n.defaultEncoding), typeof r != "function" && (r = va), n.ending ? Ea(this, r) : (o2 || xa(this, n, e, r)) && (n.pendingcb++, i = Sa(this, n, o2, e, t, r)), i;
    };
    A2.prototype.cork = function() {
      this._writableState.corked++;
    };
    A2.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Rn(this, e));
    };
    A2.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1))
        throw new _a(t);
      return this._writableState.defaultEncoding = t, this;
    };
    Object.defineProperty(A2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function Ra(e, t, r) {
      return !e.objectMode && e.decodeStrings !== false && typeof t == "string" && (t = Qe2.from(t, r)), t;
    }
    Object.defineProperty(A2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function Sa(e, t, r, n, i, o2) {
      if (!r) {
        var a2 = Ra(t, n, i);
        n !== a2 && (r = true, i = "buffer", n = a2);
      }
      var s = t.objectMode ? 1 : n.length;
      t.length += s;
      var u = t.length < t.highWaterMark;
      if (u || (t.needDrain = true), t.writing || t.corked) {
        var l2 = t.lastBufferedRequest;
        t.lastBufferedRequest = { chunk: n, encoding: i, isBuf: r, callback: o2, next: null }, l2 ? l2.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
      } else
        $t(e, t, false, s, n, i, o2);
      return u;
    }
    function $t(e, t, r, n, i, o2, a2) {
      t.writelen = n, t.writecb = a2, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new wa("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function Ta(e, t, r, n, i) {
      --t.pendingcb, r ? (process.nextTick(i, n), process.nextTick(Le, e, t), e._writableState.errorEmitted = true, Ee(e, n)) : (i(n), e._writableState.errorEmitted = true, Ee(e, n), Le(e, t));
    }
    function Aa(e) {
      e.writing = false, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
    }
    function Ba(e, t) {
      var r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function")
        throw new ya;
      if (Aa(r), t)
        Ta(e, r, n, t, i);
      else {
        var o2 = Sn2(r) || e.destroyed;
        !o2 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Rn(e, r), n ? process.nextTick(vn, e, r, o2, i) : vn(e, r, o2, i);
      }
    }
    function vn(e, t, r, n) {
      r || Ia(e, t), t.pendingcb--, n(), Le(e, t);
    }
    function Ia(e, t) {
      t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));
    }
    function Rn(e, t) {
      t.bufferProcessing = true;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount, i = new Array(n), o2 = t.corkedRequestsFree;
        o2.entry = r;
        for (var a2 = 0, s = true;r; )
          i[a2] = r, r.isBuf || (s = false), r = r.next, a2 += 1;
        i.allBuffers = s, $t(e, t, true, t.length, i, "", o2.finish), t.pendingcb++, t.lastBufferedRequest = null, o2.next ? (t.corkedRequestsFree = o2.next, o2.next = null) : t.corkedRequestsFree = new En(t), t.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: u, encoding: l2, callback: h2 } = r, c = t.objectMode ? 1 : u.length;
          if ($t(e, t, false, c, u, l2, h2), r = r.next, t.bufferedRequestCount--, t.writing)
            break;
        }
        r === null && (t.lastBufferedRequest = null);
      }
      t.bufferedRequest = r, t.bufferProcessing = false;
    }
    A2.prototype._write = function(e, t, r) {
      r(new pa("_write()"));
    };
    A2.prototype._writev = null;
    A2.prototype.end = function(e, t, r) {
      var n = this._writableState;
      return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || Ma(this, n, r), this;
    };
    Object.defineProperty(A2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Sn2(e) {
      return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
    }
    function Ca(e, t) {
      e._final(function(r) {
        t.pendingcb--, r && Ee(e, r), t.prefinished = true, e.emit("prefinish"), Le(e, t);
      });
    }
    function La(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = true, process.nextTick(Ca, e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Le(e, t) {
      var r = Sn2(t);
      if (r && (La(e, t), t.pendingcb === 0 && (t.finished = true, e.emit("finish"), t.autoDestroy))) {
        var n = e._readableState;
        (!n || n.autoDestroy && n.endEmitted) && e.destroy();
      }
      return r;
    }
    function Ma(e, t, r) {
      t.ending = true, Le(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = true, e.writable = false;
    }
    function Oa(e, t, r) {
      var n = e.entry;
      for (e.entry = null;n; ) {
        var i = n.callback;
        t.pendingcb--, i(r), n = n.next;
      }
      t.corkedRequestsFree.next = e;
    }
    Object.defineProperty(A2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(t) {
      !this._writableState || (this._writableState.destroyed = t);
    } });
    A2.prototype.destroy = Gt.destroy;
    A2.prototype._undestroy = Gt.undestroy;
    A2.prototype._destroy = function(e, t) {
      t(e);
    };
  });
  ue2 = b3((Yf, Bn2) => {
    var Fa = Object.keys || function(e) {
      var t = [];
      for (var r in e)
        t.push(r);
      return t;
    };
    Bn2.exports = $;
    var An = Xt(), Yt = Kt2();
    Q2()($, An);
    for (Vt2 = Fa(Yt.prototype), et2 = 0;et2 < Vt2.length; et2++)
      tt2 = Vt2[et2], $.prototype[tt2] || ($.prototype[tt2] = Yt.prototype[tt2]);
    var Vt2, tt2, et2;
    function $(e) {
      if (!(this instanceof $))
        return new $(e);
      An.call(this, e), Yt.call(this, e), this.allowHalfOpen = true, e && (e.readable === false && (this.readable = false), e.writable === false && (this.writable = false), e.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", Na)));
    }
    Object.defineProperty($.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Na() {
      this._writableState.ended || process.nextTick(Ua, this);
    }
    function Ua(e) {
      e.end();
    }
    Object.defineProperty($.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(t) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } });
  });
  Ln = b3((zt, Cn) => {
    var rt2 = _e2(), G = rt2.Buffer;
    function In(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    G.from && G.alloc && G.allocUnsafe && G.allocUnsafeSlow ? Cn.exports = rt2 : (In(rt2, zt), zt.Buffer = le);
    function le(e, t, r) {
      return G(e, t, r);
    }
    le.prototype = Object.create(G.prototype);
    In(G, le);
    le.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return G(e, t, r);
    };
    le.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = G(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    le.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return G(e);
    };
    le.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return rt2.SlowBuffer(e);
    };
  });
  Fn = b3((On2) => {
    var Jt = Ln().Buffer, Mn = Jt.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function Pa(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function qa(e) {
      var t = Pa(e);
      if (typeof t != "string" && (Jt.isEncoding === Mn || !Mn(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    On2.StringDecoder = Oe;
    function Oe(e) {
      this.encoding = qa(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = $a, this.end = Ga, t = 4;
          break;
        case "utf8":
          this.fillLast = ja, t = 4;
          break;
        case "base64":
          this.text = Ka, this.end = Va, t = 3;
          break;
        default:
          this.write = Ya, this.end = Xa;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Jt.allocUnsafe(t);
    }
    Oe.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Oe.prototype.end = Ha;
    Oe.prototype.text = Wa;
    Oe.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function Zt(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Da(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = Zt(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = Zt(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = Zt(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function ka(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function ja(e) {
      var t = this.lastTotal - this.lastNeed, r = ka(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Wa(e, t) {
      var r = Da(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function Ha(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function $a(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Ga(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Ka(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Va(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Ya(e) {
      return e.toString(this.encoding);
    }
    function Xa(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Qt = {};
  mt2(Qt, { StringDecoder: () => nt2.StringDecoder, default: () => nt2.StringDecoder });
  er = Cr(() => {
    nt2 = bt3(Fn());
  });
  it = b3((zf, Pn) => {
    var Nn2 = fe2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function za(e) {
      var t = false;
      return function() {
        if (!t) {
          t = true;
          for (var r = arguments.length, n = new Array(r), i = 0;i < r; i++)
            n[i] = arguments[i];
          e.apply(this, n);
        }
      };
    }
    function Za() {}
    function Ja(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Un(e, t, r) {
      if (typeof t == "function")
        return Un(e, null, t);
      t || (t = {}), r = za(r || Za);
      var n = t.readable || t.readable !== false && e.readable, i = t.writable || t.writable !== false && e.writable, o2 = function() {
        e.writable || s();
      }, a2 = e._writableState && e._writableState.finished, s = function() {
        i = false, a2 = true, n || r.call(e);
      }, u = e._readableState && e._readableState.endEmitted, l2 = function() {
        n = false, u = true, i || r.call(e);
      }, h2 = function(g2) {
        r.call(e, g2);
      }, c = function() {
        var g2;
        if (n && !u)
          return (!e._readableState || !e._readableState.ended) && (g2 = new Nn2), r.call(e, g2);
        if (i && !a2)
          return (!e._writableState || !e._writableState.ended) && (g2 = new Nn2), r.call(e, g2);
      }, d2 = function() {
        e.req.on("finish", s);
      };
      return Ja(e) ? (e.on("complete", s), e.on("abort", c), e.req ? d2() : e.on("request", d2)) : i && !e._writableState && (e.on("end", o2), e.on("close", o2)), e.on("end", l2), e.on("finish", s), t.error !== false && e.on("error", h2), e.on("close", c), function() {
        e.removeListener("complete", s), e.removeListener("abort", c), e.removeListener("request", d2), e.req && e.req.removeListener("finish", s), e.removeListener("end", o2), e.removeListener("close", o2), e.removeListener("finish", s), e.removeListener("end", l2), e.removeListener("error", h2), e.removeListener("close", c);
      };
    }
    Pn.exports = Un;
  });
  Dn = b3((Zf, qn) => {
    var ot;
    function re2(e, t, r) {
      return t in e ? Object.defineProperty(e, t, { value: r, enumerable: true, configurable: true, writable: true }) : e[t] = r, e;
    }
    var Qa = it(), ne = Symbol("lastResolve"), he = Symbol("lastReject"), Fe = Symbol("error"), at = Symbol("ended"), ce2 = Symbol("lastPromise"), tr = Symbol("handlePromise"), de = Symbol("stream");
    function ie(e, t) {
      return { value: e, done: t };
    }
    function es(e) {
      var t = e[ne];
      if (t !== null) {
        var r = e[de].read();
        r !== null && (e[ce2] = null, e[ne] = null, e[he] = null, t(ie(r, false)));
      }
    }
    function ts(e) {
      process.nextTick(es, e);
    }
    function rs(e, t) {
      return function(r, n) {
        e.then(function() {
          if (t[at]) {
            r(ie(undefined, true));
            return;
          }
          t[tr](r, n);
        }, n);
      };
    }
    var ns = Object.getPrototypeOf(function() {}), is = Object.setPrototypeOf((ot = { get stream() {
      return this[de];
    }, next: function() {
      var t = this, r = this[Fe];
      if (r !== null)
        return Promise.reject(r);
      if (this[at])
        return Promise.resolve(ie(undefined, true));
      if (this[de].destroyed)
        return new Promise(function(a2, s) {
          process.nextTick(function() {
            t[Fe] ? s(t[Fe]) : a2(ie(undefined, true));
          });
        });
      var n = this[ce2], i;
      if (n)
        i = new Promise(rs(n, this));
      else {
        var o2 = this[de].read();
        if (o2 !== null)
          return Promise.resolve(ie(o2, false));
        i = new Promise(this[tr]);
      }
      return this[ce2] = i, i;
    } }, re2(ot, Symbol.asyncIterator, function() {
      return this;
    }), re2(ot, "return", function() {
      var t = this;
      return new Promise(function(r, n) {
        t[de].destroy(null, function(i) {
          if (i) {
            n(i);
            return;
          }
          r(ie(undefined, true));
        });
      });
    }), ot), ns), os = function(t) {
      var r, n = Object.create(is, (r = {}, re2(r, de, { value: t, writable: true }), re2(r, ne, { value: null, writable: true }), re2(r, he, { value: null, writable: true }), re2(r, Fe, { value: null, writable: true }), re2(r, at, { value: t._readableState.endEmitted, writable: true }), re2(r, tr, { value: function(o2, a2) {
        var s = n[de].read();
        s ? (n[ce2] = null, n[ne] = null, n[he] = null, o2(ie(s, false))) : (n[ne] = o2, n[he] = a2);
      }, writable: true }), r));
      return n[ce2] = null, Qa(t, function(i) {
        if (i && i.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var o2 = n[he];
          o2 !== null && (n[ce2] = null, n[ne] = null, n[he] = null, o2(i)), n[Fe] = i;
          return;
        }
        var a2 = n[ne];
        a2 !== null && (n[ce2] = null, n[ne] = null, n[he] = null, a2(ie(undefined, true))), n[at] = true;
      }), t.on("readable", ts.bind(null, n)), n;
    };
    qn.exports = os;
  });
  jn = b3((Jf, kn) => {
    kn.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  Xt = b3((eu, Zn) => {
    Zn.exports = _2;
    var xe;
    _2.ReadableState = Gn;
    var Qf = Tt().EventEmitter, $n = function(t, r) {
      return t.listeners(r).length;
    }, Ue = At2(), st2 = _e2().Buffer, as = global.Uint8Array || function() {};
    function ss(e) {
      return st2.from(e);
    }
    function fs(e) {
      return st2.isBuffer(e) || e instanceof as;
    }
    var rr = qt(), w2;
    rr && rr.debuglog ? w2 = rr.debuglog("stream") : w2 = function() {};
    var us = cn(), ur2 = jt(), ls = Wt(), hs = ls.getHighWaterMark, ft = fe2().codes, cs = ft.ERR_INVALID_ARG_TYPE, ds = ft.ERR_STREAM_PUSH_AFTER_EOF, ps = ft.ERR_METHOD_NOT_IMPLEMENTED, ys = ft.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Re, nr, ir2;
    Q2()(_2, Ue);
    var Ne = ur2.errorOrDestroy, or = ["error", "close", "destroy", "pause", "resume"];
    function gs(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    function Gn(e, t, r) {
      xe = xe || ue2(), e = e || {}, typeof r != "boolean" && (r = t instanceof xe), this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = hs(this, e, "readableHighWaterMark", r), this.buffer = new us, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = e.emitClose !== false, this.autoDestroy = !!e.autoDestroy, this.destroyed = false, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, e.encoding && (Re || (Re = (er(), _t2(Qt)).StringDecoder), this.decoder = new Re(e.encoding), this.encoding = e.encoding);
    }
    function _2(e) {
      if (xe = xe || ue2(), !(this instanceof _2))
        return new _2(e);
      var t = this instanceof xe;
      this._readableState = new Gn(e, this, t), this.readable = true, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy)), Ue.call(this);
    }
    Object.defineProperty(_2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } });
    _2.prototype.destroy = ur2.destroy;
    _2.prototype._undestroy = ur2.undestroy;
    _2.prototype._destroy = function(e, t) {
      t(e);
    };
    _2.prototype.push = function(e, t) {
      var r = this._readableState, n;
      return r.objectMode ? n = true : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = st2.from(e, t), t = ""), n = true), Kn(this, e, t, false, n);
    };
    _2.prototype.unshift = function(e) {
      return Kn(this, e, null, true, false);
    };
    function Kn(e, t, r, n, i) {
      w2("readableAddChunk", t);
      var o2 = e._readableState;
      if (t === null)
        o2.reading = false, bs(e, o2);
      else {
        var a2;
        if (i || (a2 = ws(o2, t)), a2)
          Ne(e, a2);
        else if (o2.objectMode || t && t.length > 0)
          if (typeof t != "string" && !o2.objectMode && Object.getPrototypeOf(t) !== st2.prototype && (t = ss(t)), n)
            o2.endEmitted ? Ne(e, new ys) : ar2(e, o2, t, true);
          else if (o2.ended)
            Ne(e, new ds);
          else {
            if (o2.destroyed)
              return false;
            o2.reading = false, o2.decoder && !r ? (t = o2.decoder.write(t), o2.objectMode || t.length !== 0 ? ar2(e, o2, t, false) : fr(e, o2)) : ar2(e, o2, t, false);
          }
        else
          n || (o2.reading = false, fr(e, o2));
      }
      return !o2.ended && (o2.length < o2.highWaterMark || o2.length === 0);
    }
    function ar2(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && ut(e)), fr(e, t);
    }
    function ws(e, t) {
      var r;
      return !fs(t) && typeof t != "string" && t !== undefined && !e.objectMode && (r = new cs("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
    }
    _2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    _2.prototype.setEncoding = function(e) {
      Re || (Re = (er(), _t2(Qt)).StringDecoder);
      var t = new Re(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, n = "";r !== null; )
        n += t.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), n !== "" && this._readableState.buffer.push(n), this._readableState.length = n.length, this;
    };
    var Wn = 1073741824;
    function ms(e) {
      return e >= Wn ? e = Wn : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
    }
    function Hn(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = ms(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = true, 0));
    }
    _2.prototype.read = function(e) {
      w2("read", e), e = parseInt(e, 10);
      var t = this._readableState, r = e;
      if (e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return w2("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? sr(this) : ut(this), null;
      if (e = Hn(e, t), e === 0 && t.ended)
        return t.length === 0 && sr(this), null;
      var n = t.needReadable;
      w2("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, w2("length less than watermark", n)), t.ended || t.reading ? (n = false, w2("reading or ended", n)) : n && (w2("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true), this._read(t.highWaterMark), t.sync = false, t.reading || (e = Hn(r, t)));
      var i;
      return e > 0 ? i = Xn(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && sr(this)), i !== null && this.emit("data", i), i;
    };
    function bs(e, t) {
      if (w2("onEofChunk"), !t.ended) {
        if (t.decoder) {
          var r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? ut(e) : (t.needReadable = false, t.emittedReadable || (t.emittedReadable = true, Vn(e)));
      }
    }
    function ut(e) {
      var t = e._readableState;
      w2("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (w2("emitReadable", t.flowing), t.emittedReadable = true, process.nextTick(Vn, e));
    }
    function Vn(e) {
      var t = e._readableState;
      w2("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, lr(e);
    }
    function fr(e, t) {
      t.readingMore || (t.readingMore = true, process.nextTick(_s, e, t));
    }
    function _s(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        var r = t.length;
        if (w2("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    _2.prototype._read = function(e) {
      Ne(this, new ps("_read()"));
    };
    _2.prototype.pipe = function(e, t) {
      var r = this, n = this._readableState;
      switch (n.pipesCount) {
        case 0:
          n.pipes = e;
          break;
        case 1:
          n.pipes = [n.pipes, e];
          break;
        default:
          n.pipes.push(e);
          break;
      }
      n.pipesCount += 1, w2("pipe count=%d opts=%j", n.pipesCount, t);
      var i = (!t || t.end !== false) && e !== process.stdout && e !== process.stderr, o2 = i ? s : E3;
      n.endEmitted ? process.nextTick(o2) : r.once("end", o2), e.on("unpipe", a2);
      function a2(v2, m2) {
        w2("onunpipe"), v2 === r && m2 && m2.hasUnpiped === false && (m2.hasUnpiped = true, h2());
      }
      function s() {
        w2("onend"), e.end();
      }
      var u = vs(r);
      e.on("drain", u);
      var l2 = false;
      function h2() {
        w2("cleanup"), e.removeListener("close", p2), e.removeListener("finish", g2), e.removeListener("drain", u), e.removeListener("error", d2), e.removeListener("unpipe", a2), r.removeListener("end", s), r.removeListener("end", E3), r.removeListener("data", c), l2 = true, n.awaitDrain && (!e._writableState || e._writableState.needDrain) && u();
      }
      r.on("data", c);
      function c(v2) {
        w2("ondata");
        var m2 = e.write(v2);
        w2("dest.write", m2), m2 === false && ((n.pipesCount === 1 && n.pipes === e || n.pipesCount > 1 && zn2(n.pipes, e) !== -1) && !l2 && (w2("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause());
      }
      function d2(v2) {
        w2("onerror", v2), E3(), e.removeListener("error", d2), $n(e, "error") === 0 && Ne(e, v2);
      }
      gs(e, "error", d2);
      function p2() {
        e.removeListener("finish", g2), E3();
      }
      e.once("close", p2);
      function g2() {
        w2("onfinish"), e.removeListener("close", p2), E3();
      }
      e.once("finish", g2);
      function E3() {
        w2("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), n.flowing || (w2("pipe resume"), r.resume()), e;
    };
    function vs(e) {
      return function() {
        var r = e._readableState;
        w2("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && $n(e, "data") && (r.flowing = true, lr(e));
      };
    }
    _2.prototype.unpipe = function(e) {
      var t = this._readableState, r = { hasUnpiped: false };
      if (t.pipesCount === 0)
        return this;
      if (t.pipesCount === 1)
        return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = false, e && e.emit("unpipe", this, r), this);
      if (!e) {
        var { pipes: n, pipesCount: i } = t;
        t.pipes = null, t.pipesCount = 0, t.flowing = false;
        for (var o2 = 0;o2 < i; o2++)
          n[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var a2 = zn2(t.pipes, e);
      return a2 === -1 ? this : (t.pipes.splice(a2, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r), this);
    };
    _2.prototype.on = function(e, t) {
      var r = Ue.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, w2("on readable", n.length, n.reading), n.length ? ut(this) : n.reading || process.nextTick(Es, this)), r;
    };
    _2.prototype.addListener = _2.prototype.on;
    _2.prototype.removeListener = function(e, t) {
      var r = Ue.prototype.removeListener.call(this, e, t);
      return e === "readable" && process.nextTick(Yn, this), r;
    };
    _2.prototype.removeAllListeners = function(e) {
      var t = Ue.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && process.nextTick(Yn, this), t;
    };
    function Yn(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = true : e.listenerCount("data") > 0 && e.resume();
    }
    function Es(e) {
      w2("readable nexttick read 0"), e.read(0);
    }
    _2.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (w2("resume"), e.flowing = !e.readableListening, xs(this, e)), e.paused = false, this;
    };
    function xs(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, process.nextTick(Rs, e, t));
    }
    function Rs(e, t) {
      w2("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), lr(e), t.flowing && !t.reading && e.read(0);
    }
    _2.prototype.pause = function() {
      return w2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (w2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function lr(e) {
      var t = e._readableState;
      for (w2("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    _2.prototype.wrap = function(e) {
      var t = this, r = this._readableState, n = false;
      e.on("end", function() {
        if (w2("wrapped end"), r.decoder && !r.ended) {
          var a2 = r.decoder.end();
          a2 && a2.length && t.push(a2);
        }
        t.push(null);
      }), e.on("data", function(a2) {
        if (w2("wrapped data"), r.decoder && (a2 = r.decoder.write(a2)), !(r.objectMode && a2 == null) && !(!r.objectMode && (!a2 || !a2.length))) {
          var s = t.push(a2);
          s || (n = true, e.pause());
        }
      });
      for (var i in e)
        this[i] === undefined && typeof e[i] == "function" && (this[i] = function(s) {
          return function() {
            return e[s].apply(e, arguments);
          };
        }(i));
      for (var o2 = 0;o2 < or.length; o2++)
        e.on(or[o2], this.emit.bind(this, or[o2]));
      return this._read = function(a2) {
        w2("wrapped _read", a2), n && (n = false, e.resume());
      }, this;
    };
    typeof Symbol == "function" && (_2.prototype[Symbol.asyncIterator] = function() {
      return nr === undefined && (nr = Dn()), nr(this);
    });
    Object.defineProperty(_2.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(_2.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(_2.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } });
    _2._fromList = Xn;
    Object.defineProperty(_2.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Xn(e, t) {
      if (t.length === 0)
        return null;
      var r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function sr(e) {
      var t = e._readableState;
      w2("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, process.nextTick(Ss, t, e));
    }
    function Ss(e, t) {
      if (w2("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = true, t.readable = false, t.emit("end"), e.autoDestroy)) {
        var r = t._writableState;
        (!r || r.autoDestroy && r.finished) && t.destroy();
      }
    }
    typeof Symbol == "function" && (_2.from = function(e, t) {
      return ir2 === undefined && (ir2 = jn()), ir2(_2, e, t);
    });
    function zn2(e, t) {
      for (var r = 0, n = e.length;r < n; r++)
        if (e[r] === t)
          return r;
      return -1;
    }
  });
  hr2 = b3((tu, Qn) => {
    Qn.exports = z;
    var lt2 = fe2().codes, Ts = lt2.ERR_METHOD_NOT_IMPLEMENTED, As = lt2.ERR_MULTIPLE_CALLBACK, Bs = lt2.ERR_TRANSFORM_ALREADY_TRANSFORMING, Is = lt2.ERR_TRANSFORM_WITH_LENGTH_0, ht = ue2();
    Q2()(z, ht);
    function Cs(e, t) {
      var r = this._transformState;
      r.transforming = false;
      var n = r.writecb;
      if (n === null)
        return this.emit("error", new As);
      r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
      var i = this._readableState;
      i.reading = false, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
    }
    function z(e) {
      if (!(this instanceof z))
        return new z(e);
      ht.call(this, e), this._transformState = { afterTransform: Cs.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", Ls);
    }
    function Ls() {
      var e = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
        Jn(e, t, r);
      }) : Jn(this, null, null);
    }
    z.prototype.push = function(e, t) {
      return this._transformState.needTransform = false, ht.prototype.push.call(this, e, t);
    };
    z.prototype._transform = function(e, t, r) {
      r(new Ts("_transform()"));
    };
    z.prototype._write = function(e, t, r) {
      var n = this._transformState;
      if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
        var i = this._readableState;
        (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
      }
    };
    z.prototype._read = function(e) {
      var t = this._transformState;
      t.writechunk !== null && !t.transforming ? (t.transforming = true, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = true;
    };
    z.prototype._destroy = function(e, t) {
      ht.prototype._destroy.call(this, e, function(r) {
        t(r);
      });
    };
    function Jn(e, t, r) {
      if (t)
        return e.emit("error", t);
      if (r != null && e.push(r), e._writableState.length)
        throw new Is;
      if (e._transformState.transforming)
        throw new Bs;
      return e.push(null);
    }
  });
  ri = b3((ru, ti2) => {
    ti2.exports = Pe2;
    var ei = hr2();
    Q2()(Pe2, ei);
    function Pe2(e) {
      if (!(this instanceof Pe2))
        return new Pe2(e);
      ei.call(this, e);
    }
    Pe2.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  si = b3((nu, ai) => {
    var cr2;
    function Ms(e) {
      var t = false;
      return function() {
        t || (t = true, e.apply(undefined, arguments));
      };
    }
    var oi = fe2().codes, Os = oi.ERR_MISSING_ARGS, Fs = oi.ERR_STREAM_DESTROYED;
    function ni(e) {
      if (e)
        throw e;
    }
    function Ns(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    function Us(e, t, r, n) {
      n = Ms(n);
      var i = false;
      e.on("close", function() {
        i = true;
      }), cr2 === undefined && (cr2 = it()), cr2(e, { readable: t, writable: r }, function(a2) {
        if (a2)
          return n(a2);
        i = true, n();
      });
      var o2 = false;
      return function(a2) {
        if (!i && !o2) {
          if (o2 = true, Ns(e))
            return e.abort();
          if (typeof e.destroy == "function")
            return e.destroy();
          n(a2 || new Fs("pipe"));
        }
      };
    }
    function ii(e) {
      e();
    }
    function Ps(e, t) {
      return e.pipe(t);
    }
    function qs(e) {
      return !e.length || typeof e[e.length - 1] != "function" ? ni : e.pop();
    }
    function Ds() {
      for (var e = arguments.length, t = new Array(e), r = 0;r < e; r++)
        t[r] = arguments[r];
      var n = qs(t);
      if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
        throw new Os("streams");
      var i, o2 = t.map(function(a2, s) {
        var u = s < t.length - 1, l2 = s > 0;
        return Us(a2, u, l2, function(h2) {
          i || (i = h2), h2 && o2.forEach(ii), !u && (o2.forEach(ii), n(i));
        });
      });
      return t.reduce(Ps);
    }
    ai.exports = Ds;
  });
  dr3 = b3((q, fi2) => {
    q = fi2.exports = Xt();
    q.Stream = q;
    q.Readable = q;
    q.Writable = Kt2();
    q.Duplex = ue2();
    q.Transform = hr2();
    q.PassThrough = ri();
    q.finished = it();
    q.pipeline = si();
  });
  gr2 = b3((yr2) => {
    var ui = xt(), ks = Q2(), li2 = dr3(), ct2 = yr2.readyStates = { UNSENT: 0, OPENED: 1, HEADERS_RECEIVED: 2, LOADING: 3, DONE: 4 }, pr2 = yr2.IncomingMessage = function(e, t, r, n) {
      var i = this;
      if (li2.Readable.call(i), i._mode = r, i.headers = {}, i.rawHeaders = [], i.trailers = {}, i.rawTrailers = [], i.on("end", function() {
        process.nextTick(function() {
          i.emit("close");
        });
      }), r === "fetch") {
        let c = function() {
          a2.read().then(function(d2) {
            if (!i._destroyed) {
              if (n(d2.done), d2.done) {
                i.push(null);
                return;
              }
              i.push(Buffer.from(d2.value)), c();
            }
          }).catch(function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          });
        };
        var h2 = c;
        if (i._fetchResponse = t, i.url = t.url, i.statusCode = t.status, i.statusMessage = t.statusText, t.headers.forEach(function(d2, p2) {
          i.headers[p2.toLowerCase()] = d2, i.rawHeaders.push(p2, d2);
        }), ui.writableStream) {
          var o2 = new WritableStream({ write: function(d2) {
            return n(false), new Promise(function(p2, g2) {
              i._destroyed ? g2() : i.push(Buffer.from(d2)) ? p2() : i._resumeFetch = p2;
            });
          }, close: function() {
            n(true), i._destroyed || i.push(null);
          }, abort: function(d2) {
            n(true), i._destroyed || i.emit("error", d2);
          } });
          try {
            t.body.pipeTo(o2).catch(function(d2) {
              n(true), i._destroyed || i.emit("error", d2);
            });
            return;
          } catch {}
        }
        var a2 = t.body.getReader();
        c();
      } else {
        i._xhr = e, i._pos = 0, i.url = e.responseURL, i.statusCode = e.status, i.statusMessage = e.statusText;
        var s = e.getAllResponseHeaders().split(/\r?\n/);
        if (s.forEach(function(c) {
          var d2 = c.match(/^([^:]+):\s*(.*)/);
          if (d2) {
            var p2 = d2[1].toLowerCase();
            p2 === "set-cookie" ? (i.headers[p2] === undefined && (i.headers[p2] = []), i.headers[p2].push(d2[2])) : i.headers[p2] !== undefined ? i.headers[p2] += ", " + d2[2] : i.headers[p2] = d2[2], i.rawHeaders.push(d2[1], d2[2]);
          }
        }), i._charset = "x-user-defined", !ui.overrideMimeType) {
          var u = i.rawHeaders["mime-type"];
          if (u) {
            var l2 = u.match(/;\s*charset=([^;])(;|$)/);
            l2 && (i._charset = l2[1].toLowerCase());
          }
          i._charset || (i._charset = "utf-8");
        }
      }
    };
    ks(pr2, li2.Readable);
    pr2.prototype._read = function() {
      var e = this, t = e._resumeFetch;
      t && (e._resumeFetch = null, t());
    };
    pr2.prototype._onXHRProgress = function(e) {
      var t = this, r = t._xhr, n = null;
      switch (t._mode) {
        case "text":
          if (n = r.responseText, n.length > t._pos) {
            var i = n.substr(t._pos);
            if (t._charset === "x-user-defined") {
              for (var o2 = Buffer.alloc(i.length), a2 = 0;a2 < i.length; a2++)
                o2[a2] = i.charCodeAt(a2) & 255;
              t.push(o2);
            } else
              t.push(i, t._charset);
            t._pos = n.length;
          }
          break;
        case "arraybuffer":
          if (r.readyState !== ct2.DONE || !r.response)
            break;
          n = r.response, t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "moz-chunked-arraybuffer":
          if (n = r.response, r.readyState !== ct2.LOADING || !n)
            break;
          t.push(Buffer.from(new Uint8Array(n)));
          break;
        case "ms-stream":
          if (n = r.response, r.readyState !== ct2.LOADING)
            break;
          var s = new global.MSStreamReader;
          s.onprogress = function() {
            s.result.byteLength > t._pos && (t.push(Buffer.from(new Uint8Array(s.result.slice(t._pos)))), t._pos = s.result.byteLength);
          }, s.onload = function() {
            e(true), t.push(null);
          }, s.readAsArrayBuffer(n);
          break;
      }
      t._xhr.readyState === ct2.DONE && t._mode !== "ms-stream" && (e(true), t.push(null));
    };
  });
  pi2 = b3((ou2, di2) => {
    var pe = xt(), js2 = Q2(), ci2 = gr2(), wr = dr3(), Ws2 = ci2.IncomingMessage, hi = ci2.readyStates;
    function Hs2(e, t) {
      return pe.fetch && t ? "fetch" : pe.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : pe.msstream ? "ms-stream" : pe.arraybuffer && e ? "arraybuffer" : "text";
    }
    var M2 = di2.exports = function(e) {
      var t = this;
      wr.Writable.call(t), t._opts = e, t._body = [], t._headers = {}, e.auth && t.setHeader("Authorization", "Basic " + Buffer.from(e.auth).toString("base64")), Object.keys(e.headers).forEach(function(i) {
        t.setHeader(i, e.headers[i]);
      });
      var r, n = true;
      if (e.mode === "disable-fetch" || "requestTimeout" in e && !pe.abortController)
        n = false, r = true;
      else if (e.mode === "prefer-streaming")
        r = false;
      else if (e.mode === "allow-wrong-content-type")
        r = !pe.overrideMimeType;
      else if (!e.mode || e.mode === "default" || e.mode === "prefer-fast")
        r = true;
      else
        throw new Error("Invalid value for opts.mode");
      t._mode = Hs2(r, n), t._fetchTimer = null, t._socketTimeout = null, t._socketTimer = null, t.on("finish", function() {
        t._onFinish();
      });
    };
    js2(M2, wr.Writable);
    M2.prototype.setHeader = function(e, t) {
      var r = this, n = e.toLowerCase();
      Gs2.indexOf(n) === -1 && (r._headers[n] = { name: e, value: t });
    };
    M2.prototype.getHeader = function(e) {
      var t = this._headers[e.toLowerCase()];
      return t ? t.value : null;
    };
    M2.prototype.removeHeader = function(e) {
      var t = this;
      delete t._headers[e.toLowerCase()];
    };
    M2.prototype._onFinish = function() {
      var e = this;
      if (!e._destroyed) {
        var t = e._opts;
        "timeout" in t && t.timeout !== 0 && e.setTimeout(t.timeout);
        var r = e._headers, n = null;
        t.method !== "GET" && t.method !== "HEAD" && (n = new Blob(e._body, { type: (r["content-type"] || {}).value || "" }));
        var i = [];
        if (Object.keys(r).forEach(function(u) {
          var l2 = r[u].name, h2 = r[u].value;
          Array.isArray(h2) ? h2.forEach(function(c) {
            i.push([l2, c]);
          }) : i.push([l2, h2]);
        }), e._mode === "fetch") {
          var o2 = null;
          if (pe.abortController) {
            var a2 = new AbortController;
            o2 = a2.signal, e._fetchAbortController = a2, "requestTimeout" in t && t.requestTimeout !== 0 && (e._fetchTimer = global.setTimeout(function() {
              e.emit("requestTimeout"), e._fetchAbortController && e._fetchAbortController.abort();
            }, t.requestTimeout));
          }
          global.fetch(e._opts.url, { method: e._opts.method, headers: i, body: n || undefined, mode: "cors", credentials: t.withCredentials ? "include" : "same-origin", signal: o2 }).then(function(u) {
            e._fetchResponse = u, e._resetTimers(false), e._connect();
          }, function(u) {
            e._resetTimers(true), e._destroyed || e.emit("error", u);
          });
        } else {
          var s = e._xhr = new global.XMLHttpRequest;
          try {
            s.open(e._opts.method, e._opts.url, true);
          } catch (u) {
            process.nextTick(function() {
              e.emit("error", u);
            });
            return;
          }
          "responseType" in s && (s.responseType = e._mode), "withCredentials" in s && (s.withCredentials = !!t.withCredentials), e._mode === "text" && "overrideMimeType" in s && s.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in t && (s.timeout = t.requestTimeout, s.ontimeout = function() {
            e.emit("requestTimeout");
          }), i.forEach(function(u) {
            s.setRequestHeader(u[0], u[1]);
          }), e._response = null, s.onreadystatechange = function() {
            switch (s.readyState) {
              case hi.LOADING:
              case hi.DONE:
                e._onXHRProgress();
                break;
            }
          }, e._mode === "moz-chunked-arraybuffer" && (s.onprogress = function() {
            e._onXHRProgress();
          }), s.onerror = function() {
            e._destroyed || (e._resetTimers(true), e.emit("error", new Error("XHR error")));
          };
          try {
            s.send(n);
          } catch (u) {
            process.nextTick(function() {
              e.emit("error", u);
            });
            return;
          }
        }
      }
    };
    function $s2(e) {
      try {
        var t = e.status;
        return t !== null && t !== 0;
      } catch {
        return false;
      }
    }
    M2.prototype._onXHRProgress = function() {
      var e = this;
      e._resetTimers(false), !(!$s2(e._xhr) || e._destroyed) && (e._response || e._connect(), e._response._onXHRProgress(e._resetTimers.bind(e)));
    };
    M2.prototype._connect = function() {
      var e = this;
      e._destroyed || (e._response = new Ws2(e._xhr, e._fetchResponse, e._mode, e._resetTimers.bind(e)), e._response.on("error", function(t) {
        e.emit("error", t);
      }), e.emit("response", e._response));
    };
    M2.prototype._write = function(e, t, r) {
      var n = this;
      n._body.push(e), r();
    };
    M2.prototype._resetTimers = function(e) {
      var t = this;
      global.clearTimeout(t._socketTimer), t._socketTimer = null, e ? (global.clearTimeout(t._fetchTimer), t._fetchTimer = null) : t._socketTimeout && (t._socketTimer = global.setTimeout(function() {
        t.emit("timeout");
      }, t._socketTimeout));
    };
    M2.prototype.abort = M2.prototype.destroy = function(e) {
      var t = this;
      t._destroyed = true, t._resetTimers(true), t._response && (t._response._destroyed = true), t._xhr ? t._xhr.abort() : t._fetchAbortController && t._fetchAbortController.abort(), e && t.emit("error", e);
    };
    M2.prototype.end = function(e, t, r) {
      var n = this;
      typeof e == "function" && (r = e, e = undefined), wr.Writable.prototype.end.call(n, e, t, r);
    };
    M2.prototype.setTimeout = function(e, t) {
      var r = this;
      t && r.once("timeout", t), r._socketTimeout = e, r._resetTimers(false);
    };
    M2.prototype.flushHeaders = function() {};
    M2.prototype.setNoDelay = function() {};
    M2.prototype.setSocketKeepAlive = function() {};
    var Gs2 = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  });
  gi2 = b3((au2, yi2) => {
    yi2.exports = Vs2;
    var Ks2 = Object.prototype.hasOwnProperty;
    function Vs2() {
      for (var e = {}, t = 0;t < arguments.length; t++) {
        var r = arguments[t];
        for (var n in r)
          Ks2.call(r, n) && (e[n] = r[n]);
      }
      return e;
    }
  });
  mi2 = b3((su2, wi2) => {
    wi2.exports = { 100: "Continue", 101: "Switching Protocols", 102: "Processing", 200: "OK", 201: "Created", 202: "Accepted", 203: "Non-Authoritative Information", 204: "No Content", 205: "Reset Content", 206: "Partial Content", 207: "Multi-Status", 208: "Already Reported", 226: "IM Used", 300: "Multiple Choices", 301: "Moved Permanently", 302: "Found", 303: "See Other", 304: "Not Modified", 305: "Use Proxy", 307: "Temporary Redirect", 308: "Permanent Redirect", 400: "Bad Request", 401: "Unauthorized", 402: "Payment Required", 403: "Forbidden", 404: "Not Found", 405: "Method Not Allowed", 406: "Not Acceptable", 407: "Proxy Authentication Required", 408: "Request Timeout", 409: "Conflict", 410: "Gone", 411: "Length Required", 412: "Precondition Failed", 413: "Payload Too Large", 414: "URI Too Long", 415: "Unsupported Media Type", 416: "Range Not Satisfiable", 417: "Expectation Failed", 418: "I'm a teapot", 421: "Misdirected Request", 422: "Unprocessable Entity", 423: "Locked", 424: "Failed Dependency", 425: "Unordered Collection", 426: "Upgrade Required", 428: "Precondition Required", 429: "Too Many Requests", 431: "Request Header Fields Too Large", 451: "Unavailable For Legal Reasons", 500: "Internal Server Error", 501: "Not Implemented", 502: "Bad Gateway", 503: "Service Unavailable", 504: "Gateway Timeout", 505: "HTTP Version Not Supported", 506: "Variant Also Negotiates", 507: "Insufficient Storage", 508: "Loop Detected", 509: "Bandwidth Limit Exceeded", 510: "Not Extended", 511: "Network Authentication Required" };
  });
  Ti = {};
  mt2(Ti, { decode: () => vr2, default: () => tf, encode: () => Er2, toASCII: () => Si2, toUnicode: () => Ri, ucs2decode: () => _r2, ucs2encode: () => Ei });
  Ai = Cr(() => {
    _i2 = "-", Ys2 = /^xn--/, Xs = /[^\0-\x7F]/, zs = /[\x2E\u3002\uFF0E\uFF61]/g, Zs = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, mr = 36 - 1, K2 = Math.floor, br2 = String.fromCharCode;
    Ei = (e) => String.fromCodePoint(...e), Qs = function(e) {
      return e >= 48 && e < 58 ? 26 + (e - 48) : e >= 65 && e < 91 ? e - 65 : e >= 97 && e < 123 ? e - 97 : 36;
    }, bi2 = function(e, t) {
      return e + 22 + 75 * (e < 26) - ((t != 0) << 5);
    }, xi2 = function(e, t, r) {
      let n = 0;
      for (e = r ? K2(e / 700) : e >> 1, e += K2(e / t);e > mr * 26 >> 1; n += 36)
        e = K2(e / mr);
      return K2(n + (mr + 1) * e / (e + 38));
    }, vr2 = function(e) {
      let t = [], r = e.length, n = 0, i = 128, o2 = 72, a2 = e.lastIndexOf(_i2);
      a2 < 0 && (a2 = 0);
      for (let s = 0;s < a2; ++s)
        e.charCodeAt(s) >= 128 && oe2("not-basic"), t.push(e.charCodeAt(s));
      for (let s = a2 > 0 ? a2 + 1 : 0;s < r; ) {
        let u = n;
        for (let h2 = 1, c = 36;; c += 36) {
          s >= r && oe2("invalid-input");
          let d2 = Qs(e.charCodeAt(s++));
          d2 >= 36 && oe2("invalid-input"), d2 > K2((2147483647 - n) / h2) && oe2("overflow"), n += d2 * h2;
          let p2 = c <= o2 ? 1 : c >= o2 + 26 ? 26 : c - o2;
          if (d2 < p2)
            break;
          let g2 = 36 - p2;
          h2 > K2(2147483647 / g2) && oe2("overflow"), h2 *= g2;
        }
        let l2 = t.length + 1;
        o2 = xi2(n - u, l2, u == 0), K2(n / l2) > 2147483647 - i && oe2("overflow"), i += K2(n / l2), n %= l2, t.splice(n++, 0, i);
      }
      return String.fromCodePoint(...t);
    }, Er2 = function(e) {
      let t = [];
      e = _r2(e);
      let r = e.length, n = 128, i = 0, o2 = 72;
      for (let u of e)
        u < 128 && t.push(br2(u));
      let a2 = t.length, s = a2;
      for (a2 && t.push(_i2);s < r; ) {
        let u = 2147483647;
        for (let h2 of e)
          h2 >= n && h2 < u && (u = h2);
        let l2 = s + 1;
        u - n > K2((2147483647 - i) / l2) && oe2("overflow"), i += (u - n) * l2, n = u;
        for (let h2 of e)
          if (h2 < n && ++i > 2147483647 && oe2("overflow"), h2 === n) {
            let c = i;
            for (let d2 = 36;; d2 += 36) {
              let p2 = d2 <= o2 ? 1 : d2 >= o2 + 26 ? 26 : d2 - o2;
              if (c < p2)
                break;
              let g2 = c - p2, E3 = 36 - p2;
              t.push(br2(bi2(p2 + g2 % E3, 0))), c = K2(g2 / E3);
            }
            t.push(br2(bi2(c, 0))), o2 = xi2(i, l2, s === a2), i = 0, ++s;
          }
        ++i, ++n;
      }
      return t.join("");
    }, Ri = function(e) {
      return vi2(e, function(t) {
        return Ys2.test(t) ? vr2(t.slice(4).toLowerCase()) : t;
      });
    }, Si2 = function(e) {
      return vi2(e, function(t) {
        return Xs.test(t) ? "xn--" + Er2(t) : t;
      });
    }, ef = { version: "2.1.0", ucs2: { decode: _r2, encode: Ei }, decode: vr2, encode: Er2, toASCII: Si2, toUnicode: Ri }, tf = ef;
  });
  Ii = b3((fu2, Bi) => {
    Bi.exports = { isString: function(e) {
      return typeof e == "string";
    }, isObject: function(e) {
      return typeof e == "object" && e !== null;
    }, isNull: function(e) {
      return e === null;
    }, isNullOrUndefined: function(e) {
      return e == null;
    } };
  });
  Li = b3((uu2, Ci) => {
    var rf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, nf = Object.keys || function() {
      var e = Object.prototype.hasOwnProperty, t = !{ toString: null }.propertyIsEnumerable("toString"), r = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], n = r.length;
      return function(i) {
        if (typeof i != "function" && ((typeof i > "u" ? "undefined" : rf(i)) !== "object" || i === null))
          throw new TypeError("Object.keys called on non-object");
        var o2 = [], a2, s;
        for (a2 in i)
          e.call(i, a2) && o2.push(a2);
        if (t)
          for (s = 0;s < n; s++)
            e.call(i, r[s]) && o2.push(r[s]);
        return o2;
      };
    }();
    Ci.exports = nf;
  });
  ji = b3((lu2, ki) => {
    var Pi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e;
    } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
    }, pt2 = ki.exports = { unescapeBuffer: ff, unescape: Di2, escape: lf, stringify: Fi, encode: Fi, parse: Ui, decode: Ui }, of = _e2().Buffer, af = Li(), sf = function(t) {
      return Object.prototype.toString.call(t) === "[object Array]";
    }, Mi = function(t, r, n) {
      var i;
      if (t == null)
        throw new TypeError('"arr" is null or not defined');
      var o2 = Object(t), a2 = o2.length >>> 0;
      if (a2 === 0)
        return -1;
      var s = n | 0;
      if (s >= a2)
        return -1;
      for (i = Math.max(s >= 0 ? s : a2 - Math.abs(s), 0);i < a2; ) {
        if (i in o2 && o2[i] === r)
          return i;
        i++;
      }
      return -1;
    };
    function qi() {}
    qi.prototype = Object.create ? Object.create(null) : {};
    var Oi = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
    function ff(e, t) {
      for (var r = of.allocUnsafe(e.length), n = 0, i, o2, a2, s, u = 0, l2 = 0;; u++) {
        if (u < e.length)
          s = e.charCodeAt(u);
        else {
          n > 0 && (r[l2++] = 37, n === 2 && (r[l2++] = a2));
          break;
        }
        switch (n) {
          case 0:
            switch (s) {
              case 37:
                i = 0, o2 = 0, n = 1;
                break;
              case 43:
                t && (s = 32);
              default:
                r[l2++] = s;
                break;
            }
            break;
          case 1:
            if (a2 = s, i = Oi[s], !(i >= 0)) {
              r[l2++] = 37, r[l2++] = s, n = 0;
              break;
            }
            n = 2;
            break;
          case 2:
            if (n = 0, o2 = Oi[s], !(o2 >= 0)) {
              r[l2++] = 37, r[l2++] = a2, r[l2++] = s;
              break;
            }
            r[l2++] = 16 * i + o2;
            break;
        }
      }
      return r.slice(0, l2);
    }
    function Di2(e, t) {
      try {
        return decodeURIComponent(e);
      } catch {
        return pt2.unescapeBuffer(e, t).toString();
      }
    }
    var k = [];
    for (Se2 = 0;Se2 < 256; ++Se2)
      k[Se2] = "%" + ((Se2 < 16 ? "0" : "") + Se2.toString(16)).toUpperCase();
    var Se2, uf = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0];
    function lf(e) {
      typeof e != "string" && ((typeof e > "u" ? "undefined" : Pi(e)) === "object" ? e = String(e) : e += "");
      for (var t = "", r = 0, n = 0;n < e.length; ++n) {
        var i = e.charCodeAt(n);
        if (i < 128) {
          if (uf[i] === 1)
            continue;
          r < n && (t += e.slice(r, n)), r = n + 1, t += k[i];
          continue;
        }
        if (r < n && (t += e.slice(r, n)), i < 2048) {
          r = n + 1, t += k[192 | i >> 6] + k[128 | i & 63];
          continue;
        }
        if (i < 55296 || i >= 57344) {
          r = n + 1, t += k[224 | i >> 12] + k[128 | i >> 6 & 63] + k[128 | i & 63];
          continue;
        }
        ++n;
        var o2;
        if (n < e.length)
          o2 = e.charCodeAt(n) & 1023;
        else
          throw new URIError("URI malformed");
        r = n + 1, i = 65536 + ((i & 1023) << 10 | o2), t += k[240 | i >> 18] + k[128 | i >> 12 & 63] + k[128 | i >> 6 & 63] + k[128 | i & 63];
      }
      return r === 0 ? e : r < e.length ? t + e.slice(r) : t;
    }
    function xr2(e) {
      return typeof e == "string" ? e : typeof e == "number" && isFinite(e) ? "" + e : typeof e == "boolean" ? e ? "true" : "false" : "";
    }
    function Fi(e, t, r, n) {
      t = t || "&", r = r || "=";
      var i = pt2.escape;
      if (n && typeof n.encodeURIComponent == "function" && (i = n.encodeURIComponent), e !== null && (typeof e > "u" ? "undefined" : Pi(e)) === "object") {
        for (var o2 = af(e), a2 = o2.length, s = a2 - 1, u = "", l2 = 0;l2 < a2; ++l2) {
          var h2 = o2[l2], c = e[h2], d2 = i(xr2(h2)) + r;
          if (sf(c)) {
            for (var p2 = c.length, g2 = p2 - 1, E3 = 0;E3 < p2; ++E3)
              u += d2 + i(xr2(c[E3])), E3 < g2 && (u += t);
            p2 && l2 < s && (u += t);
          } else
            u += d2 + i(xr2(c)), l2 < s && (u += t);
        }
        return u;
      }
      return "";
    }
    function Ni2(e) {
      if (e.length === 0)
        return [];
      if (e.length === 1)
        return [e.charCodeAt(0)];
      for (var t = [], r = 0;r < e.length; ++r)
        t[t.length] = e.charCodeAt(r);
      return t;
    }
    var hf = [38], cf = [61];
    function Ui(e, t, r, n) {
      var i = new qi;
      if (typeof e != "string" || e.length === 0)
        return i;
      var o2 = t ? Ni2(t + "") : hf, a2 = r ? Ni2(r + "") : cf, s = o2.length, u = a2.length, l2 = 1000;
      n && typeof n.maxKeys == "number" && (l2 = n.maxKeys > 0 ? n.maxKeys : -1);
      var h2 = pt2.unescape;
      n && typeof n.decodeURIComponent == "function" && (h2 = n.decodeURIComponent);
      for (var c = h2 !== Di2, d2 = [], p2 = 0, g2 = 0, E3 = 0, v2 = 0, m2 = "", y2 = "", R2 = c, C2 = c, T = 0, S = 0;S < e.length; ++S) {
        var B = e.charCodeAt(S);
        if (B === o2[E3]) {
          if (++E3 === s) {
            var F2 = S - E3 + 1;
            if (v2 < u ? g2 < F2 && (m2 += e.slice(g2, F2)) : g2 < F2 && (y2 += e.slice(g2, F2)), R2 && (m2 = dt3(m2, h2)), C2 && (y2 = dt3(y2, h2)), m2 || y2 || g2 - p2 > s || S === 0)
              if (Mi(d2, m2) === -1)
                i[m2] = y2, d2[d2.length] = m2;
              else {
                var L2 = i[m2] || "";
                L2.pop ? L2[L2.length] = y2 : L2 && (i[m2] = [L2, y2]);
              }
            else
              S === 1 && delete i[m2];
            if (--l2 === 0)
              break;
            R2 = C2 = c, T = 0, m2 = y2 = "", p2 = g2, g2 = S + 1, E3 = v2 = 0;
          }
          continue;
        } else
          E3 = 0, C2 || (B === 37 ? T = 1 : T > 0 && (B >= 48 && B <= 57 || B >= 65 && B <= 70 || B >= 97 && B <= 102) ? ++T === 3 && (C2 = true) : T = 0);
        if (v2 < u)
          if (B === a2[v2]) {
            if (++v2 === u) {
              var Y2 = S - v2 + 1;
              g2 < Y2 && (m2 += e.slice(g2, Y2)), T = 0, g2 = S + 1;
            }
            continue;
          } else
            v2 = 0, R2 || (B === 37 ? T = 1 : T > 0 && (B >= 48 && B <= 57 || B >= 65 && B <= 70 || B >= 97 && B <= 102) ? ++T === 3 && (R2 = true) : T = 0);
        B === 43 && (v2 < u ? (g2 < S && (m2 += e.slice(g2, S)), m2 += "%20", R2 = true) : (g2 < S && (y2 += e.slice(g2, S)), y2 += "%20", C2 = true), g2 = S + 1);
      }
      if (l2 !== 0 && (g2 < e.length || v2 > 0))
        if (g2 < e.length && (v2 < u ? m2 += e.slice(g2) : E3 < s && (y2 += e.slice(g2))), R2 && (m2 = dt3(m2, h2)), C2 && (y2 = dt3(y2, h2)), Mi(d2, m2) === -1)
          i[m2] = y2, d2[d2.length] = m2;
        else {
          var Z = i[m2];
          Z.pop ? Z[Z.length] = y2 : i[m2] = [Z, y2];
        }
      return i;
    }
    function dt3(e, t) {
      try {
        return t(e);
      } catch {
        return pt2.unescape(e, true);
      }
    }
  });
  Ar = b3((Ae2) => {
    var df = (Ai(), _t2(Ti)), V2 = Ii();
    Ae2.parse = qe2;
    Ae2.resolve = xf;
    Ae2.resolveObject = Rf;
    Ae2.format = Ef;
    Ae2.Url = D;
    function D() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    var pf = /^([a-z0-9.+-]+:)/i, yf = /:[0-9]*$/, gf = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, wf = ["<", ">", '"', "`", " ", "\r", `
`, "\t"], mf = ["{", "}", "|", "\\", "^", "`"].concat(wf), Rr3 = ["'"].concat(mf), Wi = ["%", "/", "?", ";", "#"].concat(Rr3), Hi2 = ["/", "?", "#"], bf = 255, $i = /^[+a-z0-9A-Z_-]{0,63}$/, _f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, vf = { javascript: true, "javascript:": true }, Sr = { javascript: true, "javascript:": true }, Te = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, Tr = ji();
    function qe2(e, t, r) {
      if (e && V2.isObject(e) && e instanceof D)
        return e;
      var n = new D;
      return n.parse(e, t, r), n;
    }
    D.prototype.parse = function(e, t, r) {
      if (!V2.isString(e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
      var n = e.indexOf("?"), i = n !== -1 && n < e.indexOf("#") ? "?" : "#", o2 = e.split(i), a2 = /\\/g;
      o2[0] = o2[0].replace(a2, "/"), e = o2.join(i);
      var s = e;
      if (s = s.trim(), !r && e.split("#").length === 1) {
        var u = gf.exec(s);
        if (u)
          return this.path = s, this.href = s, this.pathname = u[1], u[2] ? (this.search = u[2], t ? this.query = Tr.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this;
      }
      var l2 = pf.exec(s);
      if (l2) {
        l2 = l2[0];
        var h2 = l2.toLowerCase();
        this.protocol = h2, s = s.substr(l2.length);
      }
      if (r || l2 || s.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var c = s.substr(0, 2) === "//";
        c && !(l2 && Sr[l2]) && (s = s.substr(2), this.slashes = true);
      }
      if (!Sr[l2] && (c || l2 && !Te[l2])) {
        for (var d2 = -1, p2 = 0;p2 < Hi2.length; p2++) {
          var g2 = s.indexOf(Hi2[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        var E3, v2;
        d2 === -1 ? v2 = s.lastIndexOf("@") : v2 = s.lastIndexOf("@", d2), v2 !== -1 && (E3 = s.slice(0, v2), s = s.slice(v2 + 1), this.auth = decodeURIComponent(E3)), d2 = -1;
        for (var p2 = 0;p2 < Wi.length; p2++) {
          var g2 = s.indexOf(Wi[p2]);
          g2 !== -1 && (d2 === -1 || g2 < d2) && (d2 = g2);
        }
        d2 === -1 && (d2 = s.length), this.host = s.slice(0, d2), s = s.slice(d2), this.parseHost(), this.hostname = this.hostname || "";
        var m2 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!m2)
          for (var y2 = this.hostname.split(/\./), p2 = 0, R2 = y2.length;p2 < R2; p2++) {
            var C2 = y2[p2];
            if (!!C2 && !C2.match($i)) {
              for (var T = "", S = 0, B = C2.length;S < B; S++)
                C2.charCodeAt(S) > 127 ? T += "x" : T += C2[S];
              if (!T.match($i)) {
                var F2 = y2.slice(0, p2), L2 = y2.slice(p2 + 1), Y2 = C2.match(_f);
                Y2 && (F2.push(Y2[1]), L2.unshift(Y2[2])), L2.length && (s = "/" + L2.join(".") + s), this.hostname = F2.join(".");
                break;
              }
            }
          }
        this.hostname.length > bf ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), m2 || (this.hostname = df.toASCII(this.hostname));
        var Z = this.port ? ":" + this.port : "", zi = this.hostname || "";
        this.host = zi + Z, this.href += this.host, m2 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), s[0] !== "/" && (s = "/" + s));
      }
      if (!vf[h2])
        for (var p2 = 0, R2 = Rr3.length;p2 < R2; p2++) {
          var Be = Rr3[p2];
          if (s.indexOf(Be) !== -1) {
            var gt3 = encodeURIComponent(Be);
            gt3 === Be && (gt3 = escape(Be)), s = s.split(Be).join(gt3);
          }
        }
      var wt = s.indexOf("#");
      wt !== -1 && (this.hash = s.substr(wt), s = s.slice(0, wt));
      var je = s.indexOf("?");
      if (je !== -1 ? (this.search = s.substr(je), this.query = s.substr(je + 1), t && (this.query = Tr.parse(this.query)), s = s.slice(0, je)) : t && (this.search = "", this.query = {}), s && (this.pathname = s), Te[h2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var Z = this.pathname || "", Zi = this.search || "";
        this.path = Z + Zi;
      }
      return this.href = this.format(), this;
    };
    function Ef(e) {
      return V2.isString(e) && (e = qe2(e)), e instanceof D ? e.format() : D.prototype.format.call(e);
    }
    D.prototype.format = function() {
      var e = this.auth || "";
      e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
      var t = this.protocol || "", r = this.pathname || "", n = this.hash || "", i = false, o2 = "";
      this.host ? i = e + this.host : this.hostname && (i = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && V2.isObject(this.query) && Object.keys(this.query).length && (o2 = Tr.stringify(this.query));
      var a2 = this.search || o2 && "?" + o2 || "";
      return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || Te[t]) && i !== false ? (i = "//" + (i || ""), r && r.charAt(0) !== "/" && (r = "/" + r)) : i || (i = ""), n && n.charAt(0) !== "#" && (n = "#" + n), a2 && a2.charAt(0) !== "?" && (a2 = "?" + a2), r = r.replace(/[?#]/g, function(s) {
        return encodeURIComponent(s);
      }), a2 = a2.replace("#", "%23"), t + i + r + a2 + n;
    };
    function xf(e, t) {
      return qe2(e, false, true).resolve(t);
    }
    D.prototype.resolve = function(e) {
      return this.resolveObject(qe2(e, false, true)).format();
    };
    function Rf(e, t) {
      return e ? qe2(e, false, true).resolveObject(t) : t;
    }
    D.prototype.resolveObject = function(e) {
      if (V2.isString(e)) {
        var t = new D;
        t.parse(e, false, true), e = t;
      }
      for (var r = new D, n = Object.keys(this), i = 0;i < n.length; i++) {
        var o2 = n[i];
        r[o2] = this[o2];
      }
      if (r.hash = e.hash, e.href === "")
        return r.href = r.format(), r;
      if (e.slashes && !e.protocol) {
        for (var a2 = Object.keys(e), s = 0;s < a2.length; s++) {
          var u = a2[s];
          u !== "protocol" && (r[u] = e[u]);
        }
        return Te[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r;
      }
      if (e.protocol && e.protocol !== r.protocol) {
        if (!Te[e.protocol]) {
          for (var l2 = Object.keys(e), h2 = 0;h2 < l2.length; h2++) {
            var c = l2[h2];
            r[c] = e[c];
          }
          return r.href = r.format(), r;
        }
        if (r.protocol = e.protocol, !e.host && !Sr[e.protocol]) {
          for (var R2 = (e.pathname || "").split("/");R2.length && !(e.host = R2.shift()); )
            ;
          e.host || (e.host = ""), e.hostname || (e.hostname = ""), R2[0] !== "" && R2.unshift(""), R2.length < 2 && R2.unshift(""), r.pathname = R2.join("/");
        } else
          r.pathname = e.pathname;
        if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
          var d2 = r.pathname || "", p2 = r.search || "";
          r.path = d2 + p2;
        }
        return r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
      }
      var g2 = r.pathname && r.pathname.charAt(0) === "/", E3 = e.host || e.pathname && e.pathname.charAt(0) === "/", v2 = E3 || g2 || r.host && e.pathname, m2 = v2, y2 = r.pathname && r.pathname.split("/") || [], R2 = e.pathname && e.pathname.split("/") || [], C2 = r.protocol && !Te[r.protocol];
      if (C2 && (r.hostname = "", r.port = null, r.host && (y2[0] === "" ? y2[0] = r.host : y2.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (R2[0] === "" ? R2[0] = e.host : R2.unshift(e.host)), e.host = null), v2 = v2 && (R2[0] === "" || y2[0] === "")), E3)
        r.host = e.host || e.host === "" ? e.host : r.host, r.hostname = e.hostname || e.hostname === "" ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, y2 = R2;
      else if (R2.length)
        y2 || (y2 = []), y2.pop(), y2 = y2.concat(R2), r.search = e.search, r.query = e.query;
      else if (!V2.isNullOrUndefined(e.search)) {
        if (C2) {
          r.hostname = r.host = y2.shift();
          var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
          T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
        }
        return r.search = e.search, r.query = e.query, (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
      }
      if (!y2.length)
        return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
      for (var S = y2.slice(-1)[0], B = (r.host || e.host || y2.length > 1) && (S === "." || S === "..") || S === "", F2 = 0, L2 = y2.length;L2 >= 0; L2--)
        S = y2[L2], S === "." ? y2.splice(L2, 1) : S === ".." ? (y2.splice(L2, 1), F2++) : F2 && (y2.splice(L2, 1), F2--);
      if (!v2 && !m2)
        for (;F2--; F2)
          y2.unshift("..");
      v2 && y2[0] !== "" && (!y2[0] || y2[0].charAt(0) !== "/") && y2.unshift(""), B && y2.join("/").substr(-1) !== "/" && y2.push("");
      var Y2 = y2[0] === "" || y2[0] && y2[0].charAt(0) === "/";
      if (C2) {
        r.hostname = r.host = Y2 ? "" : y2.length ? y2.shift() : "";
        var T = r.host && r.host.indexOf("@") > 0 ? r.host.split("@") : false;
        T && (r.auth = T.shift(), r.host = r.hostname = T.shift());
      }
      return v2 = v2 || r.host && y2.length, v2 && !Y2 && y2.unshift(""), y2.length ? r.pathname = y2.join("/") : (r.pathname = null, r.path = null), (!V2.isNull(r.pathname) || !V2.isNull(r.search)) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r;
    };
    D.prototype.parseHost = function() {
      var e = this.host, t = yf.exec(e);
      t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e);
    };
  });
  Vi2 = b3((Ki2) => {
    var Gi2 = pi2(), Sf = gr2(), Tf = gi2(), Af = mi2(), Bf = Ar(), j2 = Ki2;
    j2.request = function(e, t) {
      typeof e == "string" ? e = Bf.parse(e) : e = Tf(e);
      var r = global.location.protocol.search(/^https?:$/) === -1 ? "http:" : "", n = e.protocol || r, i = e.hostname || e.host, o2 = e.port, a2 = e.path || "/";
      i && i.indexOf(":") !== -1 && (i = "[" + i + "]"), e.url = (i ? n + "//" + i : "") + (o2 ? ":" + o2 : "") + a2, e.method = (e.method || "GET").toUpperCase(), e.headers = e.headers || {};
      var s = new Gi2(e);
      return t && s.on("response", t), s;
    };
    j2.get = function(t, r) {
      var n = j2.request(t, r);
      return n.end(), n;
    };
    j2.ClientRequest = Gi2;
    j2.IncomingMessage = Sf.IncomingMessage;
    j2.Agent = function() {};
    j2.Agent.defaultMaxSockets = 4;
    j2.globalAgent = new j2.Agent;
    j2.STATUS_CODES = Af;
    j2.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  });
  Ir = b3((du, Xi2) => {
    var De = Vi2(), If = Ar(), Br2 = Xi2.exports;
    for (yt2 in De)
      De.hasOwnProperty(yt2) && (Br2[yt2] = De[yt2]);
    var yt2;
    Br2.request = function(e, t) {
      return e = Yi2(e), De.request.call(this, e, t);
    };
    Br2.get = function(e, t) {
      return e = Yi2(e), De.get.call(this, e, t);
    };
    function Yi2(e) {
      if (typeof e == "string" && (e = If.parse(e)), e.protocol || (e.protocol = "https:"), e.protocol !== "https:")
        throw new Error('Protocol "' + e.protocol + '" not supported. Expected "https:"');
      return e;
    }
  });
  ke2 = {};
  mt2(ke2, { default: () => Cf });
  $e(ke2, bt3(Ir()));
  Cf = bt3(Ir());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node:os
var exports_os = {};
__export(exports_os, {
  uptime: () => A2,
  type: () => V2,
  totalmem: () => N3,
  tmpdir: () => U,
  release: () => x2,
  platform: () => O,
  networkInterfaces: () => j2,
  loadavg: () => y2,
  hostname: () => k,
  homedir: () => _2,
  getNetworkInterfaces: () => B,
  freemem: () => I,
  endianness: () => L2,
  default: () => E3,
  cpus: () => b4,
  arch: () => M2,
  EOL: () => X
});
var c, a2, m2, s, p2, d2, l2 = (r, n) => () => (n || r((n = { exports: {} }).exports, n), n.exports), h2 = (r, n, t, i) => {
  if (n && typeof n == "object" || typeof n == "function")
    for (let o2 of s(n))
      !d2.call(r, o2) && o2 !== t && a2(r, o2, { get: () => n[o2], enumerable: !(i = m2(n, o2)) || i.enumerable });
  return r;
}, g2 = (r, n, t) => (t = r != null ? c(p2(r)) : {}, h2(n || !r || !r.__esModule ? a2(t, "default", { value: r, enumerable: true }) : t, r)), f, u, E3, L2, k, y2, A2, I, N3, b4, V2, x2, M2, O, U, X, _2, j2, B;
var init_os = __esm(() => {
  c = Object.create;
  a2 = Object.defineProperty;
  m2 = Object.getOwnPropertyDescriptor;
  s = Object.getOwnPropertyNames;
  p2 = Object.getPrototypeOf;
  d2 = Object.prototype.hasOwnProperty;
  f = l2((e) => {
    e.endianness = function() {
      return "LE";
    };
    e.hostname = function() {
      return typeof location < "u" ? location.hostname : "";
    };
    e.loadavg = function() {
      return [];
    };
    e.uptime = function() {
      return 0;
    };
    e.freemem = function() {
      return Number.MAX_VALUE;
    };
    e.totalmem = function() {
      return Number.MAX_VALUE;
    };
    e.cpus = function() {
      return [];
    };
    e.type = function() {
      return "Browser";
    };
    e.release = function() {
      return typeof navigator < "u" ? navigator.appVersion : "";
    };
    e.networkInterfaces = e.getNetworkInterfaces = function() {
      return {};
    };
    e.arch = function() {
      return "javascript";
    };
    e.platform = function() {
      return "browser";
    };
    e.tmpdir = e.tmpDir = function() {
      return "/tmp";
    };
    e.EOL = `
`;
    e.homedir = function() {
      return "/";
    };
  });
  u = g2(f());
  E3 = u.default;
  ({ endianness: L2, hostname: k, loadavg: y2, uptime: A2, freemem: I, totalmem: N3, cpus: b4, type: V2, release: x2, arch: M2, platform: O, tmpdir: U, EOL: X, homedir: _2, networkInterfaces: j2, getNetworkInterfaces: B } = u.default);
});

// node_modules/process-warning/index.js
var require_process_warning = __commonJS((exports, module) => {
  var { format } = (init_util(), __toCommonJS(exports_util));
  function createDeprecation(params) {
    return createWarning({ ...params, name: "DeprecationWarning" });
  }
  function createWarning({ name, code, message, unlimited = false } = {}) {
    if (!name)
      throw new Error("Warning name must not be empty");
    if (!code)
      throw new Error("Warning code must not be empty");
    if (!message)
      throw new Error("Warning message must not be empty");
    if (typeof unlimited !== "boolean")
      throw new Error("Warning opts.unlimited must be a boolean");
    code = code.toUpperCase();
    let warningContainer = {
      [name]: function(a3, b5, c2) {
        if (warning.emitted === true && warning.unlimited !== true) {
          return;
        }
        warning.emitted = true;
        process.emitWarning(warning.format(a3, b5, c2), warning.name, warning.code);
      }
    };
    if (unlimited) {
      warningContainer = {
        [name]: function(a3, b5, c2) {
          warning.emitted = true;
          process.emitWarning(warning.format(a3, b5, c2), warning.name, warning.code);
        }
      };
    }
    const warning = warningContainer[name];
    warning.emitted = false;
    warning.message = message;
    warning.unlimited = unlimited;
    warning.code = code;
    warning.format = function(a3, b5, c2) {
      let formatted;
      if (a3 && b5 && c2) {
        formatted = format(message, a3, b5, c2);
      } else if (a3 && b5) {
        formatted = format(message, a3, b5);
      } else if (a3) {
        formatted = format(message, a3);
      } else {
        formatted = message;
      }
      return formatted;
    };
    return warning;
  }
  var out = { createWarning, createDeprecation };
  module.exports = out;
  module.exports.default = out;
  module.exports.processWarning = out;
});

// node_modules/fastify/lib/warnings.js
var require_warnings = __commonJS((exports, module) => {
  var { createWarning } = require_process_warning();
  var FSTWRN001 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN001",
    message: "The %s schema for %s: %s is missing. This may indicate the schema is not well specified.",
    unlimited: true
  });
  var FSTWRN003 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN003",
    message: "The %s mixes async and callback styles that may lead to unhandled rejections. Please use only one of them.",
    unlimited: true
  });
  var FSTWRN004 = createWarning({
    name: "FastifyWarning",
    code: "FSTWRN004",
    message: "It seems that you are overriding an errorHandler in the same scope, which can lead to subtle bugs.",
    unlimited: true
  });
  var FSTSEC001 = createWarning({
    name: "FastifySecurity",
    code: "FSTSEC001",
    message: 'You are using /%s/ Content-Type which may be vulnerable to CORS attack. Please make sure your RegExp start with "^" or include ";?" to proper detection of the essence MIME type.',
    unlimited: true
  });
  var FSTDEP022 = createWarning({
    name: "FastifyWarning",
    code: "FSTDEP022",
    message: 'The router options for %s property access is deprecated. Please use "options.routerOptions" instead for accessing router options. The router options will be removed in `fastify@6`.',
    unlimited: true
  });
  module.exports = {
    FSTWRN001,
    FSTWRN003,
    FSTWRN004,
    FSTSEC001,
    FSTDEP022
  };
});

// node_modules/fastify/lib/errors.js
var require_errors2 = __commonJS((exports, module) => {
  var createError = require_error();
  var codes = {
    FST_ERR_NOT_FOUND: createError("FST_ERR_NOT_FOUND", "Not Found", 404),
    FST_ERR_OPTIONS_NOT_OBJ: createError("FST_ERR_OPTIONS_NOT_OBJ", "Options must be an object", 500, TypeError),
    FST_ERR_QSP_NOT_FN: createError("FST_ERR_QSP_NOT_FN", "querystringParser option should be a function, instead got '%s'", 500, TypeError),
    FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN: createError("FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN", "schemaController.bucket option should be a function, instead got '%s'", 500, TypeError),
    FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN: createError("FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN", "schemaErrorFormatter option should be a non async function. Instead got '%s'.", 500, TypeError),
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ: createError("FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ", "ajv.customOptions option should be an object, instead got '%s'", 500, TypeError),
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR: createError("FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR", "ajv.plugins option should be an array, instead got '%s'", 500, TypeError),
    FST_ERR_VALIDATION: createError("FST_ERR_VALIDATION", "%s", 400),
    FST_ERR_LISTEN_OPTIONS_INVALID: createError("FST_ERR_LISTEN_OPTIONS_INVALID", "Invalid listen options: '%s'", 500, TypeError),
    FST_ERR_ERROR_HANDLER_NOT_FN: createError("FST_ERR_ERROR_HANDLER_NOT_FN", "Error Handler must be a function", 500, TypeError),
    FST_ERR_ERROR_HANDLER_ALREADY_SET: createError("FST_ERR_ERROR_HANDLER_ALREADY_SET", "Error Handler already set in this scope. Set 'allowErrorHandlerOverride: true' to allow overriding.", 500, TypeError),
    FST_ERR_CTP_ALREADY_PRESENT: createError("FST_ERR_CTP_ALREADY_PRESENT", "Content type parser '%s' already present."),
    FST_ERR_CTP_INVALID_TYPE: createError("FST_ERR_CTP_INVALID_TYPE", "The content type should be a string or a RegExp", 500, TypeError),
    FST_ERR_CTP_EMPTY_TYPE: createError("FST_ERR_CTP_EMPTY_TYPE", "The content type cannot be an empty string", 500, TypeError),
    FST_ERR_CTP_INVALID_HANDLER: createError("FST_ERR_CTP_INVALID_HANDLER", "The content type handler should be a function", 500, TypeError),
    FST_ERR_CTP_INVALID_PARSE_TYPE: createError("FST_ERR_CTP_INVALID_PARSE_TYPE", "The body parser can only parse your data as 'string' or 'buffer', you asked '%s' which is not supported.", 500, TypeError),
    FST_ERR_CTP_BODY_TOO_LARGE: createError("FST_ERR_CTP_BODY_TOO_LARGE", "Request body is too large", 413, RangeError),
    FST_ERR_CTP_INVALID_MEDIA_TYPE: createError("FST_ERR_CTP_INVALID_MEDIA_TYPE", "Unsupported Media Type: %s", 415),
    FST_ERR_CTP_INVALID_CONTENT_LENGTH: createError("FST_ERR_CTP_INVALID_CONTENT_LENGTH", "Request body size did not match Content-Length", 400, RangeError),
    FST_ERR_CTP_EMPTY_JSON_BODY: createError("FST_ERR_CTP_EMPTY_JSON_BODY", "Body cannot be empty when content-type is set to 'application/json'", 400),
    FST_ERR_CTP_INVALID_JSON_BODY: createError("FST_ERR_CTP_INVALID_JSON_BODY", "Body is not valid JSON but content-type is set to 'application/json'", 400),
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED: createError("FST_ERR_CTP_INSTANCE_ALREADY_STARTED", 'Cannot call "%s" when fastify instance is already started!', 400),
    FST_ERR_DEC_ALREADY_PRESENT: createError("FST_ERR_DEC_ALREADY_PRESENT", "The decorator '%s' has already been added!"),
    FST_ERR_DEC_DEPENDENCY_INVALID_TYPE: createError("FST_ERR_DEC_DEPENDENCY_INVALID_TYPE", "The dependencies of decorator '%s' must be of type Array.", 500, TypeError),
    FST_ERR_DEC_MISSING_DEPENDENCY: createError("FST_ERR_DEC_MISSING_DEPENDENCY", "The decorator is missing dependency '%s'."),
    FST_ERR_DEC_AFTER_START: createError("FST_ERR_DEC_AFTER_START", "The decorator '%s' has been added after start!"),
    FST_ERR_DEC_REFERENCE_TYPE: createError("FST_ERR_DEC_REFERENCE_TYPE", "The decorator '%s' of type '%s' is a reference type. Use the { getter, setter } interface instead."),
    FST_ERR_DEC_UNDECLARED: createError("FST_ERR_DEC_UNDECLARED", "No decorator '%s' has been declared on %s."),
    FST_ERR_HOOK_INVALID_TYPE: createError("FST_ERR_HOOK_INVALID_TYPE", "The hook name must be a string", 500, TypeError),
    FST_ERR_HOOK_INVALID_HANDLER: createError("FST_ERR_HOOK_INVALID_HANDLER", "%s hook should be a function, instead got %s", 500, TypeError),
    FST_ERR_HOOK_INVALID_ASYNC_HANDLER: createError("FST_ERR_HOOK_INVALID_ASYNC_HANDLER", "Async function has too many arguments. Async hooks should not use the 'done' argument.", 500, TypeError),
    FST_ERR_HOOK_NOT_SUPPORTED: createError("FST_ERR_HOOK_NOT_SUPPORTED", "%s hook not supported!", 500, TypeError),
    FST_ERR_MISSING_MIDDLEWARE: createError("FST_ERR_MISSING_MIDDLEWARE", "You must register a plugin for handling middlewares, visit fastify.dev/docs/latest/Reference/Middleware/ for more info.", 500),
    FST_ERR_HOOK_TIMEOUT: createError("FST_ERR_HOOK_TIMEOUT", "A callback for '%s' hook%s timed out. You may have forgotten to call 'done' function or to resolve a Promise"),
    FST_ERR_LOG_INVALID_DESTINATION: createError("FST_ERR_LOG_INVALID_DESTINATION", "Cannot specify both logger.stream and logger.file options"),
    FST_ERR_LOG_INVALID_LOGGER: createError("FST_ERR_LOG_INVALID_LOGGER", "Invalid logger object provided. The logger instance should have these functions(s): '%s'.", 500, TypeError),
    FST_ERR_LOG_INVALID_LOGGER_INSTANCE: createError("FST_ERR_LOG_INVALID_LOGGER_INSTANCE", "loggerInstance only accepts a logger instance.", 500, TypeError),
    FST_ERR_LOG_INVALID_LOGGER_CONFIG: createError("FST_ERR_LOG_INVALID_LOGGER_CONFIG", "logger options only accepts a configuration object.", 500, TypeError),
    FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED: createError("FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED", "You cannot provide both logger and loggerInstance. Please provide only one.", 500, TypeError),
    FST_ERR_REP_INVALID_PAYLOAD_TYPE: createError("FST_ERR_REP_INVALID_PAYLOAD_TYPE", "Attempted to send payload of invalid type '%s'. Expected a string or Buffer.", 500, TypeError),
    FST_ERR_REP_RESPONSE_BODY_CONSUMED: createError("FST_ERR_REP_RESPONSE_BODY_CONSUMED", "Response.body is already consumed."),
    FST_ERR_REP_READABLE_STREAM_LOCKED: createError("FST_ERR_REP_READABLE_STREAM_LOCKED", "ReadableStream was locked. You should call releaseLock() method on reader before sending."),
    FST_ERR_REP_ALREADY_SENT: createError("FST_ERR_REP_ALREADY_SENT", 'Reply was already sent, did you forget to "return reply" in "%s" (%s)?'),
    FST_ERR_REP_SENT_VALUE: createError("FST_ERR_REP_SENT_VALUE", "The only possible value for reply.sent is true.", 500, TypeError),
    FST_ERR_SEND_INSIDE_ONERR: createError("FST_ERR_SEND_INSIDE_ONERR", "You cannot use `send` inside the `onError` hook"),
    FST_ERR_SEND_UNDEFINED_ERR: createError("FST_ERR_SEND_UNDEFINED_ERR", "Undefined error has occurred"),
    FST_ERR_BAD_STATUS_CODE: createError("FST_ERR_BAD_STATUS_CODE", "Called reply with an invalid status code: %s"),
    FST_ERR_BAD_TRAILER_NAME: createError("FST_ERR_BAD_TRAILER_NAME", "Called reply.trailer with an invalid header name: %s"),
    FST_ERR_BAD_TRAILER_VALUE: createError("FST_ERR_BAD_TRAILER_VALUE", "Called reply.trailer('%s', fn) with an invalid type: %s. Expected a function."),
    FST_ERR_FAILED_ERROR_SERIALIZATION: createError("FST_ERR_FAILED_ERROR_SERIALIZATION", "Failed to serialize an error. Error: %s. Original error: %s"),
    FST_ERR_MISSING_SERIALIZATION_FN: createError("FST_ERR_MISSING_SERIALIZATION_FN", 'Missing serialization function. Key "%s"'),
    FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN: createError("FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN", 'Missing serialization function. Key "%s:%s"'),
    FST_ERR_REQ_INVALID_VALIDATION_INVOCATION: createError("FST_ERR_REQ_INVALID_VALIDATION_INVOCATION", 'Invalid validation invocation. Missing validation function for HTTP part "%s" nor schema provided.'),
    FST_ERR_SCH_MISSING_ID: createError("FST_ERR_SCH_MISSING_ID", "Missing schema $id property"),
    FST_ERR_SCH_ALREADY_PRESENT: createError("FST_ERR_SCH_ALREADY_PRESENT", "Schema with id '%s' already declared!"),
    FST_ERR_SCH_CONTENT_MISSING_SCHEMA: createError("FST_ERR_SCH_CONTENT_MISSING_SCHEMA", "Schema is missing for the content type '%s'"),
    FST_ERR_SCH_DUPLICATE: createError("FST_ERR_SCH_DUPLICATE", "Schema with '%s' already present!"),
    FST_ERR_SCH_VALIDATION_BUILD: createError("FST_ERR_SCH_VALIDATION_BUILD", "Failed building the validation schema for %s: %s, due to error %s"),
    FST_ERR_SCH_SERIALIZATION_BUILD: createError("FST_ERR_SCH_SERIALIZATION_BUILD", "Failed building the serialization schema for %s: %s, due to error %s"),
    FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX: createError("FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX", 'response schemas should be nested under a valid status code, e.g { 2xx: { type: "object" } }'),
    FST_ERR_INIT_OPTS_INVALID: createError("FST_ERR_INIT_OPTS_INVALID", "Invalid initialization options: '%s'"),
    FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE: createError("FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE", "Cannot set forceCloseConnections to 'idle' as your HTTP server does not support closeIdleConnections method"),
    FST_ERR_DUPLICATED_ROUTE: createError("FST_ERR_DUPLICATED_ROUTE", "Method '%s' already declared for route '%s'"),
    FST_ERR_BAD_URL: createError("FST_ERR_BAD_URL", "'%s' is not a valid url component", 400, URIError),
    FST_ERR_ASYNC_CONSTRAINT: createError("FST_ERR_ASYNC_CONSTRAINT", "Unexpected error from async constraint", 500),
    FST_ERR_INVALID_URL: createError("FST_ERR_INVALID_URL", "URL must be a string. Received '%s'", 400, TypeError),
    FST_ERR_ROUTE_OPTIONS_NOT_OBJ: createError("FST_ERR_ROUTE_OPTIONS_NOT_OBJ", 'Options for "%s:%s" route must be an object', 500, TypeError),
    FST_ERR_ROUTE_DUPLICATED_HANDLER: createError("FST_ERR_ROUTE_DUPLICATED_HANDLER", 'Duplicate handler for "%s:%s" route is not allowed!', 500),
    FST_ERR_ROUTE_HANDLER_NOT_FN: createError("FST_ERR_ROUTE_HANDLER_NOT_FN", "Error Handler for %s:%s route, if defined, must be a function", 500, TypeError),
    FST_ERR_ROUTE_MISSING_HANDLER: createError("FST_ERR_ROUTE_MISSING_HANDLER", 'Missing handler function for "%s:%s" route.', 500),
    FST_ERR_ROUTE_METHOD_INVALID: createError("FST_ERR_ROUTE_METHOD_INVALID", "Provided method is invalid!", 500, TypeError),
    FST_ERR_ROUTE_METHOD_NOT_SUPPORTED: createError("FST_ERR_ROUTE_METHOD_NOT_SUPPORTED", "%s method is not supported.", 500),
    FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED: createError("FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED", "Body validation schema for %s:%s route is not supported!", 500),
    FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT: createError("FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT", "'bodyLimit' option must be an integer > 0. Got '%s'", 500, TypeError),
    FST_ERR_ROUTE_REWRITE_NOT_STR: createError("FST_ERR_ROUTE_REWRITE_NOT_STR", 'Rewrite url for "%s" needs to be of type "string" but received "%s"', 500, TypeError),
    FST_ERR_REOPENED_CLOSE_SERVER: createError("FST_ERR_REOPENED_CLOSE_SERVER", "Fastify has already been closed and cannot be reopened"),
    FST_ERR_REOPENED_SERVER: createError("FST_ERR_REOPENED_SERVER", "Fastify is already listening"),
    FST_ERR_INSTANCE_ALREADY_LISTENING: createError("FST_ERR_INSTANCE_ALREADY_LISTENING", "Fastify instance is already listening. %s"),
    FST_ERR_PLUGIN_VERSION_MISMATCH: createError("FST_ERR_PLUGIN_VERSION_MISMATCH", "fastify-plugin: %s - expected '%s' fastify version, '%s' is installed"),
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE: createError("FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE", "The decorator '%s'%s is not present in %s"),
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER: createError("FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER", "The %s plugin being registered mixes async and callback styles. Async plugin should not mix async and callback style.", 500, TypeError),
    FST_ERR_PLUGIN_CALLBACK_NOT_FN: createError("FST_ERR_PLUGIN_CALLBACK_NOT_FN", "fastify-plugin: %s", 500, TypeError),
    FST_ERR_PLUGIN_NOT_VALID: createError("FST_ERR_PLUGIN_NOT_VALID", "fastify-plugin: %s"),
    FST_ERR_ROOT_PLG_BOOTED: createError("FST_ERR_ROOT_PLG_BOOTED", "fastify-plugin: %s"),
    FST_ERR_PARENT_PLUGIN_BOOTED: createError("FST_ERR_PARENT_PLUGIN_BOOTED", "fastify-plugin: %s"),
    FST_ERR_PLUGIN_TIMEOUT: createError("FST_ERR_PLUGIN_TIMEOUT", "fastify-plugin: %s")
  };
  function appendStackTrace(oldErr, newErr) {
    newErr.cause = oldErr;
    return newErr;
  }
  module.exports = codes;
  module.exports.appendStackTrace = appendStackTrace;
  module.exports.AVVIO_ERRORS_MAP = {
    AVV_ERR_CALLBACK_NOT_FN: codes.FST_ERR_PLUGIN_CALLBACK_NOT_FN,
    AVV_ERR_PLUGIN_NOT_VALID: codes.FST_ERR_PLUGIN_NOT_VALID,
    AVV_ERR_ROOT_PLG_BOOTED: codes.FST_ERR_ROOT_PLG_BOOTED,
    AVV_ERR_PARENT_PLG_LOADED: codes.FST_ERR_PARENT_PLUGIN_BOOTED,
    AVV_ERR_READY_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT,
    AVV_ERR_PLUGIN_EXEC_TIMEOUT: codes.FST_ERR_PLUGIN_TIMEOUT
  };
});

// node_modules/fastify/lib/hooks.js
var require_hooks = __commonJS((exports, module) => {
  var applicationHooks = [
    "onRoute",
    "onRegister",
    "onReady",
    "onListen",
    "preClose",
    "onClose"
  ];
  var lifecycleHooks = [
    "onTimeout",
    "onRequest",
    "preParsing",
    "preValidation",
    "preSerialization",
    "preHandler",
    "onSend",
    "onResponse",
    "onError",
    "onRequestAbort"
  ];
  var supportedHooks = lifecycleHooks.concat(applicationHooks);
  var {
    FST_ERR_HOOK_INVALID_TYPE,
    FST_ERR_HOOK_INVALID_HANDLER,
    FST_ERR_SEND_UNDEFINED_ERR,
    FST_ERR_HOOK_TIMEOUT,
    FST_ERR_HOOK_NOT_SUPPORTED,
    AVVIO_ERRORS_MAP,
    appendStackTrace
  } = require_errors2();
  var {
    kChildren,
    kHooks,
    kRequestPayloadStream
  } = require_symbols2();
  function Hooks() {
    this.onRequest = [];
    this.preParsing = [];
    this.preValidation = [];
    this.preSerialization = [];
    this.preHandler = [];
    this.onResponse = [];
    this.onSend = [];
    this.onError = [];
    this.onRoute = [];
    this.onRegister = [];
    this.onReady = [];
    this.onListen = [];
    this.onTimeout = [];
    this.onRequestAbort = [];
    this.preClose = [];
  }
  Hooks.prototype = Object.create(null);
  Hooks.prototype.validate = function(hook, fn) {
    if (typeof hook !== "string")
      throw new FST_ERR_HOOK_INVALID_TYPE;
    if (Array.isArray(this[hook]) === false) {
      throw new FST_ERR_HOOK_NOT_SUPPORTED(hook);
    }
    if (typeof fn !== "function")
      throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(fn));
  };
  Hooks.prototype.add = function(hook, fn) {
    this.validate(hook, fn);
    this[hook].push(fn);
  };
  function buildHooks(h3) {
    const hooks = new Hooks;
    hooks.onRequest = h3.onRequest.slice();
    hooks.preParsing = h3.preParsing.slice();
    hooks.preValidation = h3.preValidation.slice();
    hooks.preSerialization = h3.preSerialization.slice();
    hooks.preHandler = h3.preHandler.slice();
    hooks.onSend = h3.onSend.slice();
    hooks.onResponse = h3.onResponse.slice();
    hooks.onError = h3.onError.slice();
    hooks.onRoute = h3.onRoute.slice();
    hooks.onRegister = h3.onRegister.slice();
    hooks.onTimeout = h3.onTimeout.slice();
    hooks.onRequestAbort = h3.onRequestAbort.slice();
    hooks.onReady = [];
    hooks.onListen = [];
    hooks.preClose = [];
    return hooks;
  }
  function hookRunnerApplication(hookName, boot, server, cb) {
    const hooks = server[kHooks][hookName];
    let i = 0;
    let c2 = 0;
    next();
    function exit(err) {
      const hookFnName = hooks[i - 1]?.name;
      const hookFnFragment = hookFnName ? ` "${hookFnName}"` : "";
      if (err) {
        if (err.code === "AVV_ERR_READY_TIMEOUT") {
          err = appendStackTrace(err, new FST_ERR_HOOK_TIMEOUT(hookName, hookFnFragment));
        } else {
          err = AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
        }
        cb(err);
        return;
      }
      cb();
    }
    function next(err) {
      if (err) {
        exit(err);
        return;
      }
      if (i === hooks.length && c2 === server[kChildren].length) {
        if (i === 0 && c2 === 0) {
          exit();
        } else {
          boot(function manageTimeout(err2, done) {
            exit(err2);
            done(err2);
          });
        }
        return;
      }
      if (i === hooks.length && c2 < server[kChildren].length) {
        const child = server[kChildren][c2++];
        hookRunnerApplication(hookName, boot, child, next);
        return;
      }
      boot(wrap(hooks[i++], server));
      next();
    }
    function wrap(fn, server2) {
      return function(err, done) {
        if (err) {
          done(err);
          return;
        }
        if (fn.length === 1) {
          try {
            fn.call(server2, done);
          } catch (error) {
            done(error);
          }
          return;
        }
        try {
          const ret = fn.call(server2);
          if (ret && typeof ret.then === "function") {
            ret.then(done, done);
            return;
          }
        } catch (error) {
          err = error;
        }
        done(err);
      };
    }
  }
  function onListenHookRunner(server) {
    const hooks = server[kHooks].onListen;
    const hooksLen = hooks.length;
    let i = 0;
    let c2 = 0;
    next();
    function next(err) {
      err && server.log.error(err);
      if (i === hooksLen) {
        while (c2 < server[kChildren].length) {
          const child = server[kChildren][c2++];
          onListenHookRunner(child);
        }
        return;
      }
      wrap(hooks[i++], server, next);
    }
    async function wrap(fn, server2, done) {
      if (fn.length === 1) {
        try {
          fn.call(server2, done);
        } catch (e) {
          done(e);
        }
        return;
      }
      try {
        const ret = fn.call(server2);
        if (ret && typeof ret.then === "function") {
          ret.then(done, done);
          return;
        }
        done();
      } catch (error) {
        done(error);
      }
    }
  }
  function hookRunnerGenerator(iterator) {
    return function hookRunner(functions, request, reply, cb) {
      let i = 0;
      function next(err) {
        if (err || i === functions.length) {
          cb(err, request, reply);
          return;
        }
        let result;
        try {
          result = iterator(functions[i++], request, reply, next);
        } catch (error) {
          cb(error, request, reply);
          return;
        }
        if (result && typeof result.then === "function") {
          result.then(handleResolve, handleReject);
        }
      }
      function handleResolve() {
        next();
      }
      function handleReject(err) {
        if (!err) {
          err = new FST_ERR_SEND_UNDEFINED_ERR;
        }
        cb(err, request, reply);
      }
      next();
    };
  }
  function onResponseHookIterator(fn, request, reply, next) {
    return fn(request, reply, next);
  }
  var onResponseHookRunner = hookRunnerGenerator(onResponseHookIterator);
  var preValidationHookRunner = hookRunnerGenerator(hookIterator);
  var preHandlerHookRunner = hookRunnerGenerator(hookIterator);
  var onTimeoutHookRunner = hookRunnerGenerator(hookIterator);
  var onRequestHookRunner = hookRunnerGenerator(hookIterator);
  function onSendHookRunner(functions, request, reply, payload, cb) {
    let i = 0;
    function next(err, newPayload) {
      if (err) {
        cb(err, request, reply, payload);
        return;
      }
      if (newPayload !== undefined) {
        payload = newPayload;
      }
      if (i === functions.length) {
        cb(null, request, reply, payload);
        return;
      }
      let result;
      try {
        result = functions[i++](request, reply, payload, next);
      } catch (error) {
        cb(error, request, reply);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve(newPayload) {
      next(null, newPayload);
    }
    function handleReject(err) {
      if (!err) {
        err = new FST_ERR_SEND_UNDEFINED_ERR;
      }
      cb(err, request, reply, payload);
    }
    next();
  }
  var preSerializationHookRunner = onSendHookRunner;
  function preParsingHookRunner(functions, request, reply, cb) {
    let i = 0;
    function next(err, newPayload) {
      if (reply.sent) {
        return;
      }
      if (newPayload !== undefined) {
        request[kRequestPayloadStream] = newPayload;
      }
      if (err || i === functions.length) {
        cb(err, request, reply);
        return;
      }
      let result;
      try {
        result = functions[i++](request, reply, request[kRequestPayloadStream], next);
      } catch (error) {
        cb(error, request, reply);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve(newPayload) {
      next(null, newPayload);
    }
    function handleReject(err) {
      if (!err) {
        err = new FST_ERR_SEND_UNDEFINED_ERR;
      }
      cb(err, request, reply);
    }
    next();
  }
  function onRequestAbortHookRunner(functions, request, cb) {
    let i = 0;
    function next(err) {
      if (err || i === functions.length) {
        cb(err, request);
        return;
      }
      let result;
      try {
        result = functions[i++](request, next);
      } catch (error) {
        cb(error, request);
        return;
      }
      if (result && typeof result.then === "function") {
        result.then(handleResolve, handleReject);
      }
    }
    function handleResolve() {
      next();
    }
    function handleReject(err) {
      if (!err) {
        err = new FST_ERR_SEND_UNDEFINED_ERR;
      }
      cb(err, request);
    }
    next();
  }
  function hookIterator(fn, request, reply, next) {
    if (reply.sent === true)
      return;
    return fn(request, reply, next);
  }
  module.exports = {
    Hooks,
    buildHooks,
    hookRunnerGenerator,
    preParsingHookRunner,
    onResponseHookRunner,
    onSendHookRunner,
    preSerializationHookRunner,
    onRequestAbortHookRunner,
    hookIterator,
    hookRunnerApplication,
    onListenHookRunner,
    preHandlerHookRunner,
    preValidationHookRunner,
    onRequestHookRunner,
    onTimeoutHookRunner,
    lifecycleHooks,
    supportedHooks
  };
});

// node_modules/fastify/lib/promise.js
var require_promise = __commonJS((exports, module) => {
  var { kTestInternals } = require_symbols2();
  function withResolvers() {
    let res, rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  }
  module.exports = {
    withResolvers: typeof Promise.withResolvers === "function" ? Promise.withResolvers.bind(Promise) : withResolvers,
    [kTestInternals]: {
      withResolvers
    }
  };
});

// node_modules/fastify/lib/server.js
var require_server = __commonJS((exports, module) => {
  var http = (init_http(), __toCommonJS(exports_http));
  var https = (init_https(), __toCommonJS(exports_https));
  var http2 = (() => ({}));
  var dns = (() => ({}));
  var os = (init_os(), __toCommonJS(exports_os));
  var { kState, kOptions, kServerBindings, kHttp2ServerSessions } = require_symbols2();
  var { FSTWRN003 } = require_warnings();
  var { onListenHookRunner } = require_hooks();
  var {
    FST_ERR_REOPENED_CLOSE_SERVER,
    FST_ERR_REOPENED_SERVER,
    FST_ERR_LISTEN_OPTIONS_INVALID
  } = require_errors2();
  var PonyPromise = require_promise();
  exports.createServer = createServer;
  function defaultResolveServerListeningText(address) {
    return `Server listening at ${address}`;
  }
  function createServer(options, httpHandler) {
    const server = getServerInstance(options, httpHandler);
    function listen(listenOptions = { port: 0, host: "localhost" }, cb = undefined) {
      if (typeof cb === "function") {
        if (cb.constructor.name === "AsyncFunction") {
          FSTWRN003("listen method");
        }
        listenOptions.cb = cb;
      }
      if (listenOptions.signal) {
        if (typeof listenOptions.signal.on !== "function" && typeof listenOptions.signal.addEventListener !== "function") {
          throw new FST_ERR_LISTEN_OPTIONS_INVALID("Invalid options.signal");
        }
        this[kState].aborted = listenOptions.signal.aborted;
        if (this[kState].aborted) {
          return this.close();
        } else {
          const onAborted = () => {
            this[kState].aborted = true;
            this.close();
          };
          listenOptions.signal.addEventListener("abort", onAborted, { once: true });
        }
      }
      let host;
      if (listenOptions.path == null) {
        host = listenOptions.host ?? "localhost";
      } else {
        host = listenOptions.host;
      }
      if (!Object.hasOwn(listenOptions, "host") || listenOptions.host == null) {
        listenOptions.host = host;
      }
      if (host === "localhost") {
        listenOptions.cb = (err, address) => {
          if (err) {
            cb(err, address);
            return;
          }
          multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
            this[kState].listening = true;
            cb(null, address);
            onListenHookRunner(this);
          });
        };
      } else {
        listenOptions.cb = (err, address) => {
          if (err) {
            cb(err, address);
            return;
          }
          this[kState].listening = true;
          cb(null, address);
          onListenHookRunner(this);
        };
      }
      if (cb === undefined) {
        const listening = listenPromise.call(this, server, listenOptions);
        return listening.then((address) => {
          const { promise, resolve } = PonyPromise.withResolvers();
          if (host === "localhost") {
            multipleBindings.call(this, server, httpHandler, options, listenOptions, () => {
              this[kState].listening = true;
              resolve(address);
              onListenHookRunner(this);
            });
          } else {
            resolve(address);
            onListenHookRunner(this);
          }
          return promise;
        });
      }
      this.ready(listenCallback.call(this, server, listenOptions));
    }
    return { server, listen };
  }
  function multipleBindings(mainServer, httpHandler, serverOpts, listenOptions, onListen) {
    this[kState].listening = false;
    dns.lookup(listenOptions.host, { all: true }, (dnsErr, addresses) => {
      if (dnsErr || this[kState].aborted) {
        onListen();
        return;
      }
      const isMainServerListening = mainServer.listening && serverOpts.serverFactory;
      let binding = 0;
      let bound = 0;
      if (!isMainServerListening) {
        const primaryAddress = mainServer.address();
        for (const adr of addresses) {
          if (adr.address !== primaryAddress.address) {
            binding++;
            const secondaryOpts = Object.assign({}, listenOptions, {
              host: adr.address,
              port: primaryAddress.port,
              cb: (_ignoreErr) => {
                bound++;
                if (!_ignoreErr) {
                  this[kServerBindings].push(secondaryServer);
                }
                if (bound === binding) {
                  onListen();
                }
              }
            });
            const secondaryServer = getServerInstance(serverOpts, httpHandler);
            const closeSecondary = () => {
              secondaryServer.close(() => {});
              if (typeof secondaryServer.closeAllConnections === "function" && serverOpts.forceCloseConnections === true) {
                secondaryServer.closeAllConnections();
              }
              if (typeof secondaryServer.closeHttp2Sessions === "function") {
                secondaryServer.closeHttp2Sessions();
              }
            };
            secondaryServer.on("upgrade", mainServer.emit.bind(mainServer, "upgrade"));
            mainServer.on("unref", closeSecondary);
            mainServer.on("close", closeSecondary);
            mainServer.on("error", closeSecondary);
            this[kState].listening = false;
            listenCallback.call(this, secondaryServer, secondaryOpts)();
          }
        }
      }
      if (binding === 0) {
        onListen();
        return;
      }
      const originUnref = mainServer.unref;
      mainServer.unref = function() {
        originUnref.call(mainServer);
        mainServer.emit("unref");
      };
    });
  }
  function listenCallback(server, listenOptions) {
    const wrap = (err) => {
      server.removeListener("error", wrap);
      server.removeListener("listening", wrap);
      if (!err) {
        const address = logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText);
        listenOptions.cb(null, address);
      } else {
        this[kState].listening = false;
        listenOptions.cb(err, null);
      }
    };
    return (err) => {
      if (err != null)
        return listenOptions.cb(err);
      if (this[kState].listening && this[kState].closing) {
        return listenOptions.cb(new FST_ERR_REOPENED_CLOSE_SERVER, null);
      }
      if (this[kState].listening) {
        return listenOptions.cb(new FST_ERR_REOPENED_SERVER, null);
      }
      server.once("error", wrap);
      if (!this[kState].closing) {
        server.once("listening", wrap);
        server.listen(listenOptions);
        this[kState].listening = true;
      }
    };
  }
  function listenPromise(server, listenOptions) {
    if (this[kState].listening && this[kState].closing) {
      return Promise.reject(new FST_ERR_REOPENED_CLOSE_SERVER);
    }
    if (this[kState].listening) {
      return Promise.reject(new FST_ERR_REOPENED_SERVER);
    }
    return this.ready().then(() => {
      if (this[kState].aborted)
        return;
      const { promise, resolve, reject } = PonyPromise.withResolvers();
      const errEventHandler = (err) => {
        cleanup();
        this[kState].listening = false;
        reject(err);
      };
      const listeningEventHandler = () => {
        cleanup();
        this[kState].listening = true;
        resolve(logServerAddress.call(this, server, listenOptions.listenTextResolver || defaultResolveServerListeningText));
      };
      function cleanup() {
        server.removeListener("error", errEventHandler);
        server.removeListener("listening", listeningEventHandler);
      }
      server.once("error", errEventHandler);
      server.once("listening", listeningEventHandler);
      server.listen(listenOptions);
      return promise;
    });
  }
  function getServerInstance(options, httpHandler) {
    if (options.serverFactory) {
      return options.serverFactory(httpHandler, options);
    }
    const httpsOptions = options.https === true ? {} : options.https;
    if (options.http2) {
      const server2 = typeof httpsOptions === "object" ? http2.createSecureServer(httpsOptions, httpHandler) : http2.createServer(options.http, httpHandler);
      server2.on("session", (session) => session.setTimeout(options.http2SessionTimeout, () => {
        session.close();
      }));
      if (options.forceCloseConnections === true) {
        server2.closeHttp2Sessions = createCloseHttp2SessionsByHttp2Server(server2);
      }
      server2.setTimeout(options.connectionTimeout);
      return server2;
    }
    const server = httpsOptions ? https.createServer(httpsOptions, httpHandler) : http.createServer(options.http, httpHandler);
    server.keepAliveTimeout = options.keepAliveTimeout;
    server.requestTimeout = options.requestTimeout;
    server.setTimeout(options.connectionTimeout);
    if (options.maxRequestsPerSocket > 0) {
      server.maxRequestsPerSocket = options.maxRequestsPerSocket;
    }
    return server;
  }
  function getAddresses(address) {
    if (address.address === "0.0.0.0") {
      return Object.values(os.networkInterfaces()).flatMap((iface) => {
        return iface.filter((iface2) => iface2.family === "IPv4");
      }).sort((iface) => {
        return iface.internal ? -1 : 1;
      }).map((iface) => {
        return iface.address;
      });
    }
    return [address.address];
  }
  function logServerAddress(server, listenTextResolver) {
    let addresses;
    const isUnixSocket = typeof server.address() === "string";
    if (!isUnixSocket) {
      if (server.address().address.indexOf(":") === -1) {
        addresses = getAddresses(server.address()).map((address) => address + ":" + server.address().port);
      } else {
        addresses = ["[" + server.address().address + "]:" + server.address().port];
      }
      addresses = addresses.map((address) => "http" + (this[kOptions].https ? "s" : "") + "://" + address);
    } else {
      addresses = [server.address()];
    }
    for (const address of addresses) {
      this.log.info(listenTextResolver(address));
    }
    return addresses[0];
  }
  function createCloseHttp2SessionsByHttp2Server(http2Server) {
    http2Server[kHttp2ServerSessions] = new Set;
    http2Server.on("session", function(session) {
      session.once("connect", function() {
        http2Server[kHttp2ServerSessions].add(session);
      });
      session.once("close", function() {
        http2Server[kHttp2ServerSessions].delete(session);
      });
      session.once("frameError", function(type, code, streamId) {
        if (streamId === 0) {
          http2Server[kHttp2ServerSessions].delete(session);
        }
      });
      session.once("goaway", function() {
        http2Server[kHttp2ServerSessions].delete(session);
      });
    });
    return function closeHttp2Sessions() {
      if (http2Server[kHttp2ServerSessions].size === 0) {
        return;
      }
      for (const session of http2Server[kHttp2ServerSessions]) {
        session.close();
      }
    };
  }
});

// node:stream
var exports_stream = {};
__export(exports_stream, {
  default: () => Uc
});
var al, tt2, cl, dl, hl, pl, yl = (e, t) => () => (e && (t = e(e = 0)), t), E4 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Qr = (e, t) => {
  for (var r in t)
    tt2(e, r, { get: t[r], enumerable: true });
}, et2 = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of dl(t))
      !pl.call(e, i) && i !== r && tt2(e, i, { get: () => t[i], enumerable: !(n = cl(t, i)) || n.enumerable });
  return e;
}, ue3 = (e, t, r) => (et2(e, t, "default"), r && et2(r, t, "default")), rt2 = (e, t, r) => (r = e != null ? al(hl(e)) : {}, et2(t || !e || !e.__esModule ? tt2(r, "default", { value: e, enumerable: true }) : r, e)), pe = (e) => et2(tt2({}, "__esModule", { value: true }), e), tn, rn, te, I2, V3, ut, C2, He2, ir2, k2, Gu, se, ae, ce2, di2, Se2, Et, xt2, At3, Pi, Tt2, Wi, Gi2, Er3, Ke, Cr2, Mo, J, qr2, $r2, Ut, Jo, Kr2, fl, Jr, Ze, Uc;
var init_stream = __esm(() => {
  al = Object.create;
  tt2 = Object.defineProperty;
  cl = Object.getOwnPropertyDescriptor;
  dl = Object.getOwnPropertyNames;
  hl = Object.getPrototypeOf;
  pl = Object.prototype.hasOwnProperty;
  tn = E4((nt3) => {
    nt3.byteLength = bl;
    nt3.toByteArray = _l;
    nt3.fromByteArray = ml;
    var G = [], P2 = [], wl = typeof Uint8Array < "u" ? Uint8Array : Array, Wt2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (ye = 0, Zr2 = Wt2.length;ye < Zr2; ++ye)
      G[ye] = Wt2[ye], P2[Wt2.charCodeAt(ye)] = ye;
    var ye, Zr2;
    P2[45] = 62;
    P2[95] = 63;
    function en(e) {
      var t = e.length;
      if (t % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = e.indexOf("=");
      r === -1 && (r = t);
      var n = r === t ? 0 : 4 - r % 4;
      return [r, n];
    }
    function bl(e) {
      var t = en(e), r = t[0], n = t[1];
      return (r + n) * 3 / 4 - n;
    }
    function gl(e, t, r) {
      return (t + r) * 3 / 4 - r;
    }
    function _l(e) {
      var t, r = en(e), n = r[0], i = r[1], o2 = new wl(gl(e, n, i)), l3 = 0, u2 = i > 0 ? n - 4 : n, f2;
      for (f2 = 0;f2 < u2; f2 += 4)
        t = P2[e.charCodeAt(f2)] << 18 | P2[e.charCodeAt(f2 + 1)] << 12 | P2[e.charCodeAt(f2 + 2)] << 6 | P2[e.charCodeAt(f2 + 3)], o2[l3++] = t >> 16 & 255, o2[l3++] = t >> 8 & 255, o2[l3++] = t & 255;
      return i === 2 && (t = P2[e.charCodeAt(f2)] << 2 | P2[e.charCodeAt(f2 + 1)] >> 4, o2[l3++] = t & 255), i === 1 && (t = P2[e.charCodeAt(f2)] << 10 | P2[e.charCodeAt(f2 + 1)] << 4 | P2[e.charCodeAt(f2 + 2)] >> 2, o2[l3++] = t >> 8 & 255, o2[l3++] = t & 255), o2;
    }
    function El(e) {
      return G[e >> 18 & 63] + G[e >> 12 & 63] + G[e >> 6 & 63] + G[e & 63];
    }
    function Sl(e, t, r) {
      for (var n, i = [], o2 = t;o2 < r; o2 += 3)
        n = (e[o2] << 16 & 16711680) + (e[o2 + 1] << 8 & 65280) + (e[o2 + 2] & 255), i.push(El(n));
      return i.join("");
    }
    function ml(e) {
      for (var t, r = e.length, n = r % 3, i = [], o2 = 16383, l3 = 0, u2 = r - n;l3 < u2; l3 += o2)
        i.push(Sl(e, l3, l3 + o2 > u2 ? u2 : l3 + o2));
      return n === 1 ? (t = e[r - 1], i.push(G[t >> 2] + G[t << 4 & 63] + "==")) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(G[t >> 10] + G[t >> 4 & 63] + G[t << 2 & 63] + "=")), i.join("");
    }
  });
  rn = E4(($t) => {
    $t.read = function(e, t, r, n, i) {
      var o2, l3, u2 = i * 8 - n - 1, f2 = (1 << u2) - 1, s2 = f2 >> 1, d3 = -7, c2 = r ? i - 1 : 0, y3 = r ? -1 : 1, h3 = e[t + c2];
      for (c2 += y3, o2 = h3 & (1 << -d3) - 1, h3 >>= -d3, d3 += u2;d3 > 0; o2 = o2 * 256 + e[t + c2], c2 += y3, d3 -= 8)
        ;
      for (l3 = o2 & (1 << -d3) - 1, o2 >>= -d3, d3 += n;d3 > 0; l3 = l3 * 256 + e[t + c2], c2 += y3, d3 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - s2;
      else {
        if (o2 === f2)
          return l3 ? NaN : (h3 ? -1 : 1) * (1 / 0);
        l3 = l3 + Math.pow(2, n), o2 = o2 - s2;
      }
      return (h3 ? -1 : 1) * l3 * Math.pow(2, o2 - n);
    };
    $t.write = function(e, t, r, n, i, o2) {
      var l3, u2, f2, s2 = o2 * 8 - i - 1, d3 = (1 << s2) - 1, c2 = d3 >> 1, y3 = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h3 = n ? 0 : o2 - 1, p3 = n ? 1 : -1, B2 = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
      for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u2 = isNaN(t) ? 1 : 0, l3 = d3) : (l3 = Math.floor(Math.log(t) / Math.LN2), t * (f2 = Math.pow(2, -l3)) < 1 && (l3--, f2 *= 2), l3 + c2 >= 1 ? t += y3 / f2 : t += y3 * Math.pow(2, 1 - c2), t * f2 >= 2 && (l3++, f2 /= 2), l3 + c2 >= d3 ? (u2 = 0, l3 = d3) : l3 + c2 >= 1 ? (u2 = (t * f2 - 1) * Math.pow(2, i), l3 = l3 + c2) : (u2 = t * Math.pow(2, c2 - 1) * Math.pow(2, i), l3 = 0));i >= 8; e[r + h3] = u2 & 255, h3 += p3, u2 /= 256, i -= 8)
        ;
      for (l3 = l3 << i | u2, s2 += i;s2 > 0; e[r + h3] = l3 & 255, h3 += p3, l3 /= 256, s2 -= 8)
        ;
      e[r + h3 - p3] |= B2 * 128;
    };
  });
  te = E4((Fe) => {
    var jt2 = tn(), Le = rn(), nn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Fe.Buffer = a3;
    Fe.SlowBuffer = Bl;
    Fe.INSPECT_MAX_BYTES = 50;
    var it2 = 2147483647;
    Fe.kMaxLength = it2;
    a3.TYPED_ARRAY_SUPPORT = xl();
    !a3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function xl() {
      try {
        let e = new Uint8Array(1), t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t, Uint8Array.prototype), Object.setPrototypeOf(e, t), e.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(a3.prototype, "parent", { enumerable: true, get: function() {
      if (!!a3.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(a3.prototype, "offset", { enumerable: true, get: function() {
      if (!!a3.isBuffer(this))
        return this.byteOffset;
    } });
    function ee(e) {
      if (e > it2)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
      let t = new Uint8Array(e);
      return Object.setPrototypeOf(t, a3.prototype), t;
    }
    function a3(e, t, r) {
      if (typeof e == "number") {
        if (typeof t == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return Yt(e);
      }
      return fn(e, t, r);
    }
    a3.poolSize = 8192;
    function fn(e, t, r) {
      if (typeof e == "string")
        return Al(e, t);
      if (ArrayBuffer.isView(e))
        return Il(e);
      if (e == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
      if (H2(e, ArrayBuffer) || e && H2(e.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (H2(e, SharedArrayBuffer) || e && H2(e.buffer, SharedArrayBuffer)))
        return Ht2(e, t, r);
      if (typeof e == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let n = e.valueOf && e.valueOf();
      if (n != null && n !== e)
        return a3.from(n, t, r);
      let i = Tl(e);
      if (i)
        return i;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] == "function")
        return a3.from(e[Symbol.toPrimitive]("string"), t, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
    }
    a3.from = function(e, t, r) {
      return fn(e, t, r);
    };
    Object.setPrototypeOf(a3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(a3, Uint8Array);
    function sn(e) {
      if (typeof e != "number")
        throw new TypeError('"size" argument must be of type number');
      if (e < 0)
        throw new RangeError('The value "' + e + '" is invalid for option "size"');
    }
    function Rl(e, t, r) {
      return sn(e), e <= 0 ? ee(e) : t !== undefined ? typeof r == "string" ? ee(e).fill(t, r) : ee(e).fill(t) : ee(e);
    }
    a3.alloc = function(e, t, r) {
      return Rl(e, t, r);
    };
    function Yt(e) {
      return sn(e), ee(e < 0 ? 0 : Kt3(e) | 0);
    }
    a3.allocUnsafe = function(e) {
      return Yt(e);
    };
    a3.allocUnsafeSlow = function(e) {
      return Yt(e);
    };
    function Al(e, t) {
      if ((typeof t != "string" || t === "") && (t = "utf8"), !a3.isEncoding(t))
        throw new TypeError("Unknown encoding: " + t);
      let r = an2(e, t) | 0, n = ee(r), i = n.write(e, t);
      return i !== r && (n = n.slice(0, i)), n;
    }
    function Gt(e) {
      let t = e.length < 0 ? 0 : Kt3(e.length) | 0, r = ee(t);
      for (let n = 0;n < t; n += 1)
        r[n] = e[n] & 255;
      return r;
    }
    function Il(e) {
      if (H2(e, Uint8Array)) {
        let t = new Uint8Array(e);
        return Ht2(t.buffer, t.byteOffset, t.byteLength);
      }
      return Gt(e);
    }
    function Ht2(e, t, r) {
      if (t < 0 || e.byteLength < t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (e.byteLength < t + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let n;
      return t === undefined && r === undefined ? n = new Uint8Array(e) : r === undefined ? n = new Uint8Array(e, t) : n = new Uint8Array(e, t, r), Object.setPrototypeOf(n, a3.prototype), n;
    }
    function Tl(e) {
      if (a3.isBuffer(e)) {
        let t = Kt3(e.length) | 0, r = ee(t);
        return r.length === 0 || e.copy(r, 0, 0, t), r;
      }
      if (e.length !== undefined)
        return typeof e.length != "number" || Xt2(e.length) ? ee(0) : Gt(e);
      if (e.type === "Buffer" && Array.isArray(e.data))
        return Gt(e.data);
    }
    function Kt3(e) {
      if (e >= it2)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + it2.toString(16) + " bytes");
      return e | 0;
    }
    function Bl(e) {
      return +e != e && (e = 0), a3.alloc(+e);
    }
    a3.isBuffer = function(t) {
      return t != null && t._isBuffer === true && t !== a3.prototype;
    };
    a3.compare = function(t, r) {
      if (H2(t, Uint8Array) && (t = a3.from(t, t.offset, t.byteLength)), H2(r, Uint8Array) && (r = a3.from(r, r.offset, r.byteLength)), !a3.isBuffer(t) || !a3.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (t === r)
        return 0;
      let n = t.length, i = r.length;
      for (let o2 = 0, l3 = Math.min(n, i);o2 < l3; ++o2)
        if (t[o2] !== r[o2]) {
          n = t[o2], i = r[o2];
          break;
        }
      return n < i ? -1 : i < n ? 1 : 0;
    };
    a3.isEncoding = function(t) {
      switch (String(t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    a3.concat = function(t, r) {
      if (!Array.isArray(t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (t.length === 0)
        return a3.alloc(0);
      let n;
      if (r === undefined)
        for (r = 0, n = 0;n < t.length; ++n)
          r += t[n].length;
      let i = a3.allocUnsafe(r), o2 = 0;
      for (n = 0;n < t.length; ++n) {
        let l3 = t[n];
        if (H2(l3, Uint8Array))
          o2 + l3.length > i.length ? (a3.isBuffer(l3) || (l3 = a3.from(l3)), l3.copy(i, o2)) : Uint8Array.prototype.set.call(i, l3, o2);
        else if (a3.isBuffer(l3))
          l3.copy(i, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += l3.length;
      }
      return i;
    };
    function an2(e, t) {
      if (a3.isBuffer(e))
        return e.length;
      if (ArrayBuffer.isView(e) || H2(e, ArrayBuffer))
        return e.byteLength;
      if (typeof e != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e);
      let r = e.length, n = arguments.length > 2 && arguments[2] === true;
      if (!n && r === 0)
        return 0;
      let i = false;
      for (;; )
        switch (t) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return Vt2(e).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return _n2(e).length;
          default:
            if (i)
              return n ? -1 : Vt2(e).length;
            t = ("" + t).toLowerCase(), i = true;
        }
    }
    a3.byteLength = an2;
    function Ll(e, t, r) {
      let n = false;
      if ((t === undefined || t < 0) && (t = 0), t > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, t >>>= 0, r <= t))
        return "";
      for (e || (e = "utf8");; )
        switch (e) {
          case "hex":
            return vl(this, t, r);
          case "utf8":
          case "utf-8":
            return dn(this, t, r);
          case "ascii":
            return kl(this, t, r);
          case "latin1":
          case "binary":
            return Ul(this, t, r);
          case "base64":
            return Dl(this, t, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ql(this, t, r);
          default:
            if (n)
              throw new TypeError("Unknown encoding: " + e);
            e = (e + "").toLowerCase(), n = true;
        }
    }
    a3.prototype._isBuffer = true;
    function we(e, t, r) {
      let n = e[t];
      e[t] = e[r], e[r] = n;
    }
    a3.prototype.swap16 = function() {
      let t = this.length;
      if (t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < t; r += 2)
        we(this, r, r + 1);
      return this;
    };
    a3.prototype.swap32 = function() {
      let t = this.length;
      if (t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < t; r += 4)
        we(this, r, r + 3), we(this, r + 1, r + 2);
      return this;
    };
    a3.prototype.swap64 = function() {
      let t = this.length;
      if (t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < t; r += 8)
        we(this, r, r + 7), we(this, r + 1, r + 6), we(this, r + 2, r + 5), we(this, r + 3, r + 4);
      return this;
    };
    a3.prototype.toString = function() {
      let t = this.length;
      return t === 0 ? "" : arguments.length === 0 ? dn(this, 0, t) : Ll.apply(this, arguments);
    };
    a3.prototype.toLocaleString = a3.prototype.toString;
    a3.prototype.equals = function(t) {
      if (!a3.isBuffer(t))
        throw new TypeError("Argument must be a Buffer");
      return this === t ? true : a3.compare(this, t) === 0;
    };
    a3.prototype.inspect = function() {
      let t = "", r = Fe.INSPECT_MAX_BYTES;
      return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">";
    };
    nn && (a3.prototype[nn] = a3.prototype.inspect);
    a3.prototype.compare = function(t, r, n, i, o2) {
      if (H2(t, Uint8Array) && (t = a3.from(t, t.offset, t.byteLength)), !a3.isBuffer(t))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
      if (r === undefined && (r = 0), n === undefined && (n = t ? t.length : 0), i === undefined && (i = 0), o2 === undefined && (o2 = this.length), r < 0 || n > t.length || i < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (i >= o2 && r >= n)
        return 0;
      if (i >= o2)
        return -1;
      if (r >= n)
        return 1;
      if (r >>>= 0, n >>>= 0, i >>>= 0, o2 >>>= 0, this === t)
        return 0;
      let l3 = o2 - i, u2 = n - r, f2 = Math.min(l3, u2), s2 = this.slice(i, o2), d3 = t.slice(r, n);
      for (let c2 = 0;c2 < f2; ++c2)
        if (s2[c2] !== d3[c2]) {
          l3 = s2[c2], u2 = d3[c2];
          break;
        }
      return l3 < u2 ? -1 : u2 < l3 ? 1 : 0;
    };
    function cn2(e, t, r, n, i) {
      if (e.length === 0)
        return -1;
      if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, Xt2(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i)
          return -1;
        r = e.length - 1;
      } else if (r < 0)
        if (i)
          r = 0;
        else
          return -1;
      if (typeof t == "string" && (t = a3.from(t, n)), a3.isBuffer(t))
        return t.length === 0 ? -1 : on(e, t, r, n, i);
      if (typeof t == "number")
        return t = t & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : on(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer");
    }
    function on(e, t, r, n, i) {
      let o2 = 1, l3 = e.length, u2 = t.length;
      if (n !== undefined && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
        if (e.length < 2 || t.length < 2)
          return -1;
        o2 = 2, l3 /= 2, u2 /= 2, r /= 2;
      }
      function f2(d3, c2) {
        return o2 === 1 ? d3[c2] : d3.readUInt16BE(c2 * o2);
      }
      let s2;
      if (i) {
        let d3 = -1;
        for (s2 = r;s2 < l3; s2++)
          if (f2(e, s2) === f2(t, d3 === -1 ? 0 : s2 - d3)) {
            if (d3 === -1 && (d3 = s2), s2 - d3 + 1 === u2)
              return d3 * o2;
          } else
            d3 !== -1 && (s2 -= s2 - d3), d3 = -1;
      } else
        for (r + u2 > l3 && (r = l3 - u2), s2 = r;s2 >= 0; s2--) {
          let d3 = true;
          for (let c2 = 0;c2 < u2; c2++)
            if (f2(e, s2 + c2) !== f2(t, c2)) {
              d3 = false;
              break;
            }
          if (d3)
            return s2;
        }
      return -1;
    }
    a3.prototype.includes = function(t, r, n) {
      return this.indexOf(t, r, n) !== -1;
    };
    a3.prototype.indexOf = function(t, r, n) {
      return cn2(this, t, r, n, true);
    };
    a3.prototype.lastIndexOf = function(t, r, n) {
      return cn2(this, t, r, n, false);
    };
    function Nl(e, t, r, n) {
      r = Number(r) || 0;
      let i = e.length - r;
      n ? (n = Number(n), n > i && (n = i)) : n = i;
      let o2 = t.length;
      n > o2 / 2 && (n = o2 / 2);
      let l3;
      for (l3 = 0;l3 < n; ++l3) {
        let u2 = parseInt(t.substr(l3 * 2, 2), 16);
        if (Xt2(u2))
          return l3;
        e[r + l3] = u2;
      }
      return l3;
    }
    function Fl(e, t, r, n) {
      return ot(Vt2(t, e.length - r), e, r, n);
    }
    function Ml(e, t, r, n) {
      return ot(Gl(t), e, r, n);
    }
    function Cl(e, t, r, n) {
      return ot(_n2(t), e, r, n);
    }
    function Ol(e, t, r, n) {
      return ot(Hl(t, e.length - r), e, r, n);
    }
    a3.prototype.write = function(t, r, n, i) {
      if (r === undefined)
        i = "utf8", n = this.length, r = 0;
      else if (n === undefined && typeof r == "string")
        i = r, n = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(n) ? (n = n >>> 0, i === undefined && (i = "utf8")) : (i = n, n = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - r;
      if ((n === undefined || n > o2) && (n = o2), t.length > 0 && (n < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      i || (i = "utf8");
      let l3 = false;
      for (;; )
        switch (i) {
          case "hex":
            return Nl(this, t, r, n);
          case "utf8":
          case "utf-8":
            return Fl(this, t, r, n);
          case "ascii":
          case "latin1":
          case "binary":
            return Ml(this, t, r, n);
          case "base64":
            return Cl(this, t, r, n);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ol(this, t, r, n);
          default:
            if (l3)
              throw new TypeError("Unknown encoding: " + i);
            i = ("" + i).toLowerCase(), l3 = true;
        }
    };
    a3.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Dl(e, t, r) {
      return t === 0 && r === e.length ? jt2.fromByteArray(e) : jt2.fromByteArray(e.slice(t, r));
    }
    function dn(e, t, r) {
      r = Math.min(e.length, r);
      let n = [], i = t;
      for (;i < r; ) {
        let o2 = e[i], l3 = null, u2 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (i + u2 <= r) {
          let f2, s2, d3, c2;
          switch (u2) {
            case 1:
              o2 < 128 && (l3 = o2);
              break;
            case 2:
              f2 = e[i + 1], (f2 & 192) === 128 && (c2 = (o2 & 31) << 6 | f2 & 63, c2 > 127 && (l3 = c2));
              break;
            case 3:
              f2 = e[i + 1], s2 = e[i + 2], (f2 & 192) === 128 && (s2 & 192) === 128 && (c2 = (o2 & 15) << 12 | (f2 & 63) << 6 | s2 & 63, c2 > 2047 && (c2 < 55296 || c2 > 57343) && (l3 = c2));
              break;
            case 4:
              f2 = e[i + 1], s2 = e[i + 2], d3 = e[i + 3], (f2 & 192) === 128 && (s2 & 192) === 128 && (d3 & 192) === 128 && (c2 = (o2 & 15) << 18 | (f2 & 63) << 12 | (s2 & 63) << 6 | d3 & 63, c2 > 65535 && c2 < 1114112 && (l3 = c2));
          }
        }
        l3 === null ? (l3 = 65533, u2 = 1) : l3 > 65535 && (l3 -= 65536, n.push(l3 >>> 10 & 1023 | 55296), l3 = 56320 | l3 & 1023), n.push(l3), i += u2;
      }
      return Pl(n);
    }
    var ln = 4096;
    function Pl(e) {
      let t = e.length;
      if (t <= ln)
        return String.fromCharCode.apply(String, e);
      let r = "", n = 0;
      for (;n < t; )
        r += String.fromCharCode.apply(String, e.slice(n, n += ln));
      return r;
    }
    function kl(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i] & 127);
      return n;
    }
    function Ul(e, t, r) {
      let n = "";
      r = Math.min(e.length, r);
      for (let i = t;i < r; ++i)
        n += String.fromCharCode(e[i]);
      return n;
    }
    function vl(e, t, r) {
      let n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      let i = "";
      for (let o2 = t;o2 < r; ++o2)
        i += Vl[e[o2]];
      return i;
    }
    function ql(e, t, r) {
      let n = e.slice(t, r), i = "";
      for (let o2 = 0;o2 < n.length - 1; o2 += 2)
        i += String.fromCharCode(n[o2] + n[o2 + 1] * 256);
      return i;
    }
    a3.prototype.slice = function(t, r) {
      let n = this.length;
      t = ~~t, r = r === undefined ? n : ~~r, t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < t && (r = t);
      let i = this.subarray(t, r);
      return Object.setPrototypeOf(i, a3.prototype), i;
    };
    function F2(e, t, r) {
      if (e % 1 !== 0 || e < 0)
        throw new RangeError("offset is not uint");
      if (e + t > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    a3.prototype.readUintLE = a3.prototype.readUIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = this[t], o2 = 1, l3 = 0;
      for (;++l3 < r && (o2 *= 256); )
        i += this[t + l3] * o2;
      return i;
    };
    a3.prototype.readUintBE = a3.prototype.readUIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = this[t + --r], o2 = 1;
      for (;r > 0 && (o2 *= 256); )
        i += this[t + --r] * o2;
      return i;
    };
    a3.prototype.readUint8 = a3.prototype.readUInt8 = function(t, r) {
      return t = t >>> 0, r || F2(t, 1, this.length), this[t];
    };
    a3.prototype.readUint16LE = a3.prototype.readUInt16LE = function(t, r) {
      return t = t >>> 0, r || F2(t, 2, this.length), this[t] | this[t + 1] << 8;
    };
    a3.prototype.readUint16BE = a3.prototype.readUInt16BE = function(t, r) {
      return t = t >>> 0, r || F2(t, 2, this.length), this[t] << 8 | this[t + 1];
    };
    a3.prototype.readUint32LE = a3.prototype.readUInt32LE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + this[t + 3] * 16777216;
    };
    a3.prototype.readUint32BE = a3.prototype.readUInt32BE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), this[t] * 16777216 + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
    };
    a3.prototype.readBigUInt64LE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24, o2 = this[++t] + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + n * 2 ** 24;
      return BigInt(i) + (BigInt(o2) << BigInt(32));
    });
    a3.prototype.readBigUInt64BE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = r * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t], o2 = this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n;
      return (BigInt(i) << BigInt(32)) + BigInt(o2);
    });
    a3.prototype.readIntLE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = this[t], o2 = 1, l3 = 0;
      for (;++l3 < r && (o2 *= 256); )
        i += this[t + l3] * o2;
      return o2 *= 128, i >= o2 && (i -= Math.pow(2, 8 * r)), i;
    };
    a3.prototype.readIntBE = function(t, r, n) {
      t = t >>> 0, r = r >>> 0, n || F2(t, r, this.length);
      let i = r, o2 = 1, l3 = this[t + --i];
      for (;i > 0 && (o2 *= 256); )
        l3 += this[t + --i] * o2;
      return o2 *= 128, l3 >= o2 && (l3 -= Math.pow(2, 8 * r)), l3;
    };
    a3.prototype.readInt8 = function(t, r) {
      return t = t >>> 0, r || F2(t, 1, this.length), this[t] & 128 ? (255 - this[t] + 1) * -1 : this[t];
    };
    a3.prototype.readInt16LE = function(t, r) {
      t = t >>> 0, r || F2(t, 2, this.length);
      let n = this[t] | this[t + 1] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a3.prototype.readInt16BE = function(t, r) {
      t = t >>> 0, r || F2(t, 2, this.length);
      let n = this[t + 1] | this[t] << 8;
      return n & 32768 ? n | 4294901760 : n;
    };
    a3.prototype.readInt32LE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
    };
    a3.prototype.readInt32BE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
    };
    a3.prototype.readBigInt64LE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = this[t + 4] + this[t + 5] * 2 ** 8 + this[t + 6] * 2 ** 16 + (n << 24);
      return (BigInt(i) << BigInt(32)) + BigInt(r + this[++t] * 2 ** 8 + this[++t] * 2 ** 16 + this[++t] * 2 ** 24);
    });
    a3.prototype.readBigInt64BE = fe3(function(t) {
      t = t >>> 0, Ne(t, "offset");
      let r = this[t], n = this[t + 7];
      (r === undefined || n === undefined) && Ge(t, this.length - 8);
      let i = (r << 24) + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + this[++t];
      return (BigInt(i) << BigInt(32)) + BigInt(this[++t] * 2 ** 24 + this[++t] * 2 ** 16 + this[++t] * 2 ** 8 + n);
    });
    a3.prototype.readFloatLE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), Le.read(this, t, true, 23, 4);
    };
    a3.prototype.readFloatBE = function(t, r) {
      return t = t >>> 0, r || F2(t, 4, this.length), Le.read(this, t, false, 23, 4);
    };
    a3.prototype.readDoubleLE = function(t, r) {
      return t = t >>> 0, r || F2(t, 8, this.length), Le.read(this, t, true, 52, 8);
    };
    a3.prototype.readDoubleBE = function(t, r) {
      return t = t >>> 0, r || F2(t, 8, this.length), Le.read(this, t, false, 52, 8);
    };
    function O2(e, t, r, n, i, o2) {
      if (!a3.isBuffer(e))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length)
        throw new RangeError("Index out of range");
    }
    a3.prototype.writeUintLE = a3.prototype.writeUIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let u2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r, n, u2, 0);
      }
      let o2 = 1, l3 = 0;
      for (this[r] = t & 255;++l3 < n && (o2 *= 256); )
        this[r + l3] = t / o2 & 255;
      return r + n;
    };
    a3.prototype.writeUintBE = a3.prototype.writeUIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, n = n >>> 0, !i) {
        let u2 = Math.pow(2, 8 * n) - 1;
        O2(this, t, r, n, u2, 0);
      }
      let o2 = n - 1, l3 = 1;
      for (this[r + o2] = t & 255;--o2 >= 0 && (l3 *= 256); )
        this[r + o2] = t / l3 & 255;
      return r + n;
    };
    a3.prototype.writeUint8 = a3.prototype.writeUInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 1, 255, 0), this[r] = t & 255, r + 1;
    };
    a3.prototype.writeUint16LE = a3.prototype.writeUInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 65535, 0), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    a3.prototype.writeUint16BE = a3.prototype.writeUInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 65535, 0), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    a3.prototype.writeUint32LE = a3.prototype.writeUInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 4294967295, 0), this[r + 3] = t >>> 24, this[r + 2] = t >>> 16, this[r + 1] = t >>> 8, this[r] = t & 255, r + 4;
    };
    a3.prototype.writeUint32BE = a3.prototype.writeUInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 4294967295, 0), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    function hn(e, t, r, n, i) {
      gn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2, o2 = o2 >> 8, e[r++] = o2;
      let l3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, l3 = l3 >> 8, e[r++] = l3, r;
    }
    function pn2(e, t, r, n, i) {
      gn(t, n, i, e, r, 7);
      let o2 = Number(t & BigInt(4294967295));
      e[r + 7] = o2, o2 = o2 >> 8, e[r + 6] = o2, o2 = o2 >> 8, e[r + 5] = o2, o2 = o2 >> 8, e[r + 4] = o2;
      let l3 = Number(t >> BigInt(32) & BigInt(4294967295));
      return e[r + 3] = l3, l3 = l3 >> 8, e[r + 2] = l3, l3 = l3 >> 8, e[r + 1] = l3, l3 = l3 >> 8, e[r] = l3, r + 8;
    }
    a3.prototype.writeBigUInt64LE = fe3(function(t, r = 0) {
      return hn(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a3.prototype.writeBigUInt64BE = fe3(function(t, r = 0) {
      return pn2(this, t, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    a3.prototype.writeIntLE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let f2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r, n, f2 - 1, -f2);
      }
      let o2 = 0, l3 = 1, u2 = 0;
      for (this[r] = t & 255;++o2 < n && (l3 *= 256); )
        t < 0 && u2 === 0 && this[r + o2 - 1] !== 0 && (u2 = 1), this[r + o2] = (t / l3 >> 0) - u2 & 255;
      return r + n;
    };
    a3.prototype.writeIntBE = function(t, r, n, i) {
      if (t = +t, r = r >>> 0, !i) {
        let f2 = Math.pow(2, 8 * n - 1);
        O2(this, t, r, n, f2 - 1, -f2);
      }
      let o2 = n - 1, l3 = 1, u2 = 0;
      for (this[r + o2] = t & 255;--o2 >= 0 && (l3 *= 256); )
        t < 0 && u2 === 0 && this[r + o2 + 1] !== 0 && (u2 = 1), this[r + o2] = (t / l3 >> 0) - u2 & 255;
      return r + n;
    };
    a3.prototype.writeInt8 = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 1, 127, -128), t < 0 && (t = 255 + t + 1), this[r] = t & 255, r + 1;
    };
    a3.prototype.writeInt16LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 32767, -32768), this[r] = t & 255, this[r + 1] = t >>> 8, r + 2;
    };
    a3.prototype.writeInt16BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 2, 32767, -32768), this[r] = t >>> 8, this[r + 1] = t & 255, r + 2;
    };
    a3.prototype.writeInt32LE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 2147483647, -2147483648), this[r] = t & 255, this[r + 1] = t >>> 8, this[r + 2] = t >>> 16, this[r + 3] = t >>> 24, r + 4;
    };
    a3.prototype.writeInt32BE = function(t, r, n) {
      return t = +t, r = r >>> 0, n || O2(this, t, r, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), this[r] = t >>> 24, this[r + 1] = t >>> 16, this[r + 2] = t >>> 8, this[r + 3] = t & 255, r + 4;
    };
    a3.prototype.writeBigInt64LE = fe3(function(t, r = 0) {
      return hn(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    a3.prototype.writeBigInt64BE = fe3(function(t, r = 0) {
      return pn2(this, t, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function yn(e, t, r, n, i, o2) {
      if (r + n > e.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function wn(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || yn(e, t, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Le.write(e, t, r, n, 23, 4), r + 4;
    }
    a3.prototype.writeFloatLE = function(t, r, n) {
      return wn(this, t, r, true, n);
    };
    a3.prototype.writeFloatBE = function(t, r, n) {
      return wn(this, t, r, false, n);
    };
    function bn(e, t, r, n, i) {
      return t = +t, r = r >>> 0, i || yn(e, t, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Le.write(e, t, r, n, 52, 8), r + 8;
    }
    a3.prototype.writeDoubleLE = function(t, r, n) {
      return bn(this, t, r, true, n);
    };
    a3.prototype.writeDoubleBE = function(t, r, n) {
      return bn(this, t, r, false, n);
    };
    a3.prototype.copy = function(t, r, n, i) {
      if (!a3.isBuffer(t))
        throw new TypeError("argument should be a Buffer");
      if (n || (n = 0), !i && i !== 0 && (i = this.length), r >= t.length && (r = t.length), r || (r = 0), i > 0 && i < n && (i = n), i === n || t.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (n < 0 || n >= this.length)
        throw new RangeError("Index out of range");
      if (i < 0)
        throw new RangeError("sourceEnd out of bounds");
      i > this.length && (i = this.length), t.length - r < i - n && (i = t.length - r + n);
      let o2 = i - n;
      return this === t && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, i) : Uint8Array.prototype.set.call(t, this.subarray(n, i), r), o2;
    };
    a3.prototype.fill = function(t, r, n, i) {
      if (typeof t == "string") {
        if (typeof r == "string" ? (i = r, r = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== undefined && typeof i != "string")
          throw new TypeError("encoding must be a string");
        if (typeof i == "string" && !a3.isEncoding(i))
          throw new TypeError("Unknown encoding: " + i);
        if (t.length === 1) {
          let l3 = t.charCodeAt(0);
          (i === "utf8" && l3 < 128 || i === "latin1") && (t = l3);
        }
      } else
        typeof t == "number" ? t = t & 255 : typeof t == "boolean" && (t = Number(t));
      if (r < 0 || this.length < r || this.length < n)
        throw new RangeError("Out of range index");
      if (n <= r)
        return this;
      r = r >>> 0, n = n === undefined ? this.length : n >>> 0, t || (t = 0);
      let o2;
      if (typeof t == "number")
        for (o2 = r;o2 < n; ++o2)
          this[o2] = t;
      else {
        let l3 = a3.isBuffer(t) ? t : a3.from(t, i), u2 = l3.length;
        if (u2 === 0)
          throw new TypeError('The value "' + t + '" is invalid for argument "value"');
        for (o2 = 0;o2 < n - r; ++o2)
          this[o2 + r] = l3[o2 % u2];
      }
      return this;
    };
    var Be = {};
    function zt(e, t, r) {
      Be[e] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e}]`, this.stack, delete this.name;
        }
        get code() {
          return e;
        }
        set code(i) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: i, writable: true });
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      };
    }
    zt("ERR_BUFFER_OUT_OF_BOUNDS", function(e) {
      return e ? `${e} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    zt("ERR_INVALID_ARG_TYPE", function(e, t) {
      return `The "${e}" argument must be of type number. Received type ${typeof t}`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", function(e, t, r) {
      let n = `The value of "${e}" is out of range.`, i = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? i = un(String(r)) : typeof r == "bigint" && (i = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = un(i)), i += "n"), n += ` It must be ${t}. Received ${i}`, n;
    }, RangeError);
    function un(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function Wl(e, t, r) {
      Ne(t, "offset"), (e[t] === undefined || e[t + r] === undefined) && Ge(t, e.length - (r + 1));
    }
    function gn(e, t, r, n, i, o2) {
      if (e > r || e < t) {
        let l3 = typeof t == "bigint" ? "n" : "", u2;
        throw o2 > 3 ? t === 0 || t === BigInt(0) ? u2 = `>= 0${l3} and < 2${l3} ** ${(o2 + 1) * 8}${l3}` : u2 = `>= -(2${l3} ** ${(o2 + 1) * 8 - 1}${l3}) and < 2 ** ${(o2 + 1) * 8 - 1}${l3}` : u2 = `>= ${t}${l3} and <= ${r}${l3}`, new Be.ERR_OUT_OF_RANGE("value", u2, e);
      }
      Wl(n, i, o2);
    }
    function Ne(e, t) {
      if (typeof e != "number")
        throw new Be.ERR_INVALID_ARG_TYPE(t, "number", e);
    }
    function Ge(e, t, r) {
      throw Math.floor(e) !== e ? (Ne(e, r), new Be.ERR_OUT_OF_RANGE(r || "offset", "an integer", e)) : t < 0 ? new Be.ERR_BUFFER_OUT_OF_BOUNDS : new Be.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${t}`, e);
    }
    var $l = /[^+/0-9A-Za-z-_]/g;
    function jl(e) {
      if (e = e.split("=")[0], e = e.trim().replace($l, ""), e.length < 2)
        return "";
      for (;e.length % 4 !== 0; )
        e = e + "=";
      return e;
    }
    function Vt2(e, t) {
      t = t || 1 / 0;
      let r, n = e.length, i = null, o2 = [];
      for (let l3 = 0;l3 < n; ++l3) {
        if (r = e.charCodeAt(l3), r > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (l3 + 1 === n) {
              (t -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i = r;
            continue;
          }
          if (r < 56320) {
            (t -= 3) > -1 && o2.push(239, 191, 189), i = r;
            continue;
          }
          r = (i - 55296 << 10 | r - 56320) + 65536;
        } else
          i && (t -= 3) > -1 && o2.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0)
            break;
          o2.push(r);
        } else if (r < 2048) {
          if ((t -= 2) < 0)
            break;
          o2.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((t -= 3) < 0)
            break;
          o2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((t -= 4) < 0)
            break;
          o2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function Gl(e) {
      let t = [];
      for (let r = 0;r < e.length; ++r)
        t.push(e.charCodeAt(r) & 255);
      return t;
    }
    function Hl(e, t) {
      let r, n, i, o2 = [];
      for (let l3 = 0;l3 < e.length && !((t -= 2) < 0); ++l3)
        r = e.charCodeAt(l3), n = r >> 8, i = r % 256, o2.push(i), o2.push(n);
      return o2;
    }
    function _n2(e) {
      return jt2.toByteArray(jl(e));
    }
    function ot(e, t, r, n) {
      let i;
      for (i = 0;i < n && !(i + r >= t.length || i >= e.length); ++i)
        t[i + r] = e[i];
      return i;
    }
    function H2(e, t) {
      return e instanceof t || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === t.name;
    }
    function Xt2(e) {
      return e !== e;
    }
    var Vl = function() {
      let e = "0123456789abcdef", t = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let n = r * 16;
        for (let i = 0;i < 16; ++i)
          t[n + i] = e[r] + e[i];
      }
      return t;
    }();
    function fe3(e) {
      return typeof BigInt > "u" ? Yl : e;
    }
    function Yl() {
      throw new Error("BigInt not supported");
    }
  });
  I2 = E4((Gc, En) => {
    En.exports = { ArrayIsArray(e) {
      return Array.isArray(e);
    }, ArrayPrototypeIncludes(e, t) {
      return e.includes(t);
    }, ArrayPrototypeIndexOf(e, t) {
      return e.indexOf(t);
    }, ArrayPrototypeJoin(e, t) {
      return e.join(t);
    }, ArrayPrototypeMap(e, t) {
      return e.map(t);
    }, ArrayPrototypePop(e, t) {
      return e.pop(t);
    }, ArrayPrototypePush(e, t) {
      return e.push(t);
    }, ArrayPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, Error, FunctionPrototypeCall(e, t, ...r) {
      return e.call(t, ...r);
    }, FunctionPrototypeSymbolHasInstance(e, t) {
      return Function.prototype[Symbol.hasInstance].call(e, t);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(e, t) {
      return Object.defineProperties(e, t);
    }, ObjectDefineProperty(e, t, r) {
      return Object.defineProperty(e, t, r);
    }, ObjectGetOwnPropertyDescriptor(e, t) {
      return Object.getOwnPropertyDescriptor(e, t);
    }, ObjectKeys(e) {
      return Object.keys(e);
    }, ObjectSetPrototypeOf(e, t) {
      return Object.setPrototypeOf(e, t);
    }, Promise, PromisePrototypeCatch(e, t) {
      return e.catch(t);
    }, PromisePrototypeThen(e, t, r) {
      return e.then(t, r);
    }, PromiseReject(e) {
      return Promise.reject(e);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(e, t) {
      return e.test(t);
    }, SafeSet: Set, String, StringPrototypeSlice(e, t, r) {
      return e.slice(t, r);
    }, StringPrototypeToLowerCase(e) {
      return e.toLowerCase();
    }, StringPrototypeToUpperCase(e) {
      return e.toUpperCase();
    }, StringPrototypeTrim(e) {
      return e.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(e, t, r) {
      return e.set(t, r);
    }, Uint8Array };
  });
  V3 = E4((Hc, Qt2) => {
    var Kl = te(), zl = Object.getPrototypeOf(async function() {}).constructor, Sn2 = globalThis.Blob || Kl.Blob, Xl = typeof Sn2 < "u" ? function(t) {
      return t instanceof Sn2;
    } : function(t) {
      return false;
    }, Jt = class extends Error {
      constructor(t) {
        if (!Array.isArray(t))
          throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
        let r = "";
        for (let n = 0;n < t.length; n++)
          r += `    ${t[n].stack}
`;
        super(r), this.name = "AggregateError", this.errors = t;
      }
    };
    Qt2.exports = { AggregateError: Jt, kEmptyObject: Object.freeze({}), once(e) {
      let t = false;
      return function(...r) {
        t || (t = true, e.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let e, t;
      return { promise: new Promise((n, i) => {
        e = n, t = i;
      }), resolve: e, reject: t };
    }, promisify(e) {
      return new Promise((t, r) => {
        e((n, ...i) => n ? r(n) : t(...i));
      });
    }, debuglog() {
      return function() {};
    }, format(e, ...t) {
      return e.replace(/%([sdifj])/g, function(...[r, n]) {
        let i = t.shift();
        return n === "f" ? i.toFixed(6) : n === "j" ? JSON.stringify(i) : n === "s" && typeof i == "object" ? `${i.constructor !== Object ? i.constructor.name : ""} {}`.trim() : i.toString();
      });
    }, inspect(e) {
      switch (typeof e) {
        case "string":
          if (e.includes("'"))
            if (e.includes('"')) {
              if (!e.includes("`") && !e.includes("${"))
                return `\`${e}\``;
            } else
              return `"${e}"`;
          return `'${e}'`;
        case "number":
          return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
        case "bigint":
          return `${String(e)}n`;
        case "boolean":
        case "undefined":
          return String(e);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(e) {
      return e instanceof zl;
    }, isArrayBufferView(e) {
      return ArrayBuffer.isView(e);
    } }, isBlob: Xl };
    Qt2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  ut = E4((Vc, lt2) => {
    var { AbortController: mn, AbortSignal: Jl } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    lt2.exports = mn;
    lt2.exports.AbortSignal = Jl;
    lt2.exports.default = mn;
  });
  C2 = E4((Yc, An) => {
    var { format: Ql, inspect: ft, AggregateError: Zl } = V3(), eu = globalThis.AggregateError || Zl, tu = Symbol("kIsNodeError"), ru = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], nu = /^([A-Z][a-z0-9]*)+$/, iu2 = "__node_internal_", st2 = {};
    function be(e, t) {
      if (!e)
        throw new st2.ERR_INTERNAL_ASSERTION(t);
    }
    function xn(e) {
      let t = "", r = e.length, n = e[0] === "-" ? 1 : 0;
      for (;r >= n + 4; r -= 3)
        t = `_${e.slice(r - 3, r)}${t}`;
      return `${e.slice(0, r)}${t}`;
    }
    function ou2(e, t, r) {
      if (typeof t == "function")
        return be(t.length <= r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${t.length}).`), t(...r);
      let n = (t.match(/%[dfijoOs]/g) || []).length;
      return be(n === r.length, `Code: ${e}; The provided arguments length (${r.length}) does not match the required ones (${n}).`), r.length === 0 ? t : Ql(t, ...r);
    }
    function M3(e, t, r) {
      r || (r = Error);

      class n extends r {
        constructor(...o2) {
          super(ou2(e, t, o2));
        }
        toString() {
          return `${this.name} [${e}]: ${this.message}`;
        }
      }
      Object.defineProperties(n.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${e}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), n.prototype.code = e, n.prototype[tu] = true, st2[e] = n;
    }
    function Rn(e) {
      let t = iu2 + e.name;
      return Object.defineProperty(e, "name", { value: t }), e;
    }
    function lu2(e, t) {
      if (e && t && e !== t) {
        if (Array.isArray(t.errors))
          return t.errors.push(e), t;
        let r = new eu([t, e], t.message);
        return r.code = t.code, r;
      }
      return e || t;
    }
    var Zt = class extends Error {
      constructor(t = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new st2.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(t, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    M3("ERR_ASSERTION", "%s", Error);
    M3("ERR_INVALID_ARG_TYPE", (e, t, r) => {
      be(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [t]);
      let n = "The ";
      e.endsWith(" argument") ? n += `${e} ` : n += `"${e}" ${e.includes(".") ? "property" : "argument"} `, n += "must be ";
      let i = [], o2 = [], l3 = [];
      for (let f2 of t)
        be(typeof f2 == "string", "All expected entries have to be of type string"), ru.includes(f2) ? i.push(f2.toLowerCase()) : nu.test(f2) ? o2.push(f2) : (be(f2 !== "object", 'The value "object" should be written as "Object"'), l3.push(f2));
      if (o2.length > 0) {
        let f2 = i.indexOf("object");
        f2 !== -1 && (i.splice(i, f2, 1), o2.push("Object"));
      }
      if (i.length > 0) {
        switch (i.length) {
          case 1:
            n += `of type ${i[0]}`;
            break;
          case 2:
            n += `one of type ${i[0]} or ${i[1]}`;
            break;
          default: {
            let f2 = i.pop();
            n += `one of type ${i.join(", ")}, or ${f2}`;
          }
        }
        (o2.length > 0 || l3.length > 0) && (n += " or ");
      }
      if (o2.length > 0) {
        switch (o2.length) {
          case 1:
            n += `an instance of ${o2[0]}`;
            break;
          case 2:
            n += `an instance of ${o2[0]} or ${o2[1]}`;
            break;
          default: {
            let f2 = o2.pop();
            n += `an instance of ${o2.join(", ")}, or ${f2}`;
          }
        }
        l3.length > 0 && (n += " or ");
      }
      switch (l3.length) {
        case 0:
          break;
        case 1:
          l3[0].toLowerCase() !== l3[0] && (n += "an "), n += `${l3[0]}`;
          break;
        case 2:
          n += `one of ${l3[0]} or ${l3[1]}`;
          break;
        default: {
          let f2 = l3.pop();
          n += `one of ${l3.join(", ")}, or ${f2}`;
        }
      }
      if (r == null)
        n += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        n += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var u2;
        (u2 = r.constructor) !== null && u2 !== undefined && u2.name ? n += `. Received an instance of ${r.constructor.name}` : n += `. Received ${ft(r, { depth: -1 })}`;
      } else {
        let f2 = ft(r, { colors: false });
        f2.length > 25 && (f2 = `${f2.slice(0, 25)}...`), n += `. Received type ${typeof r} (${f2})`;
      }
      return n;
    }, TypeError);
    M3("ERR_INVALID_ARG_VALUE", (e, t, r = "is invalid") => {
      let n = ft(t);
      return n.length > 128 && (n = n.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${r}. Received ${n}`;
    }, TypeError);
    M3("ERR_INVALID_RETURN_VALUE", (e, t, r) => {
      var n;
      let i = r != null && (n = r.constructor) !== null && n !== undefined && n.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
    }, TypeError);
    M3("ERR_MISSING_ARGS", (...e) => {
      be(e.length > 0, "At least one arg needs to be specified");
      let t, r = e.length;
      switch (e = (Array.isArray(e) ? e : [e]).map((n) => `"${n}"`).join(" or "), r) {
        case 1:
          t += `The ${e[0]} argument`;
          break;
        case 2:
          t += `The ${e[0]} and ${e[1]} arguments`;
          break;
        default:
          {
            let n = e.pop();
            t += `The ${e.join(", ")}, and ${n} arguments`;
          }
          break;
      }
      return `${t} must be specified`;
    }, TypeError);
    M3("ERR_OUT_OF_RANGE", (e, t, r) => {
      be(t, 'Missing "range" argument');
      let n;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? n = xn(String(r)) : typeof r == "bigint" ? (n = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (n = xn(n)), n += "n") : n = ft(r), `The value of "${e}" is out of range. It must be ${t}. Received ${n}`;
    }, RangeError);
    M3("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    M3("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    M3("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    M3("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    M3("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    M3("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    M3("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    M3("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    M3("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    M3("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    M3("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    An.exports = { AbortError: Zt, aggregateTwoErrors: Rn(lu2), hideStackFrames: Rn, codes: st2 };
  });
  He2 = E4((Kc, Cn) => {
    var { ArrayIsArray: Bn2, ArrayPrototypeIncludes: Ln2, ArrayPrototypeJoin: Nn2, ArrayPrototypeMap: uu2, NumberIsInteger: tr, NumberIsNaN: fu2, NumberMAX_SAFE_INTEGER: su2, NumberMIN_SAFE_INTEGER: au2, NumberParseInt: cu2, ObjectPrototypeHasOwnProperty: du, RegExpPrototypeExec: hu2, String: pu, StringPrototypeToUpperCase: yu, StringPrototypeTrim: wu } = I2(), { hideStackFrames: W, codes: { ERR_SOCKET_BAD_PORT: bu, ERR_INVALID_ARG_TYPE: D, ERR_INVALID_ARG_VALUE: at, ERR_OUT_OF_RANGE: ge, ERR_UNKNOWN_SIGNAL: In } } = C2(), { normalizeEncoding: gu } = V3(), { isAsyncFunction: _u, isArrayBufferView: Eu } = V3().types, Tn = {};
    function Su(e) {
      return e === (e | 0);
    }
    function mu(e) {
      return e === e >>> 0;
    }
    var xu = /^[0-7]+$/, Ru = "must be a 32-bit unsigned integer or an octal string";
    function Au(e, t, r) {
      if (typeof e > "u" && (e = r), typeof e == "string") {
        if (hu2(xu, e) === null)
          throw new at(t, e, Ru);
        e = cu2(e, 8);
      }
      return Fn2(e, t), e;
    }
    var Iu = W((e, t, r = au2, n = su2) => {
      if (typeof e != "number")
        throw new D(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      if (e < r || e > n)
        throw new ge(t, `>= ${r} && <= ${n}`, e);
    }), Tu = W((e, t, r = -2147483648, n = 2147483647) => {
      if (typeof e != "number")
        throw new D(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      if (e < r || e > n)
        throw new ge(t, `>= ${r} && <= ${n}`, e);
    }), Fn2 = W((e, t, r = false) => {
      if (typeof e != "number")
        throw new D(t, "number", e);
      if (!tr(e))
        throw new ge(t, "an integer", e);
      let n = r ? 1 : 0, i = 4294967295;
      if (e < n || e > i)
        throw new ge(t, `>= ${n} && <= ${i}`, e);
    });
    function Mn(e, t) {
      if (typeof e != "string")
        throw new D(t, "string", e);
    }
    function Bu(e, t, r = undefined, n) {
      if (typeof e != "number")
        throw new D(t, "number", e);
      if (r != null && e < r || n != null && e > n || (r != null || n != null) && fu2(e))
        throw new ge(t, `${r != null ? `>= ${r}` : ""}${r != null && n != null ? " && " : ""}${n != null ? `<= ${n}` : ""}`, e);
    }
    var Lu = W((e, t, r) => {
      if (!Ln2(r, e)) {
        let n = Nn2(uu2(r, (o2) => typeof o2 == "string" ? `'${o2}'` : pu(o2)), ", "), i = "must be one of: " + n;
        throw new at(t, e, i);
      }
    });
    function Nu(e, t) {
      if (typeof e != "boolean")
        throw new D(t, "boolean", e);
    }
    function er2(e, t, r) {
      return e == null || !du(e, t) ? r : e[t];
    }
    var Fu = W((e, t, r = null) => {
      let n = er2(r, "allowArray", false), i = er2(r, "allowFunction", false);
      if (!er2(r, "nullable", false) && e === null || !n && Bn2(e) || typeof e != "object" && (!i || typeof e != "function"))
        throw new D(t, "Object", e);
    }), Mu = W((e, t, r = 0) => {
      if (!Bn2(e))
        throw new D(t, "Array", e);
      if (e.length < r) {
        let n = `must be longer than ${r}`;
        throw new at(t, e, n);
      }
    });
    function Cu(e, t = "signal") {
      if (Mn(e, t), Tn[e] === undefined)
        throw Tn[yu(e)] !== undefined ? new In(e + " (signals must use all capital letters)") : new In(e);
    }
    var Ou = W((e, t = "buffer") => {
      if (!Eu(e))
        throw new D(t, ["Buffer", "TypedArray", "DataView"], e);
    });
    function Du(e, t) {
      let r = gu(t), n = e.length;
      if (r === "hex" && n % 2 !== 0)
        throw new at("encoding", t, `is invalid for data of length ${n}`);
    }
    function Pu(e, t = "Port", r = true) {
      if (typeof e != "number" && typeof e != "string" || typeof e == "string" && wu(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !r)
        throw new bu(t, e, r);
      return e | 0;
    }
    var ku = W((e, t) => {
      if (e !== undefined && (e === null || typeof e != "object" || !("aborted" in e)))
        throw new D(t, "AbortSignal", e);
    }), Uu = W((e, t) => {
      if (typeof e != "function")
        throw new D(t, "Function", e);
    }), vu = W((e, t) => {
      if (typeof e != "function" || _u(e))
        throw new D(t, "Function", e);
    }), qu = W((e, t) => {
      if (e !== undefined)
        throw new D(t, "undefined", e);
    });
    function Wu(e, t, r) {
      if (!Ln2(r, e))
        throw new D(t, `('${Nn2(r, "|")}')`, e);
    }
    Cn.exports = { isInt32: Su, isUint32: mu, parseFileMode: Au, validateArray: Mu, validateBoolean: Nu, validateBuffer: Ou, validateEncoding: Du, validateFunction: Uu, validateInt32: Tu, validateInteger: Iu, validateNumber: Bu, validateObject: Fu, validateOneOf: Lu, validatePlainFunction: vu, validatePort: Pu, validateSignalName: Cu, validateString: Mn, validateUint32: Fn2, validateUndefined: qu, validateUnion: Wu, validateAbortSignal: ku };
  });
  ir2 = E4((zc, kn) => {
    var x3 = kn.exports = {}, Y2, K3;
    function rr() {
      throw new Error("setTimeout has not been defined");
    }
    function nr() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Y2 = setTimeout : Y2 = rr;
      } catch {
        Y2 = rr;
      }
      try {
        typeof clearTimeout == "function" ? K3 = clearTimeout : K3 = nr;
      } catch {
        K3 = nr;
      }
    })();
    function On2(e) {
      if (Y2 === setTimeout)
        return setTimeout(e, 0);
      if ((Y2 === rr || !Y2) && setTimeout)
        return Y2 = setTimeout, setTimeout(e, 0);
      try {
        return Y2(e, 0);
      } catch {
        try {
          return Y2.call(null, e, 0);
        } catch {
          return Y2.call(this, e, 0);
        }
      }
    }
    function $u(e) {
      if (K3 === clearTimeout)
        return clearTimeout(e);
      if ((K3 === nr || !K3) && clearTimeout)
        return K3 = clearTimeout, clearTimeout(e);
      try {
        return K3(e);
      } catch {
        try {
          return K3.call(null, e);
        } catch {
          return K3.call(this, e);
        }
      }
    }
    var re2 = [], Me = false, _e3, ct2 = -1;
    function ju() {
      !Me || !_e3 || (Me = false, _e3.length ? re2 = _e3.concat(re2) : ct2 = -1, re2.length && Dn2());
    }
    function Dn2() {
      if (!Me) {
        var e = On2(ju);
        Me = true;
        for (var t = re2.length;t; ) {
          for (_e3 = re2, re2 = [];++ct2 < t; )
            _e3 && _e3[ct2].run();
          ct2 = -1, t = re2.length;
        }
        _e3 = null, Me = false, $u(e);
      }
    }
    x3.nextTick = function(e) {
      var t = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          t[r - 1] = arguments[r];
      re2.push(new Pn(e, t)), re2.length === 1 && !Me && On2(Dn2);
    };
    function Pn(e, t) {
      this.fun = e, this.array = t;
    }
    Pn.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    x3.title = "browser";
    x3.browser = true;
    x3.env = {};
    x3.argv = [];
    x3.version = "";
    x3.versions = {};
    function ne() {}
    x3.on = ne;
    x3.addListener = ne;
    x3.once = ne;
    x3.off = ne;
    x3.removeListener = ne;
    x3.removeAllListeners = ne;
    x3.emit = ne;
    x3.prependListener = ne;
    x3.prependOnceListener = ne;
    x3.listeners = function(e) {
      return [];
    };
    x3.binding = function(e) {
      throw new Error("process.binding is not supported");
    };
    x3.cwd = function() {
      return "/";
    };
    x3.chdir = function(e) {
      throw new Error("process.chdir is not supported");
    };
    x3.umask = function() {
      return 0;
    };
  });
  k2 = {};
  Qr(k2, { default: () => Gu });
  se = yl(() => {
    ue3(k2, rt2(ir2()));
    Gu = rt2(ir2());
  });
  ae = E4((Jc, zn2) => {
    var { Symbol: dt3, SymbolAsyncIterator: Un, SymbolIterator: vn } = I2(), qn = dt3("kDestroyed"), Wn = dt3("kIsErrored"), or = dt3("kIsReadable"), $n = dt3("kIsDisturbed");
    function ht(e, t = false) {
      var r;
      return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((r = e._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!e._writableState || e._readableState));
    }
    function pt2(e) {
      var t;
      return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === undefined ? undefined : t.writable) !== false));
    }
    function Hu(e) {
      return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function Ee(e) {
      return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function Vu(e, t) {
      return e == null ? false : t === true ? typeof e[Un] == "function" : t === false ? typeof e[vn] == "function" : typeof e[Un] == "function" || typeof e[vn] == "function";
    }
    function yt2(e) {
      if (!Ee(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !!(e.destroyed || e[qn] || n != null && n.destroyed);
    }
    function jn2(e) {
      if (!pt2(e))
        return null;
      if (e.writableEnded === true)
        return true;
      let t = e._writableState;
      return t != null && t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Yu(e, t) {
      if (!pt2(e))
        return null;
      if (e.writableFinished === true)
        return true;
      let r = e._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || t === false && r.ended === true && r.length === 0);
    }
    function Ku(e) {
      if (!ht(e))
        return null;
      if (e.readableEnded === true)
        return true;
      let t = e._readableState;
      return !t || t.errored ? false : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function Gn(e, t) {
      if (!ht(e))
        return null;
      let r = e._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || t === false && r.ended === true && r.length === 0);
    }
    function Hn(e) {
      return e && e[or] != null ? e[or] : typeof e?.readable != "boolean" ? null : yt2(e) ? false : ht(e) && e.readable && !Gn(e);
    }
    function Vn(e) {
      return typeof e?.writable != "boolean" ? null : yt2(e) ? false : pt2(e) && e.writable && !jn2(e);
    }
    function zu(e, t) {
      return Ee(e) ? yt2(e) ? true : !(t?.readable !== false && Hn(e) || t?.writable !== false && Vn(e)) : null;
    }
    function Xu(e) {
      var t, r;
      return Ee(e) ? e.writableErrored ? e.writableErrored : (t = (r = e._writableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function Ju(e) {
      var t, r;
      return Ee(e) ? e.readableErrored ? e.readableErrored : (t = (r = e._readableState) === null || r === undefined ? undefined : r.errored) !== null && t !== undefined ? t : null : null;
    }
    function Qu(e) {
      if (!Ee(e))
        return null;
      if (typeof e.closed == "boolean")
        return e.closed;
      let { _writableState: t, _readableState: r } = e;
      return typeof t?.closed == "boolean" || typeof r?.closed == "boolean" ? t?.closed || r?.closed : typeof e._closed == "boolean" && Yn(e) ? e._closed : null;
    }
    function Yn(e) {
      return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function Kn(e) {
      return typeof e._sent100 == "boolean" && Yn(e);
    }
    function Zu(e) {
      var t;
      return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === undefined ? undefined : t.upgradeOrConnect) === undefined;
    }
    function ef2(e) {
      if (!Ee(e))
        return null;
      let { _writableState: t, _readableState: r } = e, n = t || r;
      return !n && Kn(e) || !!(n && n.autoDestroy && n.emitClose && n.closed === false);
    }
    function tf2(e) {
      var t;
      return !!(e && ((t = e[$n]) !== null && t !== undefined ? t : e.readableDidRead || e.readableAborted));
    }
    function rf(e) {
      var t, r, n, i, o2, l3, u2, f2, s2, d3;
      return !!(e && ((t = (r = (n = (i = (o2 = (l3 = e[Wn]) !== null && l3 !== undefined ? l3 : e.readableErrored) !== null && o2 !== undefined ? o2 : e.writableErrored) !== null && i !== undefined ? i : (u2 = e._readableState) === null || u2 === undefined ? undefined : u2.errorEmitted) !== null && n !== undefined ? n : (f2 = e._writableState) === null || f2 === undefined ? undefined : f2.errorEmitted) !== null && r !== undefined ? r : (s2 = e._readableState) === null || s2 === undefined ? undefined : s2.errored) !== null && t !== undefined ? t : (d3 = e._writableState) === null || d3 === undefined ? undefined : d3.errored));
    }
    zn2.exports = { kDestroyed: qn, isDisturbed: tf2, kIsDisturbed: $n, isErrored: rf, kIsErrored: Wn, isReadable: Hn, kIsReadable: or, isClosed: Qu, isDestroyed: yt2, isDuplexNodeStream: Hu, isFinished: zu, isIterable: Vu, isReadableNodeStream: ht, isReadableEnded: Ku, isReadableFinished: Gn, isReadableErrored: Ju, isNodeStream: Ee, isWritable: Vn, isWritableNodeStream: pt2, isWritableEnded: jn2, isWritableFinished: Yu, isWritableErrored: Xu, isServerRequest: Zu, isServerResponse: Kn, willEmitClose: ef2 };
  });
  ce2 = E4((Qc, ur2) => {
    var Ce = (se(), pe(k2)), { AbortError: nf, codes: of } = C2(), { ERR_INVALID_ARG_TYPE: lf, ERR_STREAM_PREMATURE_CLOSE: Xn } = of, { kEmptyObject: Jn, once: Qn } = V3(), { validateAbortSignal: uf, validateFunction: ff, validateObject: sf } = He2(), { Promise: af } = I2(), { isClosed: cf, isReadable: Zn, isReadableNodeStream: lr, isReadableFinished: ei, isReadableErrored: df, isWritable: ti2, isWritableNodeStream: ri2, isWritableFinished: ni, isWritableErrored: hf, isNodeStream: pf, willEmitClose: yf } = ae();
    function wf(e) {
      return e.setHeader && typeof e.abort == "function";
    }
    var bf = () => {};
    function ii(e, t, r) {
      var n, i;
      arguments.length === 2 ? (r = t, t = Jn) : t == null ? t = Jn : sf(t, "options"), ff(r, "callback"), uf(t.signal, "options.signal"), r = Qn(r);
      let o2 = (n = t.readable) !== null && n !== undefined ? n : lr(e), l3 = (i = t.writable) !== null && i !== undefined ? i : ri2(e);
      if (!pf(e))
        throw new lf("stream", "Stream", e);
      let { _writableState: u2, _readableState: f2 } = e, s2 = () => {
        e.writable || y3();
      }, d3 = yf(e) && lr(e) === o2 && ri2(e) === l3, c2 = ni(e, false), y3 = () => {
        c2 = true, e.destroyed && (d3 = false), !(d3 && (!e.readable || o2)) && (!o2 || h3) && r.call(e);
      }, h3 = ei(e, false), p3 = () => {
        h3 = true, e.destroyed && (d3 = false), !(d3 && (!e.writable || l3)) && (!l3 || c2) && r.call(e);
      }, B2 = (N4) => {
        r.call(e, N4);
      }, v2 = cf(e), w2 = () => {
        v2 = true;
        let N4 = hf(e) || df(e);
        if (N4 && typeof N4 != "boolean")
          return r.call(e, N4);
        if (o2 && !h3 && lr(e, true) && !ei(e, false))
          return r.call(e, new Xn);
        if (l3 && !c2 && !ni(e, false))
          return r.call(e, new Xn);
        r.call(e);
      }, b5 = () => {
        e.req.on("finish", y3);
      };
      wf(e) ? (e.on("complete", y3), d3 || e.on("abort", w2), e.req ? b5() : e.on("request", b5)) : l3 && !u2 && (e.on("end", s2), e.on("close", s2)), !d3 && typeof e.aborted == "boolean" && e.on("aborted", w2), e.on("end", p3), e.on("finish", y3), t.error !== false && e.on("error", B2), e.on("close", w2), v2 ? Ce.nextTick(w2) : u2 != null && u2.errorEmitted || f2 != null && f2.errorEmitted ? d3 || Ce.nextTick(w2) : (!o2 && (!d3 || Zn(e)) && (c2 || ti2(e) === false) || !l3 && (!d3 || ti2(e)) && (h3 || Zn(e) === false) || f2 && e.req && e.aborted) && Ce.nextTick(w2);
      let L3 = () => {
        r = bf, e.removeListener("aborted", w2), e.removeListener("complete", y3), e.removeListener("abort", w2), e.removeListener("request", b5), e.req && e.req.removeListener("finish", y3), e.removeListener("end", s2), e.removeListener("close", s2), e.removeListener("finish", y3), e.removeListener("end", p3), e.removeListener("error", B2), e.removeListener("close", w2);
      };
      if (t.signal && !v2) {
        let N4 = () => {
          let Q3 = r;
          L3(), Q3.call(e, new nf(undefined, { cause: t.signal.reason }));
        };
        if (t.signal.aborted)
          Ce.nextTick(N4);
        else {
          let Q3 = r;
          r = Qn((...Ie) => {
            t.signal.removeEventListener("abort", N4), Q3.apply(e, Ie);
          }), t.signal.addEventListener("abort", N4);
        }
      }
      return L3;
    }
    function gf(e, t) {
      return new af((r, n) => {
        ii(e, t, (i) => {
          i ? n(i) : r();
        });
      });
    }
    ur2.exports = ii;
    ur2.exports.finished = gf;
  });
  di2 = E4((Zc, ar2) => {
    var fi2 = globalThis.AbortController || ut().AbortController, { codes: { ERR_INVALID_ARG_TYPE: Ve, ERR_MISSING_ARGS: _f, ERR_OUT_OF_RANGE: Ef }, AbortError: z } = C2(), { validateAbortSignal: Oe, validateInteger: Sf, validateObject: De } = He2(), mf = I2().Symbol("kWeak"), { finished: xf } = ce2(), { ArrayPrototypePush: Rf, MathFloor: Af, Number: If, NumberIsNaN: Tf, Promise: oi, PromiseReject: li2, PromisePrototypeThen: Bf, Symbol: si2 } = I2(), wt = si2("kEmpty"), ui = si2("kEof");
    function bt4(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal");
      let r = 1;
      return t?.concurrency != null && (r = Af(t.concurrency)), Sf(r, "concurrency", 1), async function* () {
        var i, o2;
        let l3 = new fi2, u2 = this, f2 = [], s2 = l3.signal, d3 = { signal: s2 }, c2 = () => l3.abort();
        t != null && (i = t.signal) !== null && i !== undefined && i.aborted && c2(), t == null || (o2 = t.signal) === null || o2 === undefined || o2.addEventListener("abort", c2);
        let y3, h3, p3 = false;
        function B2() {
          p3 = true;
        }
        async function v2() {
          try {
            for await (let L3 of u2) {
              var w2;
              if (p3)
                return;
              if (s2.aborted)
                throw new z;
              try {
                L3 = e(L3, d3);
              } catch (N4) {
                L3 = li2(N4);
              }
              L3 !== wt && (typeof ((w2 = L3) === null || w2 === undefined ? undefined : w2.catch) == "function" && L3.catch(B2), f2.push(L3), y3 && (y3(), y3 = null), !p3 && f2.length && f2.length >= r && await new oi((N4) => {
                h3 = N4;
              }));
            }
            f2.push(ui);
          } catch (L3) {
            let N4 = li2(L3);
            Bf(N4, undefined, B2), f2.push(N4);
          } finally {
            var b5;
            p3 = true, y3 && (y3(), y3 = null), t == null || (b5 = t.signal) === null || b5 === undefined || b5.removeEventListener("abort", c2);
          }
        }
        v2();
        try {
          for (;; ) {
            for (;f2.length > 0; ) {
              let w2 = await f2[0];
              if (w2 === ui)
                return;
              if (s2.aborted)
                throw new z;
              w2 !== wt && (yield w2), f2.shift(), h3 && (h3(), h3 = null);
            }
            await new oi((w2) => {
              y3 = w2;
            });
          }
        } finally {
          l3.abort(), p3 = true, h3 && (h3(), h3 = null);
        }
      }.call(this);
    }
    function Lf(e = undefined) {
      return e != null && De(e, "options"), e?.signal != null && Oe(e.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let i of this) {
          var n;
          if (e != null && (n = e.signal) !== null && n !== undefined && n.aborted)
            throw new z({ cause: e.signal.reason });
          yield [r++, i];
        }
      }.call(this);
    }
    async function ai(e, t = undefined) {
      for await (let r of sr.call(this, e, t))
        return true;
      return false;
    }
    async function Nf(e, t = undefined) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      return !await ai.call(this, async (...r) => !await e(...r), t);
    }
    async function Ff(e, t) {
      for await (let r of sr.call(this, e, t))
        return r;
    }
    async function Mf(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i), wt;
      }
      for await (let n of bt4.call(this, r, t))
        ;
    }
    function sr(e, t) {
      if (typeof e != "function")
        throw new Ve("fn", ["Function", "AsyncFunction"], e);
      async function r(n, i) {
        return await e(n, i) ? n : wt;
      }
      return bt4.call(this, r, t);
    }
    var fr = class extends _f {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function Cf2(e, t, r) {
      var n;
      if (typeof e != "function")
        throw new Ve("reducer", ["Function", "AsyncFunction"], e);
      r != null && De(r, "options"), r?.signal != null && Oe(r.signal, "options.signal");
      let i = arguments.length > 1;
      if (r != null && (n = r.signal) !== null && n !== undefined && n.aborted) {
        let s2 = new z(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {}), await xf(this.destroy(s2)), s2;
      }
      let o2 = new fi2, l3 = o2.signal;
      if (r != null && r.signal) {
        let s2 = { once: true, [mf]: this };
        r.signal.addEventListener("abort", () => o2.abort(), s2);
      }
      let u2 = false;
      try {
        for await (let s2 of this) {
          var f2;
          if (u2 = true, r != null && (f2 = r.signal) !== null && f2 !== undefined && f2.aborted)
            throw new z;
          i ? t = await e(t, s2, { signal: l3 }) : (t = s2, i = true);
        }
        if (!u2 && !i)
          throw new fr;
      } finally {
        o2.abort();
      }
      return t;
    }
    async function Of(e) {
      e != null && De(e, "options"), e?.signal != null && Oe(e.signal, "options.signal");
      let t = [];
      for await (let n of this) {
        var r;
        if (e != null && (r = e.signal) !== null && r !== undefined && r.aborted)
          throw new z(undefined, { cause: e.signal.reason });
        Rf(t, n);
      }
      return t;
    }
    function Df(e, t) {
      let r = bt4.call(this, e, t);
      return async function* () {
        for await (let i of r)
          yield* i;
      }.call(this);
    }
    function ci2(e) {
      if (e = If(e), Tf(e))
        return 0;
      if (e < 0)
        throw new Ef("number", ">= 0", e);
      return e;
    }
    function Pf(e, t = undefined) {
      return t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal"), e = ci2(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new z;
          e-- <= 0 && (yield o2);
        }
      }.call(this);
    }
    function kf(e, t = undefined) {
      return t != null && De(t, "options"), t?.signal != null && Oe(t.signal, "options.signal"), e = ci2(e), async function* () {
        var n;
        if (t != null && (n = t.signal) !== null && n !== undefined && n.aborted)
          throw new z;
        for await (let o2 of this) {
          var i;
          if (t != null && (i = t.signal) !== null && i !== undefined && i.aborted)
            throw new z;
          if (e-- > 0)
            yield o2;
          else
            return;
        }
      }.call(this);
    }
    ar2.exports.streamReturningOperators = { asIndexedPairs: Lf, drop: Pf, filter: sr, flatMap: Df, map: bt4, take: kf };
    ar2.exports.promiseReturningOperators = { every: Nf, forEach: Mf, reduce: Cf2, toArray: Of, some: ai, find: Ff };
  });
  Se2 = E4((ed, Ei2) => {
    var de = (se(), pe(k2)), { aggregateTwoErrors: Uf, codes: { ERR_MULTIPLE_CALLBACK: vf }, AbortError: qf } = C2(), { Symbol: yi2 } = I2(), { kDestroyed: Wf, isDestroyed: $f, isFinished: jf, isServerRequest: Gf } = ae(), wi2 = yi2("kDestroy"), cr2 = yi2("kConstruct");
    function bi3(e, t, r) {
      e && (e.stack, t && !t.errored && (t.errored = e), r && !r.errored && (r.errored = e));
    }
    function Hf(e, t) {
      let r = this._readableState, n = this._writableState, i = n || r;
      return n && n.destroyed || r && r.destroyed ? (typeof t == "function" && t(), this) : (bi3(e, n, r), n && (n.destroyed = true), r && (r.destroyed = true), i.constructed ? hi(this, e, t) : this.once(wi2, function(o2) {
        hi(this, Uf(o2, e), t);
      }), this);
    }
    function hi(e, t, r) {
      let n = false;
      function i(o2) {
        if (n)
          return;
        n = true;
        let { _readableState: l3, _writableState: u2 } = e;
        bi3(o2, u2, l3), u2 && (u2.closed = true), l3 && (l3.closed = true), typeof r == "function" && r(o2), o2 ? de.nextTick(Vf, e, o2) : de.nextTick(gi3, e);
      }
      try {
        e._destroy(t || null, i);
      } catch (o2) {
        i(o2);
      }
    }
    function Vf(e, t) {
      dr4(e, t), gi3(e);
    }
    function gi3(e) {
      let { _readableState: t, _writableState: r } = e;
      r && (r.closeEmitted = true), t && (t.closeEmitted = true), (r && r.emitClose || t && t.emitClose) && e.emit("close");
    }
    function dr4(e, t) {
      let { _readableState: r, _writableState: n } = e;
      n && n.errorEmitted || r && r.errorEmitted || (n && (n.errorEmitted = true), r && (r.errorEmitted = true), e.emit("error", t));
    }
    function Yf() {
      let e = this._readableState, t = this._writableState;
      e && (e.constructed = true, e.closed = false, e.closeEmitted = false, e.destroyed = false, e.errored = null, e.errorEmitted = false, e.reading = false, e.ended = e.readable === false, e.endEmitted = e.readable === false), t && (t.constructed = true, t.destroyed = false, t.closed = false, t.closeEmitted = false, t.errored = null, t.errorEmitted = false, t.finalCalled = false, t.prefinished = false, t.ended = t.writable === false, t.ending = t.writable === false, t.finished = t.writable === false);
    }
    function hr3(e, t, r) {
      let { _readableState: n, _writableState: i } = e;
      if (i && i.destroyed || n && n.destroyed)
        return this;
      n && n.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), n && !n.errored && (n.errored = t), r ? de.nextTick(dr4, e, t) : dr4(e, t));
    }
    function Kf(e, t) {
      if (typeof e._construct != "function")
        return;
      let { _readableState: r, _writableState: n } = e;
      r && (r.constructed = false), n && (n.constructed = false), e.once(cr2, t), !(e.listenerCount(cr2) > 1) && de.nextTick(zf, e);
    }
    function zf(e) {
      let t = false;
      function r(n) {
        if (t) {
          hr3(e, n ?? new vf);
          return;
        }
        t = true;
        let { _readableState: i, _writableState: o2 } = e, l3 = o2 || i;
        i && (i.constructed = true), o2 && (o2.constructed = true), l3.destroyed ? e.emit(wi2, n) : n ? hr3(e, n, true) : de.nextTick(Xf, e);
      }
      try {
        e._construct(r);
      } catch (n) {
        r(n);
      }
    }
    function Xf(e) {
      e.emit(cr2);
    }
    function pi3(e) {
      return e && e.setHeader && typeof e.abort == "function";
    }
    function _i3(e) {
      e.emit("close");
    }
    function Jf(e, t) {
      e.emit("error", t), de.nextTick(_i3, e);
    }
    function Qf(e, t) {
      !e || $f(e) || (!t && !jf(e) && (t = new qf), Gf(e) ? (e.socket = null, e.destroy(t)) : pi3(e) ? e.abort() : pi3(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? de.nextTick(Jf, e, t) : de.nextTick(_i3, e), e.destroyed || (e[Wf] = true));
    }
    Ei2.exports = { construct: Kf, destroyer: Qf, destroy: Hf, undestroy: Yf, errorOrDestroy: hr3 };
  });
  Et = E4((td, pr2) => {
    var Pe2 = typeof Reflect == "object" ? Reflect : null, Si3 = Pe2 && typeof Pe2.apply == "function" ? Pe2.apply : function(t, r, n) {
      return Function.prototype.apply.call(t, r, n);
    }, gt3;
    Pe2 && typeof Pe2.ownKeys == "function" ? gt3 = Pe2.ownKeys : Object.getOwnPropertySymbols ? gt3 = function(t) {
      return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
    } : gt3 = function(t) {
      return Object.getOwnPropertyNames(t);
    };
    function Zf(e) {
      console && console.warn && console.warn(e);
    }
    var xi3 = Number.isNaN || function(t) {
      return t !== t;
    };
    function S() {
      S.init.call(this);
    }
    pr2.exports = S;
    pr2.exports.once = ns;
    S.EventEmitter = S;
    S.prototype._events = undefined;
    S.prototype._eventsCount = 0;
    S.prototype._maxListeners = undefined;
    var mi3 = 10;
    function _t3(e) {
      if (typeof e != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
    }
    Object.defineProperty(S, "defaultMaxListeners", { enumerable: true, get: function() {
      return mi3;
    }, set: function(e) {
      if (typeof e != "number" || e < 0 || xi3(e))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      mi3 = e;
    } });
    S.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    S.prototype.setMaxListeners = function(t) {
      if (typeof t != "number" || t < 0 || xi3(t))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
      return this._maxListeners = t, this;
    };
    function Ri2(e) {
      return e._maxListeners === undefined ? S.defaultMaxListeners : e._maxListeners;
    }
    S.prototype.getMaxListeners = function() {
      return Ri2(this);
    };
    S.prototype.emit = function(t) {
      for (var r = [], n = 1;n < arguments.length; n++)
        r.push(arguments[n]);
      var i = t === "error", o2 = this._events;
      if (o2 !== undefined)
        i = i && o2.error === undefined;
      else if (!i)
        return false;
      if (i) {
        var l3;
        if (r.length > 0 && (l3 = r[0]), l3 instanceof Error)
          throw l3;
        var u2 = new Error("Unhandled error." + (l3 ? " (" + l3.message + ")" : ""));
        throw u2.context = l3, u2;
      }
      var f2 = o2[t];
      if (f2 === undefined)
        return false;
      if (typeof f2 == "function")
        Si3(f2, this, r);
      else
        for (var s2 = f2.length, d3 = Li2(f2, s2), n = 0;n < s2; ++n)
          Si3(d3[n], this, r);
      return true;
    };
    function Ai2(e, t, r, n) {
      var i, o2, l3;
      if (_t3(r), o2 = e._events, o2 === undefined ? (o2 = e._events = Object.create(null), e._eventsCount = 0) : (o2.newListener !== undefined && (e.emit("newListener", t, r.listener ? r.listener : r), o2 = e._events), l3 = o2[t]), l3 === undefined)
        l3 = o2[t] = r, ++e._eventsCount;
      else if (typeof l3 == "function" ? l3 = o2[t] = n ? [r, l3] : [l3, r] : n ? l3.unshift(r) : l3.push(r), i = Ri2(e), i > 0 && l3.length > i && !l3.warned) {
        l3.warned = true;
        var u2 = new Error("Possible EventEmitter memory leak detected. " + l3.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        u2.name = "MaxListenersExceededWarning", u2.emitter = e, u2.type = t, u2.count = l3.length, Zf(u2);
      }
      return e;
    }
    S.prototype.addListener = function(t, r) {
      return Ai2(this, t, r, false);
    };
    S.prototype.on = S.prototype.addListener;
    S.prototype.prependListener = function(t, r) {
      return Ai2(this, t, r, true);
    };
    function es() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function Ii2(e, t, r) {
      var n = { fired: false, wrapFn: undefined, target: e, type: t, listener: r }, i = es.bind(n);
      return i.listener = r, n.wrapFn = i, i;
    }
    S.prototype.once = function(t, r) {
      return _t3(r), this.on(t, Ii2(this, t, r)), this;
    };
    S.prototype.prependOnceListener = function(t, r) {
      return _t3(r), this.prependListener(t, Ii2(this, t, r)), this;
    };
    S.prototype.removeListener = function(t, r) {
      var n, i, o2, l3, u2;
      if (_t3(r), i = this._events, i === undefined)
        return this;
      if (n = i[t], n === undefined)
        return this;
      if (n === r || n.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
      else if (typeof n != "function") {
        for (o2 = -1, l3 = n.length - 1;l3 >= 0; l3--)
          if (n[l3] === r || n[l3].listener === r) {
            u2 = n[l3].listener, o2 = l3;
            break;
          }
        if (o2 < 0)
          return this;
        o2 === 0 ? n.shift() : ts(n, o2), n.length === 1 && (i[t] = n[0]), i.removeListener !== undefined && this.emit("removeListener", t, u2 || r);
      }
      return this;
    };
    S.prototype.off = S.prototype.removeListener;
    S.prototype.removeAllListeners = function(t) {
      var r, n, i;
      if (n = this._events, n === undefined)
        return this;
      if (n.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : n[t] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete n[t]), this;
      if (arguments.length === 0) {
        var o2 = Object.keys(n), l3;
        for (i = 0;i < o2.length; ++i)
          l3 = o2[i], l3 !== "removeListener" && this.removeAllListeners(l3);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = n[t], typeof r == "function")
        this.removeListener(t, r);
      else if (r !== undefined)
        for (i = r.length - 1;i >= 0; i--)
          this.removeListener(t, r[i]);
      return this;
    };
    function Ti2(e, t, r) {
      var n = e._events;
      if (n === undefined)
        return [];
      var i = n[t];
      return i === undefined ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? rs(i) : Li2(i, i.length);
    }
    S.prototype.listeners = function(t) {
      return Ti2(this, t, true);
    };
    S.prototype.rawListeners = function(t) {
      return Ti2(this, t, false);
    };
    S.listenerCount = function(e, t) {
      return typeof e.listenerCount == "function" ? e.listenerCount(t) : Bi.call(e, t);
    };
    S.prototype.listenerCount = Bi;
    function Bi(e) {
      var t = this._events;
      if (t !== undefined) {
        var r = t[e];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    S.prototype.eventNames = function() {
      return this._eventsCount > 0 ? gt3(this._events) : [];
    };
    function Li2(e, t) {
      for (var r = new Array(t), n = 0;n < t; ++n)
        r[n] = e[n];
      return r;
    }
    function ts(e, t) {
      for (;t + 1 < e.length; t++)
        e[t] = e[t + 1];
      e.pop();
    }
    function rs(e) {
      for (var t = new Array(e.length), r = 0;r < t.length; ++r)
        t[r] = e[r].listener || e[r];
      return t;
    }
    function ns(e, t) {
      return new Promise(function(r, n) {
        function i(l3) {
          e.removeListener(t, o2), n(l3);
        }
        function o2() {
          typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
        }
        Ni2(e, t, o2, { once: true }), t !== "error" && is(e, i, { once: true });
      });
    }
    function is(e, t, r) {
      typeof e.on == "function" && Ni2(e, "error", t, r);
    }
    function Ni2(e, t, r, n) {
      if (typeof e.on == "function")
        n.once ? e.once(t, r) : e.on(t, r);
      else if (typeof e.addEventListener == "function")
        e.addEventListener(t, function i(o2) {
          n.once && e.removeEventListener(t, i), r(o2);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
    }
  });
  xt2 = E4((rd, Mi) => {
    var { ArrayIsArray: os, ObjectSetPrototypeOf: Fi } = I2(), { EventEmitter: St } = Et();
    function mt3(e) {
      St.call(this, e);
    }
    Fi(mt3.prototype, St.prototype);
    Fi(mt3, St);
    mt3.prototype.pipe = function(e, t) {
      let r = this;
      function n(d3) {
        e.writable && e.write(d3) === false && r.pause && r.pause();
      }
      r.on("data", n);
      function i() {
        r.readable && r.resume && r.resume();
      }
      e.on("drain", i), !e._isStdio && (!t || t.end !== false) && (r.on("end", l3), r.on("close", u2));
      let o2 = false;
      function l3() {
        o2 || (o2 = true, e.end());
      }
      function u2() {
        o2 || (o2 = true, typeof e.destroy == "function" && e.destroy());
      }
      function f2(d3) {
        s2(), St.listenerCount(this, "error") === 0 && this.emit("error", d3);
      }
      yr2(r, "error", f2), yr2(e, "error", f2);
      function s2() {
        r.removeListener("data", n), e.removeListener("drain", i), r.removeListener("end", l3), r.removeListener("close", u2), r.removeListener("error", f2), e.removeListener("error", f2), r.removeListener("end", s2), r.removeListener("close", s2), e.removeListener("close", s2);
      }
      return r.on("end", s2), r.on("close", s2), e.on("close", s2), e.emit("pipe", r), e;
    };
    function yr2(e, t, r) {
      if (typeof e.prependListener == "function")
        return e.prependListener(t, r);
      !e._events || !e._events[t] ? e.on(t, r) : os(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
    }
    Mi.exports = { Stream: mt3, prependListener: yr2 };
  });
  At3 = E4((nd, Rt) => {
    var { AbortError: ls, codes: us } = C2(), fs = ce2(), { ERR_INVALID_ARG_TYPE: Ci } = us, ss = (e, t) => {
      if (typeof e != "object" || !("aborted" in e))
        throw new Ci(t, "AbortSignal", e);
    };
    function as(e) {
      return !!(e && typeof e.pipe == "function");
    }
    Rt.exports.addAbortSignal = function(t, r) {
      if (ss(t, "signal"), !as(r))
        throw new Ci("stream", "stream.Stream", r);
      return Rt.exports.addAbortSignalNoValidate(t, r);
    };
    Rt.exports.addAbortSignalNoValidate = function(e, t) {
      if (typeof e != "object" || !("aborted" in e))
        return t;
      let r = () => {
        t.destroy(new ls(undefined, { cause: e.reason }));
      };
      return e.aborted ? r() : (e.addEventListener("abort", r), fs(t, () => e.removeEventListener("abort", r))), t;
    };
  });
  Pi = E4((od, Di2) => {
    var { StringPrototypeSlice: Oi, SymbolIterator: cs, TypedArrayPrototypeSet: It, Uint8Array: ds } = I2(), { Buffer: wr } = te(), { inspect: hs } = V3();
    Di2.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(t) {
        let r = { data: t, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(t) {
        let r = { data: t, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let t = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(t) {
        if (this.length === 0)
          return "";
        let r = this.head, n = "" + r.data;
        for (;(r = r.next) !== null; )
          n += t + r.data;
        return n;
      }
      concat(t) {
        if (this.length === 0)
          return wr.alloc(0);
        let r = wr.allocUnsafe(t >>> 0), n = this.head, i = 0;
        for (;n; )
          It(r, n.data, i), i += n.data.length, n = n.next;
        return r;
      }
      consume(t, r) {
        let n = this.head.data;
        if (t < n.length) {
          let i = n.slice(0, t);
          return this.head.data = n.slice(t), i;
        }
        return t === n.length ? this.shift() : r ? this._getString(t) : this._getBuffer(t);
      }
      first() {
        return this.head.data;
      }
      *[cs]() {
        for (let t = this.head;t; t = t.next)
          yield t.data;
      }
      _getString(t) {
        let r = "", n = this.head, i = 0;
        do {
          let o2 = n.data;
          if (t > o2.length)
            r += o2, t -= o2.length;
          else {
            t === o2.length ? (r += o2, ++i, n.next ? this.head = n.next : this.head = this.tail = null) : (r += Oi(o2, 0, t), this.head = n, n.data = Oi(o2, t));
            break;
          }
          ++i;
        } while ((n = n.next) !== null);
        return this.length -= i, r;
      }
      _getBuffer(t) {
        let r = wr.allocUnsafe(t), n = t, i = this.head, o2 = 0;
        do {
          let l3 = i.data;
          if (t > l3.length)
            It(r, l3, n - t), t -= l3.length;
          else {
            t === l3.length ? (It(r, l3, n - t), ++o2, i.next ? this.head = i.next : this.head = this.tail = null) : (It(r, new ds(l3.buffer, l3.byteOffset, t), n - t), this.head = i, i.data = l3.slice(t));
            break;
          }
          ++o2;
        } while ((i = i.next) !== null);
        return this.length -= o2, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](t, r) {
        return hs(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Tt2 = E4((ld, Ui) => {
    var { MathFloor: ps, NumberIsInteger: ys } = I2(), { ERR_INVALID_ARG_VALUE: ws } = C2().codes;
    function bs(e, t, r) {
      return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
    }
    function ki(e) {
      return e ? 16 : 16 * 1024;
    }
    function gs(e, t, r, n) {
      let i = bs(t, n, r);
      if (i != null) {
        if (!ys(i) || i < 0) {
          let o2 = n ? `options.${r}` : "options.highWaterMark";
          throw new ws(o2, i);
        }
        return ps(i);
      }
      return ki(e.objectMode);
    }
    Ui.exports = { getHighWaterMark: gs, getDefaultHighWaterMark: ki };
  });
  Wi = E4((br3, qi) => {
    var Bt = te(), X2 = Bt.Buffer;
    function vi3(e, t) {
      for (var r in e)
        t[r] = e[r];
    }
    X2.from && X2.alloc && X2.allocUnsafe && X2.allocUnsafeSlow ? qi.exports = Bt : (vi3(Bt, br3), br3.Buffer = me);
    function me(e, t, r) {
      return X2(e, t, r);
    }
    me.prototype = Object.create(X2.prototype);
    vi3(X2, me);
    me.from = function(e, t, r) {
      if (typeof e == "number")
        throw new TypeError("Argument must not be a number");
      return X2(e, t, r);
    };
    me.alloc = function(e, t, r) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      var n = X2(e);
      return t !== undefined ? typeof r == "string" ? n.fill(t, r) : n.fill(t) : n.fill(0), n;
    };
    me.allocUnsafe = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return X2(e);
    };
    me.allocUnsafeSlow = function(e) {
      if (typeof e != "number")
        throw new TypeError("Argument must be a number");
      return Bt.SlowBuffer(e);
    };
  });
  Gi2 = E4((ji2) => {
    var _r3 = Wi().Buffer, $i = _r3.isEncoding || function(e) {
      switch (e = "" + e, e && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _s(e) {
      if (!e)
        return "utf8";
      for (var t;; )
        switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t)
              return;
            e = ("" + e).toLowerCase(), t = true;
        }
    }
    function Es(e) {
      var t = _s(e);
      if (typeof t != "string" && (_r3.isEncoding === $i || !$i(e)))
        throw new Error("Unknown encoding: " + e);
      return t || e;
    }
    ji2.StringDecoder = Ye;
    function Ye(e) {
      this.encoding = Es(e);
      var t;
      switch (this.encoding) {
        case "utf16le":
          this.text = Is, this.end = Ts, t = 4;
          break;
        case "utf8":
          this.fillLast = xs, t = 4;
          break;
        case "base64":
          this.text = Bs, this.end = Ls, t = 3;
          break;
        default:
          this.write = Ns, this.end = Fs;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = _r3.allocUnsafe(t);
    }
    Ye.prototype.write = function(e) {
      if (e.length === 0)
        return "";
      var t, r;
      if (this.lastNeed) {
        if (t = this.fillLast(e), t === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
    };
    Ye.prototype.end = As;
    Ye.prototype.text = Rs;
    Ye.prototype.fillLast = function(e) {
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
    };
    function gr3(e) {
      return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
    }
    function Ss(e, t, r) {
      var n = t.length - 1;
      if (n < r)
        return 0;
      var i = gr3(t[n]);
      return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = gr3(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = gr3(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
    }
    function ms(e, t, r) {
      if ((t[0] & 192) !== 128)
        return e.lastNeed = 0, "�";
      if (e.lastNeed > 1 && t.length > 1) {
        if ((t[1] & 192) !== 128)
          return e.lastNeed = 1, "�";
        if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
          return e.lastNeed = 2, "�";
      }
    }
    function xs(e) {
      var t = this.lastTotal - this.lastNeed, r = ms(this, e, t);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= e.length)
        return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
    }
    function Rs(e, t) {
      var r = Ss(this, e, t);
      if (!this.lastNeed)
        return e.toString("utf8", t);
      this.lastTotal = r;
      var n = e.length - (r - this.lastNeed);
      return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
    }
    function As(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + "�" : t;
    }
    function Is(e, t) {
      if ((e.length - t) % 2 === 0) {
        var r = e.toString("utf16le", t);
        if (r) {
          var n = r.charCodeAt(r.length - 1);
          if (n >= 55296 && n <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
    }
    function Ts(e) {
      var t = e && e.length ? this.write(e) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return t + this.lastChar.toString("utf16le", 0, r);
      }
      return t;
    }
    function Bs(e, t) {
      var r = (e.length - t) % 3;
      return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
    }
    function Ls(e) {
      var t = e && e.length ? this.write(e) : "";
      return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
    }
    function Ns(e) {
      return e.toString(this.encoding);
    }
    function Fs(e) {
      return e && e.length ? this.write(e) : "";
    }
  });
  Er3 = E4((fd, Ki2) => {
    var Hi2 = (se(), pe(k2)), { PromisePrototypeThen: Ms, SymbolAsyncIterator: Vi3, SymbolIterator: Yi2 } = I2(), { Buffer: Cs } = te(), { ERR_INVALID_ARG_TYPE: Os, ERR_STREAM_NULL_VALUES: Ds } = C2().codes;
    function Ps(e, t, r) {
      let n;
      if (typeof t == "string" || t instanceof Cs)
        return new e({ objectMode: true, ...r, read() {
          this.push(t), this.push(null);
        } });
      let i;
      if (t && t[Vi3])
        i = true, n = t[Vi3]();
      else if (t && t[Yi2])
        i = false, n = t[Yi2]();
      else
        throw new Os("iterable", ["Iterable"], t);
      let o2 = new e({ objectMode: true, highWaterMark: 1, ...r }), l3 = false;
      o2._read = function() {
        l3 || (l3 = true, f2());
      }, o2._destroy = function(s2, d3) {
        Ms(u2(s2), () => Hi2.nextTick(d3, s2), (c2) => Hi2.nextTick(d3, c2 || s2));
      };
      async function u2(s2) {
        let d3 = s2 != null, c2 = typeof n.throw == "function";
        if (d3 && c2) {
          let { value: y3, done: h3 } = await n.throw(s2);
          if (await y3, h3)
            return;
        }
        if (typeof n.return == "function") {
          let { value: y3 } = await n.return();
          await y3;
        }
      }
      async function f2() {
        for (;; ) {
          try {
            let { value: s2, done: d3 } = i ? await n.next() : n.next();
            if (d3)
              o2.push(null);
            else {
              let c2 = s2 && typeof s2.then == "function" ? await s2 : s2;
              if (c2 === null)
                throw l3 = false, new Ds;
              if (o2.push(c2))
                continue;
              l3 = false;
            }
          } catch (s2) {
            o2.destroy(s2);
          }
          break;
        }
      }
      return o2;
    }
    Ki2.exports = Ps;
  });
  Ke = E4((sd, uo) => {
    var $ = (se(), pe(k2)), { ArrayPrototypeIndexOf: ks, NumberIsInteger: Us, NumberIsNaN: vs, NumberParseInt: qs, ObjectDefineProperties: Ji2, ObjectKeys: Ws2, ObjectSetPrototypeOf: Qi2, Promise: $s2, SafeSet: js2, SymbolAsyncIterator: Gs2, Symbol: Hs2 } = I2();
    uo.exports = g3;
    g3.ReadableState = Ir2;
    var { EventEmitter: Vs2 } = Et(), { Stream: he, prependListener: Ys3 } = xt2(), { Buffer: Sr } = te(), { addAbortSignal: Ks2 } = At3(), zs2 = ce2(), _3 = V3().debuglog("stream", (e) => {
      _3 = e;
    }), Xs2 = Pi(), Ue = Se2(), { getHighWaterMark: Js2, getDefaultHighWaterMark: Qs2 } = Tt2(), { aggregateTwoErrors: zi, codes: { ERR_INVALID_ARG_TYPE: Zs2, ERR_METHOD_NOT_IMPLEMENTED: ea, ERR_OUT_OF_RANGE: ta, ERR_STREAM_PUSH_AFTER_EOF: ra, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: na } } = C2(), { validateObject: ia } = He2(), xe = Hs2("kPaused"), { StringDecoder: Zi } = Gi2(), oa = Er3();
    Qi2(g3.prototype, he.prototype);
    Qi2(g3, he);
    var mr2 = () => {}, { errorOrDestroy: ke3 } = Ue;
    function Ir2(e, t, r) {
      typeof r != "boolean" && (r = t instanceof J()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? Js2(this, e, "readableHighWaterMark", r) : Qs2(false), this.buffer = new Xs2, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[xe] = null, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new Zi(e.encoding), this.encoding = e.encoding);
    }
    function g3(e) {
      if (!(this instanceof g3))
        return new g3(e);
      let t = this instanceof J();
      this._readableState = new Ir2(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && Ks2(e.signal, this)), he.call(this, e), Ue.construct(this, () => {
        this._readableState.needReadable && Lt2(this, this._readableState);
      });
    }
    g3.prototype.destroy = Ue.destroy;
    g3.prototype._undestroy = Ue.undestroy;
    g3.prototype._destroy = function(e, t) {
      t(e);
    };
    g3.prototype[Vs2.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    g3.prototype.push = function(e, t) {
      return eo2(this, e, t, false);
    };
    g3.prototype.unshift = function(e, t) {
      return eo2(this, e, t, true);
    };
    function eo2(e, t, r, n) {
      _3("readableAddChunk", t);
      let i = e._readableState, o2;
      if (i.objectMode || (typeof t == "string" ? (r = r || i.defaultEncoding, i.encoding !== r && (n && i.encoding ? t = Sr.from(t, r).toString(i.encoding) : (t = Sr.from(t, r), r = ""))) : t instanceof Sr ? r = "" : he._isUint8Array(t) ? (t = he._uint8ArrayToBuffer(t), r = "") : t != null && (o2 = new Zs2("chunk", ["string", "Buffer", "Uint8Array"], t))), o2)
        ke3(e, o2);
      else if (t === null)
        i.reading = false, fa(e, i);
      else if (i.objectMode || t && t.length > 0)
        if (n)
          if (i.endEmitted)
            ke3(e, new na);
          else {
            if (i.destroyed || i.errored)
              return false;
            xr2(e, i, t, true);
          }
        else if (i.ended)
          ke3(e, new ra);
        else {
          if (i.destroyed || i.errored)
            return false;
          i.reading = false, i.decoder && !r ? (t = i.decoder.write(t), i.objectMode || t.length !== 0 ? xr2(e, i, t, false) : Lt2(e, i)) : xr2(e, i, t, false);
        }
      else
        n || (i.reading = false, Lt2(e, i));
      return !i.ended && (i.length < i.highWaterMark || i.length === 0);
    }
    function xr2(e, t, r, n) {
      t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = true, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && Nt2(e)), Lt2(e, t);
    }
    g3.prototype.isPaused = function() {
      let e = this._readableState;
      return e[xe] === true || e.flowing === false;
    };
    g3.prototype.setEncoding = function(e) {
      let t = new Zi(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, n = "";
      for (let i of r)
        n += t.write(i);
      return r.clear(), n !== "" && r.push(n), this._readableState.length = n.length, this;
    };
    var la = 1073741824;
    function ua(e) {
      if (e > la)
        throw new ta("size", "<= 1GiB", e);
      return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function Xi2(e, t) {
      return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : vs(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    g3.prototype.read = function(e) {
      _3("read", e), e === undefined ? e = NaN : Us(e) || (e = qs(e, 10));
      let t = this._readableState, r = e;
      if (e > t.highWaterMark && (t.highWaterMark = ua(e)), e !== 0 && (t.emittedReadable = false), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended))
        return _3("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Rr3(this) : Nt2(this), null;
      if (e = Xi2(e, t), e === 0 && t.ended)
        return t.length === 0 && Rr3(this), null;
      let n = t.needReadable;
      if (_3("need readable", n), (t.length === 0 || t.length - e < t.highWaterMark) && (n = true, _3("length less than watermark", n)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed)
        n = false, _3("reading, ended or constructing", n);
      else if (n) {
        _3("do read"), t.reading = true, t.sync = true, t.length === 0 && (t.needReadable = true);
        try {
          this._read(t.highWaterMark);
        } catch (o2) {
          ke3(this, o2);
        }
        t.sync = false, t.reading || (e = Xi2(r, t));
      }
      let i;
      return e > 0 ? i = oo(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = true), r !== e && t.ended && Rr3(this)), i !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = true, this.emit("data", i)), i;
    };
    function fa(e, t) {
      if (_3("onEofChunk"), !t.ended) {
        if (t.decoder) {
          let r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
        }
        t.ended = true, t.sync ? Nt2(e) : (t.needReadable = false, t.emittedReadable = true, to2(e));
      }
    }
    function Nt2(e) {
      let t = e._readableState;
      _3("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = false, t.emittedReadable || (_3("emitReadable", t.flowing), t.emittedReadable = true, $.nextTick(to2, e));
    }
    function to2(e) {
      let t = e._readableState;
      _3("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = false), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, no(e);
    }
    function Lt2(e, t) {
      !t.readingMore && t.constructed && (t.readingMore = true, $.nextTick(sa, e, t));
    }
    function sa(e, t) {
      for (;!t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
        let r = t.length;
        if (_3("maybeReadMore read 0"), e.read(0), r === t.length)
          break;
      }
      t.readingMore = false;
    }
    g3.prototype._read = function(e) {
      throw new ea("_read()");
    };
    g3.prototype.pipe = function(e, t) {
      let r = this, n = this._readableState;
      n.pipes.length === 1 && (n.multiAwaitDrain || (n.multiAwaitDrain = true, n.awaitDrainWriters = new js2(n.awaitDrainWriters ? [n.awaitDrainWriters] : []))), n.pipes.push(e), _3("pipe count=%d opts=%j", n.pipes.length, t);
      let o2 = (!t || t.end !== false) && e !== $.stdout && e !== $.stderr ? u2 : v2;
      n.endEmitted ? $.nextTick(o2) : r.once("end", o2), e.on("unpipe", l3);
      function l3(w2, b5) {
        _3("onunpipe"), w2 === r && b5 && b5.hasUnpiped === false && (b5.hasUnpiped = true, d3());
      }
      function u2() {
        _3("onend"), e.end();
      }
      let f2, s2 = false;
      function d3() {
        _3("cleanup"), e.removeListener("close", p3), e.removeListener("finish", B2), f2 && e.removeListener("drain", f2), e.removeListener("error", h3), e.removeListener("unpipe", l3), r.removeListener("end", u2), r.removeListener("end", v2), r.removeListener("data", y3), s2 = true, f2 && n.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && f2();
      }
      function c2() {
        s2 || (n.pipes.length === 1 && n.pipes[0] === e ? (_3("false write response, pause", 0), n.awaitDrainWriters = e, n.multiAwaitDrain = false) : n.pipes.length > 1 && n.pipes.includes(e) && (_3("false write response, pause", n.awaitDrainWriters.size), n.awaitDrainWriters.add(e)), r.pause()), f2 || (f2 = aa(r, e), e.on("drain", f2));
      }
      r.on("data", y3);
      function y3(w2) {
        _3("ondata");
        let b5 = e.write(w2);
        _3("dest.write", b5), b5 === false && c2();
      }
      function h3(w2) {
        if (_3("onerror", w2), v2(), e.removeListener("error", h3), e.listenerCount("error") === 0) {
          let b5 = e._writableState || e._readableState;
          b5 && !b5.errorEmitted ? ke3(e, w2) : e.emit("error", w2);
        }
      }
      Ys3(e, "error", h3);
      function p3() {
        e.removeListener("finish", B2), v2();
      }
      e.once("close", p3);
      function B2() {
        _3("onfinish"), e.removeListener("close", p3), v2();
      }
      e.once("finish", B2);
      function v2() {
        _3("unpipe"), r.unpipe(e);
      }
      return e.emit("pipe", r), e.writableNeedDrain === true ? n.flowing && c2() : n.flowing || (_3("pipe resume"), r.resume()), e;
    };
    function aa(e, t) {
      return function() {
        let n = e._readableState;
        n.awaitDrainWriters === t ? (_3("pipeOnDrain", 1), n.awaitDrainWriters = null) : n.multiAwaitDrain && (_3("pipeOnDrain", n.awaitDrainWriters.size), n.awaitDrainWriters.delete(t)), (!n.awaitDrainWriters || n.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
      };
    }
    g3.prototype.unpipe = function(e) {
      let t = this._readableState, r = { hasUnpiped: false };
      if (t.pipes.length === 0)
        return this;
      if (!e) {
        let i = t.pipes;
        t.pipes = [], this.pause();
        for (let o2 = 0;o2 < i.length; o2++)
          i[o2].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let n = ks(t.pipes, e);
      return n === -1 ? this : (t.pipes.splice(n, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, r), this);
    };
    g3.prototype.on = function(e, t) {
      let r = he.prototype.on.call(this, e, t), n = this._readableState;
      return e === "data" ? (n.readableListening = this.listenerCount("readable") > 0, n.flowing !== false && this.resume()) : e === "readable" && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = true, n.flowing = false, n.emittedReadable = false, _3("on readable", n.length, n.reading), n.length ? Nt2(this) : n.reading || $.nextTick(ca, this)), r;
    };
    g3.prototype.addListener = g3.prototype.on;
    g3.prototype.removeListener = function(e, t) {
      let r = he.prototype.removeListener.call(this, e, t);
      return e === "readable" && $.nextTick(ro2, this), r;
    };
    g3.prototype.off = g3.prototype.removeListener;
    g3.prototype.removeAllListeners = function(e) {
      let t = he.prototype.removeAllListeners.apply(this, arguments);
      return (e === "readable" || e === undefined) && $.nextTick(ro2, this), t;
    };
    function ro2(e) {
      let t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[xe] === false ? t.flowing = true : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function ca(e) {
      _3("readable nexttick read 0"), e.read(0);
    }
    g3.prototype.resume = function() {
      let e = this._readableState;
      return e.flowing || (_3("resume"), e.flowing = !e.readableListening, da(this, e)), e[xe] = false, this;
    };
    function da(e, t) {
      t.resumeScheduled || (t.resumeScheduled = true, $.nextTick(ha, e, t));
    }
    function ha(e, t) {
      _3("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = false, e.emit("resume"), no(e), t.flowing && !t.reading && e.read(0);
    }
    g3.prototype.pause = function() {
      return _3("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (_3("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[xe] = true, this;
    };
    function no(e) {
      let t = e._readableState;
      for (_3("flow", t.flowing);t.flowing && e.read() !== null; )
        ;
    }
    g3.prototype.wrap = function(e) {
      let t = false;
      e.on("data", (n) => {
        !this.push(n) && e.pause && (t = true, e.pause());
      }), e.on("end", () => {
        this.push(null);
      }), e.on("error", (n) => {
        ke3(this, n);
      }), e.on("close", () => {
        this.destroy();
      }), e.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        t && e.resume && (t = false, e.resume());
      };
      let r = Ws2(e);
      for (let n = 1;n < r.length; n++) {
        let i = r[n];
        this[i] === undefined && typeof e[i] == "function" && (this[i] = e[i].bind(e));
      }
      return this;
    };
    g3.prototype[Gs2] = function() {
      return io(this);
    };
    g3.prototype.iterator = function(e) {
      return e !== undefined && ia(e, "options"), io(this, e);
    };
    function io(e, t) {
      typeof e.read != "function" && (e = g3.wrap(e, { objectMode: true }));
      let r = pa(e, t);
      return r.stream = e, r;
    }
    async function* pa(e, t) {
      let r = mr2;
      function n(l3) {
        this === e ? (r(), r = mr2) : r = l3;
      }
      e.on("readable", n);
      let i, o2 = zs2(e, { writable: false }, (l3) => {
        i = l3 ? zi(i, l3) : null, r(), r = mr2;
      });
      try {
        for (;; ) {
          let l3 = e.destroyed ? null : e.read();
          if (l3 !== null)
            yield l3;
          else {
            if (i)
              throw i;
            if (i === null)
              return;
            await new $s2(n);
          }
        }
      } catch (l3) {
        throw i = zi(i, l3), i;
      } finally {
        (i || t?.destroyOnReturn !== false) && (i === undefined || e._readableState.autoDestroy) ? Ue.destroyer(e, null) : (e.off("readable", n), o2());
      }
    }
    Ji2(g3.prototype, { readable: { __proto__: null, get() {
      let e = this._readableState;
      return !!e && e.readable !== false && !e.destroyed && !e.errorEmitted && !e.endEmitted;
    }, set(e) {
      this._readableState && (this._readableState.readable = !!e);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    Ji2(Ir2.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[xe] !== false;
    }, set(e) {
      this[xe] = !!e;
    } } });
    g3._fromList = oo;
    function oo(e, t) {
      if (t.length === 0)
        return null;
      let r;
      return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
    }
    function Rr3(e) {
      let t = e._readableState;
      _3("endReadable", t.endEmitted), t.endEmitted || (t.ended = true, $.nextTick(ya, t, e));
    }
    function ya(e, t) {
      if (_3("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
        if (e.endEmitted = true, t.emit("end"), t.writable && t.allowHalfOpen === false)
          $.nextTick(wa, t);
        else if (e.autoDestroy) {
          let r = t._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && t.destroy();
        }
      }
    }
    function wa(e) {
      e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    g3.from = function(e, t) {
      return oa(g3, e, t);
    };
    var Ar2;
    function lo() {
      return Ar2 === undefined && (Ar2 = {}), Ar2;
    }
    g3.fromWeb = function(e, t) {
      return lo().newStreamReadableFromReadableStream(e, t);
    };
    g3.toWeb = function(e, t) {
      return lo().newReadableStreamFromStreamReadable(e, t);
    };
    g3.wrap = function(e, t) {
      var r, n;
      return new g3({ objectMode: (r = (n = e.readableObjectMode) !== null && n !== undefined ? n : e.objectMode) !== null && r !== undefined ? r : true, ...t, destroy(i, o2) {
        Ue.destroyer(e, i), o2(i);
      } }).wrap(e);
    };
  });
  Cr2 = E4((ad, Eo) => {
    var Re = (se(), pe(k2)), { ArrayPrototypeSlice: ao, Error: ba, FunctionPrototypeSymbolHasInstance: co, ObjectDefineProperty: ho, ObjectDefineProperties: ga, ObjectSetPrototypeOf: po, StringPrototypeToLowerCase: _a, Symbol: Ea, SymbolHasInstance: Sa } = I2();
    Eo.exports = m3;
    m3.WritableState = Je;
    var { EventEmitter: ma } = Et(), ze = xt2().Stream, { Buffer: Ft2 } = te(), Ot = Se2(), { addAbortSignal: xa } = At3(), { getHighWaterMark: Ra, getDefaultHighWaterMark: Aa } = Tt2(), { ERR_INVALID_ARG_TYPE: Ia, ERR_METHOD_NOT_IMPLEMENTED: Ta, ERR_MULTIPLE_CALLBACK: yo, ERR_STREAM_CANNOT_PIPE: Ba, ERR_STREAM_DESTROYED: Xe, ERR_STREAM_ALREADY_FINISHED: La, ERR_STREAM_NULL_VALUES: Na, ERR_STREAM_WRITE_AFTER_END: Fa, ERR_UNKNOWN_ENCODING: wo } = C2().codes, { errorOrDestroy: ve } = Ot;
    po(m3.prototype, ze.prototype);
    po(m3, ze);
    function Lr() {}
    var qe2 = Ea("kOnFinished");
    function Je(e, t, r) {
      typeof r != "boolean" && (r = t instanceof J()), this.objectMode = !!(e && e.objectMode), r && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? Ra(this, e, "writableHighWaterMark", r) : Aa(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let n = !!(e && e.decodeStrings === false);
      this.decodeStrings = !n, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = Ca.bind(undefined, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, Ct(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !e || e.emitClose !== false, this.autoDestroy = !e || e.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[qe2] = [];
    }
    function Ct(e) {
      e.buffered = [], e.bufferedIndex = 0, e.allBuffers = true, e.allNoop = true;
    }
    Je.prototype.getBuffer = function() {
      return ao(this.buffered, this.bufferedIndex);
    };
    ho(Je.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function m3(e) {
      let t = this instanceof J();
      if (!t && !co(m3, this))
        return new m3(e);
      this._writableState = new Je(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && xa(e.signal, this)), ze.call(this, e), Ot.construct(this, () => {
        let r = this._writableState;
        r.writing || Fr2(this, r), Mr(this, r);
      });
    }
    ho(m3, Sa, { __proto__: null, value: function(e) {
      return co(this, e) ? true : this !== m3 ? false : e && e._writableState instanceof Je;
    } });
    m3.prototype.pipe = function() {
      ve(this, new Ba);
    };
    function bo(e, t, r, n) {
      let i = e._writableState;
      if (typeof r == "function")
        n = r, r = i.defaultEncoding;
      else {
        if (!r)
          r = i.defaultEncoding;
        else if (r !== "buffer" && !Ft2.isEncoding(r))
          throw new wo(r);
        typeof n != "function" && (n = Lr);
      }
      if (t === null)
        throw new Na;
      if (!i.objectMode)
        if (typeof t == "string")
          i.decodeStrings !== false && (t = Ft2.from(t, r), r = "buffer");
        else if (t instanceof Ft2)
          r = "buffer";
        else if (ze._isUint8Array(t))
          t = ze._uint8ArrayToBuffer(t), r = "buffer";
        else
          throw new Ia("chunk", ["string", "Buffer", "Uint8Array"], t);
      let o2;
      return i.ending ? o2 = new Fa : i.destroyed && (o2 = new Xe("write")), o2 ? (Re.nextTick(n, o2), ve(e, o2, true), o2) : (i.pendingcb++, Ma(e, i, t, r, n));
    }
    m3.prototype.write = function(e, t, r) {
      return bo(this, e, t, r) === true;
    };
    m3.prototype.cork = function() {
      this._writableState.corked++;
    };
    m3.prototype.uncork = function() {
      let e = this._writableState;
      e.corked && (e.corked--, e.writing || Fr2(this, e));
    };
    m3.prototype.setDefaultEncoding = function(t) {
      if (typeof t == "string" && (t = _a(t)), !Ft2.isEncoding(t))
        throw new wo(t);
      return this._writableState.defaultEncoding = t, this;
    };
    function Ma(e, t, r, n, i) {
      let o2 = t.objectMode ? 1 : r.length;
      t.length += o2;
      let l3 = t.length < t.highWaterMark;
      return l3 || (t.needDrain = true), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({ chunk: r, encoding: n, callback: i }), t.allBuffers && n !== "buffer" && (t.allBuffers = false), t.allNoop && i !== Lr && (t.allNoop = false)) : (t.writelen = o2, t.writecb = i, t.writing = true, t.sync = true, e._write(r, n, t.onwrite), t.sync = false), l3 && !t.errored && !t.destroyed;
    }
    function fo(e, t, r, n, i, o2, l3) {
      t.writelen = n, t.writecb = l3, t.writing = true, t.sync = true, t.destroyed ? t.onwrite(new Xe("write")) : r ? e._writev(i, t.onwrite) : e._write(i, o2, t.onwrite), t.sync = false;
    }
    function so2(e, t, r, n) {
      --t.pendingcb, n(r), Nr(t), ve(e, r);
    }
    function Ca(e, t) {
      let r = e._writableState, n = r.sync, i = r.writecb;
      if (typeof i != "function") {
        ve(e, new yo);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, t ? (t.stack, r.errored || (r.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), n ? Re.nextTick(so2, e, r, t, i) : so2(e, r, t, i)) : (r.buffered.length > r.bufferedIndex && Fr2(e, r), n ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === i ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: i, stream: e, state: r }, Re.nextTick(Oa, r.afterWriteTickInfo)) : go(e, r, 1, i));
    }
    function Oa({ stream: e, state: t, count: r, cb: n }) {
      return t.afterWriteTickInfo = null, go(e, t, r, n);
    }
    function go(e, t, r, n) {
      for (!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = false, e.emit("drain"));r-- > 0; )
        t.pendingcb--, n();
      t.destroyed && Nr(t), Mr(e, t);
    }
    function Nr(e) {
      if (e.writing)
        return;
      for (let i = e.bufferedIndex;i < e.buffered.length; ++i) {
        var t;
        let { chunk: o2, callback: l3 } = e.buffered[i], u2 = e.objectMode ? 1 : o2.length;
        e.length -= u2, l3((t = e.errored) !== null && t !== undefined ? t : new Xe("write"));
      }
      let r = e[qe2].splice(0);
      for (let i = 0;i < r.length; i++) {
        var n;
        r[i]((n = e.errored) !== null && n !== undefined ? n : new Xe("end"));
      }
      Ct(e);
    }
    function Fr2(e, t) {
      if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed)
        return;
      let { buffered: r, bufferedIndex: n, objectMode: i } = t, o2 = r.length - n;
      if (!o2)
        return;
      let l3 = n;
      if (t.bufferProcessing = true, o2 > 1 && e._writev) {
        t.pendingcb -= o2 - 1;
        let u2 = t.allNoop ? Lr : (s2) => {
          for (let d3 = l3;d3 < r.length; ++d3)
            r[d3].callback(s2);
        }, f2 = t.allNoop && l3 === 0 ? r : ao(r, l3);
        f2.allBuffers = t.allBuffers, fo(e, t, true, t.length, f2, "", u2), Ct(t);
      } else {
        do {
          let { chunk: u2, encoding: f2, callback: s2 } = r[l3];
          r[l3++] = null;
          let d3 = i ? 1 : u2.length;
          fo(e, t, false, d3, u2, f2, s2);
        } while (l3 < r.length && !t.writing);
        l3 === r.length ? Ct(t) : l3 > 256 ? (r.splice(0, l3), t.bufferedIndex = 0) : t.bufferedIndex = l3;
      }
      t.bufferProcessing = false;
    }
    m3.prototype._write = function(e, t, r) {
      if (this._writev)
        this._writev([{ chunk: e, encoding: t }], r);
      else
        throw new Ta("_write()");
    };
    m3.prototype._writev = null;
    m3.prototype.end = function(e, t, r) {
      let n = this._writableState;
      typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null);
      let i;
      if (e != null) {
        let o2 = bo(this, e, t);
        o2 instanceof ba && (i = o2);
      }
      return n.corked && (n.corked = 1, this.uncork()), i || (!n.errored && !n.ending ? (n.ending = true, Mr(this, n, true), n.ended = true) : n.finished ? i = new La("end") : n.destroyed && (i = new Xe("end"))), typeof r == "function" && (i || n.finished ? Re.nextTick(r, i) : n[qe2].push(r)), this;
    };
    function Mt(e) {
      return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function Da(e, t) {
      let r = false;
      function n(i) {
        if (r) {
          ve(e, i ?? yo());
          return;
        }
        if (r = true, t.pendingcb--, i) {
          let o2 = t[qe2].splice(0);
          for (let l3 = 0;l3 < o2.length; l3++)
            o2[l3](i);
          ve(e, i, t.sync);
        } else
          Mt(t) && (t.prefinished = true, e.emit("prefinish"), t.pendingcb++, Re.nextTick(Br2, e, t));
      }
      t.sync = true, t.pendingcb++;
      try {
        e._final(n);
      } catch (i) {
        n(i);
      }
      t.sync = false;
    }
    function Pa(e, t) {
      !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = true, Da(e, t)) : (t.prefinished = true, e.emit("prefinish")));
    }
    function Mr(e, t, r) {
      Mt(t) && (Pa(e, t), t.pendingcb === 0 && (r ? (t.pendingcb++, Re.nextTick((n, i) => {
        Mt(i) ? Br2(n, i) : i.pendingcb--;
      }, e, t)) : Mt(t) && (t.pendingcb++, Br2(e, t))));
    }
    function Br2(e, t) {
      t.pendingcb--, t.finished = true;
      let r = t[qe2].splice(0);
      for (let n = 0;n < r.length; n++)
        r[n]();
      if (e.emit("finish"), t.autoDestroy) {
        let n = e._readableState;
        (!n || n.autoDestroy && (n.endEmitted || n.readable === false)) && e.destroy();
      }
    }
    ga(m3.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(e) {
      this._writableState && (this._writableState.destroyed = e);
    } }, writable: { __proto__: null, get() {
      let e = this._writableState;
      return !!e && e.writable !== false && !e.destroyed && !e.errored && !e.ending && !e.ended;
    }, set(e) {
      this._writableState && (this._writableState.writable = !!e);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let e = this._writableState;
      return e ? !e.destroyed && !e.ending && e.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var ka = Ot.destroy;
    m3.prototype.destroy = function(e, t) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[qe2].length) && Re.nextTick(Nr, r), ka.call(this, e, t), this;
    };
    m3.prototype._undestroy = Ot.undestroy;
    m3.prototype._destroy = function(e, t) {
      t(e);
    };
    m3.prototype[ma.captureRejectionSymbol] = function(e) {
      this.destroy(e);
    };
    var Tr;
    function _o() {
      return Tr === undefined && (Tr = {}), Tr;
    }
    m3.fromWeb = function(e, t) {
      return _o().newStreamWritableFromWritableStream(e, t);
    };
    m3.toWeb = function(e) {
      return _o().newWritableStreamFromStreamWritable(e);
    };
  });
  Mo = E4((cd, Fo) => {
    var Or = (se(), pe(k2)), Ua = te(), { isReadable: va, isWritable: qa, isIterable: So, isNodeStream: Wa, isReadableNodeStream: mo, isWritableNodeStream: xo, isDuplexNodeStream: $a } = ae(), Ro = ce2(), { AbortError: No, codes: { ERR_INVALID_ARG_TYPE: ja, ERR_INVALID_RETURN_VALUE: Ao } } = C2(), { destroyer: We2 } = Se2(), Ga = J(), Ha = Ke(), { createDeferredPromise: Io } = V3(), To = Er3(), Bo = globalThis.Blob || Ua.Blob, Va = typeof Bo < "u" ? function(t) {
      return t instanceof Bo;
    } : function(t) {
      return false;
    }, Ya = globalThis.AbortController || ut().AbortController, { FunctionPrototypeCall: Lo } = I2(), Ae2 = class extends Ga {
      constructor(t) {
        super(t), t?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Fo.exports = function e(t, r) {
      if ($a(t))
        return t;
      if (mo(t))
        return Dt2({ readable: t });
      if (xo(t))
        return Dt2({ writable: t });
      if (Wa(t))
        return Dt2({ writable: false, readable: false });
      if (typeof t == "function") {
        let { value: i, write: o2, final: l3, destroy: u2 } = Ka(t);
        if (So(i))
          return To(Ae2, i, { objectMode: true, write: o2, final: l3, destroy: u2 });
        let f2 = i?.then;
        if (typeof f2 == "function") {
          let s2, d3 = Lo(f2, i, (c2) => {
            if (c2 != null)
              throw new Ao("nully", "body", c2);
          }, (c2) => {
            We2(s2, c2);
          });
          return s2 = new Ae2({ objectMode: true, readable: false, write: o2, final(c2) {
            l3(async () => {
              try {
                await d3, Or.nextTick(c2, null);
              } catch (y3) {
                Or.nextTick(c2, y3);
              }
            });
          }, destroy: u2 });
        }
        throw new Ao("Iterable, AsyncIterable or AsyncFunction", r, i);
      }
      if (Va(t))
        return e(t.arrayBuffer());
      if (So(t))
        return To(Ae2, t, { objectMode: true, writable: false });
      if (typeof t?.writable == "object" || typeof t?.readable == "object") {
        let i = t != null && t.readable ? mo(t?.readable) ? t?.readable : e(t.readable) : undefined, o2 = t != null && t.writable ? xo(t?.writable) ? t?.writable : e(t.writable) : undefined;
        return Dt2({ readable: i, writable: o2 });
      }
      let n = t?.then;
      if (typeof n == "function") {
        let i;
        return Lo(n, t, (o2) => {
          o2 != null && i.push(o2), i.push(null);
        }, (o2) => {
          We2(i, o2);
        }), i = new Ae2({ objectMode: true, writable: false, read() {} });
      }
      throw new ja(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], t);
    };
    function Ka(e) {
      let { promise: t, resolve: r } = Io(), n = new Ya, i = n.signal;
      return { value: e(async function* () {
        for (;; ) {
          let l3 = t;
          t = null;
          let { chunk: u2, done: f2, cb: s2 } = await l3;
          if (Or.nextTick(s2), f2)
            return;
          if (i.aborted)
            throw new No(undefined, { cause: i.reason });
          ({ promise: t, resolve: r } = Io()), yield u2;
        }
      }(), { signal: i }), write(l3, u2, f2) {
        let s2 = r;
        r = null, s2({ chunk: l3, done: false, cb: f2 });
      }, final(l3) {
        let u2 = r;
        r = null, u2({ done: true, cb: l3 });
      }, destroy(l3, u2) {
        n.abort(), u2(l3);
      } };
    }
    function Dt2(e) {
      let t = e.readable && typeof e.readable.read != "function" ? Ha.wrap(e.readable) : e.readable, r = e.writable, n = !!va(t), i = !!qa(r), o2, l3, u2, f2, s2;
      function d3(c2) {
        let y3 = f2;
        f2 = null, y3 ? y3(c2) : c2 ? s2.destroy(c2) : !n && !i && s2.destroy();
      }
      return s2 = new Ae2({ readableObjectMode: !!(t != null && t.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: n, writable: i }), i && (Ro(r, (c2) => {
        i = false, c2 && We2(t, c2), d3(c2);
      }), s2._write = function(c2, y3, h3) {
        r.write(c2, y3) ? h3() : o2 = h3;
      }, s2._final = function(c2) {
        r.end(), l3 = c2;
      }, r.on("drain", function() {
        if (o2) {
          let c2 = o2;
          o2 = null, c2();
        }
      }), r.on("finish", function() {
        if (l3) {
          let c2 = l3;
          l3 = null, c2();
        }
      })), n && (Ro(t, (c2) => {
        n = false, c2 && We2(t, c2), d3(c2);
      }), t.on("readable", function() {
        if (u2) {
          let c2 = u2;
          u2 = null, c2();
        }
      }), t.on("end", function() {
        s2.push(null);
      }), s2._read = function() {
        for (;; ) {
          let c2 = t.read();
          if (c2 === null) {
            u2 = s2._read;
            return;
          }
          if (!s2.push(c2))
            return;
        }
      }), s2._destroy = function(c2, y3) {
        !c2 && f2 !== null && (c2 = new No), u2 = null, o2 = null, l3 = null, f2 === null ? y3(c2) : (f2 = y3, We2(r, c2), We2(t, c2));
      }, s2;
    }
  });
  J = E4((dd, Do) => {
    var { ObjectDefineProperties: za, ObjectGetOwnPropertyDescriptor: ie, ObjectKeys: Xa, ObjectSetPrototypeOf: Co } = I2();
    Do.exports = j3;
    var kr = Ke(), U2 = Cr2();
    Co(j3.prototype, kr.prototype);
    Co(j3, kr);
    {
      let e = Xa(U2.prototype);
      for (let t = 0;t < e.length; t++) {
        let r = e[t];
        j3.prototype[r] || (j3.prototype[r] = U2.prototype[r]);
      }
    }
    function j3(e) {
      if (!(this instanceof j3))
        return new j3(e);
      kr.call(this, e), U2.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== false, e.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    za(j3.prototype, { writable: { __proto__: null, ...ie(U2.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...ie(U2.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...ie(U2.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...ie(U2.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...ie(U2.prototype, "writableLength") }, writableFinished: { __proto__: null, ...ie(U2.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...ie(U2.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...ie(U2.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...ie(U2.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(e) {
      this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } } });
    var Dr2;
    function Oo() {
      return Dr2 === undefined && (Dr2 = {}), Dr2;
    }
    j3.fromWeb = function(e, t) {
      return Oo().newStreamDuplexFromReadableWritablePair(e, t);
    };
    j3.toWeb = function(e) {
      return Oo().newReadableWritablePairFromDuplex(e);
    };
    var Pr;
    j3.from = function(e) {
      return Pr || (Pr = Mo()), Pr(e, "body");
    };
  });
  qr2 = E4((hd, ko) => {
    var { ObjectSetPrototypeOf: Po, Symbol: Ja } = I2();
    ko.exports = oe3;
    var { ERR_METHOD_NOT_IMPLEMENTED: Qa } = C2().codes, vr3 = J(), { getHighWaterMark: Za } = Tt2();
    Po(oe3.prototype, vr3.prototype);
    Po(oe3, vr3);
    var Qe2 = Ja("kCallback");
    function oe3(e) {
      if (!(this instanceof oe3))
        return new oe3(e);
      let t = e ? Za(this, e, "readableHighWaterMark", true) : null;
      t === 0 && (e = { ...e, highWaterMark: null, readableHighWaterMark: t, writableHighWaterMark: e.writableHighWaterMark || 0 }), vr3.call(this, e), this._readableState.sync = false, this[Qe2] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ec);
    }
    function Ur2(e) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((t, r) => {
        if (t) {
          e ? e(t) : this.destroy(t);
          return;
        }
        r != null && this.push(r), this.push(null), e && e();
      }) : (this.push(null), e && e());
    }
    function ec() {
      this._final !== Ur2 && Ur2.call(this);
    }
    oe3.prototype._final = Ur2;
    oe3.prototype._transform = function(e, t, r) {
      throw new Qa("_transform()");
    };
    oe3.prototype._write = function(e, t, r) {
      let n = this._readableState, i = this._writableState, o2 = n.length;
      this._transform(e, t, (l3, u2) => {
        if (l3) {
          r(l3);
          return;
        }
        u2 != null && this.push(u2), i.ended || o2 === n.length || n.length < n.highWaterMark ? r() : this[Qe2] = r;
      });
    };
    oe3.prototype._read = function() {
      if (this[Qe2]) {
        let e = this[Qe2];
        this[Qe2] = null, e();
      }
    };
  });
  $r2 = E4((pd, vo) => {
    var { ObjectSetPrototypeOf: Uo } = I2();
    vo.exports = $e2;
    var Wr = qr2();
    Uo($e2.prototype, Wr.prototype);
    Uo($e2, Wr);
    function $e2(e) {
      if (!(this instanceof $e2))
        return new $e2(e);
      Wr.call(this, e);
    }
    $e2.prototype._transform = function(e, t, r) {
      r(null, e);
    };
  });
  Ut = E4((yd, Vo) => {
    var Pt = (se(), pe(k2)), { ArrayIsArray: tc, Promise: rc, SymbolAsyncIterator: nc } = I2(), kt = ce2(), { once: ic } = V3(), oc = Se2(), qo = J(), { aggregateTwoErrors: lc, codes: { ERR_INVALID_ARG_TYPE: Go, ERR_INVALID_RETURN_VALUE: jr, ERR_MISSING_ARGS: uc, ERR_STREAM_DESTROYED: fc, ERR_STREAM_PREMATURE_CLOSE: sc }, AbortError: ac } = C2(), { validateFunction: cc, validateAbortSignal: dc } = He2(), { isIterable: je, isReadable: Gr2, isReadableNodeStream: Yr, isNodeStream: Wo } = ae(), hc = globalThis.AbortController || ut().AbortController, Hr, Vr;
    function $o(e, t, r) {
      let n = false;
      e.on("close", () => {
        n = true;
      });
      let i = kt(e, { readable: t, writable: r }, (o2) => {
        n = !o2;
      });
      return { destroy: (o2) => {
        n || (n = true, oc.destroyer(e, o2 || new fc("pipe")));
      }, cleanup: i };
    }
    function pc(e) {
      return cc(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function yc(e) {
      if (je(e))
        return e;
      if (Yr(e))
        return wc(e);
      throw new Go("val", ["Readable", "Iterable", "AsyncIterable"], e);
    }
    async function* wc(e) {
      Vr || (Vr = Ke()), yield* Vr.prototype[nc].call(e);
    }
    async function jo(e, t, r, { end: n }) {
      let i, o2 = null, l3 = (s2) => {
        if (s2 && (i = s2), o2) {
          let d3 = o2;
          o2 = null, d3();
        }
      }, u2 = () => new rc((s2, d3) => {
        i ? d3(i) : o2 = () => {
          i ? d3(i) : s2();
        };
      });
      t.on("drain", l3);
      let f2 = kt(t, { readable: false }, l3);
      try {
        t.writableNeedDrain && await u2();
        for await (let s2 of e)
          t.write(s2) || await u2();
        n && t.end(), await u2(), r();
      } catch (s2) {
        r(i !== s2 ? lc(i, s2) : s2);
      } finally {
        f2(), t.off("drain", l3);
      }
    }
    function bc(...e) {
      return Ho(e, ic(pc(e)));
    }
    function Ho(e, t, r) {
      if (e.length === 1 && tc(e[0]) && (e = e[0]), e.length < 2)
        throw new uc("streams");
      let n = new hc, i = n.signal, o2 = r?.signal, l3 = [];
      dc(o2, "options.signal");
      function u2() {
        h3(new ac);
      }
      o2?.addEventListener("abort", u2);
      let f2, s2, d3 = [], c2 = 0;
      function y3(w2) {
        h3(w2, --c2 === 0);
      }
      function h3(w2, b5) {
        if (w2 && (!f2 || f2.code === "ERR_STREAM_PREMATURE_CLOSE") && (f2 = w2), !(!f2 && !b5)) {
          for (;d3.length; )
            d3.shift()(f2);
          o2?.removeEventListener("abort", u2), n.abort(), b5 && (f2 || l3.forEach((L3) => L3()), Pt.nextTick(t, f2, s2));
        }
      }
      let p3;
      for (let w2 = 0;w2 < e.length; w2++) {
        let b5 = e[w2], L3 = w2 < e.length - 1, N4 = w2 > 0, Q3 = L3 || r?.end !== false, Ie = w2 === e.length - 1;
        if (Wo(b5)) {
          let q = function(Z) {
            Z && Z.name !== "AbortError" && Z.code !== "ERR_STREAM_PREMATURE_CLOSE" && y3(Z);
          };
          var v2 = q;
          if (Q3) {
            let { destroy: Z, cleanup: qt2 } = $o(b5, L3, N4);
            d3.push(Z), Gr2(b5) && Ie && l3.push(qt2);
          }
          b5.on("error", q), Gr2(b5) && Ie && l3.push(() => {
            b5.removeListener("error", q);
          });
        }
        if (w2 === 0)
          if (typeof b5 == "function") {
            if (p3 = b5({ signal: i }), !je(p3))
              throw new jr("Iterable, AsyncIterable or Stream", "source", p3);
          } else
            je(b5) || Yr(b5) ? p3 = b5 : p3 = qo.from(b5);
        else if (typeof b5 == "function")
          if (p3 = yc(p3), p3 = b5(p3, { signal: i }), L3) {
            if (!je(p3, true))
              throw new jr("AsyncIterable", `transform[${w2 - 1}]`, p3);
          } else {
            var B2;
            Hr || (Hr = $r2());
            let q = new Hr({ objectMode: true }), Z = (B2 = p3) === null || B2 === undefined ? undefined : B2.then;
            if (typeof Z == "function")
              c2++, Z.call(p3, (Te) => {
                s2 = Te, Te != null && q.write(Te), Q3 && q.end(), Pt.nextTick(y3);
              }, (Te) => {
                q.destroy(Te), Pt.nextTick(y3, Te);
              });
            else if (je(p3, true))
              c2++, jo(p3, q, y3, { end: Q3 });
            else
              throw new jr("AsyncIterable or Promise", "destination", p3);
            p3 = q;
            let { destroy: qt2, cleanup: sl } = $o(p3, false, true);
            d3.push(qt2), Ie && l3.push(sl);
          }
        else if (Wo(b5)) {
          if (Yr(p3)) {
            c2 += 2;
            let q = gc(p3, b5, y3, { end: Q3 });
            Gr2(b5) && Ie && l3.push(q);
          } else if (je(p3))
            c2++, jo(p3, b5, y3, { end: Q3 });
          else
            throw new Go("val", ["Readable", "Iterable", "AsyncIterable"], p3);
          p3 = b5;
        } else
          p3 = qo.from(b5);
      }
      return (i != null && i.aborted || o2 != null && o2.aborted) && Pt.nextTick(u2), p3;
    }
    function gc(e, t, r, { end: n }) {
      let i = false;
      return t.on("close", () => {
        i || r(new sc);
      }), e.pipe(t, { end: n }), n ? e.once("end", () => {
        i = true, t.end();
      }) : r(), kt(e, { readable: true, writable: false }, (o2) => {
        let l3 = e._readableState;
        o2 && o2.code === "ERR_STREAM_PREMATURE_CLOSE" && l3 && l3.ended && !l3.errored && !l3.errorEmitted ? e.once("end", r).once("error", r) : r(o2);
      }), kt(t, { readable: false, writable: true }, r);
    }
    Vo.exports = { pipelineImpl: Ho, pipeline: bc };
  });
  Jo = E4((wd, Xo) => {
    var { pipeline: _c } = Ut(), vt = J(), { destroyer: Ec } = Se2(), { isNodeStream: Sc, isReadable: Yo, isWritable: Ko } = ae(), { AbortError: mc, codes: { ERR_INVALID_ARG_VALUE: zo, ERR_MISSING_ARGS: xc } } = C2();
    Xo.exports = function(...t) {
      if (t.length === 0)
        throw new xc("streams");
      if (t.length === 1)
        return vt.from(t[0]);
      let r = [...t];
      if (typeof t[0] == "function" && (t[0] = vt.from(t[0])), typeof t[t.length - 1] == "function") {
        let h3 = t.length - 1;
        t[h3] = vt.from(t[h3]);
      }
      for (let h3 = 0;h3 < t.length; ++h3)
        if (!!Sc(t[h3])) {
          if (h3 < t.length - 1 && !Yo(t[h3]))
            throw new zo(`streams[${h3}]`, r[h3], "must be readable");
          if (h3 > 0 && !Ko(t[h3]))
            throw new zo(`streams[${h3}]`, r[h3], "must be writable");
        }
      let n, i, o2, l3, u2;
      function f2(h3) {
        let p3 = l3;
        l3 = null, p3 ? p3(h3) : h3 ? u2.destroy(h3) : !y3 && !c2 && u2.destroy();
      }
      let s2 = t[0], d3 = _c(t, f2), c2 = !!Ko(s2), y3 = !!Yo(d3);
      return u2 = new vt({ writableObjectMode: !!(s2 != null && s2.writableObjectMode), readableObjectMode: !!(d3 != null && d3.writableObjectMode), writable: c2, readable: y3 }), c2 && (u2._write = function(h3, p3, B2) {
        s2.write(h3, p3) ? B2() : n = B2;
      }, u2._final = function(h3) {
        s2.end(), i = h3;
      }, s2.on("drain", function() {
        if (n) {
          let h3 = n;
          n = null, h3();
        }
      }), d3.on("finish", function() {
        if (i) {
          let h3 = i;
          i = null, h3();
        }
      })), y3 && (d3.on("readable", function() {
        if (o2) {
          let h3 = o2;
          o2 = null, h3();
        }
      }), d3.on("end", function() {
        u2.push(null);
      }), u2._read = function() {
        for (;; ) {
          let h3 = d3.read();
          if (h3 === null) {
            o2 = u2._read;
            return;
          }
          if (!u2.push(h3))
            return;
        }
      }), u2._destroy = function(h3, p3) {
        !h3 && l3 !== null && (h3 = new mc), o2 = null, n = null, i = null, l3 === null ? p3(h3) : (l3 = p3, Ec(d3, h3));
      }, u2;
    };
  });
  Kr2 = E4((bd, Qo) => {
    var { ArrayPrototypePop: Rc, Promise: Ac } = I2(), { isIterable: Ic, isNodeStream: Tc } = ae(), { pipelineImpl: Bc } = Ut(), { finished: Lc } = ce2();
    function Nc(...e) {
      return new Ac((t, r) => {
        let n, i, o2 = e[e.length - 1];
        if (o2 && typeof o2 == "object" && !Tc(o2) && !Ic(o2)) {
          let l3 = Rc(e);
          n = l3.signal, i = l3.end;
        }
        Bc(e, (l3, u2) => {
          l3 ? r(l3) : t(u2);
        }, { signal: n, end: i });
      });
    }
    Qo.exports = { finished: Lc, pipeline: Nc };
  });
  fl = E4((gd, ul) => {
    var { Buffer: Fc } = te(), { ObjectDefineProperty: le, ObjectKeys: tl, ReflectApply: rl } = I2(), { promisify: { custom: nl } } = V3(), { streamReturningOperators: Zo, promiseReturningOperators: el } = di2(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: il } } = C2(), Mc = Jo(), { pipeline: ol } = Ut(), { destroyer: Cc } = Se2(), ll = ce2(), zr = Kr2(), Xr = ae(), R2 = ul.exports = xt2().Stream;
    R2.isDisturbed = Xr.isDisturbed;
    R2.isErrored = Xr.isErrored;
    R2.isReadable = Xr.isReadable;
    R2.Readable = Ke();
    for (let e of tl(Zo)) {
      let r = function(...n) {
        if (new.target)
          throw il();
        return R2.Readable.from(rl(t, this, n));
      };
      Dc = r;
      let t = Zo[e];
      le(r, "name", { __proto__: null, value: t.name }), le(r, "length", { __proto__: null, value: t.length }), le(R2.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    for (let e of tl(el)) {
      let r = function(...i) {
        if (new.target)
          throw il();
        return rl(t, this, i);
      };
      Dc = r;
      let t = el[e];
      le(r, "name", { __proto__: null, value: t.name }), le(r, "length", { __proto__: null, value: t.length }), le(R2.Readable.prototype, e, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var Dc;
    R2.Writable = Cr2();
    R2.Duplex = J();
    R2.Transform = qr2();
    R2.PassThrough = $r2();
    R2.pipeline = ol;
    var { addAbortSignal: Oc } = At3();
    R2.addAbortSignal = Oc;
    R2.finished = ll;
    R2.destroy = Cc;
    R2.compose = Mc;
    le(R2, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return zr;
    } });
    le(ol, nl, { __proto__: null, enumerable: true, get() {
      return zr.pipeline;
    } });
    le(ll, nl, { __proto__: null, enumerable: true, get() {
      return zr.finished;
    } });
    R2.Stream = R2;
    R2._isUint8Array = function(t) {
      return t instanceof Uint8Array;
    };
    R2._uint8ArrayToBuffer = function(t) {
      return Fc.from(t.buffer, t.byteOffset, t.byteLength);
    };
  });
  Jr = E4((_d, A3) => {
    var T = fl(), Pc = Kr2(), kc = T.Readable.destroy;
    A3.exports = T.Readable;
    A3.exports._uint8ArrayToBuffer = T._uint8ArrayToBuffer;
    A3.exports._isUint8Array = T._isUint8Array;
    A3.exports.isDisturbed = T.isDisturbed;
    A3.exports.isErrored = T.isErrored;
    A3.exports.isReadable = T.isReadable;
    A3.exports.Readable = T.Readable;
    A3.exports.Writable = T.Writable;
    A3.exports.Duplex = T.Duplex;
    A3.exports.Transform = T.Transform;
    A3.exports.PassThrough = T.PassThrough;
    A3.exports.addAbortSignal = T.addAbortSignal;
    A3.exports.finished = T.finished;
    A3.exports.destroy = T.destroy;
    A3.exports.destroy = kc;
    A3.exports.pipeline = T.pipeline;
    A3.exports.compose = T.compose;
    Object.defineProperty(T, "promises", { configurable: true, enumerable: true, get() {
      return Pc;
    } });
    A3.exports.Stream = T.Stream;
    A3.exports.default = A3.exports;
  });
  Ze = {};
  Qr(Ze, { default: () => Uc });
  ue3(Ze, rt2(Jr()));
  Uc = rt2(Jr());
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/fastify/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var {
    kSchemaHeaders: headersSchema,
    kSchemaParams: paramsSchema,
    kSchemaQuerystring: querystringSchema,
    kSchemaBody: bodySchema,
    kSchemaResponse: responseSchema
  } = require_symbols2();
  var scChecker = /^[1-5](?:\d{2}|xx)$|^default$/;
  var {
    FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX
  } = require_errors2();
  var { FSTWRN001 } = require_warnings();
  function compileSchemasForSerialization(context, compile) {
    if (!context.schema || !context.schema.response) {
      return;
    }
    const { method, url } = context.config || {};
    context[responseSchema] = Object.keys(context.schema.response).reduce(function(acc, statusCode) {
      const schema = context.schema.response[statusCode];
      statusCode = statusCode.toLowerCase();
      if (!scChecker.test(statusCode)) {
        throw new FST_ERR_SCH_RESPONSE_SCHEMA_NOT_NESTED_2XX;
      }
      if (schema.content) {
        const contentTypesSchemas = {};
        for (const mediaName of Object.keys(schema.content)) {
          const contentSchema = schema.content[mediaName].schema;
          contentTypesSchemas[mediaName] = compile({
            schema: contentSchema,
            url,
            method,
            httpStatus: statusCode,
            contentType: mediaName
          });
        }
        acc[statusCode] = contentTypesSchemas;
      } else {
        acc[statusCode] = compile({
          schema,
          url,
          method,
          httpStatus: statusCode
        });
      }
      return acc;
    }, {});
  }
  function compileSchemasForValidation(context, compile, isCustom) {
    const { schema } = context;
    if (!schema) {
      return;
    }
    const { method, url } = context.config || {};
    const headers = schema.headers;
    if (headers && (isCustom || Object.getPrototypeOf(headers) !== Object.prototype)) {
      context[headersSchema] = compile({ schema: headers, method, url, httpPart: "headers" });
    } else if (headers) {
      const headersSchemaLowerCase = {};
      Object.keys(headers).forEach((k3) => {
        headersSchemaLowerCase[k3] = headers[k3];
      });
      if (headersSchemaLowerCase.required instanceof Array) {
        headersSchemaLowerCase.required = headersSchemaLowerCase.required.map((h3) => h3.toLowerCase());
      }
      if (headers.properties) {
        headersSchemaLowerCase.properties = {};
        Object.keys(headers.properties).forEach((k3) => {
          headersSchemaLowerCase.properties[k3.toLowerCase()] = headers.properties[k3];
        });
      }
      context[headersSchema] = compile({ schema: headersSchemaLowerCase, method, url, httpPart: "headers" });
    } else if (Object.hasOwn(schema, "headers")) {
      FSTWRN001("headers", method, url);
    }
    if (schema.body) {
      const contentProperty = schema.body.content;
      if (contentProperty) {
        const contentTypeSchemas = {};
        for (const contentType of Object.keys(contentProperty)) {
          const contentSchema = contentProperty[contentType].schema;
          contentTypeSchemas[contentType] = compile({ schema: contentSchema, method, url, httpPart: "body", contentType });
        }
        context[bodySchema] = contentTypeSchemas;
      } else {
        context[bodySchema] = compile({ schema: schema.body, method, url, httpPart: "body" });
      }
    } else if (Object.hasOwn(schema, "body")) {
      FSTWRN001("body", method, url);
    }
    if (schema.querystring) {
      context[querystringSchema] = compile({ schema: schema.querystring, method, url, httpPart: "querystring" });
    } else if (Object.hasOwn(schema, "querystring")) {
      FSTWRN001("querystring", method, url);
    }
    if (schema.params) {
      context[paramsSchema] = compile({ schema: schema.params, method, url, httpPart: "params" });
    } else if (Object.hasOwn(schema, "params")) {
      FSTWRN001("params", method, url);
    }
  }
  function validateParam(validatorFunction, request, paramName) {
    const isUndefined = request[paramName] === undefined;
    const ret = validatorFunction && validatorFunction(isUndefined ? null : request[paramName]);
    if (ret && typeof ret.then === "function") {
      return ret.then((res) => {
        return answer(res);
      }).catch((err) => {
        return err;
      });
    }
    return answer(ret);
    function answer(ret2) {
      if (ret2 === false)
        return validatorFunction.errors;
      if (ret2 && ret2.error)
        return ret2.error;
      if (ret2 && ret2.value)
        request[paramName] = ret2.value;
      return false;
    }
  }
  function validate(context, request, execution) {
    const runExecution = execution === undefined;
    if (runExecution || !execution.skipParams) {
      const params = validateParam(context[paramsSchema], request, "params");
      if (params) {
        if (typeof params.then !== "function") {
          return wrapValidationError(params, "params", context.schemaErrorFormatter);
        } else {
          return validateAsyncParams(params, context, request);
        }
      }
    }
    if (runExecution || !execution.skipBody) {
      let validatorFunction = null;
      if (typeof context[bodySchema] === "function") {
        validatorFunction = context[bodySchema];
      } else if (context[bodySchema]) {
        const contentType = getEssenceMediaType(request.headers["content-type"]);
        const contentSchema = context[bodySchema][contentType];
        if (contentSchema) {
          validatorFunction = contentSchema;
        }
      }
      const body = validateParam(validatorFunction, request, "body");
      if (body) {
        if (typeof body.then !== "function") {
          return wrapValidationError(body, "body", context.schemaErrorFormatter);
        } else {
          return validateAsyncBody(body, context, request);
        }
      }
    }
    if (runExecution || !execution.skipQuery) {
      const query = validateParam(context[querystringSchema], request, "query");
      if (query) {
        if (typeof query.then !== "function") {
          return wrapValidationError(query, "querystring", context.schemaErrorFormatter);
        } else {
          return validateAsyncQuery(query, context, request);
        }
      }
    }
    const headers = validateParam(context[headersSchema], request, "headers");
    if (headers) {
      if (typeof headers.then !== "function") {
        return wrapValidationError(headers, "headers", context.schemaErrorFormatter);
      } else {
        return validateAsyncHeaders(headers, context, request);
      }
    }
    return false;
  }
  function validateAsyncParams(validatePromise, context, request) {
    return validatePromise.then((paramsResult) => {
      if (paramsResult) {
        return wrapValidationError(paramsResult, "params", context.schemaErrorFormatter);
      }
      return validate(context, request, { skipParams: true });
    });
  }
  function validateAsyncBody(validatePromise, context, request) {
    return validatePromise.then((bodyResult) => {
      if (bodyResult) {
        return wrapValidationError(bodyResult, "body", context.schemaErrorFormatter);
      }
      return validate(context, request, { skipParams: true, skipBody: true });
    });
  }
  function validateAsyncQuery(validatePromise, context, request) {
    return validatePromise.then((queryResult) => {
      if (queryResult) {
        return wrapValidationError(queryResult, "querystring", context.schemaErrorFormatter);
      }
      return validate(context, request, { skipParams: true, skipBody: true, skipQuery: true });
    });
  }
  function validateAsyncHeaders(validatePromise, context, request) {
    return validatePromise.then((headersResult) => {
      if (headersResult) {
        return wrapValidationError(headersResult, "headers", context.schemaErrorFormatter);
      }
      return false;
    });
  }
  function wrapValidationError(result, dataVar, schemaErrorFormatter) {
    if (result instanceof Error) {
      result.statusCode = result.statusCode || 400;
      result.code = result.code || "FST_ERR_VALIDATION";
      result.validationContext = result.validationContext || dataVar;
      return result;
    }
    const error = schemaErrorFormatter(result, dataVar);
    error.statusCode = error.statusCode || 400;
    error.code = error.code || "FST_ERR_VALIDATION";
    error.validation = result;
    error.validationContext = dataVar;
    return error;
  }
  function getEssenceMediaType(header) {
    if (!header)
      return "";
    return header.split(/[ ;]/, 1)[0].trim().toLowerCase();
  }
  module.exports = {
    symbols: { bodySchema, querystringSchema, responseSchema, paramsSchema, headersSchema },
    compileSchemasForValidation,
    compileSchemasForSerialization,
    validate
  };
});

// node_modules/fastify/lib/wrapThenable.js
var require_wrapThenable = __commonJS((exports, module) => {
  var {
    kReplyIsError,
    kReplyHijacked
  } = require_symbols2();
  var diagnostics = (() => ({}));
  var channels = diagnostics.tracingChannel("fastify.request.handler");
  function wrapThenable(thenable, reply, store) {
    if (store)
      store.async = true;
    thenable.then(function(payload) {
      if (reply[kReplyHijacked] === true) {
        return;
      }
      if (store) {
        channels.asyncStart.publish(store);
      }
      try {
        if (payload !== undefined || reply.sent === false && reply.raw.headersSent === false && reply.request.raw.aborted === false && reply.request.socket && !reply.request.socket.destroyed) {
          try {
            reply.send(payload);
          } catch (err) {
            reply[kReplyIsError] = true;
            reply.send(err);
          }
        }
      } finally {
        if (store) {
          channels.asyncEnd.publish(store);
        }
      }
    }, function(err) {
      if (store) {
        store.error = err;
        channels.error.publish(store);
        channels.asyncStart.publish(store);
      }
      try {
        if (reply.sent === true) {
          reply.log.error({ err }, "Promise errored, but reply.sent = true was set");
          return;
        }
        reply[kReplyIsError] = true;
        reply.send(err);
      } catch (err2) {
        reply.send(err2);
      } finally {
        if (store) {
          channels.asyncEnd.publish(store);
        }
      }
    });
  }
  module.exports = wrapThenable;
});

// node_modules/fastify/lib/handleRequest.js
var require_handleRequest = __commonJS((exports, module) => {
  var diagnostics = (() => ({}));
  var { validate: validateSchema } = require_validation();
  var { preValidationHookRunner, preHandlerHookRunner } = require_hooks();
  var wrapThenable = require_wrapThenable();
  var {
    kReplyIsError,
    kRouteContext,
    kFourOhFourContext,
    kSupportedHTTPMethods
  } = require_symbols2();
  var channels = diagnostics.tracingChannel("fastify.request.handler");
  function handleRequest(err, request, reply) {
    if (reply.sent === true)
      return;
    if (err != null) {
      reply[kReplyIsError] = true;
      reply.send(err);
      return;
    }
    const method = request.method;
    if (this[kSupportedHTTPMethods].bodyless.has(method)) {
      handler(request, reply);
      return;
    }
    if (this[kSupportedHTTPMethods].bodywith.has(method)) {
      const headers = request.headers;
      const contentType = headers["content-type"];
      if (contentType === undefined) {
        const contentLength = headers["content-length"];
        const transferEncoding = headers["transfer-encoding"];
        const isEmptyBody = transferEncoding === undefined && (contentLength === undefined || contentLength === "0");
        if (isEmptyBody) {
          handler(request, reply);
          return;
        }
        request[kRouteContext].contentTypeParser.run("", handler, request, reply);
        return;
      }
      request[kRouteContext].contentTypeParser.run(contentType, handler, request, reply);
      return;
    }
    handler(request, reply);
  }
  function handler(request, reply) {
    try {
      if (request[kRouteContext].preValidation !== null) {
        preValidationHookRunner(request[kRouteContext].preValidation, request, reply, preValidationCallback);
      } else {
        preValidationCallback(null, request, reply);
      }
    } catch (err) {
      preValidationCallback(err, request, reply);
    }
  }
  function preValidationCallback(err, request, reply) {
    if (reply.sent === true)
      return;
    if (err != null) {
      reply[kReplyIsError] = true;
      reply.send(err);
      return;
    }
    const validationErr = validateSchema(reply[kRouteContext], request);
    const isAsync = validationErr && typeof validationErr.then === "function" || false;
    if (isAsync) {
      const cb = validationCompleted.bind(null, request, reply);
      validationErr.then(cb, cb);
    } else {
      validationCompleted(request, reply, validationErr);
    }
  }
  function validationCompleted(request, reply, validationErr) {
    if (validationErr) {
      if (reply[kRouteContext].attachValidation === false) {
        reply.send(validationErr);
        return;
      }
      reply.request.validationError = validationErr;
    }
    if (request[kRouteContext].preHandler !== null) {
      preHandlerHookRunner(request[kRouteContext].preHandler, request, reply, preHandlerCallback);
    } else {
      preHandlerCallback(null, request, reply);
    }
  }
  function preHandlerCallback(err, request, reply) {
    if (reply.sent)
      return;
    const context = request[kRouteContext];
    if (!channels.hasSubscribers || context[kFourOhFourContext] === null) {
      preHandlerCallbackInner(err, request, reply);
    } else {
      const store = {
        request,
        reply,
        async: false,
        route: {
          url: context.config.url,
          method: context.config.method
        }
      };
      channels.start.runStores(store, preHandlerCallbackInner, undefined, err, request, reply, store);
    }
  }
  function preHandlerCallbackInner(err, request, reply, store) {
    const context = request[kRouteContext];
    try {
      if (err != null) {
        reply[kReplyIsError] = true;
        reply.send(err);
        if (store) {
          store.error = err;
          channels.error.publish(store);
        }
        return;
      }
      let result;
      try {
        result = context.handler(request, reply);
      } catch (err2) {
        if (store) {
          store.error = err2;
          channels.error.publish(store);
        }
        reply[kReplyIsError] = true;
        reply.send(err2);
        return;
      }
      if (result !== undefined) {
        if (result !== null && typeof result.then === "function") {
          wrapThenable(result, reply, store);
        } else {
          reply.send(result);
        }
      }
    } finally {
      if (store)
        channels.end.publish(store);
    }
  }
  module.exports = handleRequest;
  module.exports[Symbol.for("internals")] = { handler, preHandlerCallback };
});

// node_modules/abstract-logging/index.js
var require_abstract_logging = __commonJS((exports, module) => {
  function noop() {}
  var proto = {
    fatal: noop,
    error: noop,
    warn: noop,
    info: noop,
    debug: noop,
    trace: noop
  };
  Object.defineProperty(module, "exports", {
    get() {
      return Object.create(proto);
    }
  });
});

// node_modules/quick-format-unescaped/index.js
var require_quick_format_unescaped = __commonJS((exports, module) => {
  function tryStringify(o2) {
    try {
      return JSON.stringify(o2);
    } catch (e) {
      return '"[Circular]"';
    }
  }
  module.exports = format;
  function format(f2, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f2 === "object" && f2 !== null) {
      var len = args.length + offset;
      if (len === 1)
        return f2;
      var objects = new Array(len);
      objects[0] = ss(f2);
      for (var index = 1;index < len; index++) {
        objects[index] = ss(args[index]);
      }
      return objects.join(" ");
    }
    if (typeof f2 !== "string") {
      return f2;
    }
    var argLen = args.length;
    if (argLen === 0)
      return f2;
    var str = "";
    var a3 = 1 - offset;
    var lastPos = -1;
    var flen = f2 && f2.length || 0;
    for (var i = 0;i < flen; ) {
      if (f2.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;
        switch (f2.charCodeAt(i + 1)) {
          case 100:
          case 102:
            if (a3 >= argLen)
              break;
            if (args[a3] == null)
              break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += Number(args[a3]);
            lastPos = i + 2;
            i++;
            break;
          case 105:
            if (a3 >= argLen)
              break;
            if (args[a3] == null)
              break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += Math.floor(Number(args[a3]));
            lastPos = i + 2;
            i++;
            break;
          case 79:
          case 111:
          case 106:
            if (a3 >= argLen)
              break;
            if (args[a3] === undefined)
              break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            var type = typeof args[a3];
            if (type === "string") {
              str += "'" + args[a3] + "'";
              lastPos = i + 2;
              i++;
              break;
            }
            if (type === "function") {
              str += args[a3].name || "<anonymous>";
              lastPos = i + 2;
              i++;
              break;
            }
            str += ss(args[a3]);
            lastPos = i + 2;
            i++;
            break;
          case 115:
            if (a3 >= argLen)
              break;
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += String(args[a3]);
            lastPos = i + 2;
            i++;
            break;
          case 37:
            if (lastPos < i)
              str += f2.slice(lastPos, i);
            str += "%";
            lastPos = i + 2;
            i++;
            a3--;
            break;
        }
        ++a3;
      }
      ++i;
    }
    if (lastPos === -1)
      return f2;
    else if (lastPos < flen) {
      str += f2.slice(lastPos);
    }
    return str;
  }
});

// node_modules/pino/browser.js
var require_browser = __commonJS((exports, module) => {
  var format = require_quick_format_unescaped();
  module.exports = pino;
  var _console = pfGlobalThisOrFallback().console || {};
  var stdSerializers = {
    mapHttpRequest: mock,
    mapHttpResponse: mock,
    wrapRequestSerializer: passthrough,
    wrapResponseSerializer: passthrough,
    wrapErrorSerializer: passthrough,
    req: mock,
    res: mock,
    err: asErrValue,
    errWithCause: asErrValue
  };
  function levelToValue(level, logger) {
    return level === "silent" ? Infinity : logger.levels.values[level];
  }
  var baseLogFunctionSymbol = Symbol("pino.logFuncs");
  var hierarchySymbol = Symbol("pino.hierarchy");
  var logFallbackMap = {
    error: "log",
    fatal: "error",
    warn: "error",
    info: "log",
    debug: "log",
    trace: "log"
  };
  function appendChildLogger(parentLogger, childLogger) {
    const newEntry = {
      logger: childLogger,
      parent: parentLogger[hierarchySymbol]
    };
    childLogger[hierarchySymbol] = newEntry;
  }
  function setupBaseLogFunctions(logger, levels, proto) {
    const logFunctions = {};
    levels.forEach((level) => {
      logFunctions[level] = proto[level] ? proto[level] : _console[level] || _console[logFallbackMap[level] || "log"] || noop;
    });
    logger[baseLogFunctionSymbol] = logFunctions;
  }
  function shouldSerialize(serialize, serializers) {
    if (Array.isArray(serialize)) {
      const hasToFilter = serialize.filter(function(k3) {
        return k3 !== "!stdSerializers.err";
      });
      return hasToFilter;
    } else if (serialize === true) {
      return Object.keys(serializers);
    }
    return false;
  }
  function pino(opts) {
    opts = opts || {};
    opts.browser = opts.browser || {};
    const transmit2 = opts.browser.transmit;
    if (transmit2 && typeof transmit2.send !== "function") {
      throw Error("pino: transmit option must have a send function");
    }
    const proto = opts.browser.write || _console;
    if (opts.browser.write)
      opts.browser.asObject = true;
    const serializers = opts.serializers || {};
    const serialize = shouldSerialize(opts.browser.serialize, serializers);
    let stdErrSerialize = opts.browser.serialize;
    if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
      stdErrSerialize = false;
    const customLevels = Object.keys(opts.customLevels || {});
    const levels = ["error", "fatal", "warn", "info", "debug", "trace"].concat(customLevels);
    if (typeof proto === "function") {
      levels.forEach(function(level2) {
        proto[level2] = proto;
      });
    }
    if (opts.enabled === false || opts.browser.disabled)
      opts.level = "silent";
    const level = opts.level || "info";
    const logger = Object.create(proto);
    if (!logger.log)
      logger.log = noop;
    setupBaseLogFunctions(logger, levels, proto);
    appendChildLogger({}, logger);
    Object.defineProperty(logger, "levelVal", {
      get: getLevelVal
    });
    Object.defineProperty(logger, "level", {
      get: getLevel,
      set: setLevel
    });
    const setOpts = {
      transmit: transmit2,
      serialize,
      asObject: opts.browser.asObject,
      asObjectBindingsOnly: opts.browser.asObjectBindingsOnly,
      formatters: opts.browser.formatters,
      levels,
      timestamp: getTimeFunction(opts),
      messageKey: opts.messageKey || "msg",
      onChild: opts.onChild || noop
    };
    logger.levels = getLevels(opts);
    logger.level = level;
    logger.isLevelEnabled = function(level2) {
      if (!this.levels.values[level2]) {
        return false;
      }
      return this.levels.values[level2] >= this.levels.values[this.level];
    };
    logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
    logger.serializers = serializers;
    logger._serialize = serialize;
    logger._stdErrSerialize = stdErrSerialize;
    logger.child = function(...args) {
      return child.call(this, setOpts, ...args);
    };
    if (transmit2)
      logger._logEvent = createLogEventShape();
    function getLevelVal() {
      return levelToValue(this.level, this);
    }
    function getLevel() {
      return this._level;
    }
    function setLevel(level2) {
      if (level2 !== "silent" && !this.levels.values[level2]) {
        throw Error("unknown level " + level2);
      }
      this._level = level2;
      set(this, setOpts, logger, "error");
      set(this, setOpts, logger, "fatal");
      set(this, setOpts, logger, "warn");
      set(this, setOpts, logger, "info");
      set(this, setOpts, logger, "debug");
      set(this, setOpts, logger, "trace");
      customLevels.forEach((level3) => {
        set(this, setOpts, logger, level3);
      });
    }
    function child(setOpts2, bindings, childOptions) {
      if (!bindings) {
        throw new Error("missing bindings for child Pino");
      }
      childOptions = childOptions || {};
      if (serialize && bindings.serializers) {
        childOptions.serializers = bindings.serializers;
      }
      const childOptionsSerializers = childOptions.serializers;
      if (serialize && childOptionsSerializers) {
        var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
        var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
        delete bindings.serializers;
        applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
      }
      function Child(parent) {
        this._childLevel = (parent._childLevel | 0) + 1;
        this.bindings = bindings;
        if (childSerializers) {
          this.serializers = childSerializers;
          this._serialize = childSerialize;
        }
        if (transmit2) {
          this._logEvent = createLogEventShape([].concat(parent._logEvent.bindings, bindings));
        }
      }
      Child.prototype = this;
      const newLogger = new Child(this);
      appendChildLogger(this, newLogger);
      newLogger.child = function(...args) {
        return child.call(this, setOpts2, ...args);
      };
      newLogger.level = childOptions.level || this.level;
      setOpts2.onChild(newLogger);
      return newLogger;
    }
    return logger;
  }
  function getLevels(opts) {
    const customLevels = opts.customLevels || {};
    const values = Object.assign({}, pino.levels.values, customLevels);
    const labels = Object.assign({}, pino.levels.labels, invertObject(customLevels));
    return {
      values,
      labels
    };
  }
  function invertObject(obj) {
    const inverted = {};
    Object.keys(obj).forEach(function(key) {
      inverted[obj[key]] = key;
    });
    return inverted;
  }
  pino.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: "trace",
      20: "debug",
      30: "info",
      40: "warn",
      50: "error",
      60: "fatal"
    }
  };
  pino.stdSerializers = stdSerializers;
  pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
  function getBindingChain(logger) {
    const bindings = [];
    if (logger.bindings) {
      bindings.push(logger.bindings);
    }
    let hierarchy = logger[hierarchySymbol];
    while (hierarchy.parent) {
      hierarchy = hierarchy.parent;
      if (hierarchy.logger.bindings) {
        bindings.push(hierarchy.logger.bindings);
      }
    }
    return bindings.reverse();
  }
  function set(self2, opts, rootLogger, level) {
    Object.defineProperty(self2, level, {
      value: levelToValue(self2.level, rootLogger) > levelToValue(level, rootLogger) ? noop : rootLogger[baseLogFunctionSymbol][level],
      writable: true,
      enumerable: true,
      configurable: true
    });
    if (self2[level] === noop) {
      if (!opts.transmit)
        return;
      const transmitLevel = opts.transmit.level || self2.level;
      const transmitValue = levelToValue(transmitLevel, rootLogger);
      const methodValue = levelToValue(level, rootLogger);
      if (methodValue < transmitValue)
        return;
    }
    self2[level] = createWrap(self2, opts, rootLogger, level);
    const bindings = getBindingChain(self2);
    if (bindings.length === 0) {
      return;
    }
    self2[level] = prependBindingsInArguments(bindings, self2[level]);
  }
  function prependBindingsInArguments(bindings, logFunc) {
    return function() {
      return logFunc.apply(this, [...bindings, ...arguments]);
    };
  }
  function createWrap(self2, opts, rootLogger, level) {
    return function(write) {
      return function LOG() {
        const ts = opts.timestamp();
        const args = new Array(arguments.length);
        const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
        for (var i = 0;i < args.length; i++)
          args[i] = arguments[i];
        var argsIsSerialized = false;
        if (opts.serialize) {
          applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
          argsIsSerialized = true;
        }
        if (opts.asObject || opts.formatters) {
          write.call(proto, ...asObject(this, level, args, ts, opts));
        } else
          write.apply(proto, args);
        if (opts.transmit) {
          const transmitLevel = opts.transmit.level || self2._level;
          const transmitValue = levelToValue(transmitLevel, rootLogger);
          const methodValue = levelToValue(level, rootLogger);
          if (methodValue < transmitValue)
            return;
          transmit(this, {
            ts,
            methodLevel: level,
            methodValue,
            transmitLevel,
            transmitValue: rootLogger.levels.values[opts.transmit.level || self2._level],
            send: opts.transmit.send,
            val: levelToValue(self2._level, rootLogger)
          }, args, argsIsSerialized);
        }
      };
    }(self2[baseLogFunctionSymbol][level]);
  }
  function asObject(logger, level, args, ts, opts) {
    const {
      level: levelFormatter,
      log: logObjectFormatter = (obj) => obj
    } = opts.formatters || {};
    const argsCloned = args.slice();
    let msg = argsCloned[0];
    const logObject = {};
    let lvl = (logger._childLevel | 0) + 1;
    if (lvl < 1)
      lvl = 1;
    if (ts) {
      logObject.time = ts;
    }
    if (levelFormatter) {
      const formattedLevel = levelFormatter(level, logger.levels.values[level]);
      Object.assign(logObject, formattedLevel);
    } else {
      logObject.level = logger.levels.values[level];
    }
    if (opts.asObjectBindingsOnly) {
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(logObject, argsCloned.shift());
        }
      }
      const formattedLogObject = logObjectFormatter(logObject);
      return [formattedLogObject, ...argsCloned];
    } else {
      if (msg !== null && typeof msg === "object") {
        while (lvl-- && typeof argsCloned[0] === "object") {
          Object.assign(logObject, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : undefined;
      } else if (typeof msg === "string")
        msg = format(argsCloned.shift(), argsCloned);
      if (msg !== undefined)
        logObject[opts.messageKey] = msg;
      const formattedLogObject = logObjectFormatter(logObject);
      return [formattedLogObject];
    }
  }
  function applySerializers(args, serialize, serializers, stdErrSerialize) {
    for (const i in args) {
      if (stdErrSerialize && args[i] instanceof Error) {
        args[i] = pino.stdSerializers.err(args[i]);
      } else if (typeof args[i] === "object" && !Array.isArray(args[i]) && serialize) {
        for (const k3 in args[i]) {
          if (serialize.indexOf(k3) > -1 && k3 in serializers) {
            args[i][k3] = serializers[k3](args[i][k3]);
          }
        }
      }
    }
  }
  function transmit(logger, opts, args, argsIsSerialized = false) {
    const send = opts.send;
    const ts = opts.ts;
    const methodLevel = opts.methodLevel;
    const methodValue = opts.methodValue;
    const val = opts.val;
    const bindings = logger._logEvent.bindings;
    if (!argsIsSerialized) {
      applySerializers(args, logger._serialize || Object.keys(logger.serializers), logger.serializers, logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize);
    }
    logger._logEvent.ts = ts;
    logger._logEvent.messages = args.filter(function(arg) {
      return bindings.indexOf(arg) === -1;
    });
    logger._logEvent.level.label = methodLevel;
    logger._logEvent.level.value = methodValue;
    send(methodLevel, logger._logEvent, val);
    logger._logEvent = createLogEventShape(bindings);
  }
  function createLogEventShape(bindings) {
    return {
      ts: 0,
      messages: [],
      bindings: bindings || [],
      level: { label: "", value: 0 }
    };
  }
  function asErrValue(err) {
    const obj = {
      type: err.constructor.name,
      msg: err.message,
      stack: err.stack
    };
    for (const key in err) {
      if (obj[key] === undefined) {
        obj[key] = err[key];
      }
    }
    return obj;
  }
  function getTimeFunction(opts) {
    if (typeof opts.timestamp === "function") {
      return opts.timestamp;
    }
    if (opts.timestamp === false) {
      return nullTime;
    }
    return epochTime;
  }
  function mock() {
    return {};
  }
  function passthrough(a3) {
    return a3;
  }
  function noop() {}
  function nullTime() {
    return false;
  }
  function epochTime() {
    return Date.now();
  }
  function unixTime() {
    return Math.round(Date.now() / 1000);
  }
  function isoTime() {
    return new Date(Date.now()).toISOString();
  }
  function pfGlobalThisOrFallback() {
    function defd(o2) {
      return typeof o2 !== "undefined" && o2;
    }
    try {
      if (typeof globalThis !== "undefined")
        return globalThis;
      Object.defineProperty(Object.prototype, "globalThis", {
        get: function() {
          delete Object.prototype.globalThis;
          return this.globalThis = this;
        },
        configurable: true
      });
      return globalThis;
    } catch (e) {
      return defd(self) || defd(window) || defd(this) || {};
    }
  }
  module.exports.default = pino;
  module.exports.pino = pino;
});

// node_modules/fastify/lib/logger-pino.js
var require_logger_pino = __commonJS((exports, module) => {
  var pino = require_browser();
  var { serializersSym } = pino.symbols;
  var {
    FST_ERR_LOG_INVALID_DESTINATION
  } = require_errors2();
  function createPinoLogger(opts) {
    if (opts.stream && opts.file) {
      throw new FST_ERR_LOG_INVALID_DESTINATION;
    } else if (opts.file) {
      opts.stream = pino.destination(opts.file);
      delete opts.file;
    }
    const prevLogger = opts.logger;
    const prevGenReqId = opts.genReqId;
    let logger = null;
    if (prevLogger) {
      opts.logger = undefined;
      opts.genReqId = undefined;
      if (prevLogger[serializersSym]) {
        opts.serializers = Object.assign({}, opts.serializers, prevLogger[serializersSym]);
      }
      logger = prevLogger.child({}, opts);
      opts.logger = prevLogger;
      opts.genReqId = prevGenReqId;
    } else {
      logger = pino(opts, opts.stream);
    }
    return logger;
  }
  var serializers = {
    req: function asReqValue(req) {
      return {
        method: req.method,
        url: req.url,
        version: req.headers && req.headers["accept-version"],
        host: req.host,
        remoteAddress: req.ip,
        remotePort: req.socket ? req.socket.remotePort : undefined
      };
    },
    err: pino.stdSerializers.err,
    res: function asResValue(reply) {
      return {
        statusCode: reply.statusCode
      };
    }
  };
  module.exports = {
    serializers,
    createPinoLogger
  };
});

// node_modules/fastify/lib/logger-factory.js
var require_logger_factory = __commonJS((exports, module) => {
  var {
    FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED,
    FST_ERR_LOG_INVALID_LOGGER_CONFIG,
    FST_ERR_LOG_INVALID_LOGGER_INSTANCE,
    FST_ERR_LOG_INVALID_LOGGER
  } = require_errors2();
  function createChildLogger(context, logger, req, reqId, loggerOpts) {
    const loggerBindings = {
      [context.requestIdLogLabel]: reqId
    };
    const child = context.childLoggerFactory.call(context.server, logger, loggerBindings, loggerOpts || {}, req);
    if (context.childLoggerFactory !== defaultChildLoggerFactory) {
      validateLogger(child, true);
    }
    return child;
  }
  function defaultChildLoggerFactory(logger, bindings, opts) {
    return logger.child(bindings, opts);
  }
  function validateLogger(logger, strict) {
    const methods = ["info", "error", "debug", "fatal", "warn", "trace", "child"];
    const missingMethods = logger ? methods.filter((method) => !logger[method] || typeof logger[method] !== "function") : methods;
    if (!missingMethods.length) {
      return true;
    } else if (missingMethods.length === methods.length && !strict) {
      return false;
    } else {
      throw FST_ERR_LOG_INVALID_LOGGER(missingMethods.join(","));
    }
  }
  function createLogger(options) {
    if (options.logger && options.loggerInstance) {
      throw new FST_ERR_LOG_LOGGER_AND_LOGGER_INSTANCE_PROVIDED;
    }
    if (!options.loggerInstance && !options.logger) {
      const nullLogger = require_abstract_logging();
      const logger2 = nullLogger;
      logger2.child = () => logger2;
      return { logger: logger2, hasLogger: false };
    }
    const { createPinoLogger, serializers } = require_logger_pino();
    if (validateLogger(options.loggerInstance)) {
      const logger2 = createPinoLogger({
        logger: options.loggerInstance,
        serializers: Object.assign({}, serializers, options.loggerInstance.serializers)
      });
      return { logger: logger2, hasLogger: true };
    }
    if (validateLogger(options.logger)) {
      throw FST_ERR_LOG_INVALID_LOGGER_CONFIG();
    }
    if (options.loggerInstance) {
      throw FST_ERR_LOG_INVALID_LOGGER_INSTANCE();
    }
    const localLoggerOptions = {};
    if (Object.prototype.toString.call(options.logger) === "[object Object]") {
      Reflect.ownKeys(options.logger).forEach((prop) => {
        Object.defineProperty(localLoggerOptions, prop, {
          value: options.logger[prop],
          writable: true,
          enumerable: true,
          configurable: true
        });
      });
    }
    localLoggerOptions.level = localLoggerOptions.level || "info";
    localLoggerOptions.serializers = Object.assign({}, serializers, localLoggerOptions.serializers);
    options.logger = localLoggerOptions;
    const logger = createPinoLogger(options.logger);
    return { logger, hasLogger: true };
  }
  function now() {
    const ts = process.hrtime();
    return ts[0] * 1000 + ts[1] / 1e6;
  }
  module.exports = {
    createChildLogger,
    defaultChildLoggerFactory,
    createLogger,
    validateLogger,
    now
  };
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS((exports, module) => {
  module.exports = rfdc;
  function copyBuffer(cur) {
    if (cur instanceof Buffer) {
      return Buffer.from(cur);
    }
    return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
  }
  function rfdc(opts) {
    opts = opts || {};
    if (opts.circles)
      return rfdcCircles(opts);
    const constructorHandlers = new Map;
    constructorHandlers.set(Date, (o2) => new Date(o2));
    constructorHandlers.set(Map, (o2, fn) => new Map(cloneArray(Array.from(o2), fn)));
    constructorHandlers.set(Set, (o2, fn) => new Set(cloneArray(Array.from(o2), fn)));
    if (opts.constructorHandlers) {
      for (const handler2 of opts.constructorHandlers) {
        constructorHandlers.set(handler2[0], handler2[1]);
      }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone;
    function cloneArray(a3, fn) {
      const keys = Object.keys(a3);
      const a22 = new Array(keys.length);
      for (let i = 0;i < keys.length; i++) {
        const k3 = keys[i];
        const cur = a3[k3];
        if (typeof cur !== "object" || cur === null) {
          a22[k3] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          a22[k3] = handler(cur, fn);
        } else if (ArrayBuffer.isView(cur)) {
          a22[k3] = copyBuffer(cur);
        } else {
          a22[k3] = fn(cur);
        }
      }
      return a22;
    }
    function clone(o2) {
      if (typeof o2 !== "object" || o2 === null)
        return o2;
      if (Array.isArray(o2))
        return cloneArray(o2, clone);
      if (o2.constructor !== Object && (handler = constructorHandlers.get(o2.constructor))) {
        return handler(o2, clone);
      }
      const o22 = {};
      for (const k3 in o2) {
        if (Object.hasOwnProperty.call(o2, k3) === false)
          continue;
        const cur = o2[k3];
        if (typeof cur !== "object" || cur === null) {
          o22[k3] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o22[k3] = handler(cur, clone);
        } else if (ArrayBuffer.isView(cur)) {
          o22[k3] = copyBuffer(cur);
        } else {
          o22[k3] = clone(cur);
        }
      }
      return o22;
    }
    function cloneProto(o2) {
      if (typeof o2 !== "object" || o2 === null)
        return o2;
      if (Array.isArray(o2))
        return cloneArray(o2, cloneProto);
      if (o2.constructor !== Object && (handler = constructorHandlers.get(o2.constructor))) {
        return handler(o2, cloneProto);
      }
      const o22 = {};
      for (const k3 in o2) {
        const cur = o2[k3];
        if (typeof cur !== "object" || cur === null) {
          o22[k3] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o22[k3] = handler(cur, cloneProto);
        } else if (ArrayBuffer.isView(cur)) {
          o22[k3] = copyBuffer(cur);
        } else {
          o22[k3] = cloneProto(cur);
        }
      }
      return o22;
    }
  }
  function rfdcCircles(opts) {
    const refs = [];
    const refsNew = [];
    const constructorHandlers = new Map;
    constructorHandlers.set(Date, (o2) => new Date(o2));
    constructorHandlers.set(Map, (o2, fn) => new Map(cloneArray(Array.from(o2), fn)));
    constructorHandlers.set(Set, (o2, fn) => new Set(cloneArray(Array.from(o2), fn)));
    if (opts.constructorHandlers) {
      for (const handler2 of opts.constructorHandlers) {
        constructorHandlers.set(handler2[0], handler2[1]);
      }
    }
    let handler = null;
    return opts.proto ? cloneProto : clone;
    function cloneArray(a3, fn) {
      const keys = Object.keys(a3);
      const a22 = new Array(keys.length);
      for (let i = 0;i < keys.length; i++) {
        const k3 = keys[i];
        const cur = a3[k3];
        if (typeof cur !== "object" || cur === null) {
          a22[k3] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          a22[k3] = handler(cur, fn);
        } else if (ArrayBuffer.isView(cur)) {
          a22[k3] = copyBuffer(cur);
        } else {
          const index = refs.indexOf(cur);
          if (index !== -1) {
            a22[k3] = refsNew[index];
          } else {
            a22[k3] = fn(cur);
          }
        }
      }
      return a22;
    }
    function clone(o2) {
      if (typeof o2 !== "object" || o2 === null)
        return o2;
      if (Array.isArray(o2))
        return cloneArray(o2, clone);
      if (o2.constructor !== Object && (handler = constructorHandlers.get(o2.constructor))) {
        return handler(o2, clone);
      }
      const o22 = {};
      refs.push(o2);
      refsNew.push(o22);
      for (const k3 in o2) {
        if (Object.hasOwnProperty.call(o2, k3) === false)
          continue;
        const cur = o2[k3];
        if (typeof cur !== "object" || cur === null) {
          o22[k3] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o22[k3] = handler(cur, clone);
        } else if (ArrayBuffer.isView(cur)) {
          o22[k3] = copyBuffer(cur);
        } else {
          const i = refs.indexOf(cur);
          if (i !== -1) {
            o22[k3] = refsNew[i];
          } else {
            o22[k3] = clone(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o22;
    }
    function cloneProto(o2) {
      if (typeof o2 !== "object" || o2 === null)
        return o2;
      if (Array.isArray(o2))
        return cloneArray(o2, cloneProto);
      if (o2.constructor !== Object && (handler = constructorHandlers.get(o2.constructor))) {
        return handler(o2, cloneProto);
      }
      const o22 = {};
      refs.push(o2);
      refsNew.push(o22);
      for (const k3 in o2) {
        const cur = o2[k3];
        if (typeof cur !== "object" || cur === null) {
          o22[k3] = cur;
        } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
          o22[k3] = handler(cur, cloneProto);
        } else if (ArrayBuffer.isView(cur)) {
          o22[k3] = copyBuffer(cur);
        } else {
          const i = refs.indexOf(cur);
          if (i !== -1) {
            o22[k3] = refsNew[i];
          } else {
            o22[k3] = cloneProto(cur);
          }
        }
      }
      refs.pop();
      refsNew.pop();
      return o22;
    }
  }
});

// node_modules/fastify/lib/schemas.js
var require_schemas = __commonJS((exports, module) => {
  var fastClone = require_rfdc()({ circles: false, proto: true });
  var { kSchemaVisited, kSchemaResponse } = require_symbols2();
  var kFluentSchema = Symbol.for("fluent-schema-object");
  var {
    FST_ERR_SCH_MISSING_ID,
    FST_ERR_SCH_ALREADY_PRESENT,
    FST_ERR_SCH_DUPLICATE,
    FST_ERR_SCH_CONTENT_MISSING_SCHEMA
  } = require_errors2();
  var SCHEMAS_SOURCE = ["params", "body", "querystring", "query", "headers"];
  function Schemas(initStore) {
    this.store = initStore || {};
  }
  Schemas.prototype.add = function(inputSchema) {
    const schema = fastClone(inputSchema.isFluentSchema || inputSchema.isFluentJSONSchema || inputSchema[kFluentSchema] ? inputSchema.valueOf() : inputSchema);
    const id = schema.$id;
    if (!id) {
      throw new FST_ERR_SCH_MISSING_ID;
    }
    if (this.store[id]) {
      throw new FST_ERR_SCH_ALREADY_PRESENT(id);
    }
    this.store[id] = schema;
  };
  Schemas.prototype.getSchemas = function() {
    return Object.assign({}, this.store);
  };
  Schemas.prototype.getSchema = function(schemaId) {
    return this.store[schemaId];
  };
  function isCustomSchemaPrototype(schema) {
    return typeof schema === "object" && Object.getPrototypeOf(schema) !== Object.prototype;
  }
  function normalizeSchema(routeSchemas, serverOptions) {
    if (routeSchemas[kSchemaVisited]) {
      return routeSchemas;
    }
    if (routeSchemas.query) {
      if (routeSchemas.querystring) {
        throw new FST_ERR_SCH_DUPLICATE("querystring");
      }
      routeSchemas.querystring = routeSchemas.query;
    }
    generateFluentSchema(routeSchemas);
    for (const key of SCHEMAS_SOURCE) {
      const schema = routeSchemas[key];
      if (schema && !isCustomSchemaPrototype(schema)) {
        if (key === "body" && schema.content) {
          const contentProperty = schema.content;
          const keys = Object.keys(contentProperty);
          for (let i = 0;i < keys.length; i++) {
            const contentType = keys[i];
            const contentSchema = contentProperty[contentType].schema;
            if (!contentSchema) {
              throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(contentType);
            }
          }
          continue;
        }
      }
    }
    if (routeSchemas.response) {
      const httpCodes = Object.keys(routeSchemas.response);
      for (const code of httpCodes) {
        if (isCustomSchemaPrototype(routeSchemas.response[code])) {
          continue;
        }
        const contentProperty = routeSchemas.response[code].content;
        if (contentProperty) {
          const keys = Object.keys(contentProperty);
          for (let i = 0;i < keys.length; i++) {
            const mediaName = keys[i];
            if (!contentProperty[mediaName].schema) {
              throw new FST_ERR_SCH_CONTENT_MISSING_SCHEMA(mediaName);
            }
          }
        }
      }
    }
    routeSchemas[kSchemaVisited] = true;
    return routeSchemas;
  }
  function generateFluentSchema(schema) {
    for (const key of SCHEMAS_SOURCE) {
      if (schema[key] && (schema[key].isFluentSchema || schema[key][kFluentSchema])) {
        schema[key] = schema[key].valueOf();
      }
    }
    if (schema.response) {
      const httpCodes = Object.keys(schema.response);
      for (const code of httpCodes) {
        if (schema.response[code].isFluentSchema || schema.response[code][kFluentSchema]) {
          schema.response[code] = schema.response[code].valueOf();
        }
      }
    }
  }
  function getSchemaSerializer(context, statusCode, contentType) {
    const responseSchemaDef = context[kSchemaResponse];
    if (!responseSchemaDef) {
      return false;
    }
    if (responseSchemaDef[statusCode]) {
      if (responseSchemaDef[statusCode].constructor === Object && contentType) {
        const mediaName = contentType.split(";", 1)[0];
        if (responseSchemaDef[statusCode][mediaName]) {
          return responseSchemaDef[statusCode][mediaName];
        }
        if (responseSchemaDef[statusCode]["*/*"]) {
          return responseSchemaDef[statusCode]["*/*"];
        }
        return false;
      }
      return responseSchemaDef[statusCode];
    }
    const fallbackStatusCode = (statusCode + "")[0] + "xx";
    if (responseSchemaDef[fallbackStatusCode]) {
      if (responseSchemaDef[fallbackStatusCode].constructor === Object && contentType) {
        const mediaName = contentType.split(";", 1)[0];
        if (responseSchemaDef[fallbackStatusCode][mediaName]) {
          return responseSchemaDef[fallbackStatusCode][mediaName];
        }
        if (responseSchemaDef[fallbackStatusCode]["*/*"]) {
          return responseSchemaDef[fallbackStatusCode]["*/*"];
        }
        return false;
      }
      return responseSchemaDef[fallbackStatusCode];
    }
    if (responseSchemaDef.default) {
      if (responseSchemaDef.default.constructor === Object && contentType) {
        const mediaName = contentType.split(";", 1)[0];
        if (responseSchemaDef.default[mediaName]) {
          return responseSchemaDef.default[mediaName];
        }
        if (responseSchemaDef.default["*/*"]) {
          return responseSchemaDef.default["*/*"];
        }
        return false;
      }
      return responseSchemaDef.default;
    }
    return false;
  }
  module.exports = {
    buildSchemas(initStore) {
      return new Schemas(initStore);
    },
    getSchemaSerializer,
    normalizeSchema
  };
});

// node_modules/fast-json-stringify/lib/serializer.js
var require_serializer = __commonJS((exports, module) => {
  var STR_ESCAPE = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
  module.exports = class Serializer {
    constructor(options) {
      switch (options && options.rounding) {
        case "floor":
          this.parseInteger = Math.floor;
          break;
        case "ceil":
          this.parseInteger = Math.ceil;
          break;
        case "round":
          this.parseInteger = Math.round;
          break;
        case "trunc":
        default:
          this.parseInteger = Math.trunc;
          break;
      }
      this._options = options;
    }
    asInteger(i) {
      if (Number.isInteger(i)) {
        return "" + i;
      } else if (typeof i === "bigint") {
        return i.toString();
      }
      const integer = this.parseInteger(i);
      if (integer === Infinity || integer === -Infinity || integer !== integer) {
        throw new Error(`The value "${i}" cannot be converted to an integer.`);
      }
      return "" + integer;
    }
    asNumber(i) {
      const num = Number(i);
      if (num !== num) {
        throw new Error(`The value "${i}" cannot be converted to a number.`);
      } else if (num === Infinity || num === -Infinity) {
        return "null";
      } else {
        return "" + num;
      }
    }
    asBoolean(bool) {
      return bool && "true" || "false";
    }
    asDateTime(date) {
      if (date === null)
        return '""';
      if (date instanceof Date) {
        return '"' + date.toISOString() + '"';
      }
      if (typeof date === "string") {
        return '"' + date + '"';
      }
      throw new Error(`The value "${date}" cannot be converted to a date-time.`);
    }
    asDate(date) {
      if (date === null)
        return '""';
      if (date instanceof Date) {
        return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(0, 10) + '"';
      }
      if (typeof date === "string") {
        return '"' + date + '"';
      }
      throw new Error(`The value "${date}" cannot be converted to a date.`);
    }
    asTime(date) {
      if (date === null)
        return '""';
      if (date instanceof Date) {
        return '"' + new Date(date.getTime() - date.getTimezoneOffset() * 60000).toISOString().slice(11, 19) + '"';
      }
      if (typeof date === "string") {
        return '"' + date + '"';
      }
      throw new Error(`The value "${date}" cannot be converted to a time.`);
    }
    asString(str) {
      const len = str.length;
      if (len === 0) {
        return '""';
      } else if (len < 42) {
        let result = "";
        let last = -1;
        let point = 255;
        for (let i = 0;i < len; i++) {
          point = str.charCodeAt(i);
          if (point === 34 || point === 92) {
            last === -1 && (last = 0);
            result += str.slice(last, i) + "\\";
            last = i;
          } else if (point < 32 || point >= 55296 && point <= 57343) {
            return JSON.stringify(str);
          }
        }
        return last === -1 && '"' + str + '"' || '"' + result + str.slice(last) + '"';
      } else if (len < 5000 && STR_ESCAPE.test(str) === false) {
        return '"' + str + '"';
      } else {
        return JSON.stringify(str);
      }
    }
    asUnsafeString(str) {
      return '"' + str + '"';
    }
    getState() {
      return this._options;
    }
    static restoreFromState(state) {
      return new Serializer(state);
    }
  };
});

// node_modules/fastify/lib/error-serializer.js
var require_error_serializer = __commonJS((exports, module) => {
  var Serializer = require_serializer();
  var serializerState = { mode: "standalone" };
  var serializer = Serializer.restoreFromState(serializerState);
  var validator = null;
  module.exports = function anonymous(validator2, serializer2) {
    const JSON_STR_BEGIN_OBJECT = "{";
    const JSON_STR_END_OBJECT = "}";
    const JSON_STR_BEGIN_ARRAY = "[";
    const JSON_STR_END_ARRAY = "]";
    const JSON_STR_COMMA = ",";
    const JSON_STR_COLONS = ":";
    const JSON_STR_QUOTE = '"';
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT;
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY;
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE;
    const JSON_STR_NULL = "null";
    function anonymous0(input) {
      const obj = input && typeof input.toJSON === "function" ? input.toJSON() : input;
      if (obj === null)
        return JSON_STR_EMPTY_OBJECT;
      let value;
      let json = JSON_STR_BEGIN_OBJECT;
      let addComma = false;
      value = obj["statusCode"];
      if (value !== undefined) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"statusCode":';
        json += serializer2.asNumber(value);
      }
      value = obj["code"];
      if (value !== undefined) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"code":';
        if (typeof value !== "string") {
          if (value === null) {
            json += JSON_STR_EMPTY_STRING;
          } else if (value instanceof Date) {
            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
          } else if (value instanceof RegExp) {
            json += serializer2.asString(value.source);
          } else {
            json += serializer2.asString(value.toString());
          }
        } else {
          json += serializer2.asString(value);
        }
      }
      value = obj["error"];
      if (value !== undefined) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"error":';
        if (typeof value !== "string") {
          if (value === null) {
            json += JSON_STR_EMPTY_STRING;
          } else if (value instanceof Date) {
            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
          } else if (value instanceof RegExp) {
            json += serializer2.asString(value.source);
          } else {
            json += serializer2.asString(value.toString());
          }
        } else {
          json += serializer2.asString(value);
        }
      }
      value = obj["message"];
      if (value !== undefined) {
        !addComma && (addComma = true) || (json += JSON_STR_COMMA);
        json += '"message":';
        if (typeof value !== "string") {
          if (value === null) {
            json += JSON_STR_EMPTY_STRING;
          } else if (value instanceof Date) {
            json += JSON_STR_QUOTE + value.toISOString() + JSON_STR_QUOTE;
          } else if (value instanceof RegExp) {
            json += serializer2.asString(value.source);
          } else {
            json += serializer2.asString(value.toString());
          }
        } else {
          json += serializer2.asString(value);
        }
      }
      return json + JSON_STR_END_OBJECT;
    }
    const main = anonymous0;
    return main;
  }(validator, serializer);
});

// node_modules/fastify/lib/error-handler.js
var require_error_handler = __commonJS((exports, module) => {
  var statusCodes = (init_http(), __toCommonJS(exports_http)).STATUS_CODES;
  var wrapThenable = require_wrapThenable();
  var {
    kReplyHeaders,
    kReplyNextErrorHandler,
    kReplyIsRunningOnErrorHook,
    kReplyHasStatusCode,
    kRouteContext,
    kDisableRequestLogging
  } = require_symbols2();
  var {
    FST_ERR_REP_INVALID_PAYLOAD_TYPE,
    FST_ERR_FAILED_ERROR_SERIALIZATION
  } = require_errors2();
  var { getSchemaSerializer } = require_schemas();
  var serializeError = require_error_serializer();
  var rootErrorHandler = {
    func: defaultErrorHandler,
    toJSON() {
      return this.func.name.toString() + "()";
    }
  };
  function handleError(reply, error, cb) {
    reply[kReplyIsRunningOnErrorHook] = false;
    const context = reply[kRouteContext];
    if (reply[kReplyNextErrorHandler] === false) {
      fallbackErrorHandler(error, reply, function(reply2, payload) {
        try {
          reply2.raw.writeHead(reply2.raw.statusCode, reply2[kReplyHeaders]);
        } catch (error2) {
          if (!reply2.log[kDisableRequestLogging]) {
            reply2.log.warn({ req: reply2.request, res: reply2, err: error2 }, error2?.message);
          }
          reply2.raw.writeHead(reply2.raw.statusCode);
        }
        reply2.raw.end(payload);
      });
      return;
    }
    const errorHandler = reply[kReplyNextErrorHandler] || context.errorHandler;
    reply[kReplyNextErrorHandler] = Object.getPrototypeOf(errorHandler);
    delete reply[kReplyHeaders]["content-type"];
    delete reply[kReplyHeaders]["content-length"];
    const func = errorHandler.func;
    if (!func) {
      reply[kReplyNextErrorHandler] = false;
      fallbackErrorHandler(error, reply, cb);
      return;
    }
    try {
      const result = func(error, reply.request, reply);
      if (result !== undefined) {
        if (result !== null && typeof result.then === "function") {
          wrapThenable(result, reply);
        } else {
          reply.send(result);
        }
      }
    } catch (err) {
      reply.send(err);
    }
  }
  function defaultErrorHandler(error, request, reply) {
    setErrorHeaders(error, reply);
    if (!reply[kReplyHasStatusCode] || reply.statusCode === 200) {
      const statusCode = error.statusCode || error.status;
      reply.code(statusCode >= 400 ? statusCode : 500);
    }
    if (reply.statusCode < 500) {
      if (!reply.log[kDisableRequestLogging]) {
        reply.log.info({ res: reply, err: error }, error?.message);
      }
    } else {
      if (!reply.log[kDisableRequestLogging]) {
        reply.log.error({ req: request, res: reply, err: error }, error?.message);
      }
    }
    reply.send(error);
  }
  function fallbackErrorHandler(error, reply, cb) {
    const res = reply.raw;
    const statusCode = reply.statusCode;
    reply[kReplyHeaders]["content-type"] = reply[kReplyHeaders]["content-type"] ?? "application/json; charset=utf-8";
    let payload;
    try {
      const serializerFn = getSchemaSerializer(reply[kRouteContext], statusCode, reply[kReplyHeaders]["content-type"]);
      if (serializerFn === false) {
        payload = serializeError({
          error: statusCodes[statusCode + ""],
          code: error.code,
          message: error.message,
          statusCode
        });
      } else {
        payload = serializerFn(Object.create(error, {
          error: { value: statusCodes[statusCode + ""] },
          message: { value: error.message },
          statusCode: { value: statusCode }
        }));
      }
    } catch (err) {
      if (!reply.log[kDisableRequestLogging]) {
        reply.log.error({ err, statusCode: res.statusCode }, "The serializer for the given status code failed");
      }
      reply.code(500);
      payload = serializeError(new FST_ERR_FAILED_ERROR_SERIALIZATION(err.message, error.message));
    }
    if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
      payload = serializeError(new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload));
    }
    reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
    cb(reply, payload);
  }
  function buildErrorHandler(parent = rootErrorHandler, func) {
    if (!func) {
      return parent;
    }
    const errorHandler = Object.create(parent);
    errorHandler.func = func;
    return errorHandler;
  }
  function setErrorHeaders(error, reply) {
    const res = reply.raw;
    let statusCode = res.statusCode;
    statusCode = statusCode >= 400 ? statusCode : 500;
    if (error != null) {
      if (error.headers !== undefined) {
        reply.headers(error.headers);
      }
      if (error.status >= 400) {
        statusCode = error.status;
      } else if (error.statusCode >= 400) {
        statusCode = error.statusCode;
      }
    }
    res.statusCode = statusCode;
  }
  module.exports = {
    buildErrorHandler,
    handleError
  };
});

// node_modules/fastify/lib/decorate.js
var require_decorate = __commonJS((exports, module) => {
  var {
    kReply,
    kRequest,
    kState,
    kHasBeenDecorated
  } = require_symbols2();
  var {
    FST_ERR_DEC_ALREADY_PRESENT,
    FST_ERR_DEC_MISSING_DEPENDENCY,
    FST_ERR_DEC_AFTER_START,
    FST_ERR_DEC_REFERENCE_TYPE,
    FST_ERR_DEC_DEPENDENCY_INVALID_TYPE,
    FST_ERR_DEC_UNDECLARED
  } = require_errors2();
  function decorate(instance, name, fn, dependencies) {
    if (Object.hasOwn(instance, name)) {
      throw new FST_ERR_DEC_ALREADY_PRESENT(name);
    }
    checkDependencies(instance, name, dependencies);
    if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
      Object.defineProperty(instance, name, {
        get: fn.getter,
        set: fn.setter
      });
    } else {
      instance[name] = fn;
    }
  }
  function getInstanceDecorator(name) {
    if (!checkExistence(this, name)) {
      throw new FST_ERR_DEC_UNDECLARED(name, "instance");
    }
    if (typeof this[name] === "function") {
      return this[name].bind(this);
    }
    return this[name];
  }
  function decorateConstructor(konstructor, name, fn, dependencies) {
    const instance = konstructor.prototype;
    if (Object.hasOwn(instance, name) || hasKey(konstructor, name)) {
      throw new FST_ERR_DEC_ALREADY_PRESENT(name);
    }
    konstructor[kHasBeenDecorated] = true;
    checkDependencies(konstructor, name, dependencies);
    if (fn && (typeof fn.getter === "function" || typeof fn.setter === "function")) {
      Object.defineProperty(instance, name, {
        get: fn.getter,
        set: fn.setter
      });
    } else if (typeof fn === "function") {
      instance[name] = fn;
    } else {
      konstructor.props.push({ key: name, value: fn });
    }
  }
  function checkReferenceType(name, fn) {
    if (typeof fn === "object" && fn && !(typeof fn.getter === "function" || typeof fn.setter === "function")) {
      throw new FST_ERR_DEC_REFERENCE_TYPE(name, typeof fn);
    }
  }
  function decorateFastify(name, fn, dependencies) {
    assertNotStarted(this, name);
    decorate(this, name, fn, dependencies);
    return this;
  }
  function checkExistence(instance, name) {
    if (name) {
      return name in instance || instance.prototype && name in instance.prototype || hasKey(instance, name);
    }
    return instance in this;
  }
  function hasKey(fn, name) {
    if (fn.props) {
      return fn.props.find(({ key }) => key === name);
    }
    return false;
  }
  function checkRequestExistence(name) {
    if (name && hasKey(this[kRequest], name))
      return true;
    return checkExistence(this[kRequest].prototype, name);
  }
  function checkReplyExistence(name) {
    if (name && hasKey(this[kReply], name))
      return true;
    return checkExistence(this[kReply].prototype, name);
  }
  function checkDependencies(instance, name, deps) {
    if (deps === undefined || deps === null) {
      return;
    }
    if (!Array.isArray(deps)) {
      throw new FST_ERR_DEC_DEPENDENCY_INVALID_TYPE(name);
    }
    for (let i = 0;i !== deps.length; ++i) {
      if (!checkExistence(instance, deps[i])) {
        throw new FST_ERR_DEC_MISSING_DEPENDENCY(deps[i]);
      }
    }
  }
  function decorateReply(name, fn, dependencies) {
    assertNotStarted(this, name);
    checkReferenceType(name, fn);
    decorateConstructor(this[kReply], name, fn, dependencies);
    return this;
  }
  function decorateRequest(name, fn, dependencies) {
    assertNotStarted(this, name);
    checkReferenceType(name, fn);
    decorateConstructor(this[kRequest], name, fn, dependencies);
    return this;
  }
  function assertNotStarted(instance, name) {
    if (instance[kState].started) {
      throw new FST_ERR_DEC_AFTER_START(name);
    }
  }
  module.exports = {
    add: decorateFastify,
    exist: checkExistence,
    existRequest: checkRequestExistence,
    existReply: checkReplyExistence,
    dependencies: checkDependencies,
    decorateReply,
    decorateRequest,
    getInstanceDecorator,
    hasKey
  };
});

// node_modules/fastify/lib/reply.js
var require_reply = __commonJS((exports, module) => {
  var eos = (init_stream(), __toCommonJS(exports_stream)).finished;
  var Readable = (init_stream(), __toCommonJS(exports_stream)).Readable;
  var {
    kFourOhFourContext,
    kReplyErrorHandlerCalled,
    kReplyHijacked,
    kReplyStartTime,
    kReplyEndTime,
    kReplySerializer,
    kReplySerializerDefault,
    kReplyIsError,
    kReplyHeaders,
    kReplyTrailers,
    kReplyHasStatusCode,
    kReplyIsRunningOnErrorHook,
    kReplyNextErrorHandler,
    kDisableRequestLogging,
    kSchemaResponse,
    kReplyCacheSerializeFns,
    kSchemaController,
    kOptions,
    kRouteContext
  } = require_symbols2();
  var {
    onSendHookRunner,
    onResponseHookRunner,
    preHandlerHookRunner,
    preSerializationHookRunner
  } = require_hooks();
  var internals = require_handleRequest()[Symbol.for("internals")];
  var loggerUtils = require_logger_factory();
  var now = loggerUtils.now;
  var { handleError } = require_error_handler();
  var { getSchemaSerializer } = require_schemas();
  var CONTENT_TYPE = {
    JSON: "application/json; charset=utf-8",
    PLAIN: "text/plain; charset=utf-8",
    OCTET: "application/octet-stream"
  };
  var {
    FST_ERR_REP_INVALID_PAYLOAD_TYPE,
    FST_ERR_REP_RESPONSE_BODY_CONSUMED,
    FST_ERR_REP_READABLE_STREAM_LOCKED,
    FST_ERR_REP_ALREADY_SENT,
    FST_ERR_SEND_INSIDE_ONERR,
    FST_ERR_BAD_STATUS_CODE,
    FST_ERR_BAD_TRAILER_NAME,
    FST_ERR_BAD_TRAILER_VALUE,
    FST_ERR_MISSING_SERIALIZATION_FN,
    FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN,
    FST_ERR_DEC_UNDECLARED
  } = require_errors2();
  var decorators = require_decorate();
  var toString = Object.prototype.toString;
  function Reply(res, request, log) {
    this.raw = res;
    this[kReplySerializer] = null;
    this[kReplyErrorHandlerCalled] = false;
    this[kReplyIsError] = false;
    this[kReplyIsRunningOnErrorHook] = false;
    this.request = request;
    this[kReplyHeaders] = {};
    this[kReplyTrailers] = null;
    this[kReplyHasStatusCode] = false;
    this[kReplyStartTime] = undefined;
    this.log = log;
  }
  Reply.props = [];
  Object.defineProperties(Reply.prototype, {
    [kRouteContext]: {
      get() {
        return this.request[kRouteContext];
      }
    },
    elapsedTime: {
      get() {
        if (this[kReplyStartTime] === undefined) {
          return 0;
        }
        return (this[kReplyEndTime] || now()) - this[kReplyStartTime];
      }
    },
    server: {
      get() {
        return this.request[kRouteContext].server;
      }
    },
    sent: {
      enumerable: true,
      get() {
        return (this[kReplyHijacked] || this.raw.writableEnded) === true;
      }
    },
    statusCode: {
      get() {
        return this.raw.statusCode;
      },
      set(value) {
        this.code(value);
      }
    },
    routeOptions: {
      get() {
        return this.request.routeOptions;
      }
    }
  });
  Reply.prototype.writeEarlyHints = function(hints, callback) {
    this.raw.writeEarlyHints(hints, callback);
    return this;
  };
  Reply.prototype.hijack = function() {
    this[kReplyHijacked] = true;
    return this;
  };
  Reply.prototype.send = function(payload) {
    if (this[kReplyIsRunningOnErrorHook]) {
      throw new FST_ERR_SEND_INSIDE_ONERR;
    }
    if (this.sent === true) {
      this.log.warn({ err: new FST_ERR_REP_ALREADY_SENT(this.request.url, this.request.method) });
      return this;
    }
    if (this[kReplyIsError] || payload instanceof Error) {
      this[kReplyIsError] = false;
      onErrorHook(this, payload, onSendHook);
      return this;
    }
    if (payload === undefined) {
      onSendHook(this, payload);
      return this;
    }
    const contentType = this.getHeader("content-type");
    const hasContentType = contentType !== undefined;
    if (payload !== null) {
      if (typeof payload.pipe === "function" || typeof payload.getReader === "function" || toString.call(payload) === "[object Response]") {
        onSendHook(this, payload);
        return this;
      }
      if (payload.buffer instanceof ArrayBuffer) {
        if (!hasContentType) {
          this[kReplyHeaders]["content-type"] = CONTENT_TYPE.OCTET;
        }
        const payloadToSend = Buffer.isBuffer(payload) ? payload : Buffer.from(payload.buffer, payload.byteOffset, payload.byteLength);
        onSendHook(this, payloadToSend);
        return this;
      }
      if (!hasContentType && typeof payload === "string") {
        this[kReplyHeaders]["content-type"] = CONTENT_TYPE.PLAIN;
        onSendHook(this, payload);
        return this;
      }
    }
    if (this[kReplySerializer] !== null) {
      if (typeof payload !== "string") {
        preSerializationHook(this, payload);
        return this;
      }
      payload = this[kReplySerializer](payload);
    } else if (!hasContentType || contentType.indexOf("json") !== -1) {
      if (!hasContentType) {
        this[kReplyHeaders]["content-type"] = CONTENT_TYPE.JSON;
      } else if (contentType.indexOf("charset") === -1) {
        const customContentType = contentType.trim();
        if (customContentType.endsWith(";")) {
          this[kReplyHeaders]["content-type"] = `${customContentType} charset=utf-8`;
        } else {
          this[kReplyHeaders]["content-type"] = `${customContentType}; charset=utf-8`;
        }
      }
      if (typeof payload !== "string") {
        preSerializationHook(this, payload);
        return this;
      }
    }
    onSendHook(this, payload);
    return this;
  };
  Reply.prototype.getHeader = function(key) {
    key = key.toLowerCase();
    const value = this[kReplyHeaders][key];
    return value !== undefined ? value : this.raw.getHeader(key);
  };
  Reply.prototype.getHeaders = function() {
    return {
      ...this.raw.getHeaders(),
      ...this[kReplyHeaders]
    };
  };
  Reply.prototype.hasHeader = function(key) {
    key = key.toLowerCase();
    return this[kReplyHeaders][key] !== undefined || this.raw.hasHeader(key);
  };
  Reply.prototype.removeHeader = function(key) {
    delete this[kReplyHeaders][key.toLowerCase()];
    return this;
  };
  Reply.prototype.header = function(key, value = "") {
    key = key.toLowerCase();
    if (this[kReplyHeaders][key] && key === "set-cookie") {
      if (typeof this[kReplyHeaders][key] === "string") {
        this[kReplyHeaders][key] = [this[kReplyHeaders][key]];
      }
      if (Array.isArray(value)) {
        Array.prototype.push.apply(this[kReplyHeaders][key], value);
      } else {
        this[kReplyHeaders][key].push(value);
      }
    } else {
      this[kReplyHeaders][key] = value;
    }
    return this;
  };
  Reply.prototype.headers = function(headers) {
    const keys = Object.keys(headers);
    for (let i = 0;i !== keys.length; ++i) {
      const key = keys[i];
      this.header(key, headers[key]);
    }
    return this;
  };
  var INVALID_TRAILERS = new Set([
    "transfer-encoding",
    "content-length",
    "host",
    "cache-control",
    "max-forwards",
    "te",
    "authorization",
    "set-cookie",
    "content-encoding",
    "content-type",
    "content-range",
    "trailer"
  ]);
  Reply.prototype.trailer = function(key, fn) {
    key = key.toLowerCase();
    if (INVALID_TRAILERS.has(key)) {
      throw new FST_ERR_BAD_TRAILER_NAME(key);
    }
    if (typeof fn !== "function") {
      throw new FST_ERR_BAD_TRAILER_VALUE(key, typeof fn);
    }
    if (this[kReplyTrailers] === null)
      this[kReplyTrailers] = {};
    this[kReplyTrailers][key] = fn;
    return this;
  };
  Reply.prototype.hasTrailer = function(key) {
    return this[kReplyTrailers]?.[key.toLowerCase()] !== undefined;
  };
  Reply.prototype.removeTrailer = function(key) {
    if (this[kReplyTrailers] === null)
      return this;
    this[kReplyTrailers][key.toLowerCase()] = undefined;
    return this;
  };
  Reply.prototype.code = function(code) {
    const statusCode = +code;
    if (!(statusCode >= 100 && statusCode <= 599)) {
      throw new FST_ERR_BAD_STATUS_CODE(code || String(code));
    }
    this.raw.statusCode = statusCode;
    this[kReplyHasStatusCode] = true;
    return this;
  };
  Reply.prototype.status = Reply.prototype.code;
  Reply.prototype.getSerializationFunction = function(schemaOrStatus, contentType) {
    let serialize2;
    if (typeof schemaOrStatus === "string" || typeof schemaOrStatus === "number") {
      if (typeof contentType === "string") {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus]?.[contentType];
      } else {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[schemaOrStatus];
      }
    } else if (typeof schemaOrStatus === "object") {
      serialize2 = this[kRouteContext][kReplyCacheSerializeFns]?.get(schemaOrStatus);
    }
    return serialize2;
  };
  Reply.prototype.compileSerializationSchema = function(schema, httpStatus = null, contentType = null) {
    const { request } = this;
    const { method, url } = request;
    if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
      return this[kRouteContext][kReplyCacheSerializeFns].get(schema);
    }
    const serializerCompiler = this[kRouteContext].serializerCompiler || this.server[kSchemaController].serializerCompiler || (this.server[kSchemaController].setupSerializer(this.server[kOptions]) || this.server[kSchemaController].serializerCompiler);
    const serializeFn = serializerCompiler({
      schema,
      method,
      url,
      httpStatus,
      contentType
    });
    if (this[kRouteContext][kReplyCacheSerializeFns] == null) {
      this[kRouteContext][kReplyCacheSerializeFns] = new WeakMap;
    }
    this[kRouteContext][kReplyCacheSerializeFns].set(schema, serializeFn);
    return serializeFn;
  };
  Reply.prototype.serializeInput = function(input, schema, httpStatus, contentType) {
    const possibleContentType = httpStatus;
    let serialize2;
    httpStatus = typeof schema === "string" || typeof schema === "number" ? schema : httpStatus;
    contentType = httpStatus && possibleContentType !== httpStatus ? possibleContentType : contentType;
    if (httpStatus != null) {
      if (contentType != null) {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus]?.[contentType];
      } else {
        serialize2 = this[kRouteContext][kSchemaResponse]?.[httpStatus];
      }
      if (serialize2 == null) {
        if (contentType)
          throw new FST_ERR_MISSING_CONTENTTYPE_SERIALIZATION_FN(httpStatus, contentType);
        throw new FST_ERR_MISSING_SERIALIZATION_FN(httpStatus);
      }
    } else {
      if (this[kRouteContext][kReplyCacheSerializeFns]?.has(schema)) {
        serialize2 = this[kRouteContext][kReplyCacheSerializeFns].get(schema);
      } else {
        serialize2 = this.compileSerializationSchema(schema, httpStatus, contentType);
      }
    }
    return serialize2(input);
  };
  Reply.prototype.serialize = function(payload) {
    if (this[kReplySerializer] !== null) {
      return this[kReplySerializer](payload);
    } else {
      if (this[kRouteContext] && this[kRouteContext][kReplySerializerDefault]) {
        return this[kRouteContext][kReplySerializerDefault](payload, this.raw.statusCode);
      } else {
        return serialize(this[kRouteContext], payload, this.raw.statusCode);
      }
    }
  };
  Reply.prototype.serializer = function(fn) {
    this[kReplySerializer] = fn;
    return this;
  };
  Reply.prototype.type = function(type) {
    this[kReplyHeaders]["content-type"] = type;
    return this;
  };
  Reply.prototype.redirect = function(url, code) {
    if (!code) {
      code = this[kReplyHasStatusCode] ? this.raw.statusCode : 302;
    }
    return this.header("location", url).code(code).send();
  };
  Reply.prototype.callNotFound = function() {
    notFound(this);
    return this;
  };
  Reply.prototype.then = function(fulfilled, rejected) {
    if (this.sent) {
      fulfilled();
      return;
    }
    eos(this.raw, (err) => {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        if (rejected) {
          rejected(err);
        } else {
          this.log && this.log.warn("unhandled rejection on reply.then");
        }
      } else {
        fulfilled();
      }
    });
  };
  Reply.prototype.getDecorator = function(name) {
    if (!decorators.hasKey(this, name) && !decorators.exist(this, name)) {
      throw new FST_ERR_DEC_UNDECLARED(name, "reply");
    }
    const decorator = this[name];
    if (typeof decorator === "function") {
      return decorator.bind(this);
    }
    return decorator;
  };
  function preSerializationHook(reply, payload) {
    if (reply[kRouteContext].preSerialization !== null) {
      preSerializationHookRunner(reply[kRouteContext].preSerialization, reply.request, reply, payload, preSerializationHookEnd);
    } else {
      preSerializationHookEnd(null, undefined, reply, payload);
    }
  }
  function preSerializationHookEnd(err, _request, reply, payload) {
    if (err != null) {
      onErrorHook(reply, err);
      return;
    }
    try {
      if (reply[kReplySerializer] !== null) {
        payload = reply[kReplySerializer](payload);
      } else if (reply[kRouteContext] && reply[kRouteContext][kReplySerializerDefault]) {
        payload = reply[kRouteContext][kReplySerializerDefault](payload, reply.raw.statusCode);
      } else {
        payload = serialize(reply[kRouteContext], payload, reply.raw.statusCode, reply[kReplyHeaders]["content-type"]);
      }
    } catch (e) {
      wrapSerializationError(e, reply);
      onErrorHook(reply, e);
      return;
    }
    onSendHook(reply, payload);
  }
  function wrapSerializationError(error, reply) {
    error.serialization = reply[kRouteContext].config;
  }
  function onSendHook(reply, payload) {
    if (reply[kRouteContext].onSend !== null) {
      onSendHookRunner(reply[kRouteContext].onSend, reply.request, reply, payload, wrapOnSendEnd);
    } else {
      onSendEnd(reply, payload);
    }
  }
  function wrapOnSendEnd(err, request, reply, payload) {
    if (err != null) {
      onErrorHook(reply, err);
    } else {
      onSendEnd(reply, payload);
    }
  }
  function safeWriteHead(reply, statusCode) {
    const res = reply.raw;
    try {
      res.writeHead(statusCode, reply[kReplyHeaders]);
    } catch (err) {
      if (err.code === "ERR_HTTP_HEADERS_SENT") {
        reply.log.warn(`Reply was already sent, did you forget to "return reply" in the "${reply.request.raw.url}" (${reply.request.raw.method}) route?`);
      }
      throw err;
    }
  }
  function onSendEnd(reply, payload) {
    const res = reply.raw;
    const req = reply.request;
    if (reply[kReplyTrailers] !== null) {
      const trailerHeaders = Object.keys(reply[kReplyTrailers]);
      let header = "";
      for (const trailerName of trailerHeaders) {
        if (typeof reply[kReplyTrailers][trailerName] !== "function")
          continue;
        header += " ";
        header += trailerName;
      }
      reply.header("Transfer-Encoding", "chunked");
      reply.header("Trailer", header.trim());
    }
    if (toString.call(payload) === "[object Response]") {
      if (typeof payload.status === "number") {
        reply.code(payload.status);
      }
      if (typeof payload.headers === "object" && typeof payload.headers.forEach === "function") {
        for (const [headerName, headerValue] of payload.headers) {
          reply.header(headerName, headerValue);
        }
      }
      if (payload.body !== null) {
        if (payload.bodyUsed) {
          throw new FST_ERR_REP_RESPONSE_BODY_CONSUMED;
        }
      }
      payload = payload.body;
    }
    const statusCode = res.statusCode;
    if (payload === undefined || payload === null) {
      if (statusCode >= 200 && statusCode !== 204 && statusCode !== 304 && req.method !== "HEAD" && reply[kReplyTrailers] === null) {
        reply[kReplyHeaders]["content-length"] = "0";
      }
      safeWriteHead(reply, statusCode);
      sendTrailer(payload, res, reply);
      return;
    }
    if (statusCode >= 100 && statusCode < 200 || statusCode === 204) {
      reply.removeHeader("content-type");
      reply.removeHeader("content-length");
      safeWriteHead(reply, statusCode);
      sendTrailer(undefined, res, reply);
      if (typeof payload.resume === "function") {
        payload.on("error", noop);
        payload.resume();
      }
      return;
    }
    if (typeof payload.pipe === "function") {
      sendStream(payload, res, reply);
      return;
    }
    if (typeof payload.getReader === "function") {
      sendWebStream(payload, res, reply);
      return;
    }
    if (typeof payload !== "string" && !Buffer.isBuffer(payload)) {
      throw new FST_ERR_REP_INVALID_PAYLOAD_TYPE(typeof payload);
    }
    if (reply[kReplyTrailers] === null) {
      const contentLength = reply[kReplyHeaders]["content-length"];
      if (!contentLength || req.raw.method !== "HEAD" && Number(contentLength) !== Buffer.byteLength(payload)) {
        reply[kReplyHeaders]["content-length"] = "" + Buffer.byteLength(payload);
      }
    }
    safeWriteHead(reply, statusCode);
    res.write(payload);
    sendTrailer(payload, res, reply);
  }
  function logStreamError(logger, err, res) {
    if (err.code === "ERR_STREAM_PREMATURE_CLOSE") {
      if (!logger[kDisableRequestLogging]) {
        logger.info({ res }, "stream closed prematurely");
      }
    } else {
      logger.warn({ err }, "response terminated with an error with headers already sent");
    }
  }
  function sendWebStream(payload, res, reply) {
    if (payload.locked) {
      throw FST_ERR_REP_READABLE_STREAM_LOCKED();
    }
    const nodeStream = Readable.fromWeb(payload);
    sendStream(nodeStream, res, reply);
  }
  function sendStream(payload, res, reply) {
    let sourceOpen = true;
    let errorLogged = false;
    sendStreamTrailer(payload, res, reply);
    eos(payload, { readable: true, writable: false }, function(err) {
      sourceOpen = false;
      if (err != null) {
        if (res.headersSent || reply.request.raw.aborted === true) {
          if (!errorLogged) {
            errorLogged = true;
            logStreamError(reply.log, err, reply);
          }
          res.destroy();
        } else {
          onErrorHook(reply, err);
        }
      }
    });
    eos(res, function(err) {
      if (sourceOpen) {
        if (err != null && res.headersSent && !errorLogged) {
          errorLogged = true;
          logStreamError(reply.log, err, res);
        }
        if (typeof payload.destroy === "function") {
          payload.destroy();
        } else if (typeof payload.close === "function") {
          payload.close(noop);
        } else if (typeof payload.abort === "function") {
          payload.abort();
        } else {
          reply.log.warn("stream payload does not end properly");
        }
      }
    });
    if (!res.headersSent) {
      for (const key in reply[kReplyHeaders]) {
        res.setHeader(key, reply[kReplyHeaders][key]);
      }
    } else {
      reply.log.warn("response will send, but you shouldn't use res.writeHead in stream mode");
    }
    payload.pipe(res);
  }
  function sendTrailer(payload, res, reply) {
    if (reply[kReplyTrailers] === null) {
      res.end(null, null, null);
      return;
    }
    const trailerHeaders = Object.keys(reply[kReplyTrailers]);
    const trailers = {};
    let handled = 0;
    let skipped = true;
    function send() {
      if (handled === 0) {
        res.addTrailers(trailers);
        res.end(null, null, null);
      }
    }
    for (const trailerName of trailerHeaders) {
      let cb = function(err, value) {
        handled++;
        if (err)
          reply.log.debug(err);
        else
          trailers[trailerName] = value;
        process.nextTick(send);
      };
      if (typeof reply[kReplyTrailers][trailerName] !== "function")
        continue;
      skipped = false;
      handled--;
      const result = reply[kReplyTrailers][trailerName](reply, payload, cb);
      if (typeof result === "object" && typeof result.then === "function") {
        result.then((v2) => cb(null, v2), cb);
      }
    }
    if (skipped)
      res.end(null, null, null);
  }
  function sendStreamTrailer(payload, res, reply) {
    if (reply[kReplyTrailers] === null)
      return;
    payload.on("end", () => sendTrailer(null, res, reply));
  }
  function onErrorHook(reply, error, cb) {
    if (reply[kRouteContext].onError !== null && !reply[kReplyNextErrorHandler]) {
      reply[kReplyIsRunningOnErrorHook] = true;
      onSendHookRunner(reply[kRouteContext].onError, reply.request, reply, error, () => handleError(reply, error, cb));
    } else {
      handleError(reply, error, cb);
    }
  }
  function setupResponseListeners(reply) {
    reply[kReplyStartTime] = now();
    const onResFinished = (err) => {
      reply[kReplyEndTime] = now();
      reply.raw.removeListener("finish", onResFinished);
      reply.raw.removeListener("error", onResFinished);
      const ctx = reply[kRouteContext];
      if (ctx && ctx.onResponse !== null) {
        onResponseHookRunner(ctx.onResponse, reply.request, reply, onResponseCallback);
      } else {
        onResponseCallback(err, reply.request, reply);
      }
    };
    reply.raw.on("finish", onResFinished);
    reply.raw.on("error", onResFinished);
  }
  function onResponseCallback(err, request, reply) {
    if (reply.log[kDisableRequestLogging]) {
      return;
    }
    const responseTime = reply.elapsedTime;
    if (err != null) {
      reply.log.error({
        res: reply,
        err,
        responseTime
      }, "request errored");
      return;
    }
    reply.log.info({
      res: reply,
      responseTime
    }, "request completed");
  }
  function buildReply(R2) {
    const props = R2.props.slice();
    function _Reply(res, request, log) {
      this.raw = res;
      this[kReplyIsError] = false;
      this[kReplyErrorHandlerCalled] = false;
      this[kReplyHijacked] = false;
      this[kReplySerializer] = null;
      this.request = request;
      this[kReplyHeaders] = {};
      this[kReplyTrailers] = null;
      this[kReplyStartTime] = undefined;
      this[kReplyEndTime] = undefined;
      this.log = log;
      let prop;
      for (let i = 0;i < props.length; i++) {
        prop = props[i];
        this[prop.key] = prop.value;
      }
    }
    Object.setPrototypeOf(_Reply.prototype, R2.prototype);
    Object.setPrototypeOf(_Reply, R2);
    _Reply.parent = R2;
    _Reply.props = props;
    return _Reply;
  }
  function notFound(reply) {
    if (reply[kRouteContext][kFourOhFourContext] === null) {
      reply.log.warn("Trying to send a NotFound error inside a 404 handler. Sending basic 404 response.");
      reply.code(404).send("404 Not Found");
      return;
    }
    reply.request[kRouteContext] = reply[kRouteContext][kFourOhFourContext];
    if (reply[kRouteContext].preHandler !== null) {
      preHandlerHookRunner(reply[kRouteContext].preHandler, reply.request, reply, internals.preHandlerCallback);
    } else {
      internals.preHandlerCallback(null, reply.request, reply);
    }
  }
  function serialize(context, data, statusCode, contentType) {
    const fnSerialize = getSchemaSerializer(context, statusCode, contentType);
    if (fnSerialize) {
      return fnSerialize(data);
    }
    return JSON.stringify(data);
  }
  function noop() {}
  module.exports = Reply;
  module.exports.buildReply = buildReply;
  module.exports.setupResponseListeners = setupResponseListeners;
});

// node_modules/@fastify/forwarded/index.js
var require_forwarded = __commonJS((exports, module) => {
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    const header = req.headers["x-forwarded-for"];
    const socketAddr = req.socket.remoteAddress;
    if (!header || typeof header !== "string") {
      return [socketAddr];
    } else if (header.indexOf(",") === -1) {
      const remote = header.trim();
      return remote.length ? [socketAddr, remote] : [socketAddr];
    } else {
      return parse(header, socketAddr);
    }
  }
  function parse(header, socketAddr) {
    const result = [socketAddr];
    let end = header.length;
    let start = end;
    let char;
    let i;
    for (i = end - 1;i >= 0; --i) {
      char = header[i];
      if (char === " ") {
        start === end && (start = end = i);
      } else if (char === ",") {
        start !== end && result.push(header.slice(start, end));
        start = end = i;
      } else {
        start = i;
      }
    }
    start !== end && result.push(header.substring(start, end));
    return result;
  }
  module.exports = forwarded;
  module.exports.default = forwarded;
  module.exports.forwarded = forwarded;
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS((exports, module) => {
  (function(root) {
    const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    const ipv4Regexes = {
      fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
      twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
      longValue: new RegExp(`^${ipv4Part}$`, "i")
    };
    const octalRegex = new RegExp(`^0[0-7]+$`, "i");
    const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
    const zoneIndex = "%[0-9a-z]{1,}";
    const ipv6Part = "(?:[0-9a-f]+::?)+";
    const ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      native: new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
      deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
      transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
    };
    function expandIPv6(string, parts) {
      if (string.indexOf("::") !== string.lastIndexOf("::")) {
        return null;
      }
      let colonCount = 0;
      let lastColon = -1;
      let zoneId = (string.match(ipv6Regexes.zoneIndex) || [])[0];
      let replacement, replacementCount;
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string = string.replace(/%.+$/, "");
      }
      while ((lastColon = string.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string = string.replace("::", replacement);
      if (string[0] === ":") {
        string = string.slice(1);
      }
      if (string[string.length - 1] === ":") {
        string = string.slice(0, -1);
      }
      parts = function() {
        const ref = string.split(":");
        const results = [];
        for (let i = 0;i < ref.length; i++) {
          results.push(parseInt(ref[i], 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    }
    function matchCIDR(first, second, partSize, cidrBits) {
      if (first.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      let part = 0;
      let shift;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    }
    function parseIntAuto(string) {
      if (hexRegex.test(string)) {
        return parseInt(string, 16);
      }
      if (string[0] === "0" && !isNaN(parseInt(string[1], 10))) {
        if (octalRegex.test(string)) {
          return parseInt(string, 8);
        }
        throw new Error(`ipaddr: cannot parse ${string} as octal`);
      }
      return parseInt(string, 10);
    }
    function padPart(part, length) {
      while (part.length < length) {
        part = `0${part}`;
      }
      return part;
    }
    const ipaddr = {};
    ipaddr.IPv4 = function() {
      function IPv4(octets) {
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        let i, octet;
        for (i = 0;i < octets.length; i++) {
          octet = octets[i];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        private: [
          [new IPv4([10, 0, 0, 0]), 8],
          [new IPv4([172, 16, 0, 0]), 12],
          [new IPv4([192, 168, 0, 0]), 16]
        ],
        reserved: [
          [new IPv4([192, 0, 0, 0]), 24],
          [new IPv4([192, 0, 2, 0]), 24],
          [new IPv4([192, 88, 99, 0]), 24],
          [new IPv4([198, 18, 0, 0]), 15],
          [new IPv4([198, 51, 100, 0]), 24],
          [new IPv4([203, 0, 113, 0]), 24],
          [new IPv4([240, 0, 0, 0]), 4]
        ],
        as112: [
          [new IPv4([192, 175, 48, 0]), 24],
          [new IPv4([192, 31, 196, 0]), 24]
        ],
        amt: [
          [new IPv4([192, 52, 193, 0]), 24]
        ]
      };
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.match = function(other, cidrRange) {
        let ref;
        if (cidrRange === undefined) {
          ref = other;
          other = ref[0];
          cidrRange = ref[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        let i, octet, zeros;
        for (i = 3;i >= 0; i -= 1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      IPv4.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      return IPv4;
    }();
    ipaddr.IPv4.broadcastAddressFromCIDR = function(string) {
      try {
        const cidr = this.parseCIDR(string);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.isIPv4 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv4.isValid = function(string) {
      try {
        new this(this.parser(string));
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv4.isValidCIDR = function(string) {
      try {
        this.parseCIDR(string);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv4.isValidFourPartDecimal = function(string) {
      if (ipaddr.IPv4.isValid(string) && string.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr.IPv4.networkAddressFromCIDR = function(string) {
      let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr.IPv4.parse = function(string) {
      const parts = this.parser(string);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv4 Address");
      }
      return new this(parts);
    };
    ipaddr.IPv4.parseCIDR = function(string) {
      let match;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        const maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          const parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr.IPv4.parser = function(string) {
      let match, part, value;
      if (match = string.match(ipv4Regexes.fourOctet)) {
        return function() {
          const ref = match.slice(1, 6);
          const results = [];
          for (let i = 0;i < ref.length; i++) {
            part = ref[i];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.longValue)) {
        value = parseIntAuto(match[1]);
        if (value > 4294967295 || value < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          const results = [];
          let shift;
          for (shift = 0;shift <= 24; shift += 8) {
            results.push(value >> shift & 255);
          }
          return results;
        }().reverse();
      } else if (match = string.match(ipv4Regexes.twoOctet)) {
        return function() {
          const ref = match.slice(1, 4);
          const results = [];
          value = parseIntAuto(ref[1]);
          if (value > 16777215 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref[0]));
          results.push(value >> 16 & 255);
          results.push(value >> 8 & 255);
          results.push(value & 255);
          return results;
        }();
      } else if (match = string.match(ipv4Regexes.threeOctet)) {
        return function() {
          const ref = match.slice(1, 5);
          const results = [];
          value = parseIntAuto(ref[2]);
          if (value > 65535 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          results.push(parseIntAuto(ref[0]));
          results.push(parseIntAuto(ref[1]));
          results.push(value >> 8 & 255);
          results.push(value & 255);
          return results;
        }();
      } else {
        return null;
      }
    };
    ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      const octets = [0, 0, 0, 0];
      let j3 = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j3 < filledOctetCount) {
        octets[j3] = 255;
        j3++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.IPv6 = function() {
      function IPv6(parts, zoneId) {
        let i, part;
        if (parts.length === 16) {
          this.parts = [];
          for (i = 0;i <= 14; i += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        for (i = 0;i < this.parts.length; i++) {
          part = this.parts[i];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        discard: [new IPv6([256, 0, 0, 0, 0, 0, 0, 0]), 64],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        benchmarking: [new IPv6([8193, 2, 0, 0, 0, 0, 0, 0]), 48],
        amt: [new IPv6([8193, 3, 0, 0, 0, 0, 0, 0]), 32],
        as112v6: [
          [new IPv6([8193, 4, 274, 0, 0, 0, 0, 0]), 48],
          [new IPv6([9760, 79, 32768, 0, 0, 0, 0, 0]), 48]
        ],
        deprecated: [new IPv6([8193, 16, 0, 0, 0, 0, 0, 0]), 28],
        orchid2: [new IPv6([8193, 32, 0, 0, 0, 0, 0, 0]), 28],
        droneRemoteIdProtocolEntityTags: [new IPv6([8193, 48, 0, 0, 0, 0, 0, 0]), 28],
        reserved: [
          [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 23],
          [new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]
        ]
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.match = function(other, cidrRange) {
        let ref;
        if (cidrRange === undefined) {
          ref = other;
          other = ref[0];
          cidrRange = ref[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        let cidr = 0;
        let stop = false;
        const zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        let part, zeros;
        for (let i = 7;i >= 0; i -= 1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      IPv6.prototype.range = function() {
        return ipaddr.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.toByteArray = function() {
        let part;
        const bytes = [];
        const ref = this.parts;
        for (let i = 0;i < ref.length; i++) {
          part = ref[i];
          bytes.push(part >> 8);
          bytes.push(part & 255);
        }
        return bytes;
      };
      IPv6.prototype.toFixedLengthString = function() {
        const addr = function() {
          const results = [];
          for (let i = 0;i < this.parts.length; i++) {
            results.push(padPart(this.parts[i].toString(16), 4));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toIPv4Address = function() {
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        const ref = this.parts.slice(-2);
        const high = ref[0];
        const low = ref[1];
        return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.toNormalizedString = function() {
        const addr = function() {
          const results = [];
          for (let i = 0;i < this.parts.length; i++) {
            results.push(this.parts[i].toString(16));
          }
          return results;
        }.call(this).join(":");
        let suffix = "";
        if (this.zoneId) {
          suffix = `%${this.zoneId}`;
        }
        return addr + suffix;
      };
      IPv6.prototype.toRFC5952String = function() {
        const regex = /((^|:)(0(:|$)){2,})/g;
        const string = this.toNormalizedString();
        let bestMatchIndex = 0;
        let bestMatchLength = -1;
        let match;
        while (match = regex.exec(string)) {
          if (match[0].length > bestMatchLength) {
            bestMatchIndex = match.index;
            bestMatchLength = match[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string;
        }
        return `${string.substring(0, bestMatchIndex)}::${string.substring(bestMatchIndex + bestMatchLength)}`;
      };
      IPv6.prototype.toString = function() {
        return this.toRFC5952String();
      };
      return IPv6;
    }();
    ipaddr.IPv6.broadcastAddressFromCIDR = function(string) {
      try {
        const cidr = this.parseCIDR(string);
        const ipInterfaceOctets = cidr[0].toByteArray();
        const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        const octets = [];
        let i = 0;
        while (i < 16) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr.IPv6.isIPv6 = function(string) {
      return this.parser(string) !== null;
    };
    ipaddr.IPv6.isValid = function(string) {
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        const addr = this.parser(string);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv6.isValidCIDR = function(string) {
      if (typeof string === "string" && string.indexOf(":") === -1) {
        return false;
      }
      try {
        this.parseCIDR(string);
        return true;
      } catch (e) {
        return false;
      }
    };
    ipaddr.IPv6.networkAddressFromCIDR = function(string) {
      let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 16) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (e) {
        throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
      }
    };
    ipaddr.IPv6.parse = function(string) {
      const addr = this.parser(string);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like an IPv6 Address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr.IPv6.parseCIDR = function(string) {
      let maskLength, match, parsed;
      if (match = string.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr.IPv6.parser = function(string) {
      let addr, i, match, octet, octets, zoneId;
      if (match = string.match(ipv6Regexes.deprecatedTransitional)) {
        return this.parser(`::ffff:${match[1]}`);
      }
      if (ipv6Regexes.native.test(string)) {
        return expandIPv6(string, 8);
      }
      if (match = string.match(ipv6Regexes.transitional)) {
        zoneId = match[6] || "";
        addr = match[1];
        if (!match[1].endsWith("::")) {
          addr = addr.slice(0, -1);
        }
        addr = expandIPv6(addr + zoneId, 6);
        if (addr.parts) {
          octets = [
            parseInt(match[2]),
            parseInt(match[3]),
            parseInt(match[4]),
            parseInt(match[5])
          ];
          for (i = 0;i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 128) {
        throw new Error("ipaddr: invalid IPv6 prefix length");
      }
      const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      let j3 = 0;
      const filledOctetCount = Math.floor(prefix / 8);
      while (j3 < filledOctetCount) {
        octets[j3] = 255;
        j3++;
      }
      if (filledOctetCount < 16) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr.fromByteArray = function(bytes) {
      const length = bytes.length;
      if (length === 4) {
        return new ipaddr.IPv4(bytes);
      } else if (length === 16) {
        return new ipaddr.IPv6(bytes);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr.isValid = function(string) {
      return ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
    };
    ipaddr.isValidCIDR = function(string) {
      return ipaddr.IPv6.isValidCIDR(string) || ipaddr.IPv4.isValidCIDR(string);
    };
    ipaddr.parse = function(string) {
      if (ipaddr.IPv6.isValid(string)) {
        return ipaddr.IPv6.parse(string);
      } else if (ipaddr.IPv4.isValid(string)) {
        return ipaddr.IPv4.parse(string);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr.parseCIDR = function(string) {
      try {
        return ipaddr.IPv6.parseCIDR(string);
      } catch (e) {
        try {
          return ipaddr.IPv4.parseCIDR(string);
        } catch (e2) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr.process = function(string) {
      const addr = this.parse(string);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
    ipaddr.subnetMatch = function(address, rangeList, defaultName) {
      let i, rangeName, rangeSubnets, subnet;
      if (defaultName === undefined || defaultName === null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
          rangeSubnets = rangeList[rangeName];
          if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
            rangeSubnets = [rangeSubnets];
          }
          for (i = 0;i < rangeSubnets.length; i++) {
            subnet = rangeSubnets[i];
            if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    if (typeof module !== "undefined" && module.exports) {
      module.exports = ipaddr;
    } else {
      root.ipaddr = ipaddr;
    }
  })(exports);
});

// node_modules/@fastify/proxy-addr/index.js
var require_proxy_addr = __commonJS((exports, module) => {
  /*!
   * proxy-addr
   * Copyright(c) 2021 Fastify collaborators
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = proxyaddr;
  module.exports.default = proxyaddr;
  module.exports.proxyaddr = proxyaddr;
  module.exports.all = alladdrs;
  module.exports.compile = compile;
  var forwarded = require_forwarded();
  var ipaddr = require_ipaddr();
  var DIGIT_REGEXP = /^\d+$/u;
  var isip = ipaddr.isValid;
  var parseip = ipaddr.parse;
  var IP_RANGES = {
    linklocal: ["169.254.0.0/16", "fe80::/10"],
    loopback: ["127.0.0.1/8", "::1/128"],
    uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
  };
  function alladdrs(req, trust) {
    const addrs = forwarded(req);
    if (!trust) {
      return addrs;
    }
    if (typeof trust !== "function") {
      trust = compile(trust);
    }
    for (let i = 0;i < addrs.length - 1; i++) {
      if (trust(addrs[i], i))
        continue;
      addrs.length = i + 1;
    }
    return addrs;
  }
  function compile(val) {
    if (!val) {
      throw new TypeError("argument is required");
    }
    let trust;
    if (typeof val === "string") {
      trust = [val];
    } else if (Array.isArray(val)) {
      trust = val.slice();
    } else {
      throw new TypeError("unsupported trust argument");
    }
    for (let i = 0;i < trust.length; i++) {
      val = trust[i];
      if (!Object.hasOwn(IP_RANGES, val)) {
        continue;
      }
      val = IP_RANGES[val];
      trust.splice.apply(trust, [i, 1].concat(val));
      i += val.length - 1;
    }
    return compileTrust(compileRangeSubnets(trust));
  }
  function compileRangeSubnets(arr) {
    const rangeSubnets = new Array(arr.length);
    for (let i = 0;i < arr.length; i++) {
      rangeSubnets[i] = parseipNotation(arr[i]);
    }
    return rangeSubnets;
  }
  function compileTrust(rangeSubnets) {
    const len = rangeSubnets.length;
    return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
  }
  function parseipNotation(note) {
    const pos = note.lastIndexOf("/");
    const str = pos !== -1 ? note.substring(0, pos) : note;
    if (!isip(str)) {
      throw new TypeError("invalid IP address: " + str);
    }
    let ip = parseip(str);
    if (pos === -1 && ip.kind() === "ipv6" && ip.isIPv4MappedAddress()) {
      ip = ip.toIPv4Address();
    }
    const max = ip.kind() === "ipv6" ? 128 : 32;
    let range = pos !== -1 ? note.substring(pos + 1, note.length) : null;
    if (range === null) {
      range = max;
    } else if (DIGIT_REGEXP.test(range)) {
      range = parseInt(range, 10);
    } else if (ip.kind() === "ipv4" && isip(range)) {
      range = parseNetmask(range);
    } else {
      range = null;
    }
    if (range <= 0 || range > max) {
      throw new TypeError("invalid range on address: " + note);
    }
    return [ip, range];
  }
  function parseNetmask(netmask) {
    const ip = parseip(netmask);
    const kind = ip.kind();
    return kind === "ipv4" ? ip.prefixLengthFromSubnetMask() : null;
  }
  function proxyaddr(req, trust) {
    if (!req) {
      throw new TypeError("req argument is required");
    }
    if (!trust) {
      throw new TypeError("trust argument is required");
    }
    const addrs = alladdrs(req, trust);
    return addrs[addrs.length - 1];
  }
  function trustNone() {
    return false;
  }
  function trustMulti(subnets) {
    return function trust(addr) {
      if (!isip(addr))
        return false;
      const ip = parseip(addr);
      let ipconv;
      const kind = ip.kind();
      for (let i = 0;i < subnets.length; i++) {
        const subnet = subnets[i];
        const subnetip = subnet[0];
        const subnetkind = subnetip.kind();
        const subnetrange = subnet[1];
        let trusted = ip;
        if (kind !== subnetkind) {
          const subnetisipv4 = subnetkind === "ipv4";
          if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
            continue;
          }
          if (!ipconv) {
            ipconv = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
          }
          trusted = ipconv;
        }
        if (trusted.match(subnetip, subnetrange)) {
          return true;
        }
      }
      return false;
    };
  }
  function trustSingle(subnet) {
    const subnetip = subnet[0];
    const subnetkind = subnetip.kind();
    const subnetisipv4 = subnetkind === "ipv4";
    const subnetrange = subnet[1];
    return function trust(addr) {
      if (!isip(addr))
        return false;
      let ip = parseip(addr);
      const kind = ip.kind();
      if (kind !== subnetkind) {
        if (subnetisipv4 && !ip.isIPv4MappedAddress()) {
          return false;
        }
        ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();
      }
      return ip.match(subnetip, subnetrange);
    };
  }
});

// node_modules/fastify/lib/request.js
var require_request = __commonJS((exports, module) => {
  var proxyAddr = require_proxy_addr();
  var {
    kHasBeenDecorated,
    kSchemaBody,
    kSchemaHeaders,
    kSchemaParams,
    kSchemaQuerystring,
    kSchemaController,
    kOptions,
    kRequestCacheValidateFns,
    kRouteContext,
    kRequestOriginalUrl
  } = require_symbols2();
  var { FST_ERR_REQ_INVALID_VALIDATION_INVOCATION, FST_ERR_DEC_UNDECLARED } = require_errors2();
  var decorators = require_decorate();
  var HTTP_PART_SYMBOL_MAP = {
    body: kSchemaBody,
    headers: kSchemaHeaders,
    params: kSchemaParams,
    querystring: kSchemaQuerystring,
    query: kSchemaQuerystring
  };
  function Request(id, params, req, query, log, context) {
    this.id = id;
    this[kRouteContext] = context;
    this.params = params;
    this.raw = req;
    this.query = query;
    this.log = log;
    this.body = undefined;
  }
  Request.props = [];
  function getTrustProxyFn(tp) {
    if (typeof tp === "function") {
      return tp;
    }
    if (tp === true) {
      return null;
    }
    if (typeof tp === "number") {
      return function(a3, i) {
        return i < tp;
      };
    }
    if (typeof tp === "string") {
      const values = tp.split(",").map((it2) => it2.trim());
      return proxyAddr.compile(values);
    }
    return proxyAddr.compile(tp);
  }
  function buildRequest(R2, trustProxy) {
    if (trustProxy) {
      return buildRequestWithTrustProxy(R2, trustProxy);
    }
    return buildRegularRequest(R2);
  }
  function buildRegularRequest(R2) {
    const props = R2.props.slice();
    function _Request(id, params, req, query, log, context) {
      this.id = id;
      this[kRouteContext] = context;
      this.params = params;
      this.raw = req;
      this.query = query;
      this.log = log;
      this.body = undefined;
      let prop;
      for (let i = 0;i < props.length; i++) {
        prop = props[i];
        this[prop.key] = prop.value;
      }
    }
    Object.setPrototypeOf(_Request.prototype, R2.prototype);
    Object.setPrototypeOf(_Request, R2);
    _Request.props = props;
    _Request.parent = R2;
    return _Request;
  }
  function getLastEntryInMultiHeaderValue(headerValue) {
    const lastIndex = headerValue.lastIndexOf(",");
    return lastIndex === -1 ? headerValue.trim() : headerValue.slice(lastIndex + 1).trim();
  }
  function buildRequestWithTrustProxy(R2, trustProxy) {
    const _Request = buildRegularRequest(R2);
    const proxyFn = getTrustProxyFn(trustProxy);
    _Request[kHasBeenDecorated] = true;
    Object.defineProperties(_Request.prototype, {
      ip: {
        get() {
          const addrs = proxyAddr.all(this.raw, proxyFn);
          return addrs[addrs.length - 1];
        }
      },
      ips: {
        get() {
          return proxyAddr.all(this.raw, proxyFn);
        }
      },
      host: {
        get() {
          if (this.ip !== undefined && this.headers["x-forwarded-host"]) {
            return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-host"]);
          }
          return this.headers.host ?? this.headers[":authority"] ?? "";
        }
      },
      protocol: {
        get() {
          if (this.headers["x-forwarded-proto"]) {
            return getLastEntryInMultiHeaderValue(this.headers["x-forwarded-proto"]);
          }
          if (this.socket) {
            return this.socket.encrypted ? "https" : "http";
          }
        }
      }
    });
    return _Request;
  }
  function assertsRequestDecoration(request, name) {
    if (!decorators.hasKey(request, name) && !decorators.exist(request, name)) {
      throw new FST_ERR_DEC_UNDECLARED(name, "request");
    }
  }
  Object.defineProperties(Request.prototype, {
    server: {
      get() {
        return this[kRouteContext].server;
      }
    },
    url: {
      get() {
        return this.raw.url;
      }
    },
    originalUrl: {
      get() {
        if (!this[kRequestOriginalUrl]) {
          this[kRequestOriginalUrl] = this.raw.originalUrl || this.raw.url;
        }
        return this[kRequestOriginalUrl];
      }
    },
    method: {
      get() {
        return this.raw.method;
      }
    },
    routeOptions: {
      get() {
        const context = this[kRouteContext];
        const routeLimit = context._parserOptions.limit;
        const serverLimit = context.server.initialConfig.bodyLimit;
        const version = context.server.hasConstraintStrategy("version") ? this.raw.headers["accept-version"] : undefined;
        const options = {
          method: context.config?.method,
          url: context.config?.url,
          bodyLimit: routeLimit || serverLimit,
          attachValidation: context.attachValidation,
          logLevel: context.logLevel,
          exposeHeadRoute: context.exposeHeadRoute,
          prefixTrailingSlash: context.prefixTrailingSlash,
          handler: context.handler,
          config: context.config,
          schema: context.schema,
          version
        };
        return options;
      }
    },
    is404: {
      get() {
        return this[kRouteContext].config?.url === undefined;
      }
    },
    socket: {
      get() {
        return this.raw.socket;
      }
    },
    ip: {
      get() {
        if (this.socket) {
          return this.socket.remoteAddress;
        }
      }
    },
    host: {
      get() {
        return this.raw.headers.host ?? this.raw.headers[":authority"] ?? "";
      }
    },
    hostname: {
      get() {
        return this.host.split(":", 1)[0];
      }
    },
    port: {
      get() {
        const portFromHost = parseInt(this.host.split(":").slice(-1)[0]);
        if (!isNaN(portFromHost)) {
          return portFromHost;
        }
        const host = this.headers.host ?? this.headers[":authority"] ?? "";
        const portFromHeader = parseInt(host.split(":").slice(-1)[0]);
        if (!isNaN(portFromHeader)) {
          return portFromHeader;
        }
        return null;
      }
    },
    protocol: {
      get() {
        if (this.socket) {
          return this.socket.encrypted ? "https" : "http";
        }
      }
    },
    headers: {
      get() {
        if (this.additionalHeaders) {
          return Object.assign({}, this.raw.headers, this.additionalHeaders);
        }
        return this.raw.headers;
      },
      set(headers) {
        this.additionalHeaders = headers;
      }
    },
    getValidationFunction: {
      value: function(httpPartOrSchema) {
        if (typeof httpPartOrSchema === "string") {
          const symbol = HTTP_PART_SYMBOL_MAP[httpPartOrSchema];
          return this[kRouteContext][symbol];
        } else if (typeof httpPartOrSchema === "object") {
          return this[kRouteContext][kRequestCacheValidateFns]?.get(httpPartOrSchema);
        }
      }
    },
    compileValidationSchema: {
      value: function(schema, httpPart = null) {
        const { method, url } = this;
        if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
          return this[kRouteContext][kRequestCacheValidateFns].get(schema);
        }
        const validatorCompiler = this[kRouteContext].validatorCompiler || this.server[kSchemaController].validatorCompiler || (this.server[kSchemaController].setupValidator(this.server[kOptions]) || this.server[kSchemaController].validatorCompiler);
        const validateFn = validatorCompiler({
          schema,
          method,
          url,
          httpPart
        });
        if (this[kRouteContext][kRequestCacheValidateFns] == null) {
          this[kRouteContext][kRequestCacheValidateFns] = new WeakMap;
        }
        this[kRouteContext][kRequestCacheValidateFns].set(schema, validateFn);
        return validateFn;
      }
    },
    validateInput: {
      value: function(input, schema, httpPart) {
        httpPart = typeof schema === "string" ? schema : httpPart;
        const symbol = httpPart != null && typeof httpPart === "string" && HTTP_PART_SYMBOL_MAP[httpPart];
        let validate;
        if (symbol) {
          validate = this[kRouteContext][symbol];
        }
        if (validate == null && (schema == null || typeof schema !== "object" || Array.isArray(schema))) {
          throw new FST_ERR_REQ_INVALID_VALIDATION_INVOCATION(httpPart);
        }
        if (validate == null) {
          if (this[kRouteContext][kRequestCacheValidateFns]?.has(schema)) {
            validate = this[kRouteContext][kRequestCacheValidateFns].get(schema);
          } else {
            validate = this.compileValidationSchema(schema, httpPart);
          }
        }
        return validate(input);
      }
    },
    getDecorator: {
      value: function(name) {
        assertsRequestDecoration(this, name);
        const decorator = this[name];
        if (typeof decorator === "function") {
          return decorator.bind(this);
        }
        return decorator;
      }
    },
    setDecorator: {
      value: function(name, value) {
        assertsRequestDecoration(this, name);
        this[name] = value;
      }
    }
  });
  module.exports = Request;
  module.exports.buildRequest = buildRequest;
});

// node_modules/fastify/lib/context.js
var require_context = __commonJS((exports, module) => {
  var {
    kFourOhFourContext,
    kReplySerializerDefault,
    kSchemaErrorFormatter,
    kErrorHandler,
    kChildLoggerFactory,
    kOptions,
    kReply,
    kRequest,
    kBodyLimit,
    kLogLevel,
    kContentTypeParser,
    kRouteByFastify,
    kRequestCacheValidateFns,
    kReplyCacheSerializeFns
  } = require_symbols2();
  function Context({
    schema,
    handler,
    config,
    requestIdLogLabel,
    childLoggerFactory,
    errorHandler,
    bodyLimit,
    logLevel,
    logSerializers,
    attachValidation,
    validatorCompiler,
    serializerCompiler,
    replySerializer,
    schemaErrorFormatter,
    exposeHeadRoute,
    prefixTrailingSlash,
    server,
    isFastify
  }) {
    this.schema = schema;
    this.handler = handler;
    this.Reply = server[kReply];
    this.Request = server[kRequest];
    this.contentTypeParser = server[kContentTypeParser];
    this.onRequest = null;
    this.onSend = null;
    this.onError = null;
    this.onTimeout = null;
    this.preHandler = null;
    this.onResponse = null;
    this.preSerialization = null;
    this.onRequestAbort = null;
    this.config = config;
    this.errorHandler = errorHandler || server[kErrorHandler];
    this.requestIdLogLabel = requestIdLogLabel || server[kOptions].requestIdLogLabel;
    this.childLoggerFactory = childLoggerFactory || server[kChildLoggerFactory];
    this._middie = null;
    this._parserOptions = {
      limit: bodyLimit || server[kBodyLimit]
    };
    this.exposeHeadRoute = exposeHeadRoute;
    this.prefixTrailingSlash = prefixTrailingSlash;
    this.logLevel = logLevel || server[kLogLevel];
    this.logSerializers = logSerializers;
    this[kFourOhFourContext] = null;
    this.attachValidation = attachValidation;
    this[kReplySerializerDefault] = replySerializer;
    this.schemaErrorFormatter = schemaErrorFormatter || server[kSchemaErrorFormatter] || defaultSchemaErrorFormatter;
    this[kRouteByFastify] = isFastify;
    this[kRequestCacheValidateFns] = null;
    this[kReplyCacheSerializeFns] = null;
    this.validatorCompiler = validatorCompiler || null;
    this.serializerCompiler = serializerCompiler || null;
    this.server = server;
  }
  function defaultSchemaErrorFormatter(errors, dataVar) {
    let text = "";
    const separator = ", ";
    for (let i = 0;i !== errors.length; ++i) {
      const e = errors[i];
      text += dataVar + (e.instancePath || "") + " " + e.message + separator;
    }
    return new Error(text.slice(0, -separator.length));
  }
  module.exports = Context;
});

// node_modules/toad-cache/dist/toad-cache.cjs
var require_toad_cache = __commonJS((exports) => {
  class FifoMap {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = new Map;
      this.last = null;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    get size() {
      return this.items.size;
    }
    clear() {
      this.items = new Map;
      this.first = null;
      this.last = null;
    }
    delete(key) {
      if (this.items.has(key)) {
        const deletedItem = this.items.get(key);
        this.items.delete(key);
        if (deletedItem.prev !== null) {
          deletedItem.prev.next = deletedItem.next;
        }
        if (deletedItem.next !== null) {
          deletedItem.next.prev = deletedItem.prev;
        }
        if (this.first === deletedItem) {
          this.first = deletedItem.next;
        }
        if (this.last === deletedItem) {
          this.last = deletedItem.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        this.items.delete(item.key);
        if (this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (this.items.has(key)) {
        return this.items.get(key).expiry;
      }
    }
    get(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return this.items.keys();
    }
    set(key, value) {
      if (this.items.has(key)) {
        const item2 = this.items.get(key);
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items.set(key, item);
      if (this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }

  class LruMap {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = new Map;
      this.last = null;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    get size() {
      return this.items.size;
    }
    bumpLru(item) {
      if (this.last === item) {
        return;
      }
      const last = this.last;
      const next = item.next;
      const prev = item.prev;
      if (this.first === item) {
        this.first = next;
      }
      item.next = null;
      item.prev = last;
      last.next = item;
      if (prev !== null) {
        prev.next = next;
      }
      if (next !== null) {
        next.prev = prev;
      }
      this.last = item;
    }
    clear() {
      this.items = new Map;
      this.first = null;
      this.last = null;
    }
    delete(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        this.items.delete(key);
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        if (this.last === item) {
          this.last = item.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        this.items.delete(item.key);
        if (this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (this.items.has(key)) {
        return this.items.get(key).expiry;
      }
    }
    get(key) {
      if (this.items.has(key)) {
        const item = this.items.get(key);
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        this.bumpLru(item);
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return this.items.keys();
    }
    set(key, value) {
      if (this.items.has(key)) {
        const item2 = this.items.get(key);
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        if (this.last !== item2) {
          this.bumpLru(item2);
        }
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items.set(key, item);
      if (this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }

  class LruObject {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = Object.create(null);
      this.last = null;
      this.size = 0;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    bumpLru(item) {
      if (this.last === item) {
        return;
      }
      const last = this.last;
      const next = item.next;
      const prev = item.prev;
      if (this.first === item) {
        this.first = next;
      }
      item.next = null;
      item.prev = last;
      last.next = item;
      if (prev !== null) {
        prev.next = next;
      }
      if (next !== null) {
        next.prev = prev;
      }
      this.last = item;
    }
    clear() {
      this.items = Object.create(null);
      this.first = null;
      this.last = null;
      this.size = 0;
    }
    delete(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        delete this.items[key];
        this.size--;
        if (item.prev !== null) {
          item.prev.next = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        }
        if (this.first === item) {
          this.first = item.next;
        }
        if (this.last === item) {
          this.last = item.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        delete this.items[item.key];
        if (--this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        return this.items[key].expiry;
      }
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        this.bumpLru(item);
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return Object.keys(this.items);
    }
    set(key, value) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item2 = this.items[key];
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        if (this.last !== item2) {
          this.bumpLru(item2);
        }
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items[key] = item;
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }

  class HitStatisticsRecord {
    constructor() {
      this.records = {};
    }
    initForCache(cacheId, currentTimeStamp) {
      this.records[cacheId] = {
        [currentTimeStamp]: {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          invalidateOne: 0,
          invalidateAll: 0,
          sets: 0
        }
      };
    }
    resetForCache(cacheId) {
      for (let key of Object.keys(this.records[cacheId])) {
        this.records[cacheId][key] = {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          invalidateOne: 0,
          invalidateAll: 0,
          sets: 0
        };
      }
    }
    getStatistics() {
      return this.records;
    }
  }
  function getTimestamp(date) {
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
  }

  class HitStatistics {
    constructor(cacheId, statisticTtlInHours, globalStatisticsRecord) {
      this.cacheId = cacheId;
      this.statisticTtlInHours = statisticTtlInHours;
      this.collectionStart = new Date;
      this.currentTimeStamp = getTimestamp(this.collectionStart);
      this.records = globalStatisticsRecord || new HitStatisticsRecord;
      this.records.initForCache(this.cacheId, this.currentTimeStamp);
    }
    get currentRecord() {
      if (!this.records.records[this.cacheId][this.currentTimeStamp]) {
        this.records.records[this.cacheId][this.currentTimeStamp] = {
          cacheSize: 0,
          hits: 0,
          falsyHits: 0,
          emptyHits: 0,
          misses: 0,
          expirations: 0,
          evictions: 0,
          sets: 0,
          invalidateOne: 0,
          invalidateAll: 0
        };
      }
      return this.records.records[this.cacheId][this.currentTimeStamp];
    }
    hoursPassed() {
      return (Date.now() - this.collectionStart) / 1000 / 60 / 60;
    }
    addHit() {
      this.archiveIfNeeded();
      this.currentRecord.hits++;
    }
    addFalsyHit() {
      this.archiveIfNeeded();
      this.currentRecord.falsyHits++;
    }
    addEmptyHit() {
      this.archiveIfNeeded();
      this.currentRecord.emptyHits++;
    }
    addMiss() {
      this.archiveIfNeeded();
      this.currentRecord.misses++;
    }
    addEviction() {
      this.archiveIfNeeded();
      this.currentRecord.evictions++;
    }
    setCacheSize(currentSize) {
      this.archiveIfNeeded();
      this.currentRecord.cacheSize = currentSize;
    }
    addExpiration() {
      this.archiveIfNeeded();
      this.currentRecord.expirations++;
    }
    addSet() {
      this.archiveIfNeeded();
      this.currentRecord.sets++;
    }
    addInvalidateOne() {
      this.archiveIfNeeded();
      this.currentRecord.invalidateOne++;
    }
    addInvalidateAll() {
      this.archiveIfNeeded();
      this.currentRecord.invalidateAll++;
    }
    getStatistics() {
      return this.records.getStatistics();
    }
    archiveIfNeeded() {
      if (this.hoursPassed() >= this.statisticTtlInHours) {
        this.collectionStart = new Date;
        this.currentTimeStamp = getTimestamp(this.collectionStart);
        this.records.initForCache(this.cacheId, this.currentTimeStamp);
      }
    }
  }

  class LruObjectHitStatistics extends LruObject {
    constructor(max, ttlInMsecs, cacheId, globalStatisticsRecord, statisticTtlInHours) {
      super(max || 1000, ttlInMsecs || 0);
      if (!cacheId) {
        throw new Error("Cache id is mandatory");
      }
      this.hitStatistics = new HitStatistics(cacheId, statisticTtlInHours !== undefined ? statisticTtlInHours : 24, globalStatisticsRecord);
    }
    getStatistics() {
      return this.hitStatistics.getStatistics();
    }
    set(key, value) {
      super.set(key, value);
      this.hitStatistics.addSet();
      this.hitStatistics.setCacheSize(this.size);
    }
    evict() {
      super.evict();
      this.hitStatistics.addEviction();
      this.hitStatistics.setCacheSize(this.size);
    }
    delete(key, isExpiration = false) {
      super.delete(key);
      if (!isExpiration) {
        this.hitStatistics.addInvalidateOne();
      }
      this.hitStatistics.setCacheSize(this.size);
    }
    clear() {
      super.clear();
      this.hitStatistics.addInvalidateAll();
      this.hitStatistics.setCacheSize(this.size);
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key, true);
          this.hitStatistics.addExpiration();
          return;
        }
        this.bumpLru(item);
        if (!item.value) {
          this.hitStatistics.addFalsyHit();
        }
        if (item.value === undefined || item.value === null || item.value === "") {
          this.hitStatistics.addEmptyHit();
        }
        this.hitStatistics.addHit();
        return item.value;
      }
      this.hitStatistics.addMiss();
    }
  }

  class FifoObject {
    constructor(max = 1000, ttlInMsecs = 0) {
      if (isNaN(max) || max < 0) {
        throw new Error("Invalid max value");
      }
      if (isNaN(ttlInMsecs) || ttlInMsecs < 0) {
        throw new Error("Invalid ttl value");
      }
      this.first = null;
      this.items = Object.create(null);
      this.last = null;
      this.size = 0;
      this.max = max;
      this.ttl = ttlInMsecs;
    }
    clear() {
      this.items = Object.create(null);
      this.first = null;
      this.last = null;
      this.size = 0;
    }
    delete(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const deletedItem = this.items[key];
        delete this.items[key];
        this.size--;
        if (deletedItem.prev !== null) {
          deletedItem.prev.next = deletedItem.next;
        }
        if (deletedItem.next !== null) {
          deletedItem.next.prev = deletedItem.prev;
        }
        if (this.first === deletedItem) {
          this.first = deletedItem.next;
        }
        if (this.last === deletedItem) {
          this.last = deletedItem.prev;
        }
      }
    }
    deleteMany(keys) {
      for (var i = 0;i < keys.length; i++) {
        this.delete(keys[i]);
      }
    }
    evict() {
      if (this.size > 0) {
        const item = this.first;
        delete this.items[item.key];
        if (--this.size === 0) {
          this.first = null;
          this.last = null;
        } else {
          this.first = item.next;
          this.first.prev = null;
        }
      }
    }
    expiresAt(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        return this.items[key].expiry;
      }
    }
    get(key) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item = this.items[key];
        if (this.ttl > 0 && item.expiry <= Date.now()) {
          this.delete(key);
          return;
        }
        return item.value;
      }
    }
    getMany(keys) {
      const result = [];
      for (var i = 0;i < keys.length; i++) {
        result.push(this.get(keys[i]));
      }
      return result;
    }
    keys() {
      return Object.keys(this.items);
    }
    set(key, value) {
      if (Object.prototype.hasOwnProperty.call(this.items, key)) {
        const item2 = this.items[key];
        item2.value = value;
        item2.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
        return;
      }
      if (this.max > 0 && this.size === this.max) {
        this.evict();
      }
      const item = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      this.items[key] = item;
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
      this.last = item;
    }
  }
  exports.Fifo = FifoObject;
  exports.FifoMap = FifoMap;
  exports.FifoObject = FifoObject;
  exports.HitStatisticsRecord = HitStatisticsRecord;
  exports.Lru = LruObject;
  exports.LruHitStatistics = LruObjectHitStatistics;
  exports.LruMap = LruMap;
  exports.LruObject = LruObject;
  exports.LruObjectHitStatistics = LruObjectHitStatistics;
});

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS((exports, module) => {
  var hasBuffer = typeof Buffer !== "undefined";
  var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
  var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
  function _parse(text, reviver, options) {
    if (options == null) {
      if (reviver !== null && typeof reviver === "object") {
        options = reviver;
        reviver = undefined;
      }
    }
    if (hasBuffer && Buffer.isBuffer(text)) {
      text = text.toString();
    }
    if (text && text.charCodeAt(0) === 65279) {
      text = text.slice(1);
    }
    const obj = JSON.parse(text, reviver);
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    const protoAction = options && options.protoAction || "error";
    const constructorAction = options && options.constructorAction || "error";
    if (protoAction === "ignore" && constructorAction === "ignore") {
      return obj;
    }
    if (protoAction !== "ignore" && constructorAction !== "ignore") {
      if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
        return obj;
      }
    } else if (protoAction !== "ignore" && constructorAction === "ignore") {
      if (suspectProtoRx.test(text) === false) {
        return obj;
      }
    } else {
      if (suspectConstructorRx.test(text) === false) {
        return obj;
      }
    }
    return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
  }
  function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
    let next = [obj];
    while (next.length) {
      const nodes = next;
      next = [];
      for (const node of nodes) {
        if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
          if (safe === true) {
            return null;
          } else if (protoAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.__proto__;
        }
        if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
          if (safe === true) {
            return null;
          } else if (constructorAction === "error") {
            throw new SyntaxError("Object contains forbidden prototype property");
          }
          delete node.constructor;
        }
        for (const key in node) {
          const value = node[key];
          if (value && typeof value === "object") {
            next.push(value);
          }
        }
      }
    }
    return obj;
  }
  function parse(text, reviver, options) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text, reviver, options);
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  function safeParse(text, reviver) {
    const { stackTraceLimit } = Error;
    Error.stackTraceLimit = 0;
    try {
      return _parse(text, reviver, { safe: true });
    } catch {
      return;
    } finally {
      Error.stackTraceLimit = stackTraceLimit;
    }
  }
  module.exports = parse;
  module.exports.default = parse;
  module.exports.parse = parse;
  module.exports.safeParse = safeParse;
  module.exports.scan = filter;
});

// node_modules/fastify/lib/contentTypeParser.js
var require_contentTypeParser = __commonJS((exports, module) => {
  var { AsyncResource } = (() => ({}));
  var { FifoMap: Fifo } = require_toad_cache();
  var { parse: secureJsonParse } = require_secure_json_parse();
  var {
    kDefaultJsonParse,
    kContentTypeParser,
    kBodyLimit,
    kRequestPayloadStream,
    kState,
    kTestInternals,
    kReplyIsError,
    kRouteContext
  } = require_symbols2();
  var {
    FST_ERR_CTP_INVALID_TYPE,
    FST_ERR_CTP_EMPTY_TYPE,
    FST_ERR_CTP_ALREADY_PRESENT,
    FST_ERR_CTP_INVALID_HANDLER,
    FST_ERR_CTP_INVALID_PARSE_TYPE,
    FST_ERR_CTP_BODY_TOO_LARGE,
    FST_ERR_CTP_INVALID_MEDIA_TYPE,
    FST_ERR_CTP_INVALID_CONTENT_LENGTH,
    FST_ERR_CTP_EMPTY_JSON_BODY,
    FST_ERR_CTP_INSTANCE_ALREADY_STARTED,
    FST_ERR_CTP_INVALID_JSON_BODY
  } = require_errors2();
  var { FSTSEC001 } = require_warnings();
  function ContentTypeParser(bodyLimit, onProtoPoisoning, onConstructorPoisoning) {
    this[kDefaultJsonParse] = getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning);
    this.customParsers = new Map;
    this.customParsers.set("application/json", new Parser(true, false, bodyLimit, this[kDefaultJsonParse]));
    this.customParsers.set("text/plain", new Parser(true, false, bodyLimit, defaultPlainTextParser));
    this.parserList = ["application/json", "text/plain"];
    this.parserRegExpList = [];
    this.cache = new Fifo(100);
  }
  ContentTypeParser.prototype.add = function(contentType, opts, parserFn) {
    const contentTypeIsString = typeof contentType === "string";
    if (contentTypeIsString) {
      contentType = contentType.trim().toLowerCase();
      if (contentType.length === 0)
        throw new FST_ERR_CTP_EMPTY_TYPE;
    } else if (!(contentType instanceof RegExp)) {
      throw new FST_ERR_CTP_INVALID_TYPE;
    }
    if (typeof parserFn !== "function") {
      throw new FST_ERR_CTP_INVALID_HANDLER;
    }
    if (this.existingParser(contentType)) {
      throw new FST_ERR_CTP_ALREADY_PRESENT(contentType);
    }
    if (opts.parseAs !== undefined) {
      if (opts.parseAs !== "string" && opts.parseAs !== "buffer") {
        throw new FST_ERR_CTP_INVALID_PARSE_TYPE(opts.parseAs);
      }
    }
    const parser = new Parser(opts.parseAs === "string", opts.parseAs === "buffer", opts.bodyLimit, parserFn);
    if (contentType === "*") {
      this.customParsers.set("", parser);
    } else {
      if (contentTypeIsString) {
        this.parserList.unshift(contentType);
        this.customParsers.set(contentType, parser);
      } else {
        validateRegExp(contentType);
        this.parserRegExpList.unshift(contentType);
        this.customParsers.set(contentType.toString(), parser);
      }
    }
  };
  ContentTypeParser.prototype.hasParser = function(contentType) {
    if (typeof contentType === "string") {
      contentType = contentType.trim().toLowerCase();
    } else {
      if (!(contentType instanceof RegExp))
        throw new FST_ERR_CTP_INVALID_TYPE;
      contentType = contentType.toString();
    }
    return this.customParsers.has(contentType);
  };
  ContentTypeParser.prototype.existingParser = function(contentType) {
    if (contentType === "application/json" && this.customParsers.has(contentType)) {
      return this.customParsers.get(contentType).fn !== this[kDefaultJsonParse];
    }
    if (contentType === "text/plain" && this.customParsers.has(contentType)) {
      return this.customParsers.get(contentType).fn !== defaultPlainTextParser;
    }
    return this.hasParser(contentType);
  };
  ContentTypeParser.prototype.getParser = function(contentType) {
    let parser = this.customParsers.get(contentType);
    if (parser !== undefined)
      return parser;
    parser = this.cache.get(contentType);
    if (parser !== undefined)
      return parser;
    const caseInsensitiveContentType = contentType.toLowerCase();
    for (let i = 0;i !== this.parserList.length; ++i) {
      const parserListItem = this.parserList[i];
      if (caseInsensitiveContentType.slice(0, parserListItem.length) === parserListItem && (caseInsensitiveContentType.length === parserListItem.length || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 59 || caseInsensitiveContentType.charCodeAt(parserListItem.length) === 32)) {
        parser = this.customParsers.get(parserListItem);
        this.cache.set(contentType, parser);
        return parser;
      }
    }
    for (let j3 = 0;j3 !== this.parserRegExpList.length; ++j3) {
      const parserRegExp = this.parserRegExpList[j3];
      if (parserRegExp.test(contentType)) {
        parser = this.customParsers.get(parserRegExp.toString());
        this.cache.set(contentType, parser);
        return parser;
      }
    }
    return this.customParsers.get("");
  };
  ContentTypeParser.prototype.removeAll = function() {
    this.customParsers = new Map;
    this.parserRegExpList = [];
    this.parserList = [];
    this.cache = new Fifo(100);
  };
  ContentTypeParser.prototype.remove = function(contentType) {
    let parsers;
    if (typeof contentType === "string") {
      contentType = contentType.trim().toLowerCase();
      parsers = this.parserList;
    } else {
      if (!(contentType instanceof RegExp))
        throw new FST_ERR_CTP_INVALID_TYPE;
      contentType = contentType.toString();
      parsers = this.parserRegExpList;
    }
    const removed = this.customParsers.delete(contentType);
    const idx = parsers.findIndex((ct2) => ct2.toString() === contentType);
    if (idx > -1) {
      parsers.splice(idx, 1);
    }
    return removed || idx > -1;
  };
  ContentTypeParser.prototype.run = function(contentType, handler, request, reply) {
    const parser = this.getParser(contentType);
    if (parser === undefined) {
      if (request.is404 === true) {
        handler(request, reply);
        return;
      }
      reply[kReplyIsError] = true;
      reply.send(new FST_ERR_CTP_INVALID_MEDIA_TYPE(contentType || undefined));
      return;
    }
    const resource = new AsyncResource("content-type-parser:run", request);
    const done = resource.bind(onDone);
    if (parser.asString === true || parser.asBuffer === true) {
      rawBody(request, reply, reply[kRouteContext]._parserOptions, parser, done);
      return;
    }
    const result = parser.fn(request, request[kRequestPayloadStream], done);
    if (result && typeof result.then === "function") {
      result.then((body) => {
        done(null, body);
      }, done);
    }
    function onDone(error, body) {
      resource.emitDestroy();
      if (error != null) {
        reply.header("connection", "close");
        reply[kReplyIsError] = true;
        reply.send(error);
        return;
      }
      request.body = body;
      handler(request, reply);
    }
  };
  function rawBody(request, reply, options, parser, done) {
    const asString = parser.asString === true;
    const limit = options.limit === null ? parser.bodyLimit : options.limit;
    const contentLength = Number(request.headers["content-length"]);
    if (contentLength > limit) {
      done(new FST_ERR_CTP_BODY_TOO_LARGE, undefined);
      return;
    }
    let receivedLength = 0;
    let body = asString ? "" : [];
    const payload = request[kRequestPayloadStream] || request.raw;
    if (asString) {
      payload.setEncoding("utf8");
    }
    payload.on("data", onData);
    payload.on("end", onEnd);
    payload.on("error", onEnd);
    payload.resume();
    function onData(chunk) {
      receivedLength += asString ? Buffer.byteLength(chunk) : chunk.length;
      const { receivedEncodedLength = 0 } = payload;
      if (receivedLength > limit || receivedEncodedLength > limit) {
        payload.removeListener("data", onData);
        payload.removeListener("end", onEnd);
        payload.removeListener("error", onEnd);
        done(new FST_ERR_CTP_BODY_TOO_LARGE, undefined);
        return;
      }
      if (asString) {
        body += chunk;
      } else {
        body.push(chunk);
      }
    }
    function onEnd(err) {
      payload.removeListener("data", onData);
      payload.removeListener("end", onEnd);
      payload.removeListener("error", onEnd);
      if (err != null) {
        if (!(typeof err.statusCode === "number" && err.statusCode >= 400)) {
          err.statusCode = 400;
        }
        done(err, undefined);
        return;
      }
      if (!Number.isNaN(contentLength) && (payload.receivedEncodedLength || receivedLength) !== contentLength) {
        done(new FST_ERR_CTP_INVALID_CONTENT_LENGTH, undefined);
        return;
      }
      if (!asString) {
        body = Buffer.concat(body);
      }
      const result = parser.fn(request, body, done);
      if (result && typeof result.then === "function") {
        result.then((body2) => {
          done(null, body2);
        }, done);
      }
    }
  }
  function getDefaultJsonParser(onProtoPoisoning, onConstructorPoisoning) {
    const parseOptions = { protoAction: onProtoPoisoning, constructorAction: onConstructorPoisoning };
    return defaultJsonParser;
    function defaultJsonParser(req, body, done) {
      if (body.length === 0) {
        done(new FST_ERR_CTP_EMPTY_JSON_BODY, undefined);
        return;
      }
      try {
        done(null, secureJsonParse(body, parseOptions));
      } catch {
        done(new FST_ERR_CTP_INVALID_JSON_BODY, undefined);
      }
    }
  }
  function defaultPlainTextParser(req, body, done) {
    done(null, body);
  }
  function Parser(asString, asBuffer, bodyLimit, fn) {
    this.asString = asString;
    this.asBuffer = asBuffer;
    this.bodyLimit = bodyLimit;
    this.fn = fn;
  }
  function buildContentTypeParser(c2) {
    const contentTypeParser = new ContentTypeParser;
    contentTypeParser[kDefaultJsonParse] = c2[kDefaultJsonParse];
    contentTypeParser.customParsers = new Map(c2.customParsers.entries());
    contentTypeParser.parserList = c2.parserList.slice();
    contentTypeParser.parserRegExpList = c2.parserRegExpList.slice();
    return contentTypeParser;
  }
  function addContentTypeParser(contentType, opts, parser) {
    if (this[kState].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("addContentTypeParser");
    }
    if (typeof opts === "function") {
      parser = opts;
      opts = {};
    }
    if (!opts)
      opts = {};
    if (!opts.bodyLimit)
      opts.bodyLimit = this[kBodyLimit];
    if (Array.isArray(contentType)) {
      contentType.forEach((type) => this[kContentTypeParser].add(type, opts, parser));
    } else {
      this[kContentTypeParser].add(contentType, opts, parser);
    }
    return this;
  }
  function hasContentTypeParser(contentType) {
    return this[kContentTypeParser].hasParser(contentType);
  }
  function removeContentTypeParser(contentType) {
    if (this[kState].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeContentTypeParser");
    }
    if (Array.isArray(contentType)) {
      for (const type of contentType) {
        this[kContentTypeParser].remove(type);
      }
    } else {
      this[kContentTypeParser].remove(contentType);
    }
  }
  function removeAllContentTypeParsers() {
    if (this[kState].started) {
      throw new FST_ERR_CTP_INSTANCE_ALREADY_STARTED("removeAllContentTypeParsers");
    }
    this[kContentTypeParser].removeAll();
  }
  function validateRegExp(regexp) {
    if (regexp.source[0] !== "^" && regexp.source.includes(";?") === false) {
      FSTSEC001(regexp.source);
    }
  }
  module.exports = ContentTypeParser;
  module.exports.helpers = {
    buildContentTypeParser,
    addContentTypeParser,
    hasContentTypeParser,
    removeContentTypeParser,
    removeAllContentTypeParsers
  };
  module.exports.defaultParsers = {
    getDefaultJsonParser,
    defaultTextParser: defaultPlainTextParser
  };
  module.exports[kTestInternals] = { rawBody };
});

// node_modules/dequal/dist/index.js
var require_dist = __commonJS((exports) => {
  var has = Object.prototype.hasOwnProperty;
  function find(iter, tar, key) {
    for (key of iter.keys()) {
      if (dequal(key, tar))
        return key;
    }
  }
  function dequal(foo, bar) {
    var ctor, len, tmp;
    if (foo === bar)
      return true;
    if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
      if (ctor === Date)
        return foo.getTime() === bar.getTime();
      if (ctor === RegExp)
        return foo.toString() === bar.toString();
      if (ctor === Array) {
        if ((len = foo.length) === bar.length) {
          while (len-- && dequal(foo[len], bar[len]))
            ;
        }
        return len === -1;
      }
      if (ctor === Set) {
        if (foo.size !== bar.size) {
          return false;
        }
        for (len of foo) {
          tmp = len;
          if (tmp && typeof tmp === "object") {
            tmp = find(bar, tmp);
            if (!tmp)
              return false;
          }
          if (!bar.has(tmp))
            return false;
        }
        return true;
      }
      if (ctor === Map) {
        if (foo.size !== bar.size) {
          return false;
        }
        for (len of foo) {
          tmp = len[0];
          if (tmp && typeof tmp === "object") {
            tmp = find(bar, tmp);
            if (!tmp)
              return false;
          }
          if (!dequal(len[1], bar.get(tmp))) {
            return false;
          }
        }
        return true;
      }
      if (ctor === ArrayBuffer) {
        foo = new Uint8Array(foo);
        bar = new Uint8Array(bar);
      } else if (ctor === DataView) {
        if ((len = foo.byteLength) === bar.byteLength) {
          while (len-- && foo.getInt8(len) === bar.getInt8(len))
            ;
        }
        return len === -1;
      }
      if (ArrayBuffer.isView(foo)) {
        if ((len = foo.byteLength) === bar.byteLength) {
          while (len-- && foo[len] === bar[len])
            ;
        }
        return len === -1;
      }
      if (!ctor || typeof foo === "object") {
        len = 0;
        for (ctor in foo) {
          if (has.call(foo, ctor) && ++len && !has.call(bar, ctor))
            return false;
          if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor]))
            return false;
        }
        return Object.keys(bar).length === len;
      }
    }
    return foo !== foo && bar !== bar;
  }
  exports.dequal = dequal;
});

// node_modules/json-schema-ref-resolver/index.js
var require_json_schema_ref_resolver = __commonJS((exports, module) => {
  var { dequal: deepEqual } = require_dist();
  var jsonSchemaRefSymbol = Symbol.for("json-schema-ref");

  class RefResolver {
    #schemas;
    #derefSchemas;
    #insertRefSymbol;
    #allowEqualDuplicates;
    #cloneSchemaWithoutRefs;
    constructor(opts = {}) {
      this.#schemas = {};
      this.#derefSchemas = {};
      this.#insertRefSymbol = opts.insertRefSymbol ?? false;
      this.#allowEqualDuplicates = opts.allowEqualDuplicates ?? true;
      this.#cloneSchemaWithoutRefs = opts.cloneSchemaWithoutRefs ?? false;
    }
    addSchema(schema, rootSchemaId, isRootSchema = true) {
      if (isRootSchema) {
        if (schema.$id !== undefined && schema.$id.charAt(0) !== "#") {
          rootSchemaId = schema.$id;
        } else {
          this.#insertSchemaBySchemaId(schema, rootSchemaId);
        }
      }
      const schemaId = schema.$id;
      if (schemaId !== undefined && typeof schemaId === "string") {
        if (schemaId.charAt(0) === "#") {
          this.#insertSchemaByAnchor(schema, rootSchemaId, schemaId);
        } else {
          this.#insertSchemaBySchemaId(schema, schemaId);
          rootSchemaId = schemaId;
        }
      }
      const ref = schema.$ref;
      if (ref !== undefined && typeof ref === "string") {
        const { refSchemaId, refJsonPointer } = this.#parseSchemaRef(ref, rootSchemaId);
        this.#schemas[rootSchemaId].refs.push({
          schemaId: refSchemaId,
          jsonPointer: refJsonPointer
        });
      }
      for (const key in schema) {
        if (typeof schema[key] === "object" && schema[key] !== null) {
          this.addSchema(schema[key], rootSchemaId, false);
        }
      }
    }
    getSchema(schemaId, jsonPointer = "#") {
      const schema = this.#schemas[schemaId];
      if (schema === undefined) {
        throw new Error(`Cannot resolve ref "${schemaId}${jsonPointer}". Schema with id "${schemaId}" is not found.`);
      }
      if (schema.anchors[jsonPointer] !== undefined) {
        return schema.anchors[jsonPointer];
      }
      return getDataByJSONPointer(schema.schema, jsonPointer);
    }
    hasSchema(schemaId) {
      return this.#schemas[schemaId] !== undefined;
    }
    getSchemaRefs(schemaId) {
      const schema = this.#schemas[schemaId];
      if (schema === undefined) {
        throw new Error(`Schema with id "${schemaId}" is not found.`);
      }
      return schema.refs;
    }
    getSchemaDependencies(schemaId, dependencies = {}) {
      const schema = this.#schemas[schemaId];
      for (const ref of schema.refs) {
        const dependencySchemaId = ref.schemaId;
        if (dependencySchemaId === schemaId || dependencies[dependencySchemaId] !== undefined)
          continue;
        dependencies[dependencySchemaId] = this.getSchema(dependencySchemaId);
        this.getSchemaDependencies(dependencySchemaId, dependencies);
      }
      return dependencies;
    }
    derefSchema(schemaId) {
      if (this.#derefSchemas[schemaId] !== undefined)
        return;
      const schema = this.#schemas[schemaId];
      if (schema === undefined) {
        throw new Error(`Schema with id "${schemaId}" is not found.`);
      }
      if (!this.#cloneSchemaWithoutRefs && schema.refs.length === 0) {
        this.#derefSchemas[schemaId] = {
          schema: schema.schema,
          anchors: schema.anchors
        };
      }
      const refs = [];
      this.#addDerefSchema(schema.schema, schemaId, true, refs);
      const dependencies = this.getSchemaDependencies(schemaId);
      for (const schemaId2 in dependencies) {
        const schema2 = dependencies[schemaId2];
        this.#addDerefSchema(schema2, schemaId2, true, refs);
      }
      for (const ref of refs) {
        const {
          refSchemaId,
          refJsonPointer
        } = this.#parseSchemaRef(ref.ref, ref.sourceSchemaId);
        const targetSchema = this.getDerefSchema(refSchemaId, refJsonPointer);
        if (targetSchema === null) {
          throw new Error(`Cannot resolve ref "${ref.ref}". Ref "${refJsonPointer}" is not found in schema "${refSchemaId}".`);
        }
        ref.targetSchema = targetSchema;
        ref.targetSchemaId = refSchemaId;
      }
      for (const ref of refs) {
        this.#resolveRef(ref, refs);
      }
    }
    getDerefSchema(schemaId, jsonPointer = "#") {
      let derefSchema = this.#derefSchemas[schemaId];
      if (derefSchema === undefined) {
        this.derefSchema(schemaId);
        derefSchema = this.#derefSchemas[schemaId];
      }
      if (derefSchema.anchors[jsonPointer] !== undefined) {
        return derefSchema.anchors[jsonPointer];
      }
      return getDataByJSONPointer(derefSchema.schema, jsonPointer);
    }
    #parseSchemaRef(ref, schemaId) {
      const sharpIndex = ref.indexOf("#");
      if (sharpIndex === -1) {
        return { refSchemaId: ref, refJsonPointer: "#" };
      }
      if (sharpIndex === 0) {
        return { refSchemaId: schemaId, refJsonPointer: ref };
      }
      return {
        refSchemaId: ref.slice(0, sharpIndex),
        refJsonPointer: ref.slice(sharpIndex)
      };
    }
    #addDerefSchema(schema, rootSchemaId, isRootSchema, refs = []) {
      const derefSchema = Array.isArray(schema) ? [...schema] : { ...schema };
      if (isRootSchema) {
        if (schema.$id !== undefined && schema.$id.charAt(0) !== "#") {
          rootSchemaId = schema.$id;
        } else {
          this.#insertDerefSchemaBySchemaId(derefSchema, rootSchemaId);
        }
      }
      const schemaId = derefSchema.$id;
      if (schemaId !== undefined && typeof schemaId === "string") {
        if (schemaId.charAt(0) === "#") {
          this.#insertDerefSchemaByAnchor(derefSchema, rootSchemaId, schemaId);
        } else {
          this.#insertDerefSchemaBySchemaId(derefSchema, schemaId);
          rootSchemaId = schemaId;
        }
      }
      if (derefSchema.$ref !== undefined) {
        refs.push({
          ref: derefSchema.$ref,
          sourceSchemaId: rootSchemaId,
          sourceSchema: derefSchema
        });
      }
      for (const key in derefSchema) {
        const value = derefSchema[key];
        if (typeof value === "object" && value !== null) {
          derefSchema[key] = this.#addDerefSchema(value, rootSchemaId, false, refs);
        }
      }
      return derefSchema;
    }
    #resolveRef(ref, refs) {
      const { sourceSchema, targetSchema } = ref;
      if (!sourceSchema.$ref)
        return;
      if (this.#insertRefSymbol) {
        sourceSchema[jsonSchemaRefSymbol] = sourceSchema.$ref;
      }
      delete sourceSchema.$ref;
      if (targetSchema.$ref) {
        const targetSchemaRef = refs.find((ref2) => ref2.sourceSchema === targetSchema);
        this.#resolveRef(targetSchemaRef, refs);
      }
      for (const key in targetSchema) {
        if (key === "$id")
          continue;
        if (sourceSchema[key] !== undefined) {
          if (deepEqual(sourceSchema[key], targetSchema[key]))
            continue;
          throw new Error(`Cannot resolve ref "${ref.ref}". Property "${key}" already exists in schema "${ref.sourceSchemaId}".`);
        }
        sourceSchema[key] = targetSchema[key];
      }
      ref.isResolved = true;
    }
    #insertSchemaBySchemaId(schema, schemaId) {
      const foundSchema = this.#schemas[schemaId];
      if (foundSchema !== undefined) {
        if (this.#allowEqualDuplicates && deepEqual(schema, foundSchema.schema))
          return;
        throw new Error(`There is already another schema with id "${schemaId}".`);
      }
      this.#schemas[schemaId] = { schema, anchors: {}, refs: [] };
    }
    #insertSchemaByAnchor(schema, schemaId, anchor) {
      const { anchors } = this.#schemas[schemaId];
      if (anchors[anchor] !== undefined) {
        throw new Error(`There is already another anchor "${anchor}" in schema "${schemaId}".`);
      }
      anchors[anchor] = schema;
    }
    #insertDerefSchemaBySchemaId(schema, schemaId) {
      const foundSchema = this.#derefSchemas[schemaId];
      if (foundSchema !== undefined)
        return;
      this.#derefSchemas[schemaId] = { schema, anchors: {} };
    }
    #insertDerefSchemaByAnchor(schema, schemaId, anchor) {
      const { anchors } = this.#derefSchemas[schemaId];
      anchors[anchor] = schema;
    }
  }
  function getDataByJSONPointer(data, jsonPointer) {
    const parts = jsonPointer.split("/");
    let current = data;
    for (const part of parts) {
      if (part === "" || part === "#")
        continue;
      if (typeof current !== "object" || current === null) {
        return null;
      }
      current = current[part];
    }
    return current ?? null;
  }
  module.exports = { RefResolver };
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = undefined;

  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;

  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;

  class _Code extends _CodeOrName {
    constructor(code) {
      super();
      this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== undefined ? _a : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== undefined ? _a : this._names = this._items.reduce((names, c2) => {
        if (c2 instanceof Name)
          names[c2.str] = (names[c2.str] || 0) + 1;
        return names;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _3(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code, args[i]);
      code.push(strs[++i]);
    }
    return new _Code(code);
  }
  exports._ = _3;
  var plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code, arg) {
    if (arg instanceof _Code)
      code.push(...arg._items);
    else if (arg instanceof Name)
      code.push(arg);
    else
      code.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== undefined) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a3, b5) {
    if (b5 === '""')
      return a3;
    if (a3 === '""')
      return b5;
    if (typeof a3 == "string") {
      if (b5 instanceof Name || a3[a3.length - 1] !== '"')
        return;
      if (typeof b5 != "string")
        return `${a3.slice(0, -1)}${b5}"`;
      if (b5[0] === '"')
        return a3.slice(0, -1) + b5.slice(1);
      return;
    }
    if (typeof b5 == "string" && b5[0] === '"' && !(a3 instanceof Name))
      return `"${a3}${b5.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x3) {
    return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
  }
  function stringify(x3) {
    return new _Code(safeStringify(x3));
  }
  exports.stringify = stringify;
  function safeStringify(x3) {
    return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _3`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = undefined;
  var code_1 = require_code();

  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var")
  };

  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === undefined ? undefined : _a._prefixes) === null || _b === undefined ? undefined : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;

  class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  var line = (0, code_1._)`\n`;

  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === undefined)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== undefined ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map;
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_1._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code = code_1.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map;
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c2 = valueCode(name);
          if (c2) {
            const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
          } else if (c2 = getCode === null || getCode === undefined ? undefined : getCode(name)) {
            code = (0, code_1._)`${code}${c2}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code;
    }
  }
  exports.ValueScope = ValueScope;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = undefined;
  var code_1 = require_code();
  var scope_1 = require_scope();
  var code_2 = require_code();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = require_scope();
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+")
  };

  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }

  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n: _n2 }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n2;
    }
    optimizeNames(names, constants) {
      if (!names[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
  }

  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} = ${this.rhs};` + _n2;
    }
    optimizeNames(names, constants) {
      if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
      return addExprNames(names, this.rhs);
    }
  }

  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
    }
  }

  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      return `${this.label}:` + _n2;
    }
  }

  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n2;
    }
  }

  class Throw extends Node {
    constructor(error) {
      super();
      this.error = error;
    }
    render({ _n: _n2 }) {
      return `throw ${this.error};` + _n2;
    }
    get names() {
      return this.error.names;
    }
  }

  class AnyCode extends Node {
    constructor(code) {
      super();
      this.code = code;
    }
    render({ _n: _n2 }) {
      return `${this.code};` + _n2;
    }
    optimizeNodes() {
      return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
      this.code = optimizeExpr(this.code, names, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
  }

  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names, constants))
          continue;
        subtractNames(names, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    get names() {
      return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
  }

  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }

  class Root extends ParentNode {
  }

  class Else extends BlockNode {
  }
  Else.kind = "else";

  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code += "else " + this.else.render(opts);
      return code;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return;
      return this;
    }
    optimizeNames(names, constants) {
      var _a;
      this.else = (_a = this.else) === null || _a === undefined ? undefined : _a.optimizeNames(names, constants);
      if (!(super.optimizeNames(names, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      addExprNames(names, this.condition);
      if (this.else)
        addNames(names, this.else.names);
      return names;
    }
  }
  If.kind = "if";

  class For extends BlockNode {
  }
  For.kind = "for";

  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }

  class ForRange extends For {
    constructor(varKind, name, from, to2) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to2;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to: to2 } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to2}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names = addExprNames(super.names, this.from);
      return addExprNames(names, this.to);
    }
  }

  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }

  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";

  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";

  class Try extends BlockNode {
    render(opts) {
      let code = "try" + super.render(opts);
      if (this.catch)
        code += this.catch.render(opts);
      if (this.finally)
        code += this.finally.render(opts);
      return code;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === undefined || _a.optimizeNodes();
      (_b = this.finally) === null || _b === undefined || _b.optimizeNodes();
      return this;
    }
    optimizeNames(names, constants) {
      var _a, _b;
      super.optimizeNames(names, constants);
      (_a = this.catch) === null || _a === undefined || _a.optimizeNames(names, constants);
      (_b = this.finally) === null || _b === undefined || _b.optimizeNames(names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      if (this.catch)
        addNames(names, this.catch.names);
      if (this.finally)
        addNames(names, this.finally.names);
      return names;
    }
  }

  class Catch extends BlockNode {
    constructor(error) {
      super();
      this.error = error;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";

  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";

  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? `
` : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set);
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== undefined && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c2) {
      if (typeof c2 == "function")
        c2();
      else if (c2 !== code_1.nil)
        this._leafNode(new AnyCode(c2));
      return this;
    }
    object(...keyValues) {
      const code = ["{"];
      for (const [key, value] of keyValues) {
        if (code.length > 1)
          code.push(",");
        code.push(key);
        if (key !== value || this.opts.es5) {
          code.push(":");
          (0, code_1.addCodeArg)(code, value);
        }
      }
      code.push("}");
      return new code_1._Code(code);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else);
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to2), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
          this.var(name, (0, code_1._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return;
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try;
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error = this.name("e");
        this._currNode = node.catch = new Catch(error);
        catchCode(error);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally;
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error) {
      return this._leafNode(new Throw(error));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === undefined)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_1.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N22) {
      const n = this._currNode;
      if (n instanceof N1 || N22 && n instanceof N22) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
  }
  function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
  }
  function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_1._Code(expr._items.reduce((items, c2) => {
      if (c2 instanceof code_1.Name)
        c2 = replaceName(c2);
      if (c2 instanceof code_1._Code)
        items.push(...c2._items);
      else
        items.push(c2);
      return items;
    }, []));
    function replaceName(n) {
      const c2 = constants[n.str];
      if (c2 === undefined || names[n.str] !== 1)
        return n;
      delete names[n.str];
      return c2;
    }
    function canOptimize(e) {
      return e instanceof code_1._Code && e._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== undefined);
    }
  }
  function subtractNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) - (from[n] || 0);
  }
  function not(x3) {
    return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_1._)`!${par(x3)}`;
  }
  exports.not = not;
  var andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  var orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x3, y3) => x3 === code_1.nil ? y3 : y3 === code_1.nil ? x3 : (0, code_1._)`${par(x3)} ${op} ${par(y3)}`;
  }
  function par(x3) {
    return x3 instanceof code_1.Name ? x3 : (0, code_1._)`(${x3})`;
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = undefined;
  var codegen_1 = require_codegen();
  var code_1 = require_code();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it2, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it2, schema);
    return !schemaHasRules(schema, it2.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it2, schema = it2.schema) {
    const { opts, self: self2 } = it2;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules[key])
        checkStrictMode(it2, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f2) {
    if (Array.isArray(xs)) {
      for (const x3 of xs)
        f2(x3);
    } else {
      f2(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to2, toName) => {
      const res = to2 === undefined ? from : to2 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to2) : mergeToName(gen, from, to2), to2) : from instanceof codegen_1.Name ? (mergeToName(gen, to2, from), from) : mergeValues(from, to2);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1._)`${to2} || {}`).code((0, codegen_1._)`Object.assign(${to2}, ${from})`));
      }),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => {
        if (from === true) {
          gen.assign(to2, true);
        } else {
          gen.assign(to2, (0, codegen_1._)`${to2} || {}`);
          setEvaluated(gen, to2, from);
        }
      }),
      mergeValues: (from, to2) => from === true ? true : { ...from, ...to2 },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => gen.assign(to2, (0, codegen_1._)`${from} === true ? true : ${to2} > ${from} ? ${to2} : ${from}`)),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => gen.assign(to2, from === true ? true : (0, codegen_1._)`${to2} > ${from} ? ${to2} : ${from}`)),
      mergeValues: (from, to2) => from === true ? true : Math.max(from, to2),
      resultToName: (gen, items) => gen.var("items", items)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== undefined)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p3) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p3)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  var snippets = {};
  function useFunc(gen, f2) {
    return gen.scopeValue("func", {
      ref: f2,
      code: snippets[f2.code] || (snippets[f2.code] = new code_1._Code(f2.code))
    });
  }
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (exports.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it2.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var names = {
    data: new codegen_1.Name("data"),
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  exports.default = names;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/errors.js
var require_errors3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var names_1 = require_names();
  exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
  };
  function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== undefined ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it2, names_1.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword, schemaValue, data, errsCount, it: it2 }) {
    if (errsCount === undefined)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
      gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
      gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
      gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword}`);
      if (it2.opts.verbose) {
        gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_1._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._)`${names_1.default.errors}++`);
  }
  function returnErrors(it2, errs) {
    const { gen, validateName, schemaEnv } = it2;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  var E5 = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema")
  };
  function errorObjectCode(cxt, error, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_1._)`{}`;
    return errorObject(cxt, error, errorPaths);
  }
  function errorObject(cxt, error, errorPaths = {}) {
    const { gen, it: it2 } = cxt;
    const keyValues = [
      errorInstancePath(it2, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
    if (schemaPath) {
      schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E5.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it: it2 } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it2;
    keyValues.push([E5.keyword, keyword], [E5.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
    if (opts.messages) {
      keyValues.push([E5.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E5.schema, schemaValue], [E5.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E5.propertyName, propertyName]);
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;
  var errors_1 = require_errors3();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it2) {
    const { gen, schema, validateName } = it2;
    if (schema === false) {
      falseSchemaError(it2, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it2, valid) {
    const { gen, schema } = it2;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it2);
    } else {
      gen.var(valid, true);
    }
  }
  exports.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it2, overrideAllErrors) {
    const { gen, data } = it2;
    const cxt = {
      gen,
      keyword: "false schema",
      data,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it: it2
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRules = exports.isJSONType = undefined;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  function isJSONType(x3) {
    return typeof x3 == "string" && jsonTypes.has(x3);
  }
  exports.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  exports.getRules = getRules;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = undefined;
  function schemaHasRulesForType({ schema, self: self2 }, type) {
    const group = self2.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  exports.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  exports.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a;
    return schema[rule.keyword] !== undefined || ((_a = rule.definition.implements) === null || _a === undefined ? undefined : _a.some((kwd) => schema[kwd] !== undefined));
  }
  exports.shouldUseRule = shouldUseRule;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = undefined;
  var rules_1 = require_rules();
  var applicability_1 = require_applicability();
  var errors_1 = require_errors3();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (exports.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types.length && schema.nullable !== undefined) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types.push("null");
    }
    return types;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
      return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it2, types) {
    const { gen, data, opts } = it2;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it2, types, coerceTo);
        else
          reportTypeError(it2);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types, coerceTypes) {
    return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it2, types, coerceTo) {
    const { gen, data, opts } = it2;
    const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it2);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it2, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
      case "null":
        return (0, codegen_1._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
      const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
      cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
      delete types.null;
      delete types.array;
      delete types.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types.number)
      delete types.integer;
    for (const t in types)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  var typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it2) {
    const cxt = getTypeErrorContext(it2);
    (0, errors_1.reportError)(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it2) {
    const { gen, data, schema } = it2;
    const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it: it2
    };
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assignDefaults = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  function assignDefaults(it2, ty) {
    const { properties, items } = it2.schema;
    if (ty === "object" && properties) {
      for (const key in properties) {
        assignDefault(it2, key, properties[key].default);
      }
    } else if (ty === "array" && Array.isArray(items)) {
      items.forEach((sch, i) => assignDefault(it2, i, sch.default));
    }
  }
  exports.assignDefaults = assignDefaults;
  function assignDefault(it2, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it2;
    if (defaultValue === undefined)
      return;
    const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var names_1 = require_names();
  var util_2 = require_util();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data, it: it2 } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  exports.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  exports.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  exports.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  exports.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
  }
  exports.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
  }
  exports.propertyInData = propertyInData;
  function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
  }
  exports.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p3) => p3 !== "__proto__") : [];
  }
  exports.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it2, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p3]));
  }
  exports.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it2.parentData],
      [names_1.default.parentDataProperty, it2.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it2.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  exports.callValidateCode = callValidateCode;
  var newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern) {
    const u2 = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u2);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u2})`
    });
  }
  exports.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data, keyword, it: it2 } = cxt;
    const valid = gen.name("valid");
    if (it2.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  exports.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
    if (alwaysValid && !it2.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  exports.validateUnion = validateUnion;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = undefined;
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var code_1 = require_code2();
  var errors_1 = require_errors3();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it: it2 } = cxt;
    const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it2.opts.validateSchema !== false)
      it2.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it2.errSchemaPath}/${keyword}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  exports.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it: it2 } = cxt;
    checkAsyncKeyword(it2, def);
    const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== undefined ? _a : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !(("compile" in def) && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
      var _a2;
      gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== undefined ? _a2 : valid), errors);
    }
  }
  exports.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data, it: it2 } = cxt;
    gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword, result) {
    if (result === undefined)
      throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
  }
  exports.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === undefined ? undefined : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword]);
      if (!valid) {
        const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  exports.validateKeywordUsage = validateKeywordUsage;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  function getSubschema(it2, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
      const sch = it2.schema[keyword];
      return schemaProp === undefined ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== undefined) {
      if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  exports.getSubschema = getSubschema;
  function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it2;
    if (dataProp !== undefined) {
      const { errorPath, dataPathArr, opts } = it2;
      const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
      const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
      dataContextProps(nextData);
      if (propertyName !== undefined)
        subschema.propertyName = propertyName;
    }
    if (dataTypes)
      subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema.data = _nextData;
      subschema.dataLevel = it2.dataLevel + 1;
      subschema.dataTypes = [];
      it2.definedProperties = new Set;
      subschema.parentData = it2.data;
      subschema.dataNames = [...it2.dataNames, _nextData];
    }
  }
  exports.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
      subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
      subschema.createErrors = createErrors;
    if (allErrors !== undefined)
      subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator;
    subschema.jtdMetadata = jtdMetadata;
  }
  exports.extendSubschemaMode = extendSubschemaMode;
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a3, b5) {
    if (a3 === b5)
      return true;
    if (a3 && b5 && typeof a3 == "object" && typeof b5 == "object") {
      if (a3.constructor !== b5.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a3)) {
        length = a3.length;
        if (length != b5.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a3[i], b5[i]))
            return false;
        return true;
      }
      if (a3.constructor === RegExp)
        return a3.source === b5.source && a3.flags === b5.flags;
      if (a3.valueOf !== Object.prototype.valueOf)
        return a3.valueOf() === b5.valueOf();
      if (a3.toString !== Object.prototype.toString)
        return a3.toString() === b5.toString();
      keys = Object.keys(a3);
      length = keys.length;
      if (length !== Object.keys(b5).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b5, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a3[key], b5[key]))
          return false;
      }
      return true;
    }
    return a3 !== a3 && b5 !== b5;
  };
});

// node_modules/fast-json-stringify/node_modules/ajv/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports, module) => {
  var traverse = module.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0;i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = undefined;
  var util_1 = require_util();
  var equal = require_fast_deep_equal();
  var traverse = require_json_schema_traverse();
  var SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  }
  exports.inlineRef = inlineRef;
  var REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
      id = normalizeId(id);
    const p3 = resolver.parse(id);
    return _getFullPath(resolver, p3);
  }
  exports.getFullPath = getFullPath;
  function _getFullPath(resolver, p3) {
    const serialized = resolver.serialize(p3);
    return serialized.split("#")[0] + "#";
  }
  exports._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  exports.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
  }
  exports.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set;
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _3, parentJsonPtr) => {
      if (parentJsonPtr === undefined)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref) {
        const _resolve = this.opts.uriResolver.resolve;
        ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
        if (schemaRefs.has(ref))
          throw ambiguos(ref);
        schemaRefs.add(ref);
        let schOrRef = this.refs[ref];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref);
        } else if (ref !== normalizeId(fullPath)) {
          if (ref[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref], ref);
            localRefs[ref] = sch;
          } else {
            this.refs[ref] = fullPath;
          }
        }
        return ref;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
      if (sch2 !== undefined && !equal(sch1, sch2))
        throw ambiguos(ref);
    }
    function ambiguos(ref) {
      return new Error(`reference "${ref}" resolves to more than one schema`);
    }
  }
  exports.getSchemaRefs = getSchemaRefs;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;
  var boolSchema_1 = require_boolSchema();
  var dataType_1 = require_dataType();
  var applicability_1 = require_applicability();
  var dataType_2 = require_dataType();
  var defaults_1 = require_defaults();
  var keyword_1 = require_keyword();
  var subschema_1 = require_subschema();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util();
  var errors_1 = require_errors3();
  function validateFunctionCode(it2) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        topSchemaObjCode(it2);
        return;
      }
    }
    validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
  }
  exports.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it2) {
    const { schema, opts, gen } = it2;
    validateFunction(it2, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      checkNoDefault(it2);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it2);
      typeAndKeywords(it2);
      returnResults(it2);
    });
    return;
  }
  function resetEvaluated(it2) {
    const { gen, validateName } = it2;
    it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it2, valid) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        subSchemaObjCode(it2, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it2) {
    return typeof it2.schema != "boolean";
  }
  function subSchemaObjCode(it2, valid) {
    const { schema, gen, opts } = it2;
    if (opts.$comment && schema.$comment)
      commentKeyword(it2);
    updateContext(it2);
    checkAsyncSchema(it2);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it2, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it2) {
    (0, util_1.checkUnknownRules)(it2);
    checkRefsAndKeywords(it2);
  }
  function typeAndKeywords(it2, errsCount) {
    if (it2.opts.jtd)
      return schemaKeywords(it2, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it2.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types);
    schemaKeywords(it2, types, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it2) {
    const { schema, errSchemaPath, opts, self: self2 } = it2;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it2) {
    const { schema, opts } = it2;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
    }
  }
  function updateContext(it2) {
    const schId = it2.schema[it2.opts.schemaId];
    if (schId)
      it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
  }
  function checkAsyncSchema(it2) {
    if (it2.schema.$async && !it2.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it2) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it2);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items);
  }
  function schemaKeywords(it2, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self: self2 } = it2;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it2, types);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
        iterateKeywords(it2, group);
        if (types.length === 1 && types[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it2);
        }
        gen.endIf();
      } else {
        iterateKeywords(it2, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it2, group) {
    const { gen, schema, opts: { useDefaults } } = it2;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it2, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it2, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it2, types) {
    if (it2.schemaEnv.meta || !it2.opts.strictTypes)
      return;
    checkContextTypes(it2, types);
    if (!it2.opts.allowUnionTypes)
      checkMultipleTypes(it2, types);
    checkKeywordTypes(it2, it2.dataTypes);
  }
  function checkContextTypes(it2, types) {
    if (!types.length)
      return;
    if (!it2.dataTypes.length) {
      it2.dataTypes = types;
      return;
    }
    types.forEach((t) => {
      if (!includesType(it2.dataTypes, t)) {
        strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it2, types);
  }
  function checkMultipleTypes(it2, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it2, ts) {
    const rules = it2.self.RULES.all;
    for (const keyword in rules) {
      const rule = rules[keyword];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
        const { type } = rule.definition;
        if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it2, withTypes) {
    const ts = [];
    for (const t of it2.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it2.dataTypes = ts;
  }
  function strictTypesError(it2, msg) {
    const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
  }

  class KeywordCxt {
    constructor(it2, def, keyword) {
      (0, keyword_1.validateKeywordUsage)(it2, def, keyword);
      this.gen = it2.gen;
      this.allErrors = it2.allErrors;
      this.keyword = keyword;
      this.data = it2.data;
      this.schema = it2.schema[keyword];
      this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it2.schema;
      this.params = {};
      this.it = it2;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it2.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
      if (condition === undefined) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === undefined)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it: it2 } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);
      const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it: it2, gen } = this;
      if (!it2.opts.unevaluated)
        return;
      if (it2.props !== true && schemaCxt.props !== undefined) {
        it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
      }
      if (it2.items !== true && schemaCxt.items !== undefined) {
        it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it: it2, gen } = this;
      if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  exports.KeywordCxt = KeywordCxt;
  function keywordCode(it2, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it2, def, keyword);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  exports.getData = getData;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ValidationError extends Error {
    constructor(errors) {
      super("validation failed");
      this.errors = errors;
      this.ajv = this.validation = true;
    }
  }
  exports.default = ValidationError;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolve_1 = require_resolve();

  class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
      super(msg || `can't resolve reference ${ref} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  exports.default = MissingRefError;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = undefined;
  var codegen_1 = require_codegen();
  var validation_error_1 = require_validation_error();
  var names_1 = require_names();
  var resolve_1 = require_resolve();
  var util_1 = require_util();
  var validate_1 = require_validate();

  class SchemaEnv {
    constructor(env) {
      var _a;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a = env.baseId) !== null && _a !== undefined ? _a : (0, resolve_1.normalizeId)(schema === null || schema === undefined ? undefined : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === undefined ? undefined : schema.$async;
      this.refs = {};
    }
  }
  exports.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set,
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate });
      validate.errors = null;
      validate.schema = sch.schema;
      validate.schemaEnv = sch;
      if (sch.$async)
        validate.$async = true;
      if (this.opts.code.source === true) {
        validate.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items } = schemaCxt;
        validate.evaluated = {
          props: props instanceof codegen_1.Name ? undefined : props,
          items: items instanceof codegen_1.Name ? undefined : items,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items instanceof codegen_1.Name
        };
        if (validate.source)
          validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
      }
      sch.validate = validate;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  exports.compileSchema = compileSchema;
  function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
      const schema = (_a = root.localRefs) === null || _a === undefined ? undefined : _a[ref];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
      return;
    return root.refs[ref] = inlineOrCompile.call(this, _sch);
  }
  exports.resolveRef = resolveRef;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  exports.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve(root, ref) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
      ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
  }
  function resolveSchema(root, ref) {
    const p3 = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p3);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p3, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === undefined ? undefined : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p3, sch);
    }
    if (typeof (schOrRef === null || schOrRef === undefined ? undefined : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p3, schOrRef);
  }
  exports.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === undefined ? undefined : _a[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === undefined)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return;
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS((exports, module) => {
  module.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
      }
    },
    additionalProperties: false
  };
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
  var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
  function stringArrayToHexStripped(input) {
    let acc = "";
    let code = 0;
    let i = 0;
    for (i = 0;i < input.length; i++) {
      code = input[i].charCodeAt(0);
      if (code === 48) {
        continue;
      }
      if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
        return "";
      }
      acc += input[i];
      break;
    }
    for (i += 1;i < input.length; i++) {
      code = input[i].charCodeAt(0);
      if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
        return "";
      }
      acc += input[i];
    }
    return acc;
  }
  var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
  function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
  }
  function consumeHextets(buffer, address, output) {
    if (buffer.length) {
      const hex = stringArrayToHexStripped(buffer);
      if (hex !== "") {
        address.push(hex);
      } else {
        output.error = true;
        return false;
      }
      buffer.length = 0;
    }
    return true;
  }
  function getIPV6(input) {
    let tokenCount = 0;
    const output = { error: false, address: "", zone: "" };
    const address = [];
    const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for (let i = 0;i < input.length; i++) {
      const cursor = input[i];
      if (cursor === "[" || cursor === "]") {
        continue;
      }
      if (cursor === ":") {
        if (endipv6Encountered === true) {
          endIpv6 = true;
        }
        if (!consume(buffer, address, output)) {
          break;
        }
        if (++tokenCount > 7) {
          output.error = true;
          break;
        }
        if (i > 0 && input[i - 1] === ":") {
          endipv6Encountered = true;
        }
        address.push(":");
        continue;
      } else if (cursor === "%") {
        if (!consume(buffer, address, output)) {
          break;
        }
        consume = consumeIsZone;
      } else {
        buffer.push(cursor);
        continue;
      }
    }
    if (buffer.length) {
      if (consume === consumeIsZone) {
        output.zone = buffer.join("");
      } else if (endIpv6) {
        address.push(buffer.join(""));
      } else {
        address.push(stringArrayToHexStripped(buffer));
      }
    }
    output.address = address.join("");
    return output;
  }
  function normalizeIPv6(host) {
    if (findToken(host, ":") < 2) {
      return { host, isIPV6: false };
    }
    const ipv6 = getIPV6(host);
    if (!ipv6.error) {
      let newHost = ipv6.address;
      let escapedHost = ipv6.address;
      if (ipv6.zone) {
        newHost += "%" + ipv6.zone;
        escapedHost += "%25" + ipv6.zone;
      }
      return { host: newHost, isIPV6: true, escapedHost };
    } else {
      return { host, isIPV6: false };
    }
  }
  function findToken(str, token) {
    let ind = 0;
    for (let i = 0;i < str.length; i++) {
      if (str[i] === token)
        ind++;
    }
    return ind;
  }
  function removeDotSegments(path) {
    let input = path;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    while (len = input.length) {
      if (len === 1) {
        if (input === ".") {
          break;
        } else if (input === "/") {
          output.push("/");
          break;
        } else {
          output.push(input);
          break;
        }
      } else if (len === 2) {
        if (input[0] === ".") {
          if (input[1] === ".") {
            break;
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === "." || input[1] === "/") {
            output.push("/");
            break;
          }
        }
      } else if (len === 3) {
        if (input === "/..") {
          if (output.length !== 0) {
            output.pop();
          }
          output.push("/");
          break;
        }
      }
      if (input[0] === ".") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(3);
            continue;
          }
        } else if (input[1] === "/") {
          input = input.slice(2);
          continue;
        }
      } else if (input[0] === "/") {
        if (input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === ".") {
            if (input[3] === "/") {
              input = input.slice(3);
              if (output.length !== 0) {
                output.pop();
              }
              continue;
            }
          }
        }
      }
      if ((nextSlash = input.indexOf("/", 1)) === -1) {
        output.push(input);
        break;
      } else {
        output.push(input.slice(0, nextSlash));
        input = input.slice(nextSlash);
      }
    }
    return output.join("");
  }
  function normalizeComponentEncoding(component, esc) {
    const func = esc !== true ? escape : unescape;
    if (component.scheme !== undefined) {
      component.scheme = func(component.scheme);
    }
    if (component.userinfo !== undefined) {
      component.userinfo = func(component.userinfo);
    }
    if (component.host !== undefined) {
      component.host = func(component.host);
    }
    if (component.path !== undefined) {
      component.path = func(component.path);
    }
    if (component.query !== undefined) {
      component.query = func(component.query);
    }
    if (component.fragment !== undefined) {
      component.fragment = func(component.fragment);
    }
    return component;
  }
  function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== undefined) {
      uriTokens.push(component.userinfo);
      uriTokens.push("@");
    }
    if (component.host !== undefined) {
      let host = unescape(component.host);
      if (!isIPv4(host)) {
        const ipV6res = normalizeIPv6(host);
        if (ipV6res.isIPV6 === true) {
          host = `[${ipV6res.escapedHost}]`;
        } else {
          host = component.host;
        }
      }
      uriTokens.push(host);
    }
    if (typeof component.port === "number" || typeof component.port === "string") {
      uriTokens.push(":");
      uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
  }
  module.exports = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
  };
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS((exports, module) => {
  var { isUUID } = require_utils();
  var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  var supportedSchemeNames = [
    "http",
    "https",
    "ws",
    "wss",
    "urn",
    "urn:uuid"
  ];
  function isValidSchemeName(name) {
    return supportedSchemeNames.indexOf(name) !== -1;
  }
  function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
      return true;
    } else if (wsComponent.secure === false) {
      return false;
    } else if (wsComponent.scheme) {
      return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
    } else {
      return false;
    }
  }
  function httpParse(component) {
    if (!component.host) {
      component.error = component.error || "HTTP URIs must have a host.";
    }
    return component;
  }
  function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === "https";
    if (component.port === (secure ? 443 : 80) || component.port === "") {
      component.port = undefined;
    }
    if (!component.path) {
      component.path = "/";
    }
    return component;
  }
  function wsParse(wsComponent) {
    wsComponent.secure = wsIsSecure(wsComponent);
    wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
    wsComponent.path = undefined;
    wsComponent.query = undefined;
    return wsComponent;
  }
  function wsSerialize(wsComponent) {
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
      wsComponent.port = undefined;
    }
    if (typeof wsComponent.secure === "boolean") {
      wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
      wsComponent.secure = undefined;
    }
    if (wsComponent.resourceName) {
      const [path, query] = wsComponent.resourceName.split("?");
      wsComponent.path = path && path !== "/" ? path : undefined;
      wsComponent.query = query;
      wsComponent.resourceName = undefined;
    }
    wsComponent.fragment = undefined;
    return wsComponent;
  }
  function urnParse(urnComponent, options) {
    if (!urnComponent.path) {
      urnComponent.error = "URN can not be parsed";
      return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
      const scheme = options.scheme || urnComponent.scheme || "urn";
      urnComponent.nid = matches[1].toLowerCase();
      urnComponent.nss = matches[2];
      const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      urnComponent.path = undefined;
      if (schemeHandler) {
        urnComponent = schemeHandler.parse(urnComponent, options);
      }
    } else {
      urnComponent.error = urnComponent.error || "URN can not be parsed.";
    }
    return urnComponent;
  }
  function urnSerialize(urnComponent, options) {
    if (urnComponent.nid === undefined) {
      throw new Error("URN without nid cannot be serialized");
    }
    const scheme = options.scheme || urnComponent.scheme || "urn";
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
      urnComponent = schemeHandler.serialize(urnComponent, options);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponent;
  }
  function urnuuidParse(urnComponent, options) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = undefined;
    if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
      uuidComponent.error = uuidComponent.error || "UUID is not valid.";
    }
    return uuidComponent;
  }
  function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
    return urnComponent;
  }
  var http = {
    scheme: "http",
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
  };
  var https = {
    scheme: "https",
    domainHost: http.domainHost,
    parse: httpParse,
    serialize: httpSerialize
  };
  var ws = {
    scheme: "ws",
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
  };
  var wss = {
    scheme: "wss",
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
  };
  var urn = {
    scheme: "urn",
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
  };
  var urnuuid = {
    scheme: "urn:uuid",
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
  };
  var SCHEMES = {
    http,
    https,
    ws,
    wss,
    urn,
    "urn:uuid": urnuuid
  };
  Object.setPrototypeOf(SCHEMES, null);
  function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[scheme] || SCHEMES[scheme.toLowerCase()]) || undefined;
  }
  module.exports = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
  };
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS((exports, module) => {
  var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
  var { SCHEMES, getSchemeHandler } = require_schemes();
  function normalize(uri, options) {
    if (typeof uri === "string") {
      uri = serialize(parse(uri, options), options);
    } else if (typeof uri === "object") {
      uri = parse(serialize(uri, options), options);
    }
    return uri;
  }
  function resolve(baseURI, relativeURI, options) {
    const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
    const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize(resolved, schemelessOptions);
  }
  function resolveComponent(base, relative, options, skipNormalization) {
    const target = {};
    if (!skipNormalization) {
      base = parse(serialize(base, options), options);
      relative = parse(serialize(relative, options), options);
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
      target.scheme = relative.scheme;
      target.userinfo = relative.userinfo;
      target.host = relative.host;
      target.port = relative.port;
      target.path = removeDotSegments(relative.path || "");
      target.query = relative.query;
    } else {
      if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (!relative.path) {
          target.path = base.path;
          if (relative.query !== undefined) {
            target.query = relative.query;
          } else {
            target.query = base.query;
          }
        } else {
          if (relative.path[0] === "/") {
            target.path = removeDotSegments(relative.path);
          } else {
            if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
              target.path = "/" + relative.path;
            } else if (!base.path) {
              target.path = relative.path;
            } else {
              target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
            }
            target.path = removeDotSegments(target.path);
          }
          target.query = relative.query;
        }
        target.userinfo = base.userinfo;
        target.host = base.host;
        target.port = base.port;
      }
      target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
  }
  function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
      uriA = unescape(uriA);
      uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true });
    } else if (typeof uriA === "object") {
      uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
    }
    if (typeof uriB === "string") {
      uriB = unescape(uriB);
      uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true });
    } else if (typeof uriB === "object") {
      uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
  }
  function serialize(cmpts, opts) {
    const component = {
      host: cmpts.host,
      scheme: cmpts.scheme,
      userinfo: cmpts.userinfo,
      port: cmpts.port,
      path: cmpts.path,
      query: cmpts.query,
      nid: cmpts.nid,
      nss: cmpts.nss,
      uuid: cmpts.uuid,
      fragment: cmpts.fragment,
      reference: cmpts.reference,
      resourceName: cmpts.resourceName,
      secure: cmpts.secure,
      error: ""
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
    if (schemeHandler && schemeHandler.serialize)
      schemeHandler.serialize(component, options);
    if (component.path !== undefined) {
      if (!options.skipEscape) {
        component.path = escape(component.path);
        if (component.scheme !== undefined) {
          component.path = component.path.split("%3A").join(":");
        }
      } else {
        component.path = unescape(component.path);
      }
    }
    if (options.reference !== "suffix" && component.scheme) {
      uriTokens.push(component.scheme, ":");
    }
    const authority = recomposeAuthority(component);
    if (authority !== undefined) {
      if (options.reference !== "suffix") {
        uriTokens.push("//");
      }
      uriTokens.push(authority);
      if (component.path && component.path[0] !== "/") {
        uriTokens.push("/");
      }
    }
    if (component.path !== undefined) {
      let s2 = component.path;
      if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
        s2 = removeDotSegments(s2);
      }
      if (authority === undefined && s2[0] === "/" && s2[1] === "/") {
        s2 = "/%2F" + s2.slice(2);
      }
      uriTokens.push(s2);
    }
    if (component.query !== undefined) {
      uriTokens.push("?", component.query);
    }
    if (component.fragment !== undefined) {
      uriTokens.push("#", component.fragment);
    }
    return uriTokens.join("");
  }
  var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function parse(uri, opts) {
    const options = Object.assign({}, opts);
    const parsed = {
      scheme: undefined,
      userinfo: undefined,
      host: "",
      port: undefined,
      path: "",
      query: undefined,
      fragment: undefined
    };
    let isIP = false;
    if (options.reference === "suffix") {
      if (options.scheme) {
        uri = options.scheme + ":" + uri;
      } else {
        uri = "//" + uri;
      }
    }
    const matches = uri.match(URI_PARSE);
    if (matches) {
      parsed.scheme = matches[1];
      parsed.userinfo = matches[3];
      parsed.host = matches[4];
      parsed.port = parseInt(matches[5], 10);
      parsed.path = matches[6] || "";
      parsed.query = matches[7];
      parsed.fragment = matches[8];
      if (isNaN(parsed.port)) {
        parsed.port = matches[5];
      }
      if (parsed.host) {
        const ipv4result = isIPv4(parsed.host);
        if (ipv4result === false) {
          const ipv6result = normalizeIPv6(parsed.host);
          parsed.host = ipv6result.host.toLowerCase();
          isIP = ipv6result.isIPV6;
        } else {
          isIP = true;
        }
      }
      if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
        parsed.reference = "same-document";
      } else if (parsed.scheme === undefined) {
        parsed.reference = "relative";
      } else if (parsed.fragment === undefined) {
        parsed.reference = "absolute";
      } else {
        parsed.reference = "uri";
      }
      if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
        parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
      }
      const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
      if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
        if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        }
      }
      if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
        if (uri.indexOf("%") !== -1) {
          if (parsed.scheme !== undefined) {
            parsed.scheme = unescape(parsed.scheme);
          }
          if (parsed.host !== undefined) {
            parsed.host = unescape(parsed.host);
          }
        }
        if (parsed.path) {
          parsed.path = escape(unescape(parsed.path));
        }
        if (parsed.fragment) {
          parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
        }
      }
      if (schemeHandler && schemeHandler.parse) {
        schemeHandler.parse(parsed, options);
      }
    } else {
      parsed.error = parsed.error || "URI can not be parsed.";
    }
    return parsed;
  }
  var fastUri = {
    SCHEMES,
    normalize,
    resolve,
    resolveComponent,
    equal,
    serialize,
    parse
  };
  module.exports = fastUri;
  module.exports.default = fastUri;
  module.exports.fastUri = fastUri;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uri = require_fast_uri();
  uri.code = 'require("ajv/dist/runtime/uri").default';
  exports.default = uri;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/core.js
var require_core = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  var ref_error_1 = require_ref_error();
  var rules_1 = require_rules();
  var compile_1 = require_compile();
  var codegen_2 = require_codegen();
  var resolve_1 = require_resolve();
  var dataType_1 = require_dataType();
  var util_1 = require_util();
  var $dataRefSchema = require_data();
  var uri_1 = require_uri();
  var defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  var EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  var removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  var deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  var MAX_EXPRESSION = 200;
  function requiredOptions(o2) {
    var _a, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r3, _s, _t3, _u, _v, _w, _x, _y, _z, _0;
    const s2 = o2.strict;
    const _optz = (_a = o2.code) === null || _a === undefined ? undefined : _a.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o2.code) === null || _b === undefined ? undefined : _b.regExp) !== null && _c !== undefined ? _c : defaultRegExp;
    const uriResolver = (_d = o2.uriResolver) !== null && _d !== undefined ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e3 = o2.strictSchema) !== null && _e3 !== undefined ? _e3 : s2) !== null && _f !== undefined ? _f : true,
      strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== undefined ? _g : s2) !== null && _h !== undefined ? _h : true,
      strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== undefined ? _j : s2) !== null && _k !== undefined ? _k : "log",
      strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== undefined ? _l : s2) !== null && _m !== undefined ? _m : "log",
      strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== undefined ? _o : s2) !== null && _p !== undefined ? _p : false,
      code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o2.loopRequired) !== null && _q !== undefined ? _q : MAX_EXPRESSION,
      loopEnum: (_r3 = o2.loopEnum) !== null && _r3 !== undefined ? _r3 : MAX_EXPRESSION,
      meta: (_s = o2.meta) !== null && _s !== undefined ? _s : true,
      messages: (_t3 = o2.messages) !== null && _t3 !== undefined ? _t3 : true,
      inlineRefs: (_u = o2.inlineRefs) !== null && _u !== undefined ? _u : true,
      schemaId: (_v = o2.schemaId) !== null && _v !== undefined ? _v : "$id",
      addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== undefined ? _w : true,
      validateSchema: (_x = o2.validateSchema) !== null && _x !== undefined ? _x : true,
      validateFormats: (_y = o2.validateFormats) !== null && _y !== undefined ? _y : true,
      unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== undefined ? _z : true,
      int32range: (_0 = o2.int32range) !== null && _0 !== undefined ? _0 : true,
      uriResolver
    };
  }

  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set;
      this._loading = {};
      this._cache = new Map;
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined;
    }
    validate(schemaKeyRef, data) {
      let v2;
      if (typeof schemaKeyRef == "string") {
        v2 = this.getSchema(schemaKeyRef);
        if (!v2)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v2 = this.compile(schemaKeyRef);
      }
      const valid = v2(data);
      if (!("$async" in v2))
        this.errors = v2.errors;
      return valid;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_1.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref, missingRef }) {
        if (this.refs[ref]) {
          throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref) {
        const _schema = await _loadSchema.call(this, ref);
        if (!this.refs[ref])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref])
          this.addSchema(_schema, ref, meta);
      }
      async function _loadSchema(ref) {
        const p3 = this._loading[ref];
        if (p3)
          return p3;
        try {
          return await (this._loading[ref] = loadSchema(ref));
        } finally {
          delete this._loading[ref];
        }
      }
    }
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, undefined, _meta, _validateSchema);
        return this;
      }
      let id;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id = schema[schemaId];
        if (id !== undefined && typeof id != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_1.normalizeId)(key || id);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema;
      $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }
      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === undefined) {
        const { schemaId } = this.opts;
        const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id = schemaKeyRef[this.opts.schemaId];
          if (id) {
            id = (0, resolve_1.normalizeId)(id);
            delete this.schemas[id];
            delete this.refs[id];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions) {
      for (const def of definitions)
        this.addKeyword(def);
      return this;
    }
    addKeyword(kwdOrDef, def) {
      let keyword;
      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;
        if (typeof def == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (typeof kwdOrDef == "object" && def === undefined) {
        def = kwdOrDef;
        keyword = def.keyword;
        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword, def);
      if (!def) {
        (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def);
      const definition = {
        ...def,
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      };
      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k3) => addRule.call(this, k3, definition) : (k3) => definition.type.forEach((t) => addRule.call(this, k3, definition, t)));
      return this;
    }
    getKeyword(keyword) {
      const rule = this.RULES.all[keyword];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword) {
      const { RULES } = this;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this.formats[name] = format;
      return this;
    }
    errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors || errors.length === 0)
        return "No errors";
      return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules) {
          const rule = rules[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== undefined)
        return sch;
      baseId = (0, resolve_1.normalizeId)(id || baseId);
      const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id) {
      if (this.schemas[id] || this.refs[id]) {
        throw new Error(`schema with key or id "${id}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_1.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_1.default;
  Ajv.MissingRefError = ref_error_1.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format = this.opts.formats[name];
      if (format)
        this.addFormat(name, format);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
      const def = defs[keyword];
      if (!def.keyword)
        def.keyword = keyword;
      this.addKeyword(def);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  var noLogs = { log() {}, warn() {}, error() {} };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === undefined)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
      return;
    if (def.$data && !(("code" in def) || ("validate" in def))) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === undefined ? undefined : definition.post;
    if (dataType && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
      return;
    const rule = {
      keyword,
      definition: {
        ...definition,
        type: (0, dataType_1.getJSONTypes)(definition.type),
        schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === undefined || _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
      return;
    if (def.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
  }
  var $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callRef = exports.getValidate = undefined;
  var ref_error_1 = require_ref_error();
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var compile_1 = require_compile();
  var util_1 = require_util();
  var def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it: it2 } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === undefined)
        throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v2 = getValidate(cxt, sch);
        callRef(cxt, v2, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  exports.getValidate = getValidate;
  function callRef(cxt, v2, sch, $async) {
    const { gen, it: it2 } = cxt;
    const { allErrors, schemaEnv: env, opts } = it2;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v2, passCxt)}`);
        addEvaluatedFrom(v2);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a;
      if (!it2.opts.unevaluated)
        return;
      const schEvaluated = (_a = sch === null || sch === undefined ? undefined : sch.validate) === null || _a === undefined ? undefined : _a.evaluated;
      if (it2.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== undefined) {
            it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
        }
      }
      if (it2.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== undefined) {
            it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
          }
        } else {
          const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
        }
      }
    }
  }
  exports.callRef = callRef;
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var id_1 = require_id();
  var ref_1 = require_ref();
  var core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  exports.default = core;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var ops = codegen_1.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  var def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  var def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, schemaCode, it: it2 } = cxt;
      const prec = it2.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  exports.default = ucs2length;
  ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var ucs2length_1 = require_ucs2length();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode, it: it2 } = cxt;
      const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  var def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { data, $data, schema, schemaCode, it: it2 } = cxt;
      const u2 = it2.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  var def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
      const { opts } = it2;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it2.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === undefined ? undefined : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
            const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var equal = require_fast_deep_equal();
  equal.code = 'require("ajv/dist/runtime/equal").default';
  exports.default = equal;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dataType_1 = require_dataType();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error = {
    message: ({ params: { i, j: j3 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j3} and ${i} are identical)`,
    params: ({ params: { i, j: j3 } }) => (0, codegen_1._)`{i: ${i}, j: ${j3}}`
  };
  var def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data}.length`);
        const j3 = gen.let("j");
        cxt.setParams({ i, j: j3 });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j3));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j3) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j3, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j3) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j3} = ${i}; ${j3}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j3}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  var def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var equal_1 = require_equal();
  var error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it2.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== undefined ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var limitNumber_1 = require_limitNumber();
  var multipleOf_1 = require_multipleOf();
  var limitLength_1 = require_limitLength();
  var pattern_1 = require_pattern();
  var limitProperties_1 = require_limitProperties();
  var required_1 = require_required();
  var limitItems_1 = require_limitItems();
  var uniqueItems_1 = require_uniqueItems();
  var const_1 = require_const();
  var enum_1 = require_enum();
  var validation = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  exports.default = validation;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAdditionalItems = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { parentSchema, it: it2 } = cxt;
      const { items } = parentSchema;
      if (!Array.isArray(items)) {
        (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items);
    }
  };
  function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it: it2 } = cxt;
    it2.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items.length, len, (i) => {
        cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it2.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  exports.validateAdditionalItems = validateAdditionalItems;
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTuple = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it: it2 } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it: it2 } = cxt;
    checkStrictTuple(parentSchema);
    if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
      it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it2, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it2;
      const l3 = schArr.length;
      const fullTuple = l3 === sch.minItems && (l3 === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword}" is ${l3}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
      }
    }
  }
  exports.validateTuple = validateTuple;
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var items_1 = require_items();
  var def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  var additionalItems_1 = require_additionalItems();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { schema, parentSchema, it: it2 } = cxt;
      const { prefixItems } = parentSchema;
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      if (prefixItems)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error = {
    message: ({ params: { min, max } }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data, it: it2 } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it2.opts.next) {
        min = minContains === undefined ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === undefined && min === 0) {
        (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== undefined && min > max) {
        (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== undefined)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it2.items = true;
      const valid = gen.name("valid");
      if (max === undefined && min === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid, true);
        if (max !== undefined)
          gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === undefined) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
          if (min === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = undefined;
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var code_1 = require_code2();
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  var def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it: it2 } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it2.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_1.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_1.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it: it2 } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
        continue;
      gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
        cxt.mergeValidEvaluated(schCxt, valid);
      }, () => gen.var(valid, true));
      cxt.ok(valid);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  var def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
      const { gen, schema, data, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it2.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var names_1 = require_names();
  var util_1 = require_util();
  var error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it2;
      it2.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p3) => (0, codegen_1._)`${key} === ${p3}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p3) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p3)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors) {
        const subschema = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors === false) {
          Object.assign(subschema, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validate_1 = require_validate();
  var code_1 = require_code2();
  var util_1 = require_util();
  var additionalProperties_1 = require_additionalProperties();
  var def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data, it: it2 } = cxt;
      if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it2.definedProperties.add(prop);
      }
      if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
        it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
      }
      const properties = allProps.filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schema[p3]));
      if (properties.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it2.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== undefined;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var util_2 = require_util();
  var def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data, parentSchema, it: it2 } = cxt;
      const { opts } = it2;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p3) => (0, util_1.alwaysValidSchema)(it2, schema[p3]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
        it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
      }
      const { props } = it2;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it2.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it2.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it2.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code2();
  var def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  var def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it2.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it2, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var util_1 = require_util();
  var error = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  var def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, parentSchema, it: it2 } = cxt;
      if (parentSchema.then === undefined && parentSchema.else === undefined) {
        (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it2, "then");
      const hasElse = hasSchema(it2, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
          else
            cxt.setParams({ ifClause: keyword });
        };
      }
    }
  };
  function hasSchema(it2, keyword) {
    const schema = it2.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it2, schema);
  }
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it: it2 }) {
      if (parentSchema.if === undefined)
        (0, util_1.checkStrictMode)(it2, `"${keyword}" without "if" is ignored`);
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var additionalItems_1 = require_additionalItems();
  var prefixItems_1 = require_prefixItems();
  var items_1 = require_items();
  var items2020_1 = require_items2020();
  var contains_1 = require_contains();
  var dependencies_1 = require_dependencies();
  var propertyNames_1 = require_propertyNames();
  var additionalProperties_1 = require_additionalProperties();
  var properties_1 = require_properties();
  var patternProperties_1 = require_patternProperties();
  var not_1 = require_not();
  var anyOf_1 = require_anyOf();
  var oneOf_1 = require_oneOf();
  var allOf_1 = require_allOf();
  var if_1 = require_if();
  var thenElse_1 = require_thenElse();
  function getApplicator(draft2020 = false) {
    const applicator = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator.push(prefixItems_1.default, items2020_1.default);
    else
      applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
  }
  exports.default = getApplicator;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  var def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
      const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
          const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
          return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data})`;
          }
          return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var format_1 = require_format();
  var format = [format_1.default];
  exports.default = format;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contentVocabulary = exports.metadataVocabulary = undefined;
  exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core_1 = require_core2();
  var validation_1 = require_validation2();
  var applicator_1 = require_applicator();
  var format_1 = require_format2();
  var metadata_1 = require_metadata();
  var draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  exports.default = draft7Vocabularies;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = undefined;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (exports.DiscrError = DiscrError = {}));
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen();
  var types_1 = require_types();
  var compile_1 = require_compile();
  var ref_error_1 = require_ref_error();
  var util_1 = require_util();
  var error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
      const { gen, data, schema, parentSchema, it: it2 } = cxt;
      const { oneOf } = parentSchema;
      if (!it2.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0;i < oneOf.length; i++) {
          let sch = oneOf[i];
          if ((sch === null || sch === undefined ? undefined : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
            const ref = sch.$ref;
            sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === undefined)
              throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref);
          }
          const propSch = (_a = sch === null || sch === undefined ? undefined : sch.properties) === null || _a === undefined ? undefined : _a[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required }) {
          return Array.isArray(required) && required.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});

// node_modules/fast-json-stringify/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = undefined;
  var core_1 = require_core();
  var draft7_1 = require_draft7();
  var discriminator_1 = require_discriminator();
  var draft7MetaSchema = require_json_schema_draft_07();
  var META_SUPPORT_DATA = ["/properties"];
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";

  class Ajv extends core_1.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v2) => this.addVocabulary(v2));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
  }
  exports.Ajv = Ajv;
  module.exports = exports = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatNames = exports.fastFormats = exports.fullFormats = undefined;
  function fmtDef(validate, compare) {
    return { validate, compare };
  }
  exports.fullFormats = {
    date: fmtDef(date, compareDate),
    time: fmtDef(getTime(true), compareTime),
    "date-time": fmtDef(getDateTime(true), compareDateTime),
    "iso-time": fmtDef(getTime(), compareIsoTime),
    "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    byte,
    int32: { type: "number", validate: validateInt32 },
    int64: { type: "number", validate: validateInt64 },
    float: { type: "number", validate: validateNumber },
    double: { type: "number", validate: validateNumber },
    password: true,
    binary: true
  };
  exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
    "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
  };
  exports.formatNames = Object.keys(exports.fullFormats);
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function date(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function compareDate(d1, d22) {
    if (!(d1 && d22))
      return;
    if (d1 > d22)
      return 1;
    if (d1 < d22)
      return -1;
    return 0;
  }
  var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function getTime(strictTimeZone) {
    return function time(str) {
      const matches = TIME.exec(str);
      if (!matches)
        return false;
      const hr3 = +matches[1];
      const min = +matches[2];
      const sec = +matches[3];
      const tz = matches[4];
      const tzSign = matches[5] === "-" ? -1 : 1;
      const tzH = +(matches[6] || 0);
      const tzM = +(matches[7] || 0);
      if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
        return false;
      if (hr3 <= 23 && min <= 59 && sec < 60)
        return true;
      const utcMin = min - tzM * tzSign;
      const utcHr = hr3 - tzH * tzSign - (utcMin < 0 ? 1 : 0);
      return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
    };
  }
  function compareTime(s1, s2) {
    if (!(s1 && s2))
      return;
    const t1 = new Date("2020-01-01T" + s1).valueOf();
    const t2 = new Date("2020-01-01T" + s2).valueOf();
    if (!(t1 && t2))
      return;
    return t1 - t2;
  }
  function compareIsoTime(t1, t2) {
    if (!(t1 && t2))
      return;
    const a1 = TIME.exec(t1);
    const a22 = TIME.exec(t2);
    if (!(a1 && a22))
      return;
    t1 = a1[1] + a1[2] + a1[3];
    t2 = a22[1] + a22[2] + a22[3];
    if (t1 > t2)
      return 1;
    if (t1 < t2)
      return -1;
    return 0;
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function getDateTime(strictTimeZone) {
    const time = getTime(strictTimeZone);
    return function date_time(str) {
      const dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1]);
    };
  }
  function compareDateTime(dt1, dt22) {
    if (!(dt1 && dt22))
      return;
    const d1 = new Date(dt1).valueOf();
    const d22 = new Date(dt22).valueOf();
    if (!(d1 && d22))
      return;
    return d1 - d22;
  }
  function compareIsoDateTime(dt1, dt22) {
    if (!(dt1 && dt22))
      return;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d22, t2] = dt22.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d22);
    if (res === undefined)
      return;
    return res || compareTime(t1, t2);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
  }
  var MIN_INT32 = -(2 ** 31);
  var MAX_INT32 = 2 ** 31 - 1;
  function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
  }
  function validateInt64(value) {
    return Number.isInteger(value);
  }
  function validateNumber() {
    return true;
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js
var require_code3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = undefined;

  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;

  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;

  class _Code extends _CodeOrName {
    constructor(code) {
      super();
      this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== undefined ? _a : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== undefined ? _a : this._names = this._items.reduce((names, c2) => {
        if (c2 instanceof Name)
          names[c2.str] = (names[c2.str] || 0) + 1;
        return names;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _3(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code, args[i]);
      code.push(strs[++i]);
    }
    return new _Code(code);
  }
  exports._ = _3;
  var plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code, arg) {
    if (arg instanceof _Code)
      code.push(...arg._items);
    else if (arg instanceof Name)
      code.push(arg);
    else
      code.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== undefined) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a3, b5) {
    if (b5 === '""')
      return a3;
    if (a3 === '""')
      return b5;
    if (typeof a3 == "string") {
      if (b5 instanceof Name || a3[a3.length - 1] !== '"')
        return;
      if (typeof b5 != "string")
        return `${a3.slice(0, -1)}${b5}"`;
      if (b5[0] === '"')
        return a3.slice(0, -1) + b5.slice(1);
      return;
    }
    if (typeof b5 == "string" && b5[0] === '"' && !(a3 instanceof Name))
      return `"${a3}${b5.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x3) {
    return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
  }
  function stringify(x3) {
    return new _Code(safeStringify(x3));
  }
  exports.stringify = stringify;
  function safeStringify(x3) {
    return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _3`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = undefined;
  var code_1 = require_code3();

  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var")
  };

  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === undefined ? undefined : _a._prefixes) === null || _b === undefined ? undefined : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;

  class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  var line = (0, code_1._)`\n`;

  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === undefined)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== undefined ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map;
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_1._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code = code_1.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map;
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c2 = valueCode(name);
          if (c2) {
            const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
          } else if (c2 = getCode === null || getCode === undefined ? undefined : getCode(name)) {
            code = (0, code_1._)`${code}${c2}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code;
    }
  }
  exports.ValueScope = ValueScope;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = undefined;
  var code_1 = require_code3();
  var scope_1 = require_scope2();
  var code_2 = require_code3();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = require_scope2();
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+")
  };

  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }

  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n: _n2 }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n2;
    }
    optimizeNames(names, constants) {
      if (!names[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
  }

  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} = ${this.rhs};` + _n2;
    }
    optimizeNames(names, constants) {
      if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
      return addExprNames(names, this.rhs);
    }
  }

  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
    }
  }

  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      return `${this.label}:` + _n2;
    }
  }

  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n2;
    }
  }

  class Throw extends Node {
    constructor(error) {
      super();
      this.error = error;
    }
    render({ _n: _n2 }) {
      return `throw ${this.error};` + _n2;
    }
    get names() {
      return this.error.names;
    }
  }

  class AnyCode extends Node {
    constructor(code) {
      super();
      this.code = code;
    }
    render({ _n: _n2 }) {
      return `${this.code};` + _n2;
    }
    optimizeNodes() {
      return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
      this.code = optimizeExpr(this.code, names, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
  }

  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names, constants))
          continue;
        subtractNames(names, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    get names() {
      return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
  }

  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }

  class Root extends ParentNode {
  }

  class Else extends BlockNode {
  }
  Else.kind = "else";

  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code += "else " + this.else.render(opts);
      return code;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return;
      return this;
    }
    optimizeNames(names, constants) {
      var _a;
      this.else = (_a = this.else) === null || _a === undefined ? undefined : _a.optimizeNames(names, constants);
      if (!(super.optimizeNames(names, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      addExprNames(names, this.condition);
      if (this.else)
        addNames(names, this.else.names);
      return names;
    }
  }
  If.kind = "if";

  class For extends BlockNode {
  }
  For.kind = "for";

  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }

  class ForRange extends For {
    constructor(varKind, name, from, to2) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to2;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to: to2 } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to2}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names = addExprNames(super.names, this.from);
      return addExprNames(names, this.to);
    }
  }

  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }

  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";

  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";

  class Try extends BlockNode {
    render(opts) {
      let code = "try" + super.render(opts);
      if (this.catch)
        code += this.catch.render(opts);
      if (this.finally)
        code += this.finally.render(opts);
      return code;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === undefined || _a.optimizeNodes();
      (_b = this.finally) === null || _b === undefined || _b.optimizeNodes();
      return this;
    }
    optimizeNames(names, constants) {
      var _a, _b;
      super.optimizeNames(names, constants);
      (_a = this.catch) === null || _a === undefined || _a.optimizeNames(names, constants);
      (_b = this.finally) === null || _b === undefined || _b.optimizeNames(names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      if (this.catch)
        addNames(names, this.catch.names);
      if (this.finally)
        addNames(names, this.finally.names);
      return names;
    }
  }

  class Catch extends BlockNode {
    constructor(error) {
      super();
      this.error = error;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";

  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";

  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? `
` : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set);
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== undefined && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c2) {
      if (typeof c2 == "function")
        c2();
      else if (c2 !== code_1.nil)
        this._leafNode(new AnyCode(c2));
      return this;
    }
    object(...keyValues) {
      const code = ["{"];
      for (const [key, value] of keyValues) {
        if (code.length > 1)
          code.push(",");
        code.push(key);
        if (key !== value || this.opts.es5) {
          code.push(":");
          (0, code_1.addCodeArg)(code, value);
        }
      }
      code.push("}");
      return new code_1._Code(code);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else);
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to2), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
          this.var(name, (0, code_1._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return;
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try;
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error = this.name("e");
        this._currNode = node.catch = new Catch(error);
        catchCode(error);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally;
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error) {
      return this._leafNode(new Throw(error));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === undefined)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_1.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N22) {
      const n = this._currNode;
      if (n instanceof N1 || N22 && n instanceof N22) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
  }
  function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
  }
  function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_1._Code(expr._items.reduce((items, c2) => {
      if (c2 instanceof code_1.Name)
        c2 = replaceName(c2);
      if (c2 instanceof code_1._Code)
        items.push(...c2._items);
      else
        items.push(c2);
      return items;
    }, []));
    function replaceName(n) {
      const c2 = constants[n.str];
      if (c2 === undefined || names[n.str] !== 1)
        return n;
      delete names[n.str];
      return c2;
    }
    function canOptimize(e) {
      return e instanceof code_1._Code && e._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== undefined);
    }
  }
  function subtractNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) - (from[n] || 0);
  }
  function not(x3) {
    return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_1._)`!${par(x3)}`;
  }
  exports.not = not;
  var andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  var orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x3, y3) => x3 === code_1.nil ? y3 : y3 === code_1.nil ? x3 : (0, code_1._)`${par(x3)} ${op} ${par(y3)}`;
  }
  function par(x3) {
    return x3 instanceof code_1.Name ? x3 : (0, code_1._)`(${x3})`;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = undefined;
  var codegen_1 = require_codegen2();
  var code_1 = require_code3();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it2, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it2, schema);
    return !schemaHasRules(schema, it2.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it2, schema = it2.schema) {
    const { opts, self: self2 } = it2;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules[key])
        checkStrictMode(it2, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f2) {
    if (Array.isArray(xs)) {
      for (const x3 of xs)
        f2(x3);
    } else {
      f2(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to2, toName) => {
      const res = to2 === undefined ? from : to2 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to2) : mergeToName(gen, from, to2), to2) : from instanceof codegen_1.Name ? (mergeToName(gen, to2, from), from) : mergeValues(from, to2);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1._)`${to2} || {}`).code((0, codegen_1._)`Object.assign(${to2}, ${from})`));
      }),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => {
        if (from === true) {
          gen.assign(to2, true);
        } else {
          gen.assign(to2, (0, codegen_1._)`${to2} || {}`);
          setEvaluated(gen, to2, from);
        }
      }),
      mergeValues: (from, to2) => from === true ? true : { ...from, ...to2 },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => gen.assign(to2, (0, codegen_1._)`${from} === true ? true : ${to2} > ${from} ? ${to2} : ${from}`)),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => gen.assign(to2, from === true ? true : (0, codegen_1._)`${to2} > ${from} ? ${to2} : ${from}`)),
      mergeValues: (from, to2) => from === true ? true : Math.max(from, to2),
      resultToName: (gen, items) => gen.var("items", items)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== undefined)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p3) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p3)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  var snippets = {};
  function useFunc(gen, f2) {
    return gen.scopeValue("func", {
      ref: f2,
      code: snippets[f2.code] || (snippets[f2.code] = new code_1._Code(f2.code))
    });
  }
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (exports.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it2.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js
var require_names2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var names = {
    data: new codegen_1.Name("data"),
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  exports.default = names;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js
var require_errors4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = undefined;
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var names_1 = require_names2();
  exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
  };
  function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== undefined ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it2, names_1.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword, schemaValue, data, errsCount, it: it2 }) {
    if (errsCount === undefined)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
      gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
      gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
      gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword}`);
      if (it2.opts.verbose) {
        gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_1._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._)`${names_1.default.errors}++`);
  }
  function returnErrors(it2, errs) {
    const { gen, validateName, schemaEnv } = it2;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  var E5 = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema")
  };
  function errorObjectCode(cxt, error, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_1._)`{}`;
    return errorObject(cxt, error, errorPaths);
  }
  function errorObject(cxt, error, errorPaths = {}) {
    const { gen, it: it2 } = cxt;
    const keyValues = [
      errorInstancePath(it2, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
    if (schemaPath) {
      schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E5.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it: it2 } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it2;
    keyValues.push([E5.keyword, keyword], [E5.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
    if (opts.messages) {
      keyValues.push([E5.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E5.schema, schemaValue], [E5.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E5.propertyName, propertyName]);
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;
  var errors_1 = require_errors4();
  var codegen_1 = require_codegen2();
  var names_1 = require_names2();
  var boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it2) {
    const { gen, schema, validateName } = it2;
    if (schema === false) {
      falseSchemaError(it2, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it2, valid) {
    const { gen, schema } = it2;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it2);
    } else {
      gen.var(valid, true);
    }
  }
  exports.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it2, overrideAllErrors) {
    const { gen, data } = it2;
    const cxt = {
      gen,
      keyword: "false schema",
      data,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it: it2
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js
var require_rules2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRules = exports.isJSONType = undefined;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  function isJSONType(x3) {
    return typeof x3 == "string" && jsonTypes.has(x3);
  }
  exports.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  exports.getRules = getRules;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = undefined;
  function schemaHasRulesForType({ schema, self: self2 }, type) {
    const group = self2.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  exports.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  exports.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a;
    return schema[rule.keyword] !== undefined || ((_a = rule.definition.implements) === null || _a === undefined ? undefined : _a.some((kwd) => schema[kwd] !== undefined));
  }
  exports.shouldUseRule = shouldUseRule;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = undefined;
  var rules_1 = require_rules2();
  var applicability_1 = require_applicability2();
  var errors_1 = require_errors4();
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (exports.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types.length && schema.nullable !== undefined) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types.push("null");
    }
    return types;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
      return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it2, types) {
    const { gen, data, opts } = it2;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it2, types, coerceTo);
        else
          reportTypeError(it2);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types, coerceTypes) {
    return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it2, types, coerceTo) {
    const { gen, data, opts } = it2;
    const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it2);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it2, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
      case "null":
        return (0, codegen_1._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
      const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
      cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
      delete types.null;
      delete types.array;
      delete types.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types.number)
      delete types.integer;
    for (const t in types)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  var typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it2) {
    const cxt = getTypeErrorContext(it2);
    (0, errors_1.reportError)(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it2) {
    const { gen, data, schema } = it2;
    const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it: it2
    };
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assignDefaults = undefined;
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  function assignDefaults(it2, ty) {
    const { properties, items } = it2.schema;
    if (ty === "object" && properties) {
      for (const key in properties) {
        assignDefault(it2, key, properties[key].default);
      }
    } else if (ty === "array" && Array.isArray(items)) {
      items.forEach((sch, i) => assignDefault(it2, i, sch.default));
    }
  }
  exports.assignDefaults = assignDefaults;
  function assignDefault(it2, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it2;
    if (defaultValue === undefined)
      return;
    const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js
var require_code4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = undefined;
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var names_1 = require_names2();
  var util_2 = require_util2();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data, it: it2 } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  exports.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  exports.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  exports.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  exports.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
  }
  exports.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
  }
  exports.propertyInData = propertyInData;
  function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
  }
  exports.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p3) => p3 !== "__proto__") : [];
  }
  exports.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it2, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p3]));
  }
  exports.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it2.parentData],
      [names_1.default.parentDataProperty, it2.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it2.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  exports.callValidateCode = callValidateCode;
  var newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern) {
    const u2 = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u2);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u2})`
    });
  }
  exports.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data, keyword, it: it2 } = cxt;
    const valid = gen.name("valid");
    if (it2.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  exports.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
    if (alwaysValid && !it2.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  exports.validateUnion = validateUnion;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = undefined;
  var codegen_1 = require_codegen2();
  var names_1 = require_names2();
  var code_1 = require_code4();
  var errors_1 = require_errors4();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it: it2 } = cxt;
    const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it2.opts.validateSchema !== false)
      it2.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it2.errSchemaPath}/${keyword}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  exports.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it: it2 } = cxt;
    checkAsyncKeyword(it2, def);
    const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== undefined ? _a : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !(("compile" in def) && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
      var _a2;
      gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== undefined ? _a2 : valid), errors);
    }
  }
  exports.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data, it: it2 } = cxt;
    gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword, result) {
    if (result === undefined)
      throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
  }
  exports.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === undefined ? undefined : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword]);
      if (!valid) {
        const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  exports.validateKeywordUsage = validateKeywordUsage;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = undefined;
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  function getSubschema(it2, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
      const sch = it2.schema[keyword];
      return schemaProp === undefined ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== undefined) {
      if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  exports.getSubschema = getSubschema;
  function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it2;
    if (dataProp !== undefined) {
      const { errorPath, dataPathArr, opts } = it2;
      const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
      const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
      dataContextProps(nextData);
      if (propertyName !== undefined)
        subschema.propertyName = propertyName;
    }
    if (dataTypes)
      subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema.data = _nextData;
      subschema.dataLevel = it2.dataLevel + 1;
      subschema.dataTypes = [];
      it2.definedProperties = new Set;
      subschema.parentData = it2.data;
      subschema.dataNames = [...it2.dataNames, _nextData];
    }
  }
  exports.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
      subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
      subschema.createErrors = createErrors;
    if (allErrors !== undefined)
      subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator;
    subschema.jtdMetadata = jtdMetadata;
  }
  exports.extendSubschemaMode = extendSubschemaMode;
});

// node_modules/ajv-formats/node_modules/ajv/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse2 = __commonJS((exports, module) => {
  var traverse = module.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0;i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js
var require_resolve2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = undefined;
  var util_1 = require_util2();
  var equal = require_fast_deep_equal();
  var traverse = require_json_schema_traverse2();
  var SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  }
  exports.inlineRef = inlineRef;
  var REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
      id = normalizeId(id);
    const p3 = resolver.parse(id);
    return _getFullPath(resolver, p3);
  }
  exports.getFullPath = getFullPath;
  function _getFullPath(resolver, p3) {
    const serialized = resolver.serialize(p3);
    return serialized.split("#")[0] + "#";
  }
  exports._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  exports.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
  }
  exports.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set;
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _3, parentJsonPtr) => {
      if (parentJsonPtr === undefined)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref) {
        const _resolve = this.opts.uriResolver.resolve;
        ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
        if (schemaRefs.has(ref))
          throw ambiguos(ref);
        schemaRefs.add(ref);
        let schOrRef = this.refs[ref];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref);
        } else if (ref !== normalizeId(fullPath)) {
          if (ref[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref], ref);
            localRefs[ref] = sch;
          } else {
            this.refs[ref] = fullPath;
          }
        }
        return ref;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
      if (sch2 !== undefined && !equal(sch1, sch2))
        throw ambiguos(ref);
    }
    function ambiguos(ref) {
      return new Error(`reference "${ref}" resolves to more than one schema`);
    }
  }
  exports.getSchemaRefs = getSchemaRefs;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js
var require_validate2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;
  var boolSchema_1 = require_boolSchema2();
  var dataType_1 = require_dataType2();
  var applicability_1 = require_applicability2();
  var dataType_2 = require_dataType2();
  var defaults_1 = require_defaults2();
  var keyword_1 = require_keyword2();
  var subschema_1 = require_subschema2();
  var codegen_1 = require_codegen2();
  var names_1 = require_names2();
  var resolve_1 = require_resolve2();
  var util_1 = require_util2();
  var errors_1 = require_errors4();
  function validateFunctionCode(it2) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        topSchemaObjCode(it2);
        return;
      }
    }
    validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
  }
  exports.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it2) {
    const { schema, opts, gen } = it2;
    validateFunction(it2, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      checkNoDefault(it2);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it2);
      typeAndKeywords(it2);
      returnResults(it2);
    });
    return;
  }
  function resetEvaluated(it2) {
    const { gen, validateName } = it2;
    it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it2, valid) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        subSchemaObjCode(it2, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it2) {
    return typeof it2.schema != "boolean";
  }
  function subSchemaObjCode(it2, valid) {
    const { schema, gen, opts } = it2;
    if (opts.$comment && schema.$comment)
      commentKeyword(it2);
    updateContext(it2);
    checkAsyncSchema(it2);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it2, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it2) {
    (0, util_1.checkUnknownRules)(it2);
    checkRefsAndKeywords(it2);
  }
  function typeAndKeywords(it2, errsCount) {
    if (it2.opts.jtd)
      return schemaKeywords(it2, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it2.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types);
    schemaKeywords(it2, types, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it2) {
    const { schema, errSchemaPath, opts, self: self2 } = it2;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it2) {
    const { schema, opts } = it2;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
    }
  }
  function updateContext(it2) {
    const schId = it2.schema[it2.opts.schemaId];
    if (schId)
      it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
  }
  function checkAsyncSchema(it2) {
    if (it2.schema.$async && !it2.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it2) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it2);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items);
  }
  function schemaKeywords(it2, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self: self2 } = it2;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it2, types);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
        iterateKeywords(it2, group);
        if (types.length === 1 && types[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it2);
        }
        gen.endIf();
      } else {
        iterateKeywords(it2, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it2, group) {
    const { gen, schema, opts: { useDefaults } } = it2;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it2, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it2, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it2, types) {
    if (it2.schemaEnv.meta || !it2.opts.strictTypes)
      return;
    checkContextTypes(it2, types);
    if (!it2.opts.allowUnionTypes)
      checkMultipleTypes(it2, types);
    checkKeywordTypes(it2, it2.dataTypes);
  }
  function checkContextTypes(it2, types) {
    if (!types.length)
      return;
    if (!it2.dataTypes.length) {
      it2.dataTypes = types;
      return;
    }
    types.forEach((t) => {
      if (!includesType(it2.dataTypes, t)) {
        strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it2, types);
  }
  function checkMultipleTypes(it2, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it2, ts) {
    const rules = it2.self.RULES.all;
    for (const keyword in rules) {
      const rule = rules[keyword];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
        const { type } = rule.definition;
        if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it2, withTypes) {
    const ts = [];
    for (const t of it2.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it2.dataTypes = ts;
  }
  function strictTypesError(it2, msg) {
    const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
  }

  class KeywordCxt {
    constructor(it2, def, keyword) {
      (0, keyword_1.validateKeywordUsage)(it2, def, keyword);
      this.gen = it2.gen;
      this.allErrors = it2.allErrors;
      this.keyword = keyword;
      this.data = it2.data;
      this.schema = it2.schema[keyword];
      this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it2.schema;
      this.params = {};
      this.it = it2;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it2.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
      if (condition === undefined) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === undefined)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it: it2 } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);
      const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it: it2, gen } = this;
      if (!it2.opts.unevaluated)
        return;
      if (it2.props !== true && schemaCxt.props !== undefined) {
        it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
      }
      if (it2.items !== true && schemaCxt.items !== undefined) {
        it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it: it2, gen } = this;
      if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  exports.KeywordCxt = KeywordCxt;
  function keywordCode(it2, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it2, def, keyword);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  exports.getData = getData;
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ValidationError extends Error {
    constructor(errors) {
      super("validation failed");
      this.errors = errors;
      this.ajv = this.validation = true;
    }
  }
  exports.default = ValidationError;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolve_1 = require_resolve2();

  class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
      super(msg || `can't resolve reference ${ref} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  exports.default = MissingRefError;
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js
var require_compile2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = undefined;
  var codegen_1 = require_codegen2();
  var validation_error_1 = require_validation_error2();
  var names_1 = require_names2();
  var resolve_1 = require_resolve2();
  var util_1 = require_util2();
  var validate_1 = require_validate2();

  class SchemaEnv {
    constructor(env) {
      var _a;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a = env.baseId) !== null && _a !== undefined ? _a : (0, resolve_1.normalizeId)(schema === null || schema === undefined ? undefined : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === undefined ? undefined : schema.$async;
      this.refs = {};
    }
  }
  exports.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set,
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate });
      validate.errors = null;
      validate.schema = sch.schema;
      validate.schemaEnv = sch;
      if (sch.$async)
        validate.$async = true;
      if (this.opts.code.source === true) {
        validate.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items } = schemaCxt;
        validate.evaluated = {
          props: props instanceof codegen_1.Name ? undefined : props,
          items: items instanceof codegen_1.Name ? undefined : items,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items instanceof codegen_1.Name
        };
        if (validate.source)
          validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
      }
      sch.validate = validate;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  exports.compileSchema = compileSchema;
  function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
      const schema = (_a = root.localRefs) === null || _a === undefined ? undefined : _a[ref];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
      return;
    return root.refs[ref] = inlineOrCompile.call(this, _sch);
  }
  exports.resolveRef = resolveRef;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  exports.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve(root, ref) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
      ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
  }
  function resolveSchema(root, ref) {
    const p3 = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p3);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p3, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === undefined ? undefined : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p3, sch);
    }
    if (typeof (schOrRef === null || schOrRef === undefined ? undefined : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p3, schOrRef);
  }
  exports.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === undefined ? undefined : _a[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === undefined)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json
var require_data2 = __commonJS((exports, module) => {
  module.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
      }
    },
    additionalProperties: false
  };
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js
var require_uri2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uri = require_fast_uri();
  uri.code = 'require("ajv/dist/runtime/uri").default';
  exports.default = uri;
});

// node_modules/ajv-formats/node_modules/ajv/dist/core.js
var require_core3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var validate_1 = require_validate2();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen2();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error2();
  var ref_error_1 = require_ref_error2();
  var rules_1 = require_rules2();
  var compile_1 = require_compile2();
  var codegen_2 = require_codegen2();
  var resolve_1 = require_resolve2();
  var dataType_1 = require_dataType2();
  var util_1 = require_util2();
  var $dataRefSchema = require_data2();
  var uri_1 = require_uri2();
  var defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  var EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  var removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  var deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  var MAX_EXPRESSION = 200;
  function requiredOptions(o2) {
    var _a, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r3, _s, _t3, _u, _v, _w, _x, _y, _z, _0;
    const s2 = o2.strict;
    const _optz = (_a = o2.code) === null || _a === undefined ? undefined : _a.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o2.code) === null || _b === undefined ? undefined : _b.regExp) !== null && _c !== undefined ? _c : defaultRegExp;
    const uriResolver = (_d = o2.uriResolver) !== null && _d !== undefined ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e3 = o2.strictSchema) !== null && _e3 !== undefined ? _e3 : s2) !== null && _f !== undefined ? _f : true,
      strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== undefined ? _g : s2) !== null && _h !== undefined ? _h : true,
      strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== undefined ? _j : s2) !== null && _k !== undefined ? _k : "log",
      strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== undefined ? _l : s2) !== null && _m !== undefined ? _m : "log",
      strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== undefined ? _o : s2) !== null && _p !== undefined ? _p : false,
      code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o2.loopRequired) !== null && _q !== undefined ? _q : MAX_EXPRESSION,
      loopEnum: (_r3 = o2.loopEnum) !== null && _r3 !== undefined ? _r3 : MAX_EXPRESSION,
      meta: (_s = o2.meta) !== null && _s !== undefined ? _s : true,
      messages: (_t3 = o2.messages) !== null && _t3 !== undefined ? _t3 : true,
      inlineRefs: (_u = o2.inlineRefs) !== null && _u !== undefined ? _u : true,
      schemaId: (_v = o2.schemaId) !== null && _v !== undefined ? _v : "$id",
      addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== undefined ? _w : true,
      validateSchema: (_x = o2.validateSchema) !== null && _x !== undefined ? _x : true,
      validateFormats: (_y = o2.validateFormats) !== null && _y !== undefined ? _y : true,
      unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== undefined ? _z : true,
      int32range: (_0 = o2.int32range) !== null && _0 !== undefined ? _0 : true,
      uriResolver
    };
  }

  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set;
      this._loading = {};
      this._cache = new Map;
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined;
    }
    validate(schemaKeyRef, data) {
      let v2;
      if (typeof schemaKeyRef == "string") {
        v2 = this.getSchema(schemaKeyRef);
        if (!v2)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v2 = this.compile(schemaKeyRef);
      }
      const valid = v2(data);
      if (!("$async" in v2))
        this.errors = v2.errors;
      return valid;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_1.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref, missingRef }) {
        if (this.refs[ref]) {
          throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref) {
        const _schema = await _loadSchema.call(this, ref);
        if (!this.refs[ref])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref])
          this.addSchema(_schema, ref, meta);
      }
      async function _loadSchema(ref) {
        const p3 = this._loading[ref];
        if (p3)
          return p3;
        try {
          return await (this._loading[ref] = loadSchema(ref));
        } finally {
          delete this._loading[ref];
        }
      }
    }
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, undefined, _meta, _validateSchema);
        return this;
      }
      let id;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id = schema[schemaId];
        if (id !== undefined && typeof id != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_1.normalizeId)(key || id);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema;
      $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }
      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === undefined) {
        const { schemaId } = this.opts;
        const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id = schemaKeyRef[this.opts.schemaId];
          if (id) {
            id = (0, resolve_1.normalizeId)(id);
            delete this.schemas[id];
            delete this.refs[id];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions) {
      for (const def of definitions)
        this.addKeyword(def);
      return this;
    }
    addKeyword(kwdOrDef, def) {
      let keyword;
      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;
        if (typeof def == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (typeof kwdOrDef == "object" && def === undefined) {
        def = kwdOrDef;
        keyword = def.keyword;
        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword, def);
      if (!def) {
        (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def);
      const definition = {
        ...def,
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      };
      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k3) => addRule.call(this, k3, definition) : (k3) => definition.type.forEach((t) => addRule.call(this, k3, definition, t)));
      return this;
    }
    getKeyword(keyword) {
      const rule = this.RULES.all[keyword];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword) {
      const { RULES } = this;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this.formats[name] = format;
      return this;
    }
    errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors || errors.length === 0)
        return "No errors";
      return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules) {
          const rule = rules[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== undefined)
        return sch;
      baseId = (0, resolve_1.normalizeId)(id || baseId);
      const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id) {
      if (this.schemas[id] || this.refs[id]) {
        throw new Error(`schema with key or id "${id}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_1.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_1.default;
  Ajv.MissingRefError = ref_error_1.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format = this.opts.formats[name];
      if (format)
        this.addFormat(name, format);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
      const def = defs[keyword];
      if (!def.keyword)
        def.keyword = keyword;
      this.addKeyword(def);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  var noLogs = { log() {}, warn() {}, error() {} };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === undefined)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
      return;
    if (def.$data && !(("code" in def) || ("validate" in def))) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === undefined ? undefined : definition.post;
    if (dataType && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
      return;
    const rule = {
      keyword,
      definition: {
        ...definition,
        type: (0, dataType_1.getJSONTypes)(definition.type),
        schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === undefined || _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
      return;
    if (def.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
  }
  var $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js
var require_id2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callRef = exports.getValidate = undefined;
  var ref_error_1 = require_ref_error2();
  var code_1 = require_code4();
  var codegen_1 = require_codegen2();
  var names_1 = require_names2();
  var compile_1 = require_compile2();
  var util_1 = require_util2();
  var def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it: it2 } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === undefined)
        throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v2 = getValidate(cxt, sch);
        callRef(cxt, v2, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  exports.getValidate = getValidate;
  function callRef(cxt, v2, sch, $async) {
    const { gen, it: it2 } = cxt;
    const { allErrors, schemaEnv: env, opts } = it2;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v2, passCxt)}`);
        addEvaluatedFrom(v2);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a;
      if (!it2.opts.unevaluated)
        return;
      const schEvaluated = (_a = sch === null || sch === undefined ? undefined : sch.validate) === null || _a === undefined ? undefined : _a.evaluated;
      if (it2.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== undefined) {
            it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
        }
      }
      if (it2.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== undefined) {
            it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
          }
        } else {
          const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
        }
      }
    }
  }
  exports.callRef = callRef;
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js
var require_core4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var id_1 = require_id2();
  var ref_1 = require_ref2();
  var core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  exports.default = core;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var ops = codegen_1.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  var def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  var def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, schemaCode, it: it2 } = cxt;
      const prec = it2.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  exports.default = ucs2length;
  ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var ucs2length_1 = require_ucs2length2();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode, it: it2 } = cxt;
      const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code4();
  var codegen_1 = require_codegen2();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  var def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { data, $data, schema, schemaCode, it: it2 } = cxt;
      const u2 = it2.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code4();
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  var def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
      const { opts } = it2;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it2.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === undefined ? undefined : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
            const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js
var require_equal2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var equal = require_fast_deep_equal();
  equal.code = 'require("ajv/dist/runtime/equal").default';
  exports.default = equal;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dataType_1 = require_dataType2();
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var equal_1 = require_equal2();
  var error = {
    message: ({ params: { i, j: j3 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j3} and ${i} are identical)`,
    params: ({ params: { i, j: j3 } }) => (0, codegen_1._)`{i: ${i}, j: ${j3}}`
  };
  var def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data}.length`);
        const j3 = gen.let("j");
        cxt.setParams({ i, j: j3 });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j3));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j3) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j3, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j3) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j3} = ${i}; ${j3}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j3}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var equal_1 = require_equal2();
  var error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  var def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var equal_1 = require_equal2();
  var error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it2.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== undefined ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var limitNumber_1 = require_limitNumber2();
  var multipleOf_1 = require_multipleOf2();
  var limitLength_1 = require_limitLength2();
  var pattern_1 = require_pattern2();
  var limitProperties_1 = require_limitProperties2();
  var required_1 = require_required2();
  var limitItems_1 = require_limitItems2();
  var uniqueItems_1 = require_uniqueItems2();
  var const_1 = require_const2();
  var enum_1 = require_enum2();
  var validation = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  exports.default = validation;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAdditionalItems = undefined;
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { parentSchema, it: it2 } = cxt;
      const { items } = parentSchema;
      if (!Array.isArray(items)) {
        (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items);
    }
  };
  function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it: it2 } = cxt;
    it2.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items.length, len, (i) => {
        cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it2.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  exports.validateAdditionalItems = validateAdditionalItems;
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTuple = undefined;
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var code_1 = require_code4();
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it: it2 } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it: it2 } = cxt;
    checkStrictTuple(parentSchema);
    if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
      it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it2, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it2;
      const l3 = schArr.length;
      const fullTuple = l3 === sch.minItems && (l3 === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword}" is ${l3}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
      }
    }
  }
  exports.validateTuple = validateTuple;
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var items_1 = require_items2();
  var def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items20202 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var code_1 = require_code4();
  var additionalItems_1 = require_additionalItems2();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { schema, parentSchema, it: it2 } = cxt;
      const { prefixItems } = parentSchema;
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      if (prefixItems)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var error = {
    message: ({ params: { min, max } }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data, it: it2 } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it2.opts.next) {
        min = minContains === undefined ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === undefined && min === 0) {
        (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== undefined && min > max) {
        (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== undefined)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it2.items = true;
      const valid = gen.name("valid");
      if (max === undefined && min === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid, true);
        if (max !== undefined)
          gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === undefined) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
          if (min === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = undefined;
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var code_1 = require_code4();
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  var def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it: it2 } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it2.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_1.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_1.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it: it2 } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
        continue;
      gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
        cxt.mergeValidEvaluated(schCxt, valid);
      }, () => gen.var(valid, true));
      cxt.ok(valid);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  var def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
      const { gen, schema, data, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it2.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code4();
  var codegen_1 = require_codegen2();
  var names_1 = require_names2();
  var util_1 = require_util2();
  var error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it2;
      it2.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p3) => (0, codegen_1._)`${key} === ${p3}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p3) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p3)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors) {
        const subschema = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors === false) {
          Object.assign(subschema, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validate_1 = require_validate2();
  var code_1 = require_code4();
  var util_1 = require_util2();
  var additionalProperties_1 = require_additionalProperties2();
  var def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data, it: it2 } = cxt;
      if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it2.definedProperties.add(prop);
      }
      if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
        it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
      }
      const properties = allProps.filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schema[p3]));
      if (properties.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it2.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== undefined;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code4();
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var util_2 = require_util2();
  var def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data, parentSchema, it: it2 } = cxt;
      const { opts } = it2;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p3) => (0, util_1.alwaysValidSchema)(it2, schema[p3]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
        it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
      }
      const { props } = it2;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it2.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it2.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it2.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code4();
  var def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  var def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it2.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it2, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var util_1 = require_util2();
  var error = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  var def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, parentSchema, it: it2 } = cxt;
      if (parentSchema.then === undefined && parentSchema.else === undefined) {
        (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it2, "then");
      const hasElse = hasSchema(it2, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
          else
            cxt.setParams({ ifClause: keyword });
        };
      }
    }
  };
  function hasSchema(it2, keyword) {
    const schema = it2.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it2, schema);
  }
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util2();
  var def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it: it2 }) {
      if (parentSchema.if === undefined)
        (0, util_1.checkStrictMode)(it2, `"${keyword}" without "if" is ignored`);
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var additionalItems_1 = require_additionalItems2();
  var prefixItems_1 = require_prefixItems2();
  var items_1 = require_items2();
  var items2020_1 = require_items20202();
  var contains_1 = require_contains2();
  var dependencies_1 = require_dependencies2();
  var propertyNames_1 = require_propertyNames2();
  var additionalProperties_1 = require_additionalProperties2();
  var properties_1 = require_properties2();
  var patternProperties_1 = require_patternProperties2();
  var not_1 = require_not2();
  var anyOf_1 = require_anyOf2();
  var oneOf_1 = require_oneOf2();
  var allOf_1 = require_allOf2();
  var if_1 = require_if2();
  var thenElse_1 = require_thenElse2();
  function getApplicator(draft2020 = false) {
    const applicator = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator.push(prefixItems_1.default, items2020_1.default);
    else
      applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
  }
  exports.default = getApplicator;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js
var require_format3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  var def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
      const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
          const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
          return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data})`;
          }
          return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js
var require_format4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var format_1 = require_format3();
  var format = [format_1.default];
  exports.default = format;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contentVocabulary = exports.metadataVocabulary = undefined;
  exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft72 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core_1 = require_core4();
  var validation_1 = require_validation3();
  var applicator_1 = require_applicator2();
  var format_1 = require_format4();
  var metadata_1 = require_metadata2();
  var draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  exports.default = draft7Vocabularies;
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = undefined;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (exports.DiscrError = DiscrError = {}));
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen2();
  var types_1 = require_types2();
  var compile_1 = require_compile2();
  var ref_error_1 = require_ref_error2();
  var util_1 = require_util2();
  var error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
      const { gen, data, schema, parentSchema, it: it2 } = cxt;
      const { oneOf } = parentSchema;
      if (!it2.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0;i < oneOf.length; i++) {
          let sch = oneOf[i];
          if ((sch === null || sch === undefined ? undefined : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
            const ref = sch.$ref;
            sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === undefined)
              throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref);
          }
          const propSch = (_a = sch === null || sch === undefined ? undefined : sch.properties) === null || _a === undefined ? undefined : _a[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required }) {
          return Array.isArray(required) && required.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_072 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});

// node_modules/ajv-formats/node_modules/ajv/dist/ajv.js
var require_ajv2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = undefined;
  var core_1 = require_core3();
  var draft7_1 = require_draft72();
  var discriminator_1 = require_discriminator2();
  var draft7MetaSchema = require_json_schema_draft_072();
  var META_SUPPORT_DATA = ["/properties"];
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";

  class Ajv extends core_1.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v2) => this.addVocabulary(v2));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
  }
  exports.Ajv = Ajv;
  module.exports = exports = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate2();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen2();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error2();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error2();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.formatLimitDefinition = undefined;
  var ajv_1 = require_ajv2();
  var codegen_1 = require_codegen2();
  var ops = codegen_1.operators;
  var KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, schemaCode, keyword, it: it2 } = cxt;
      const { opts, self: self2 } = it2;
      if (!opts.validateFormats)
        return;
      const fCxt = new ajv_1.KeywordCxt(it2, self2.RULES.all.format.definition, "format");
      if (fCxt.$data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
        cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
      }
      function validateFormat() {
        const format = fCxt.schema;
        const fmtDef = self2.formats[format];
        if (!fmtDef || fmtDef === true)
          return;
        if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
          throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
        }
        const fmt = gen.scopeValue("formats", {
          key: format,
          ref: fmtDef,
          code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : undefined
        });
        cxt.fail$data(compareCode(fmt));
      }
      function compareCode(fmt) {
        return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
      }
    },
    dependencies: ["format"]
  };
  var formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
  };
  exports.default = formatLimitPlugin;
});

// node_modules/ajv-formats/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var formats_1 = require_formats();
  var limit_1 = require_limit();
  var codegen_1 = require_codegen2();
  var fullName = new codegen_1.Name("fullFormats");
  var fastName = new codegen_1.Name("fastFormats");
  var formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
      addFormats(ajv, opts, formats_1.fullFormats, fullName);
      return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
      (0, limit_1.default)(ajv);
    return ajv;
  };
  formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f2 = formats[name];
    if (!f2)
      throw new Error(`Unknown format "${name}"`);
    return f2;
  };
  function addFormats(ajv, list, fs, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv.opts.code).formats) !== null && _a !== undefined || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
    for (const f2 of list)
      ajv.addFormat(f2, fs[f2]);
  }
  module.exports = exports = formatsPlugin;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = formatsPlugin;
});

// node_modules/fast-json-stringify/lib/validator.js
var require_validator = __commonJS((exports, module) => {
  var Ajv = require_ajv();
  var fastUri = require_fast_uri();
  var ajvFormats = require_dist2();
  var clone = require_rfdc()({ proto: true });

  class Validator {
    constructor(ajvOptions) {
      this.ajv = new Ajv({
        ...ajvOptions,
        strictSchema: false,
        validateSchema: false,
        allowUnionTypes: true,
        uriResolver: fastUri
      });
      ajvFormats(this.ajv);
      this.ajv.addKeyword({
        keyword: "fjs_type",
        type: "object",
        errors: false,
        validate: (_type, date) => {
          return date instanceof Date;
        }
      });
      this._ajvSchemas = {};
      this._ajvOptions = ajvOptions || {};
    }
    addSchema(schema, schemaName) {
      let schemaKey = schema.$id || schemaName;
      if (schema.$id !== undefined && schema.$id[0] === "#") {
        schemaKey = schemaName + schema.$id;
      }
      if (this.ajv.refs[schemaKey] === undefined && this.ajv.schemas[schemaKey] === undefined) {
        const ajvSchema = clone(schema);
        this.convertSchemaToAjvFormat(ajvSchema);
        this.ajv.addSchema(ajvSchema, schemaKey);
        this._ajvSchemas[schemaKey] = schema;
      }
    }
    validate(schemaRef, data) {
      return this.ajv.validate(schemaRef, data);
    }
    convertSchemaToAjvFormat(schema) {
      if (schema === null)
        return;
      if (schema.type === "string") {
        schema.fjs_type = "string";
        schema.type = ["string", "object"];
      } else if (Array.isArray(schema.type) && schema.type.includes("string") && !schema.type.includes("object")) {
        schema.fjs_type = "string";
        schema.type.push("object");
      }
      for (const property in schema) {
        if (typeof schema[property] === "object") {
          this.convertSchemaToAjvFormat(schema[property]);
        }
      }
    }
    getState() {
      return {
        ajvOptions: this._ajvOptions,
        ajvSchemas: this._ajvSchemas
      };
    }
    static restoreFromState(state) {
      const validator = new Validator(state.ajvOptions);
      for (const [id, ajvSchema] of Object.entries(state.ajvSchemas)) {
        validator.ajv.addSchema(ajvSchema, id);
      }
      return validator;
    }
  }
  module.exports = Validator;
});

// node_modules/fast-json-stringify/lib/location.js
var require_location = __commonJS((exports, module) => {
  class Location {
    constructor(schema, schemaId, jsonPointer = "#") {
      this.schema = schema;
      this.schemaId = schemaId;
      this.jsonPointer = jsonPointer;
    }
    getPropertyLocation(propertyName) {
      const propertyLocation = new Location(this.schema[propertyName], this.schemaId, this.jsonPointer + "/" + propertyName);
      return propertyLocation;
    }
    getSchemaRef() {
      return this.schemaId + this.jsonPointer;
    }
  }
  module.exports = Location;
});

// node_modules/fast-json-stringify/lib/schema-validator.js
var require_schema_validator = __commonJS((exports, module) => {
  module.exports = validate10;
  module.exports.default = validate10;
  var schema11 = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
  var schema20 = { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] };
  var formats0 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var formats2 = require_formats().fullFormats.uri;
  var formats6 = require_formats().fullFormats.regex;
  function validate11(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs1 = errors;
    if (!(typeof data == "number" && (!(data % 1) && !isNaN(data)) && isFinite(data))) {
      validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
      return false;
    }
    if (errors === _errs1) {
      if (typeof data == "number" && isFinite(data)) {
        if (data < 0 || isNaN(data)) {
          validate11.errors = [{ instancePath, schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
          return false;
        }
      }
    }
    validate11.errors = vErrors;
    return errors === 0;
  }
  var root1 = { validate: validate10 };
  function validate13(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
      if (Array.isArray(data)) {
        if (data.length < 1) {
          validate13.errors = [{ instancePath, schemaPath: "#/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
          return false;
        } else {
          var valid0 = true;
          const len0 = data.length;
          for (let i0 = 0;i0 < len0; i0++) {
            const _errs1 = errors;
            if (!root1.validate(data[i0], { instancePath: instancePath + "/" + i0, parentData: data, parentDataProperty: i0, rootData })) {
              vErrors = vErrors === null ? root1.validate.errors : vErrors.concat(root1.validate.errors);
              errors = vErrors.length;
            }
            var valid0 = _errs1 === errors;
            if (!valid0) {
              break;
            }
          }
        }
      } else {
        validate13.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
        return false;
      }
    }
    validate13.errors = vErrors;
    return errors === 0;
  }
  var func0 = require_equal().default;
  function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (!(data && typeof data == "object" && !Array.isArray(data)) && typeof data !== "boolean") {
      validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: schema11.type }, message: "must be object,boolean" }];
      return false;
    }
    if (errors === 0) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.$id !== undefined) {
          let data0 = data.$id;
          const _errs1 = errors;
          if (errors === _errs1) {
            if (errors === _errs1) {
              if (typeof data0 === "string") {
                if (!formats0.test(data0)) {
                  validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "' + "uri-reference" + '"' }];
                  return false;
                }
              } else {
                validate10.errors = [{ instancePath: instancePath + "/$id", schemaPath: "#/properties/%24id/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                return false;
              }
            }
          }
          var valid0 = _errs1 === errors;
        } else {
          var valid0 = true;
        }
        if (valid0) {
          if (data.$schema !== undefined) {
            let data1 = data.$schema;
            const _errs3 = errors;
            if (errors === _errs3) {
              if (errors === _errs3) {
                if (typeof data1 === "string") {
                  if (!formats2(data1)) {
                    validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/format", keyword: "format", params: { format: "uri" }, message: 'must match format "' + "uri" + '"' }];
                    return false;
                  }
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/$schema", schemaPath: "#/properties/%24schema/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
              }
            }
            var valid0 = _errs3 === errors;
          } else {
            var valid0 = true;
          }
          if (valid0) {
            if (data.$ref !== undefined) {
              let data2 = data.$ref;
              const _errs5 = errors;
              if (errors === _errs5) {
                if (errors === _errs5) {
                  if (typeof data2 === "string") {
                    if (!formats0.test(data2)) {
                      validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/format", keyword: "format", params: { format: "uri-reference" }, message: 'must match format "' + "uri-reference" + '"' }];
                      return false;
                    }
                  } else {
                    validate10.errors = [{ instancePath: instancePath + "/$ref", schemaPath: "#/properties/%24ref/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                }
              }
              var valid0 = _errs5 === errors;
            } else {
              var valid0 = true;
            }
            if (valid0) {
              if (data.$comment !== undefined) {
                const _errs7 = errors;
                if (typeof data.$comment !== "string") {
                  validate10.errors = [{ instancePath: instancePath + "/$comment", schemaPath: "#/properties/%24comment/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                  return false;
                }
                var valid0 = _errs7 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                if (data.title !== undefined) {
                  const _errs9 = errors;
                  if (typeof data.title !== "string") {
                    validate10.errors = [{ instancePath: instancePath + "/title", schemaPath: "#/properties/title/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                    return false;
                  }
                  var valid0 = _errs9 === errors;
                } else {
                  var valid0 = true;
                }
                if (valid0) {
                  if (data.description !== undefined) {
                    const _errs11 = errors;
                    if (typeof data.description !== "string") {
                      validate10.errors = [{ instancePath: instancePath + "/description", schemaPath: "#/properties/description/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                      return false;
                    }
                    var valid0 = _errs11 === errors;
                  } else {
                    var valid0 = true;
                  }
                  if (valid0) {
                    if (data.readOnly !== undefined) {
                      const _errs13 = errors;
                      if (typeof data.readOnly !== "boolean") {
                        validate10.errors = [{ instancePath: instancePath + "/readOnly", schemaPath: "#/properties/readOnly/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                        return false;
                      }
                      var valid0 = _errs13 === errors;
                    } else {
                      var valid0 = true;
                    }
                    if (valid0) {
                      if (data.examples !== undefined) {
                        const _errs15 = errors;
                        if (errors === _errs15) {
                          if (!Array.isArray(data.examples)) {
                            validate10.errors = [{ instancePath: instancePath + "/examples", schemaPath: "#/properties/examples/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                            return false;
                          }
                        }
                        var valid0 = _errs15 === errors;
                      } else {
                        var valid0 = true;
                      }
                      if (valid0) {
                        if (data.multipleOf !== undefined) {
                          let data8 = data.multipleOf;
                          const _errs17 = errors;
                          if (errors === _errs17) {
                            if (typeof data8 == "number" && isFinite(data8)) {
                              if (data8 <= 0 || isNaN(data8)) {
                                validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/exclusiveMinimum", keyword: "exclusiveMinimum", params: { comparison: ">", limit: 0 }, message: "must be > 0" }];
                                return false;
                              }
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/multipleOf", schemaPath: "#/properties/multipleOf/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                          }
                          var valid0 = _errs17 === errors;
                        } else {
                          var valid0 = true;
                        }
                        if (valid0) {
                          if (data.maximum !== undefined) {
                            let data9 = data.maximum;
                            const _errs19 = errors;
                            if (!(typeof data9 == "number" && isFinite(data9))) {
                              validate10.errors = [{ instancePath: instancePath + "/maximum", schemaPath: "#/properties/maximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                              return false;
                            }
                            var valid0 = _errs19 === errors;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.exclusiveMaximum !== undefined) {
                              let data10 = data.exclusiveMaximum;
                              const _errs21 = errors;
                              if (!(typeof data10 == "number" && isFinite(data10))) {
                                validate10.errors = [{ instancePath: instancePath + "/exclusiveMaximum", schemaPath: "#/properties/exclusiveMaximum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                return false;
                              }
                              var valid0 = _errs21 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              if (data.minimum !== undefined) {
                                let data11 = data.minimum;
                                const _errs23 = errors;
                                if (!(typeof data11 == "number" && isFinite(data11))) {
                                  validate10.errors = [{ instancePath: instancePath + "/minimum", schemaPath: "#/properties/minimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                  return false;
                                }
                                var valid0 = _errs23 === errors;
                              } else {
                                var valid0 = true;
                              }
                              if (valid0) {
                                if (data.exclusiveMinimum !== undefined) {
                                  let data12 = data.exclusiveMinimum;
                                  const _errs25 = errors;
                                  if (!(typeof data12 == "number" && isFinite(data12))) {
                                    validate10.errors = [{ instancePath: instancePath + "/exclusiveMinimum", schemaPath: "#/properties/exclusiveMinimum/type", keyword: "type", params: { type: "number" }, message: "must be number" }];
                                    return false;
                                  }
                                  var valid0 = _errs25 === errors;
                                } else {
                                  var valid0 = true;
                                }
                                if (valid0) {
                                  if (data.maxLength !== undefined) {
                                    let data13 = data.maxLength;
                                    const _errs27 = errors;
                                    const _errs28 = errors;
                                    if (!(typeof data13 == "number" && (!(data13 % 1) && !isNaN(data13)) && isFinite(data13))) {
                                      validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                      return false;
                                    }
                                    if (errors === _errs28) {
                                      if (typeof data13 == "number" && isFinite(data13)) {
                                        if (data13 < 0 || isNaN(data13)) {
                                          validate10.errors = [{ instancePath: instancePath + "/maxLength", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                          return false;
                                        }
                                      }
                                    }
                                    var valid0 = _errs27 === errors;
                                  } else {
                                    var valid0 = true;
                                  }
                                  if (valid0) {
                                    if (data.minLength !== undefined) {
                                      const _errs30 = errors;
                                      if (!validate11(data.minLength, { instancePath: instancePath + "/minLength", parentData: data, parentDataProperty: "minLength", rootData })) {
                                        vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                        errors = vErrors.length;
                                      }
                                      var valid0 = _errs30 === errors;
                                    } else {
                                      var valid0 = true;
                                    }
                                    if (valid0) {
                                      if (data.pattern !== undefined) {
                                        let data15 = data.pattern;
                                        const _errs31 = errors;
                                        if (errors === _errs31) {
                                          if (errors === _errs31) {
                                            if (typeof data15 === "string") {
                                              if (!formats6(data15)) {
                                                validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/format", keyword: "format", params: { format: "regex" }, message: 'must match format "' + "regex" + '"' }];
                                                return false;
                                              }
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/pattern", schemaPath: "#/properties/pattern/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                        }
                                        var valid0 = _errs31 === errors;
                                      } else {
                                        var valid0 = true;
                                      }
                                      if (valid0) {
                                        if (data.additionalItems !== undefined) {
                                          const _errs33 = errors;
                                          if (!validate10(data.additionalItems, { instancePath: instancePath + "/additionalItems", parentData: data, parentDataProperty: "additionalItems", rootData })) {
                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                            errors = vErrors.length;
                                          }
                                          var valid0 = _errs33 === errors;
                                        } else {
                                          var valid0 = true;
                                        }
                                        if (valid0) {
                                          if (data.items !== undefined) {
                                            let data17 = data.items;
                                            const _errs34 = errors;
                                            const _errs35 = errors;
                                            let valid2 = false;
                                            const _errs36 = errors;
                                            if (!validate10(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                              errors = vErrors.length;
                                            }
                                            var _valid0 = _errs36 === errors;
                                            valid2 = valid2 || _valid0;
                                            if (!valid2) {
                                              const _errs37 = errors;
                                              if (!validate13(data17, { instancePath: instancePath + "/items", parentData: data, parentDataProperty: "items", rootData })) {
                                                vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                errors = vErrors.length;
                                              }
                                              var _valid0 = _errs37 === errors;
                                              valid2 = valid2 || _valid0;
                                            }
                                            if (!valid2) {
                                              const err0 = { instancePath: instancePath + "/items", schemaPath: "#/properties/items/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                              if (vErrors === null) {
                                                vErrors = [err0];
                                              } else {
                                                vErrors.push(err0);
                                              }
                                              errors++;
                                              validate10.errors = vErrors;
                                              return false;
                                            } else {
                                              errors = _errs35;
                                              if (vErrors !== null) {
                                                if (_errs35) {
                                                  vErrors.length = _errs35;
                                                } else {
                                                  vErrors = null;
                                                }
                                              }
                                            }
                                            var valid0 = _errs34 === errors;
                                          } else {
                                            var valid0 = true;
                                          }
                                          if (valid0) {
                                            if (data.maxItems !== undefined) {
                                              let data18 = data.maxItems;
                                              const _errs38 = errors;
                                              const _errs39 = errors;
                                              if (!(typeof data18 == "number" && (!(data18 % 1) && !isNaN(data18)) && isFinite(data18))) {
                                                validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                return false;
                                              }
                                              if (errors === _errs39) {
                                                if (typeof data18 == "number" && isFinite(data18)) {
                                                  if (data18 < 0 || isNaN(data18)) {
                                                    validate10.errors = [{ instancePath: instancePath + "/maxItems", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                    return false;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs38 === errors;
                                            } else {
                                              var valid0 = true;
                                            }
                                            if (valid0) {
                                              if (data.minItems !== undefined) {
                                                const _errs41 = errors;
                                                if (!validate11(data.minItems, { instancePath: instancePath + "/minItems", parentData: data, parentDataProperty: "minItems", rootData })) {
                                                  vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                  errors = vErrors.length;
                                                }
                                                var valid0 = _errs41 === errors;
                                              } else {
                                                var valid0 = true;
                                              }
                                              if (valid0) {
                                                if (data.uniqueItems !== undefined) {
                                                  const _errs42 = errors;
                                                  if (typeof data.uniqueItems !== "boolean") {
                                                    validate10.errors = [{ instancePath: instancePath + "/uniqueItems", schemaPath: "#/properties/uniqueItems/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                    return false;
                                                  }
                                                  var valid0 = _errs42 === errors;
                                                } else {
                                                  var valid0 = true;
                                                }
                                                if (valid0) {
                                                  if (data.contains !== undefined) {
                                                    const _errs44 = errors;
                                                    if (!validate10(data.contains, { instancePath: instancePath + "/contains", parentData: data, parentDataProperty: "contains", rootData })) {
                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                      errors = vErrors.length;
                                                    }
                                                    var valid0 = _errs44 === errors;
                                                  } else {
                                                    var valid0 = true;
                                                  }
                                                  if (valid0) {
                                                    if (data.maxProperties !== undefined) {
                                                      let data22 = data.maxProperties;
                                                      const _errs45 = errors;
                                                      const _errs46 = errors;
                                                      if (!(typeof data22 == "number" && (!(data22 % 1) && !isNaN(data22)) && isFinite(data22))) {
                                                        validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                        return false;
                                                      }
                                                      if (errors === _errs46) {
                                                        if (typeof data22 == "number" && isFinite(data22)) {
                                                          if (data22 < 0 || isNaN(data22)) {
                                                            validate10.errors = [{ instancePath: instancePath + "/maxProperties", schemaPath: "#/definitions/nonNegativeInteger/minimum", keyword: "minimum", params: { comparison: ">=", limit: 0 }, message: "must be >= 0" }];
                                                            return false;
                                                          }
                                                        }
                                                      }
                                                      var valid0 = _errs45 === errors;
                                                    } else {
                                                      var valid0 = true;
                                                    }
                                                    if (valid0) {
                                                      if (data.minProperties !== undefined) {
                                                        const _errs48 = errors;
                                                        if (!validate11(data.minProperties, { instancePath: instancePath + "/minProperties", parentData: data, parentDataProperty: "minProperties", rootData })) {
                                                          vErrors = vErrors === null ? validate11.errors : vErrors.concat(validate11.errors);
                                                          errors = vErrors.length;
                                                        }
                                                        var valid0 = _errs48 === errors;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data.required !== undefined) {
                                                          let data24 = data.required;
                                                          const _errs49 = errors;
                                                          const _errs50 = errors;
                                                          if (errors === _errs50) {
                                                            if (Array.isArray(data24)) {
                                                              var valid6 = true;
                                                              const len0 = data24.length;
                                                              for (let i0 = 0;i0 < len0; i0++) {
                                                                const _errs52 = errors;
                                                                if (typeof data24[i0] !== "string") {
                                                                  validate10.errors = [{ instancePath: instancePath + "/required/" + i0, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                  return false;
                                                                }
                                                                var valid6 = _errs52 === errors;
                                                                if (!valid6) {
                                                                  break;
                                                                }
                                                              }
                                                              if (valid6) {
                                                                let i1 = data24.length;
                                                                let j0;
                                                                if (i1 > 1) {
                                                                  const indices0 = {};
                                                                  for (;i1--; ) {
                                                                    let item0 = data24[i1];
                                                                    if (typeof item0 !== "string") {
                                                                      continue;
                                                                    }
                                                                    if (typeof indices0[item0] == "number") {
                                                                      j0 = indices0[item0];
                                                                      validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i1, j: j0 }, message: "must NOT have duplicate items (items ## " + j0 + " and " + i1 + " are identical)" }];
                                                                      return false;
                                                                      break;
                                                                    }
                                                                    indices0[item0] = i1;
                                                                  }
                                                                }
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/required", schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs49 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                        if (valid0) {
                                                          if (data.additionalProperties !== undefined) {
                                                            const _errs54 = errors;
                                                            if (!validate10(data.additionalProperties, { instancePath: instancePath + "/additionalProperties", parentData: data, parentDataProperty: "additionalProperties", rootData })) {
                                                              vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                              errors = vErrors.length;
                                                            }
                                                            var valid0 = _errs54 === errors;
                                                          } else {
                                                            var valid0 = true;
                                                          }
                                                          if (valid0) {
                                                            if (data.definitions !== undefined) {
                                                              let data27 = data.definitions;
                                                              const _errs55 = errors;
                                                              if (errors === _errs55) {
                                                                if (data27 && typeof data27 == "object" && !Array.isArray(data27)) {
                                                                  for (const key0 in data27) {
                                                                    const _errs58 = errors;
                                                                    if (!validate10(data27[key0], { instancePath: instancePath + "/definitions/" + key0.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data27, parentDataProperty: key0, rootData })) {
                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                      errors = vErrors.length;
                                                                    }
                                                                    var valid8 = _errs58 === errors;
                                                                    if (!valid8) {
                                                                      break;
                                                                    }
                                                                  }
                                                                } else {
                                                                  validate10.errors = [{ instancePath: instancePath + "/definitions", schemaPath: "#/properties/definitions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                  return false;
                                                                }
                                                              }
                                                              var valid0 = _errs55 === errors;
                                                            } else {
                                                              var valid0 = true;
                                                            }
                                                            if (valid0) {
                                                              if (data.properties !== undefined) {
                                                                let data29 = data.properties;
                                                                const _errs59 = errors;
                                                                if (errors === _errs59) {
                                                                  if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                                    for (const key1 in data29) {
                                                                      const _errs62 = errors;
                                                                      if (!validate10(data29[key1], { instancePath: instancePath + "/properties/" + key1.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data29, parentDataProperty: key1, rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors = vErrors.length;
                                                                      }
                                                                      var valid9 = _errs62 === errors;
                                                                      if (!valid9) {
                                                                        break;
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/properties", schemaPath: "#/properties/properties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid0 = _errs59 === errors;
                                                              } else {
                                                                var valid0 = true;
                                                              }
                                                              if (valid0) {
                                                                if (data.patternProperties !== undefined) {
                                                                  let data31 = data.patternProperties;
                                                                  const _errs63 = errors;
                                                                  if (errors === _errs63) {
                                                                    if (data31 && typeof data31 == "object" && !Array.isArray(data31)) {
                                                                      for (const key2 in data31) {
                                                                        const _errs65 = errors;
                                                                        if (errors === _errs65) {
                                                                          if (typeof key2 === "string") {
                                                                            if (!formats6(key2)) {
                                                                              const err1 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames/format", keyword: "format", params: { format: "regex" }, message: 'must match format "' + "regex" + '"', propertyName: key2 };
                                                                              if (vErrors === null) {
                                                                                vErrors = [err1];
                                                                              } else {
                                                                                vErrors.push(err1);
                                                                              }
                                                                              errors++;
                                                                            }
                                                                          }
                                                                        }
                                                                        var valid10 = _errs65 === errors;
                                                                        if (!valid10) {
                                                                          const err2 = { instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/propertyNames", keyword: "propertyNames", params: { propertyName: key2 }, message: "property name must be valid" };
                                                                          if (vErrors === null) {
                                                                            vErrors = [err2];
                                                                          } else {
                                                                            vErrors.push(err2);
                                                                          }
                                                                          errors++;
                                                                          validate10.errors = vErrors;
                                                                          return false;
                                                                          break;
                                                                        }
                                                                      }
                                                                      if (valid10) {
                                                                        for (const key3 in data31) {
                                                                          const _errs67 = errors;
                                                                          if (!validate10(data31[key3], { instancePath: instancePath + "/patternProperties/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data31, parentDataProperty: key3, rootData })) {
                                                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                            errors = vErrors.length;
                                                                          }
                                                                          var valid11 = _errs67 === errors;
                                                                          if (!valid11) {
                                                                            break;
                                                                          }
                                                                        }
                                                                      }
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/patternProperties", schemaPath: "#/properties/patternProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  var valid0 = _errs63 === errors;
                                                                } else {
                                                                  var valid0 = true;
                                                                }
                                                                if (valid0) {
                                                                  if (data.dependencies !== undefined) {
                                                                    let data33 = data.dependencies;
                                                                    const _errs68 = errors;
                                                                    if (errors === _errs68) {
                                                                      if (data33 && typeof data33 == "object" && !Array.isArray(data33)) {
                                                                        for (const key4 in data33) {
                                                                          let data34 = data33[key4];
                                                                          const _errs71 = errors;
                                                                          const _errs72 = errors;
                                                                          let valid13 = false;
                                                                          const _errs73 = errors;
                                                                          if (!validate10(data34, { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), parentData: data33, parentDataProperty: key4, rootData })) {
                                                                            vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                            errors = vErrors.length;
                                                                          }
                                                                          var _valid1 = _errs73 === errors;
                                                                          valid13 = valid13 || _valid1;
                                                                          if (!valid13) {
                                                                            const _errs74 = errors;
                                                                            const _errs75 = errors;
                                                                            if (errors === _errs75) {
                                                                              if (Array.isArray(data34)) {
                                                                                var valid15 = true;
                                                                                const len1 = data34.length;
                                                                                for (let i2 = 0;i2 < len1; i2++) {
                                                                                  const _errs77 = errors;
                                                                                  if (typeof data34[i2] !== "string") {
                                                                                    const err3 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1") + "/" + i2, schemaPath: "#/definitions/stringArray/items/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                                                    if (vErrors === null) {
                                                                                      vErrors = [err3];
                                                                                    } else {
                                                                                      vErrors.push(err3);
                                                                                    }
                                                                                    errors++;
                                                                                  }
                                                                                  var valid15 = _errs77 === errors;
                                                                                  if (!valid15) {
                                                                                    break;
                                                                                  }
                                                                                }
                                                                                if (valid15) {
                                                                                  let i3 = data34.length;
                                                                                  let j1;
                                                                                  if (i3 > 1) {
                                                                                    const indices1 = {};
                                                                                    for (;i3--; ) {
                                                                                      let item1 = data34[i3];
                                                                                      if (typeof item1 !== "string") {
                                                                                        continue;
                                                                                      }
                                                                                      if (typeof indices1[item1] == "number") {
                                                                                        j1 = indices1[item1];
                                                                                        const err4 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/uniqueItems", keyword: "uniqueItems", params: { i: i3, j: j1 }, message: "must NOT have duplicate items (items ## " + j1 + " and " + i3 + " are identical)" };
                                                                                        if (vErrors === null) {
                                                                                          vErrors = [err4];
                                                                                        } else {
                                                                                          vErrors.push(err4);
                                                                                        }
                                                                                        errors++;
                                                                                        break;
                                                                                      }
                                                                                      indices1[item1] = i3;
                                                                                    }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                const err5 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/definitions/stringArray/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err5];
                                                                                } else {
                                                                                  vErrors.push(err5);
                                                                                }
                                                                                errors++;
                                                                              }
                                                                            }
                                                                            var _valid1 = _errs74 === errors;
                                                                            valid13 = valid13 || _valid1;
                                                                          }
                                                                          if (!valid13) {
                                                                            const err6 = { instancePath: instancePath + "/dependencies/" + key4.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/dependencies/additionalProperties/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err6];
                                                                            } else {
                                                                              vErrors.push(err6);
                                                                            }
                                                                            errors++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                          } else {
                                                                            errors = _errs72;
                                                                            if (vErrors !== null) {
                                                                              if (_errs72) {
                                                                                vErrors.length = _errs72;
                                                                              } else {
                                                                                vErrors = null;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid12 = _errs71 === errors;
                                                                          if (!valid12) {
                                                                            break;
                                                                          }
                                                                        }
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/dependencies", schemaPath: "#/properties/dependencies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    var valid0 = _errs68 === errors;
                                                                  } else {
                                                                    var valid0 = true;
                                                                  }
                                                                  if (valid0) {
                                                                    if (data.propertyNames !== undefined) {
                                                                      const _errs79 = errors;
                                                                      if (!validate10(data.propertyNames, { instancePath: instancePath + "/propertyNames", parentData: data, parentDataProperty: "propertyNames", rootData })) {
                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                        errors = vErrors.length;
                                                                      }
                                                                      var valid0 = _errs79 === errors;
                                                                    } else {
                                                                      var valid0 = true;
                                                                    }
                                                                    if (valid0) {
                                                                      if (data.enum !== undefined) {
                                                                        let data37 = data.enum;
                                                                        const _errs80 = errors;
                                                                        if (errors === _errs80) {
                                                                          if (Array.isArray(data37)) {
                                                                            if (data37.length < 1) {
                                                                              validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" }];
                                                                              return false;
                                                                            } else {
                                                                              let i4 = data37.length;
                                                                              let j22;
                                                                              if (i4 > 1) {
                                                                                outer0:
                                                                                  for (;i4--; ) {
                                                                                    for (j22 = i4;j22--; ) {
                                                                                      if (func0(data37[i4], data37[j22])) {
                                                                                        validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/uniqueItems", keyword: "uniqueItems", params: { i: i4, j: j22 }, message: "must NOT have duplicate items (items ## " + j22 + " and " + i4 + " are identical)" }];
                                                                                        return false;
                                                                                        break outer0;
                                                                                      }
                                                                                    }
                                                                                  }
                                                                              }
                                                                            }
                                                                          } else {
                                                                            validate10.errors = [{ instancePath: instancePath + "/enum", schemaPath: "#/properties/enum/type", keyword: "type", params: { type: "array" }, message: "must be array" }];
                                                                            return false;
                                                                          }
                                                                        }
                                                                        var valid0 = _errs80 === errors;
                                                                      } else {
                                                                        var valid0 = true;
                                                                      }
                                                                      if (valid0) {
                                                                        if (data.type !== undefined) {
                                                                          let data38 = data.type;
                                                                          const _errs82 = errors;
                                                                          const _errs83 = errors;
                                                                          let valid18 = false;
                                                                          const _errs84 = errors;
                                                                          if (!(data38 === "array" || data38 === "boolean" || data38 === "integer" || data38 === "null" || data38 === "number" || data38 === "object" || data38 === "string")) {
                                                                            const err7 = { instancePath: instancePath + "/type", schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err7];
                                                                            } else {
                                                                              vErrors.push(err7);
                                                                            }
                                                                            errors++;
                                                                          }
                                                                          var _valid2 = _errs84 === errors;
                                                                          valid18 = valid18 || _valid2;
                                                                          if (!valid18) {
                                                                            const _errs86 = errors;
                                                                            if (errors === _errs86) {
                                                                              if (Array.isArray(data38)) {
                                                                                if (data38.length < 1) {
                                                                                  const err8 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/minItems", keyword: "minItems", params: { limit: 1 }, message: "must NOT have fewer than 1 items" };
                                                                                  if (vErrors === null) {
                                                                                    vErrors = [err8];
                                                                                  } else {
                                                                                    vErrors.push(err8);
                                                                                  }
                                                                                  errors++;
                                                                                } else {
                                                                                  var valid20 = true;
                                                                                  const len2 = data38.length;
                                                                                  for (let i5 = 0;i5 < len2; i5++) {
                                                                                    let data39 = data38[i5];
                                                                                    const _errs88 = errors;
                                                                                    if (!(data39 === "array" || data39 === "boolean" || data39 === "integer" || data39 === "null" || data39 === "number" || data39 === "object" || data39 === "string")) {
                                                                                      const err9 = { instancePath: instancePath + "/type/" + i5, schemaPath: "#/definitions/simpleTypes/enum", keyword: "enum", params: { allowedValues: schema20.enum }, message: "must be equal to one of the allowed values" };
                                                                                      if (vErrors === null) {
                                                                                        vErrors = [err9];
                                                                                      } else {
                                                                                        vErrors.push(err9);
                                                                                      }
                                                                                      errors++;
                                                                                    }
                                                                                    var valid20 = _errs88 === errors;
                                                                                    if (!valid20) {
                                                                                      break;
                                                                                    }
                                                                                  }
                                                                                  if (valid20) {
                                                                                    let i6 = data38.length;
                                                                                    let j3;
                                                                                    if (i6 > 1) {
                                                                                      outer1:
                                                                                        for (;i6--; ) {
                                                                                          for (j3 = i6;j3--; ) {
                                                                                            if (func0(data38[i6], data38[j3])) {
                                                                                              const err10 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/uniqueItems", keyword: "uniqueItems", params: { i: i6, j: j3 }, message: "must NOT have duplicate items (items ## " + j3 + " and " + i6 + " are identical)" };
                                                                                              if (vErrors === null) {
                                                                                                vErrors = [err10];
                                                                                              } else {
                                                                                                vErrors.push(err10);
                                                                                              }
                                                                                              errors++;
                                                                                              break outer1;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              } else {
                                                                                const err11 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf/1/type", keyword: "type", params: { type: "array" }, message: "must be array" };
                                                                                if (vErrors === null) {
                                                                                  vErrors = [err11];
                                                                                } else {
                                                                                  vErrors.push(err11);
                                                                                }
                                                                                errors++;
                                                                              }
                                                                            }
                                                                            var _valid2 = _errs86 === errors;
                                                                            valid18 = valid18 || _valid2;
                                                                          }
                                                                          if (!valid18) {
                                                                            const err12 = { instancePath: instancePath + "/type", schemaPath: "#/properties/type/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                                                            if (vErrors === null) {
                                                                              vErrors = [err12];
                                                                            } else {
                                                                              vErrors.push(err12);
                                                                            }
                                                                            errors++;
                                                                            validate10.errors = vErrors;
                                                                            return false;
                                                                          } else {
                                                                            errors = _errs83;
                                                                            if (vErrors !== null) {
                                                                              if (_errs83) {
                                                                                vErrors.length = _errs83;
                                                                              } else {
                                                                                vErrors = null;
                                                                              }
                                                                            }
                                                                          }
                                                                          var valid0 = _errs82 === errors;
                                                                        } else {
                                                                          var valid0 = true;
                                                                        }
                                                                        if (valid0) {
                                                                          if (data.format !== undefined) {
                                                                            const _errs90 = errors;
                                                                            if (typeof data.format !== "string") {
                                                                              validate10.errors = [{ instancePath: instancePath + "/format", schemaPath: "#/properties/format/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                            var valid0 = _errs90 === errors;
                                                                          } else {
                                                                            var valid0 = true;
                                                                          }
                                                                          if (valid0) {
                                                                            if (data.contentMediaType !== undefined) {
                                                                              const _errs92 = errors;
                                                                              if (typeof data.contentMediaType !== "string") {
                                                                                validate10.errors = [{ instancePath: instancePath + "/contentMediaType", schemaPath: "#/properties/contentMediaType/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                return false;
                                                                              }
                                                                              var valid0 = _errs92 === errors;
                                                                            } else {
                                                                              var valid0 = true;
                                                                            }
                                                                            if (valid0) {
                                                                              if (data.contentEncoding !== undefined) {
                                                                                const _errs94 = errors;
                                                                                if (typeof data.contentEncoding !== "string") {
                                                                                  validate10.errors = [{ instancePath: instancePath + "/contentEncoding", schemaPath: "#/properties/contentEncoding/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                                  return false;
                                                                                }
                                                                                var valid0 = _errs94 === errors;
                                                                              } else {
                                                                                var valid0 = true;
                                                                              }
                                                                              if (valid0) {
                                                                                if (data.if !== undefined) {
                                                                                  const _errs96 = errors;
                                                                                  if (!validate10(data.if, { instancePath: instancePath + "/if", parentData: data, parentDataProperty: "if", rootData })) {
                                                                                    vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                    errors = vErrors.length;
                                                                                  }
                                                                                  var valid0 = _errs96 === errors;
                                                                                } else {
                                                                                  var valid0 = true;
                                                                                }
                                                                                if (valid0) {
                                                                                  if (data.then !== undefined) {
                                                                                    const _errs97 = errors;
                                                                                    if (!validate10(data.then, { instancePath: instancePath + "/then", parentData: data, parentDataProperty: "then", rootData })) {
                                                                                      vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                      errors = vErrors.length;
                                                                                    }
                                                                                    var valid0 = _errs97 === errors;
                                                                                  } else {
                                                                                    var valid0 = true;
                                                                                  }
                                                                                  if (valid0) {
                                                                                    if (data.else !== undefined) {
                                                                                      const _errs98 = errors;
                                                                                      if (!validate10(data.else, { instancePath: instancePath + "/else", parentData: data, parentDataProperty: "else", rootData })) {
                                                                                        vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                        errors = vErrors.length;
                                                                                      }
                                                                                      var valid0 = _errs98 === errors;
                                                                                    } else {
                                                                                      var valid0 = true;
                                                                                    }
                                                                                    if (valid0) {
                                                                                      if (data.allOf !== undefined) {
                                                                                        const _errs99 = errors;
                                                                                        if (!validate13(data.allOf, { instancePath: instancePath + "/allOf", parentData: data, parentDataProperty: "allOf", rootData })) {
                                                                                          vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                          errors = vErrors.length;
                                                                                        }
                                                                                        var valid0 = _errs99 === errors;
                                                                                      } else {
                                                                                        var valid0 = true;
                                                                                      }
                                                                                      if (valid0) {
                                                                                        if (data.anyOf !== undefined) {
                                                                                          const _errs100 = errors;
                                                                                          if (!validate13(data.anyOf, { instancePath: instancePath + "/anyOf", parentData: data, parentDataProperty: "anyOf", rootData })) {
                                                                                            vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                            errors = vErrors.length;
                                                                                          }
                                                                                          var valid0 = _errs100 === errors;
                                                                                        } else {
                                                                                          var valid0 = true;
                                                                                        }
                                                                                        if (valid0) {
                                                                                          if (data.oneOf !== undefined) {
                                                                                            const _errs101 = errors;
                                                                                            if (!validate13(data.oneOf, { instancePath: instancePath + "/oneOf", parentData: data, parentDataProperty: "oneOf", rootData })) {
                                                                                              vErrors = vErrors === null ? validate13.errors : vErrors.concat(validate13.errors);
                                                                                              errors = vErrors.length;
                                                                                            }
                                                                                            var valid0 = _errs101 === errors;
                                                                                          } else {
                                                                                            var valid0 = true;
                                                                                          }
                                                                                          if (valid0) {
                                                                                            if (data.not !== undefined) {
                                                                                              const _errs102 = errors;
                                                                                              if (!validate10(data.not, { instancePath: instancePath + "/not", parentData: data, parentDataProperty: "not", rootData })) {
                                                                                                vErrors = vErrors === null ? validate10.errors : vErrors.concat(validate10.errors);
                                                                                                errors = vErrors.length;
                                                                                              }
                                                                                              var valid0 = _errs102 === errors;
                                                                                            } else {
                                                                                              var valid0 = true;
                                                                                            }
                                                                                          }
                                                                                        }
                                                                                      }
                                                                                    }
                                                                                  }
                                                                                }
                                                                              }
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    validate10.errors = vErrors;
    return errors === 0;
  }
});

// node_modules/@fastify/merge-json-schemas/lib/errors.js
var require_errors5 = __commonJS((exports, module) => {
  class MergeError extends Error {
    constructor(keyword, schemas) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Failed to merge "${keyword}" keyword schemas.`;
      this.schemas = schemas;
    }
  }

  class ResolverNotFoundError extends Error {
    constructor(keyword, schemas) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Resolver for "${keyword}" keyword not found.`;
      this.schemas = schemas;
    }
  }

  class InvalidOnConflictOptionError extends Error {
    constructor(onConflict) {
      super();
      this.name = "JsonSchemaMergeError";
      this.code = "JSON_SCHEMA_MERGE_ERROR";
      this.message = `Invalid "onConflict" option: "${onConflict}".`;
    }
  }
  module.exports = {
    MergeError,
    ResolverNotFoundError,
    InvalidOnConflictOptionError
  };
});

// node_modules/@fastify/merge-json-schemas/lib/resolvers.js
var require_resolvers = __commonJS((exports, module) => {
  var { dequal: deepEqual } = require_dist();
  var { MergeError } = require_errors5();
  function _arraysIntersection(arrays) {
    let intersection = arrays[0];
    for (let i = 1;i < arrays.length; i++) {
      intersection = intersection.filter((value) => arrays[i].includes(value));
    }
    return intersection;
  }
  function arraysIntersection(keyword, values, mergedSchema) {
    const intersection = _arraysIntersection(values);
    if (intersection.length === 0) {
      throw new MergeError(keyword, values);
    }
    mergedSchema[keyword] = intersection;
  }
  function hybridArraysIntersection(keyword, values, mergedSchema) {
    for (let i = 0;i < values.length; i++) {
      if (!Array.isArray(values[i])) {
        values[i] = [values[i]];
      }
    }
    const intersection = _arraysIntersection(values);
    if (intersection.length === 0) {
      throw new MergeError(keyword, values);
    }
    if (intersection.length === 1) {
      mergedSchema[keyword] = intersection[0];
    } else {
      mergedSchema[keyword] = intersection;
    }
  }
  function arraysUnion(keyword, values, mergedSchema) {
    const union = [];
    for (const array of values) {
      for (const value of array) {
        if (!union.includes(value)) {
          union.push(value);
        }
      }
    }
    mergedSchema[keyword] = union;
  }
  function minNumber(keyword, values, mergedSchema) {
    mergedSchema[keyword] = Math.min(...values);
  }
  function maxNumber(keyword, values, mergedSchema) {
    mergedSchema[keyword] = Math.max(...values);
  }
  function commonMultiple(keyword, values, mergedSchema) {
    const gcd = (a3, b5) => !b5 ? a3 : gcd(b5, a3 % b5);
    const lcm = (a3, b5) => a3 * b5 / gcd(a3, b5);
    let scale = 1;
    for (const value of values) {
      while (value * scale % 1 !== 0) {
        scale *= 10;
      }
    }
    let multiple = values[0] * scale;
    for (const value of values) {
      multiple = lcm(multiple, value * scale);
    }
    mergedSchema[keyword] = multiple / scale;
  }
  function allEqual(keyword, values, mergedSchema) {
    const firstValue = values[0];
    for (let i = 1;i < values.length; i++) {
      if (!deepEqual(values[i], firstValue)) {
        throw new MergeError(keyword, values);
      }
    }
    mergedSchema[keyword] = firstValue;
  }
  function skip() {}
  function booleanAnd(keyword, values, mergedSchema) {
    for (const value of values) {
      if (value === false) {
        mergedSchema[keyword] = false;
        return;
      }
    }
    mergedSchema[keyword] = true;
  }
  function booleanOr(keyword, values, mergedSchema) {
    for (const value of values) {
      if (value === true) {
        mergedSchema[keyword] = true;
        return;
      }
    }
    mergedSchema[keyword] = false;
  }
  module.exports = {
    arraysIntersection,
    hybridArraysIntersection,
    arraysUnion,
    minNumber,
    maxNumber,
    commonMultiple,
    allEqual,
    booleanAnd,
    booleanOr,
    skip
  };
});

// node_modules/@fastify/merge-json-schemas/index.js
var require_merge_json_schemas = __commonJS((exports, module) => {
  var { dequal: deepEqual } = require_dist();
  var resolvers = require_resolvers();
  var errors = require_errors5();
  var keywordsResolvers = {
    $id: resolvers.skip,
    type: resolvers.hybridArraysIntersection,
    enum: resolvers.arraysIntersection,
    minLength: resolvers.maxNumber,
    maxLength: resolvers.minNumber,
    minimum: resolvers.maxNumber,
    maximum: resolvers.minNumber,
    multipleOf: resolvers.commonMultiple,
    exclusiveMinimum: resolvers.maxNumber,
    exclusiveMaximum: resolvers.minNumber,
    minItems: resolvers.maxNumber,
    maxItems: resolvers.minNumber,
    maxProperties: resolvers.minNumber,
    minProperties: resolvers.maxNumber,
    const: resolvers.allEqual,
    default: resolvers.allEqual,
    format: resolvers.allEqual,
    required: resolvers.arraysUnion,
    properties: mergeProperties,
    patternProperties: mergeObjects,
    additionalProperties: mergeSchemasResolver,
    items: mergeItems,
    additionalItems: mergeAdditionalItems,
    definitions: mergeObjects,
    $defs: mergeObjects,
    nullable: resolvers.booleanAnd,
    oneOf: mergeOneOf,
    anyOf: mergeOneOf,
    allOf: resolvers.arraysUnion,
    not: mergeSchemasResolver,
    if: mergeIfThenElseSchemas,
    then: resolvers.skip,
    else: resolvers.skip,
    dependencies: mergeDependencies,
    dependentRequired: mergeDependencies,
    dependentSchemas: mergeObjects,
    propertyNames: mergeSchemasResolver,
    uniqueItems: resolvers.booleanOr,
    contains: mergeSchemasResolver
  };
  function mergeSchemasResolver(keyword, values, mergedSchema, _schemas, options) {
    mergedSchema[keyword] = _mergeSchemas(values, options);
  }
  function cartesianProduct(arrays) {
    let result = [[]];
    for (const array of arrays) {
      const temp = [];
      for (const x3 of result) {
        for (const y3 of array) {
          temp.push([...x3, y3]);
        }
      }
      result = temp;
    }
    return result;
  }
  function mergeOneOf(keyword, values, mergedSchema, _schemas, options) {
    if (values.length === 1) {
      mergedSchema[keyword] = values[0];
      return;
    }
    const product = cartesianProduct(values);
    const mergedOneOf = [];
    for (const combination of product) {
      try {
        const mergedSchema2 = _mergeSchemas(combination, options);
        if (mergedSchema2 !== undefined) {
          mergedOneOf.push(mergedSchema2);
        }
      } catch (error) {
        if (error instanceof errors.MergeError)
          continue;
        throw error;
      }
    }
    mergedSchema[keyword] = mergedOneOf;
  }
  function getSchemaForItem(schema, index) {
    const { items, additionalItems } = schema;
    if (Array.isArray(items)) {
      if (index < items.length) {
        return items[index];
      }
      return additionalItems;
    }
    if (items !== undefined) {
      return items;
    }
    return additionalItems;
  }
  function mergeItems(keyword, values, mergedSchema, schemas, options) {
    let maxArrayItemsLength = 0;
    for (const itemsSchema of values) {
      if (Array.isArray(itemsSchema)) {
        maxArrayItemsLength = Math.max(maxArrayItemsLength, itemsSchema.length);
      }
    }
    if (maxArrayItemsLength === 0) {
      mergedSchema[keyword] = _mergeSchemas(values, options);
      return;
    }
    const mergedItemsSchemas = [];
    for (let i = 0;i < maxArrayItemsLength; i++) {
      const indexItemSchemas = [];
      for (const schema of schemas) {
        const itemSchema = getSchemaForItem(schema, i);
        if (itemSchema !== undefined) {
          indexItemSchemas.push(itemSchema);
        }
      }
      mergedItemsSchemas[i] = _mergeSchemas(indexItemSchemas, options);
    }
    mergedSchema[keyword] = mergedItemsSchemas;
  }
  function mergeAdditionalItems(keyword, values, mergedSchema, schemas, options) {
    let hasArrayItems = false;
    for (const schema of schemas) {
      if (Array.isArray(schema.items)) {
        hasArrayItems = true;
        break;
      }
    }
    if (!hasArrayItems) {
      mergedSchema[keyword] = _mergeSchemas(values, options);
      return;
    }
    const mergedAdditionalItemsSchemas = [];
    for (const schema of schemas) {
      let additionalItemsSchema = schema.additionalItems;
      if (additionalItemsSchema === undefined && !Array.isArray(schema.items)) {
        additionalItemsSchema = schema.items;
      }
      if (additionalItemsSchema !== undefined) {
        mergedAdditionalItemsSchemas.push(additionalItemsSchema);
      }
    }
    mergedSchema[keyword] = _mergeSchemas(mergedAdditionalItemsSchemas, options);
  }
  function getSchemaForProperty(schema, propertyName) {
    const { properties, patternProperties, additionalProperties } = schema;
    if (properties?.[propertyName] !== undefined) {
      return properties[propertyName];
    }
    for (const pattern of Object.keys(patternProperties ?? {})) {
      const regexp = new RegExp(pattern);
      if (regexp.test(propertyName)) {
        return patternProperties[pattern];
      }
    }
    return additionalProperties;
  }
  function mergeProperties(keyword, _values, mergedSchema, schemas, options) {
    const foundProperties = {};
    for (const currentSchema of schemas) {
      const properties = currentSchema.properties ?? {};
      for (const propertyName of Object.keys(properties)) {
        if (foundProperties[propertyName] !== undefined)
          continue;
        const propertySchema = properties[propertyName];
        foundProperties[propertyName] = [propertySchema];
        for (const anotherSchema of schemas) {
          if (currentSchema === anotherSchema)
            continue;
          const propertySchema2 = getSchemaForProperty(anotherSchema, propertyName);
          if (propertySchema2 !== undefined) {
            foundProperties[propertyName].push(propertySchema2);
          }
        }
      }
    }
    const mergedProperties = {};
    for (const property of Object.keys(foundProperties)) {
      const propertySchemas = foundProperties[property];
      mergedProperties[property] = _mergeSchemas(propertySchemas, options);
    }
    mergedSchema[keyword] = mergedProperties;
  }
  function mergeObjects(keyword, values, mergedSchema, _schemas, options) {
    const objectsProperties = {};
    for (const properties of values) {
      for (const propertyName of Object.keys(properties)) {
        if (objectsProperties[propertyName] === undefined) {
          objectsProperties[propertyName] = [];
        }
        objectsProperties[propertyName].push(properties[propertyName]);
      }
    }
    const mergedProperties = {};
    for (const propertyName of Object.keys(objectsProperties)) {
      const propertySchemas = objectsProperties[propertyName];
      const mergedPropertySchema = _mergeSchemas(propertySchemas, options);
      mergedProperties[propertyName] = mergedPropertySchema;
    }
    mergedSchema[keyword] = mergedProperties;
  }
  function mergeIfThenElseSchemas(_keyword, _values, mergedSchema, schemas, options) {
    for (let i = 0;i < schemas.length; i++) {
      const subSchema = {
        if: schemas[i].if,
        then: schemas[i].then,
        else: schemas[i].else
      };
      if (subSchema.if === undefined)
        continue;
      if (mergedSchema.if === undefined) {
        mergedSchema.if = subSchema.if;
        if (subSchema.then !== undefined) {
          mergedSchema.then = subSchema.then;
        }
        if (subSchema.else !== undefined) {
          mergedSchema.else = subSchema.else;
        }
        continue;
      }
      if (mergedSchema.then !== undefined) {
        mergedSchema.then = _mergeSchemas([mergedSchema.then, subSchema], options);
      }
      if (mergedSchema.else !== undefined) {
        mergedSchema.else = _mergeSchemas([mergedSchema.else, subSchema], options);
      }
    }
  }
  function mergeDependencies(keyword, values, mergedSchema) {
    const mergedDependencies = {};
    for (const dependencies of values) {
      for (const propertyName of Object.keys(dependencies)) {
        if (mergedDependencies[propertyName] === undefined) {
          mergedDependencies[propertyName] = [];
        }
        const mergedPropertyDependencies = mergedDependencies[propertyName];
        for (const propertyDependency of dependencies[propertyName]) {
          if (!mergedPropertyDependencies.includes(propertyDependency)) {
            mergedPropertyDependencies.push(propertyDependency);
          }
        }
      }
    }
    mergedSchema[keyword] = mergedDependencies;
  }
  function _mergeSchemas(schemas, options) {
    if (schemas.length === 0)
      return {};
    if (schemas.length === 1)
      return schemas[0];
    const mergedSchema = {};
    const keywords = {};
    let allSchemasAreTrue = true;
    for (const schema of schemas) {
      if (schema === false)
        return false;
      if (schema === true)
        continue;
      allSchemasAreTrue = false;
      for (const keyword of Object.keys(schema)) {
        if (keywords[keyword] === undefined) {
          keywords[keyword] = [];
        }
        keywords[keyword].push(schema[keyword]);
      }
    }
    if (allSchemasAreTrue)
      return true;
    for (const keyword of Object.keys(keywords)) {
      const keywordValues = keywords[keyword];
      const resolver = options.resolvers[keyword] ?? options.defaultResolver;
      resolver(keyword, keywordValues, mergedSchema, schemas, options);
    }
    return mergedSchema;
  }
  function defaultResolver(keyword, values, mergedSchema, _schemas, options) {
    const onConflict = options.onConflict ?? "throw";
    if (values.length === 1 || onConflict === "first") {
      mergedSchema[keyword] = values[0];
      return;
    }
    let allValuesEqual = true;
    for (let i = 1;i < values.length; i++) {
      if (!deepEqual(values[i], values[0])) {
        allValuesEqual = false;
        break;
      }
    }
    if (allValuesEqual) {
      mergedSchema[keyword] = values[0];
      return;
    }
    if (onConflict === "throw") {
      throw new errors.ResolverNotFoundError(keyword, values);
    }
    if (onConflict === "skip") {
      return;
    }
    throw new errors.InvalidOnConflictOptionError(onConflict);
  }
  function mergeSchemas(schemas, options = {}) {
    if (options.defaultResolver === undefined) {
      options.defaultResolver = defaultResolver;
    }
    options.resolvers = { ...keywordsResolvers, ...options.resolvers };
    const mergedSchema = _mergeSchemas(schemas, options);
    return mergedSchema;
  }
  module.exports = { mergeSchemas, keywordsResolvers, defaultResolver, ...errors };
});

// node_modules/fast-json-stringify/lib/merge-schemas.js
var require_merge_schemas = __commonJS((exports, module) => {
  var { mergeSchemas: _mergeSchemas } = require_merge_json_schemas();
  function mergeSchemas(schemas) {
    return _mergeSchemas(schemas, { onConflict: "skip" });
  }
  module.exports = mergeSchemas;
});

// node_modules/fast-json-stringify/lib/standalone.js
var require_standalone = __commonJS((exports, module) => {
  function buildStandaloneCode(contextFunc, context, serializer, validator) {
    let ajvDependencyCode = "";
    if (context.validatorSchemasIds.size > 0) {
      ajvDependencyCode += `const Validator = require('fast-json-stringify/lib/validator')
`;
      ajvDependencyCode += `const validatorState = ${JSON.stringify(validator.getState())}
`;
      ajvDependencyCode += `const validator = Validator.restoreFromState(validatorState)
`;
    } else {
      ajvDependencyCode += `const validator = null
`;
    }
    const { schema, ...serializerState } = serializer.getState();
    return `
  'use strict'

  const Serializer = require('fast-json-stringify/lib/serializer')
  const serializerState = ${JSON.stringify(serializerState)}
  const serializer = Serializer.restoreFromState(serializerState)

  ${ajvDependencyCode}

  module.exports = ${contextFunc.toString()}(validator, serializer)`;
  }
  module.exports = buildStandaloneCode;
  module.exports.dependencies = {
    Serializer: require_serializer(),
    Validator: require_validator()
  };
});

// node_modules/fast-json-stringify/index.js
var require_fast_json_stringify = __commonJS((exports, module) => {
  var { RefResolver } = require_json_schema_ref_resolver();
  var Serializer = require_serializer();
  var Validator = require_validator();
  var Location = require_location();
  var validate = require_schema_validator();
  var mergeSchemas = require_merge_schemas();
  var SINGLE_TICK = /'/g;
  var largeArraySize = 20000;
  var largeArrayMechanism = "default";
  var serializerFns = `
const {
  asString,
  asNumber,
  asBoolean,
  asDateTime,
  asDate,
  asTime,
  asUnsafeString
} = serializer

const asInteger = serializer.asInteger.bind(serializer)

`;
  var validRoundingMethods = [
    "floor",
    "ceil",
    "round",
    "trunc"
  ];
  var validLargeArrayMechanisms = [
    "default",
    "json-stringify"
  ];
  var schemaIdCounter = 0;
  function isValidSchema(schema, name) {
    if (!validate(schema)) {
      if (name) {
        name = `"${name}" `;
      } else {
        name = "";
      }
      const first = validate.errors[0];
      const err = new Error(`${name}schema is invalid: data${first.instancePath} ${first.message}`);
      err.errors = isValidSchema.errors;
      throw err;
    }
  }
  function resolveRef(context, location2) {
    const ref = location2.schema.$ref;
    let hashIndex = ref.indexOf("#");
    if (hashIndex === -1) {
      hashIndex = ref.length;
    }
    const schemaId = ref.slice(0, hashIndex) || location2.schemaId;
    const jsonPointer = ref.slice(hashIndex) || "#";
    const schema = context.refResolver.getSchema(schemaId, jsonPointer);
    if (schema === null) {
      throw new Error(`Cannot find reference "${ref}"`);
    }
    const newLocation = new Location(schema, schemaId, jsonPointer);
    if (schema.$ref !== undefined) {
      return resolveRef(context, newLocation);
    }
    return newLocation;
  }
  function getMergedLocation(context, mergedSchemaId) {
    const mergedSchema = context.refResolver.getSchema(mergedSchemaId, "#");
    return new Location(mergedSchema, mergedSchemaId, "#");
  }
  function getSchemaId(schema, rootSchemaId) {
    if (schema.$id && schema.$id.charAt(0) !== "#") {
      return schema.$id;
    }
    return rootSchemaId;
  }
  function build(schema, options) {
    isValidSchema(schema);
    options = options || {};
    const context = {
      functions: [],
      functionsCounter: 0,
      functionsNamesBySchema: new Map,
      options,
      refResolver: new RefResolver,
      rootSchemaId: schema.$id || `__fjs_root_${schemaIdCounter++}`,
      validatorSchemasIds: new Set,
      mergedSchemasIds: new Map
    };
    const schemaId = getSchemaId(schema, context.rootSchemaId);
    if (!context.refResolver.hasSchema(schemaId)) {
      context.refResolver.addSchema(schema, context.rootSchemaId);
    }
    if (options.schema) {
      for (const key in options.schema) {
        const schema2 = options.schema[key];
        const schemaId2 = getSchemaId(schema2, key);
        if (!context.refResolver.hasSchema(schemaId2)) {
          isValidSchema(schema2, key);
          context.refResolver.addSchema(schema2, key);
        }
      }
    }
    if (options.rounding) {
      if (!validRoundingMethods.includes(options.rounding)) {
        throw new Error(`Unsupported integer rounding method ${options.rounding}`);
      }
    }
    if (options.largeArrayMechanism) {
      if (validLargeArrayMechanisms.includes(options.largeArrayMechanism)) {
        largeArrayMechanism = options.largeArrayMechanism;
      } else {
        throw new Error(`Unsupported large array mechanism ${options.largeArrayMechanism}`);
      }
    }
    if (options.largeArraySize) {
      if (typeof options.largeArraySize === "string" && Number.isFinite(Number.parseInt(options.largeArraySize, 10))) {
        largeArraySize = Number.parseInt(options.largeArraySize, 10);
      } else if (typeof options.largeArraySize === "number" && Number.isInteger(options.largeArraySize)) {
        largeArraySize = options.largeArraySize;
      } else if (typeof options.largeArraySize === "bigint") {
        largeArraySize = Number(options.largeArraySize);
      } else {
        throw new Error(`Unsupported large array size. Expected integer-like, got ${typeof options.largeArraySize} with value ${options.largeArraySize}`);
      }
    }
    const location2 = new Location(schema, context.rootSchemaId);
    const code = buildValue(context, location2, "input");
    let contextFunctionCode = `
    ${serializerFns}
    const JSON_STR_BEGIN_OBJECT = '{'
    const JSON_STR_END_OBJECT = '}'
    const JSON_STR_BEGIN_ARRAY = '['
    const JSON_STR_END_ARRAY = ']'
    const JSON_STR_COMMA = ','
    const JSON_STR_COLONS = ':'
    const JSON_STR_QUOTE = '"'
    const JSON_STR_EMPTY_OBJECT = JSON_STR_BEGIN_OBJECT + JSON_STR_END_OBJECT
    const JSON_STR_EMPTY_ARRAY = JSON_STR_BEGIN_ARRAY + JSON_STR_END_ARRAY
    const JSON_STR_EMPTY_STRING = JSON_STR_QUOTE + JSON_STR_QUOTE
    const JSON_STR_NULL = 'null'
  `;
    if (code === "json += anonymous0(input)") {
      contextFunctionCode += `
    ${context.functions.join(`
`)}
    const main = anonymous0
    return main
    `;
    } else {
      contextFunctionCode += `
    function main (input) {
      let json = ''
      ${code}
      return json
    }
    ${context.functions.join(`
`)}
    return main
    `;
    }
    const serializer = new Serializer(options);
    const validator = new Validator(options.ajv);
    for (const schemaId2 of context.validatorSchemasIds) {
      const schema2 = context.refResolver.getSchema(schemaId2);
      validator.addSchema(schema2, schemaId2);
      const dependencies = context.refResolver.getSchemaDependencies(schemaId2);
      for (const [schemaId3, schema3] of Object.entries(dependencies)) {
        validator.addSchema(schema3, schemaId3);
      }
    }
    if (options.debugMode) {
      options.mode = "debug";
    }
    if (options.mode === "debug") {
      return {
        validator,
        serializer,
        code: `validator
serializer
${contextFunctionCode}`,
        ajv: validator.ajv
      };
    }
    const contextFunc = new Function("validator", "serializer", contextFunctionCode);
    if (options.mode === "standalone") {
      const buildStandaloneCode = require_standalone();
      return buildStandaloneCode(contextFunc, context, serializer, validator);
    }
    return contextFunc(validator, serializer);
  }
  var objectKeywords = [
    "properties",
    "required",
    "additionalProperties",
    "patternProperties",
    "maxProperties",
    "minProperties",
    "dependencies"
  ];
  var arrayKeywords = [
    "items",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "contains"
  ];
  var stringKeywords = [
    "maxLength",
    "minLength",
    "pattern"
  ];
  var numberKeywords = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum"
  ];
  function inferTypeByKeyword(schema) {
    for (const keyword of objectKeywords) {
      if (keyword in schema)
        return "object";
    }
    for (const keyword of arrayKeywords) {
      if (keyword in schema)
        return "array";
    }
    for (const keyword of stringKeywords) {
      if (keyword in schema)
        return "string";
    }
    for (const keyword of numberKeywords) {
      if (keyword in schema)
        return "number";
    }
    return schema.type;
  }
  function buildExtraObjectPropertiesSerializer(context, location2, addComma) {
    const schema = location2.schema;
    const propertiesKeys = Object.keys(schema.properties || {});
    let code = `
    const propertiesKeys = ${JSON.stringify(propertiesKeys)}
    for (const [key, value] of Object.entries(obj)) {
      if (
        propertiesKeys.includes(key) ||
        value === undefined ||
        typeof value === 'function' ||
        typeof value === 'symbol'
      ) continue
  `;
    const patternPropertiesLocation = location2.getPropertyLocation("patternProperties");
    const patternPropertiesSchema = patternPropertiesLocation.schema;
    if (patternPropertiesSchema !== undefined) {
      for (const propertyKey in patternPropertiesSchema) {
        const propertyLocation = patternPropertiesLocation.getPropertyLocation(propertyKey);
        code += `
        if (/${propertyKey.replace(/\\*\//g, "\\/")}/.test(key)) {
          ${addComma}
          json += asString(key) + JSON_STR_COLONS
          ${buildValue(context, propertyLocation, "value")}
          continue
        }
      `;
      }
    }
    const additionalPropertiesLocation = location2.getPropertyLocation("additionalProperties");
    const additionalPropertiesSchema = additionalPropertiesLocation.schema;
    if (additionalPropertiesSchema !== undefined) {
      if (additionalPropertiesSchema === true) {
        code += `
        ${addComma}
        json += asString(key) + JSON_STR_COLONS + JSON.stringify(value)
      `;
      } else {
        const propertyLocation = location2.getPropertyLocation("additionalProperties");
        code += `
        ${addComma}
        json += asString(key) + JSON_STR_COLONS
        ${buildValue(context, propertyLocation, "value")}
      `;
      }
    }
    code += `
    }
  `;
    return code;
  }
  function buildInnerObject(context, location2) {
    const schema = location2.schema;
    const propertiesLocation = location2.getPropertyLocation("properties");
    const requiredProperties = schema.required || [];
    const propertiesKeys = Object.keys(schema.properties || {}).sort((key1, key2) => {
      const required1 = requiredProperties.includes(key1);
      const required2 = requiredProperties.includes(key2);
      return required1 === required2 ? 0 : required1 ? -1 : 1;
    });
    const hasRequiredProperties = requiredProperties.includes(propertiesKeys[0]);
    let code = `let value
`;
    for (const key of requiredProperties) {
      if (!propertiesKeys.includes(key)) {
        const sanitizedKey = JSON.stringify(key);
        code += `if (obj[${sanitizedKey}] === undefined) throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
`;
      }
    }
    code += `let json = JSON_STR_BEGIN_OBJECT
`;
    let addComma = "";
    if (!hasRequiredProperties) {
      code += `let addComma = false
`;
      addComma = "!addComma && (addComma = true) || (json += JSON_STR_COMMA)";
    }
    for (const key of propertiesKeys) {
      let propertyLocation = propertiesLocation.getPropertyLocation(key);
      if (propertyLocation.schema.$ref) {
        propertyLocation = resolveRef(context, propertyLocation);
      }
      const sanitizedKey = JSON.stringify(key);
      const defaultValue = propertyLocation.schema.default;
      const isRequired = requiredProperties.includes(key);
      code += `
      value = obj[${sanitizedKey}]
      if (value !== undefined) {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":")}
        ${buildValue(context, propertyLocation, "value")}
      }`;
      if (defaultValue !== undefined) {
        code += ` else {
        ${addComma}
        json += ${JSON.stringify(sanitizedKey + ":" + JSON.stringify(defaultValue))}
      }
      `;
      } else if (isRequired) {
        code += ` else {
        throw new Error('${sanitizedKey.replace(/'/g, "\\'")} is required!')
      }
      `;
      } else {
        code += `
`;
      }
      if (hasRequiredProperties) {
        addComma = "json += ','";
      }
    }
    if (schema.patternProperties || schema.additionalProperties) {
      code += buildExtraObjectPropertiesSerializer(context, location2, addComma);
    }
    code += `
    return json + JSON_STR_END_OBJECT
  `;
    return code;
  }
  function mergeLocations(context, mergedSchemaId, mergedLocations) {
    for (let i = 0;i < mergedLocations.length; i++) {
      const location2 = mergedLocations[i];
      const schema = location2.schema;
      if (schema.$ref) {
        mergedLocations[i] = resolveRef(context, location2);
      }
    }
    const mergedSchemas = [];
    for (const location2 of mergedLocations) {
      const schema = cloneOriginSchema(context, location2.schema, location2.schemaId);
      delete schema.$id;
      mergedSchemas.push(schema);
    }
    const mergedSchema = mergeSchemas(mergedSchemas);
    const mergedLocation = new Location(mergedSchema, mergedSchemaId);
    context.refResolver.addSchema(mergedSchema, mergedSchemaId);
    return mergedLocation;
  }
  function cloneOriginSchema(context, schema, schemaId) {
    const clonedSchema = Array.isArray(schema) ? [] : {};
    if (schema.$id !== undefined && schema.$id.charAt(0) !== "#") {
      schemaId = schema.$id;
    }
    const mergedSchemaRef = context.mergedSchemasIds.get(schema);
    if (mergedSchemaRef) {
      context.mergedSchemasIds.set(clonedSchema, mergedSchemaRef);
    }
    for (const key in schema) {
      let value = schema[key];
      if (key === "$ref" && typeof value === "string" && value.charAt(0) === "#") {
        value = schemaId + value;
      }
      if (typeof value === "object" && value !== null) {
        value = cloneOriginSchema(context, value, schemaId);
      }
      clonedSchema[key] = value;
    }
    return clonedSchema;
  }
  function toJSON(variableName) {
    return `(${variableName} && typeof ${variableName}.toJSON === 'function')
    ? ${variableName}.toJSON()
    : ${variableName}
  `;
  }
  function buildObject(context, location2) {
    const schema = location2.schema;
    if (context.functionsNamesBySchema.has(schema)) {
      return context.functionsNamesBySchema.get(schema);
    }
    const functionName = generateFuncName(context);
    context.functionsNamesBySchema.set(schema, functionName);
    let schemaRef = location2.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    let functionCode = `
  `;
    const nullable = schema.nullable === true;
    functionCode += `
    // ${schemaRef}
    function ${functionName} (input) {
      const obj = ${toJSON("input")}
      ${!nullable ? "if (obj === null) return JSON_STR_EMPTY_OBJECT" : ""}

      ${buildInnerObject(context, location2)}
    }
  `;
    context.functions.push(functionCode);
    return functionName;
  }
  function buildArray(context, location2) {
    const schema = location2.schema;
    let itemsLocation = location2.getPropertyLocation("items");
    itemsLocation.schema = itemsLocation.schema || {};
    if (itemsLocation.schema.$ref) {
      itemsLocation = resolveRef(context, itemsLocation);
    }
    const itemsSchema = itemsLocation.schema;
    if (context.functionsNamesBySchema.has(schema)) {
      return context.functionsNamesBySchema.get(schema);
    }
    const functionName = generateFuncName(context);
    context.functionsNamesBySchema.set(schema, functionName);
    let schemaRef = location2.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    let functionCode = `
    function ${functionName} (obj) {
      // ${schemaRef}
  `;
    const nullable = schema.nullable === true;
    functionCode += `
    ${!nullable ? "if (obj === null) return JSON_STR_EMPTY_ARRAY" : ""}
    if (!Array.isArray(obj)) {
      throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
    }
    const arrayLength = obj.length
  `;
    if (!schema.additionalItems && Array.isArray(itemsSchema)) {
      functionCode += `
      if (arrayLength > ${itemsSchema.length}) {
        throw new Error(\`Item at ${itemsSchema.length} does not match schema definition.\`)
      }
    `;
    }
    if (largeArrayMechanism === "json-stringify") {
      functionCode += `if (arrayLength >= ${largeArraySize}) return JSON.stringify(obj)
`;
    }
    functionCode += `
    const arrayEnd = arrayLength - 1
    let value
    let json = ''
  `;
    if (Array.isArray(itemsSchema)) {
      for (let i = 0;i < itemsSchema.length; i++) {
        const item = itemsSchema[i];
        functionCode += `value = obj[${i}]`;
        const tmpRes = buildValue(context, itemsLocation.getPropertyLocation(i), "value");
        functionCode += `
        if (${i} < arrayLength) {
          if (${buildArrayTypeCondition(item.type, "value")}) {
            ${tmpRes}
            if (${i} < arrayEnd) {
              json += JSON_STR_COMMA
            }
          } else {
            throw new Error(\`Item at ${i} does not match schema definition.\`)
          }
        }
        `;
      }
      if (schema.additionalItems) {
        functionCode += `
        for (let i = ${itemsSchema.length}; i < arrayLength; i++) {
          value = obj[i]
          json += JSON.stringify(value)
          if (i < arrayEnd) {
            json += JSON_STR_COMMA
          }
        }`;
      }
    } else {
      const code = buildValue(context, itemsLocation, "value");
      functionCode += `
      for (let i = 0; i < arrayLength; i++) {
        value = obj[i]
        ${code}
        if (i < arrayEnd) {
          json += JSON_STR_COMMA
        }
      }`;
    }
    functionCode += `
    return JSON_STR_BEGIN_ARRAY + json + JSON_STR_END_ARRAY
  }`;
    context.functions.push(functionCode);
    return functionName;
  }
  function buildArrayTypeCondition(type, accessor) {
    let condition;
    switch (type) {
      case "null":
        condition = "value === null";
        break;
      case "string":
        condition = `typeof value === 'string' ||
      value === null ||
      value instanceof Date ||
      value instanceof RegExp ||
      (
        typeof value === "object" &&
        typeof value.toString === "function" &&
        value.toString !== Object.prototype.toString
      )`;
        break;
      case "integer":
        condition = "Number.isInteger(value)";
        break;
      case "number":
        condition = "Number.isFinite(value)";
        break;
      case "boolean":
        condition = "typeof value === 'boolean'";
        break;
      case "object":
        condition = "value && typeof value === 'object' && value.constructor === Object";
        break;
      case "array":
        condition = "Array.isArray(value)";
        break;
      default:
        if (Array.isArray(type)) {
          const conditions = type.map((subType) => {
            return buildArrayTypeCondition(subType, accessor);
          });
          condition = `(${conditions.join(" || ")})`;
        }
    }
    return condition;
  }
  function generateFuncName(context) {
    return "anonymous" + context.functionsCounter++;
  }
  function buildMultiTypeSerializer(context, location2, input) {
    const schema = location2.schema;
    const types = schema.type.sort((t1) => t1 === "null" ? -1 : 1);
    let code = "";
    types.forEach((type, index) => {
      location2.schema = { ...location2.schema, type };
      const nestedResult = buildSingleTypeSerializer(context, location2, input);
      const statement = index === 0 ? "if" : "else if";
      switch (type) {
        case "null":
          code += `
          ${statement} (${input} === null)
            ${nestedResult}
          `;
          break;
        case "string": {
          code += `
          ${statement}(
            typeof ${input} === "string" ||
            ${input} === null ||
            ${input} instanceof Date ||
            ${input} instanceof RegExp ||
            (
              typeof ${input} === "object" &&
              typeof ${input}.toString === "function" &&
              ${input}.toString !== Object.prototype.toString
            )
          )
            ${nestedResult}
        `;
          break;
        }
        case "array": {
          code += `
          ${statement}(Array.isArray(${input}))
            ${nestedResult}
        `;
          break;
        }
        case "integer": {
          code += `
          ${statement}(Number.isInteger(${input}) || ${input} === null)
            ${nestedResult}
        `;
          break;
        }
        default: {
          code += `
          ${statement}(typeof ${input} === "${type}" || ${input} === null)
            ${nestedResult}
        `;
          break;
        }
      }
    });
    let schemaRef = location2.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
    return code;
  }
  function buildSingleTypeSerializer(context, location2, input) {
    const schema = location2.schema;
    switch (schema.type) {
      case "null":
        return "json += JSON_STR_NULL";
      case "string": {
        if (schema.format === "date-time") {
          return `json += asDateTime(${input})`;
        } else if (schema.format === "date") {
          return `json += asDate(${input})`;
        } else if (schema.format === "time") {
          return `json += asTime(${input})`;
        } else if (schema.format === "unsafe") {
          return `json += asUnsafeString(${input})`;
        } else {
          return `
        if (typeof ${input} !== 'string') {
          if (${input} === null) {
            json += JSON_STR_EMPTY_STRING
          } else if (${input} instanceof Date) {
            json += JSON_STR_QUOTE + ${input}.toISOString() + JSON_STR_QUOTE
          } else if (${input} instanceof RegExp) {
            json += asString(${input}.source)
          } else {
            json += asString(${input}.toString())
          }
        } else {
          json += asString(${input})
        }
        `;
        }
      }
      case "integer":
        return `json += asInteger(${input})`;
      case "number":
        return `json += asNumber(${input})`;
      case "boolean":
        return `json += asBoolean(${input})`;
      case "object": {
        const funcName = buildObject(context, location2);
        return `json += ${funcName}(${input})`;
      }
      case "array": {
        const funcName = buildArray(context, location2);
        return `json += ${funcName}(${input})`;
      }
      case undefined:
        return `json += JSON.stringify(${input})`;
      default:
        throw new Error(`${schema.type} unsupported`);
    }
  }
  function buildConstSerializer(location2, input) {
    const schema = location2.schema;
    const type = schema.type;
    const hasNullType = Array.isArray(type) && type.includes("null");
    let code = "";
    if (hasNullType) {
      code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
    }
    code += `json += '${JSON.stringify(schema.const).replace(SINGLE_TICK, "\\'")}'`;
    if (hasNullType) {
      code += `
      }
    `;
    }
    return code;
  }
  function buildAllOf(context, location2, input) {
    const schema = location2.schema;
    let mergedSchemaId = context.mergedSchemasIds.get(schema);
    if (mergedSchemaId) {
      const mergedLocation2 = getMergedLocation(context, mergedSchemaId);
      return buildValue(context, mergedLocation2, input);
    }
    mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
    context.mergedSchemasIds.set(schema, mergedSchemaId);
    const { allOf, ...schemaWithoutAllOf } = location2.schema;
    const locations = [
      new Location(schemaWithoutAllOf, location2.schemaId, location2.jsonPointer)
    ];
    const allOfsLocation = location2.getPropertyLocation("allOf");
    for (let i = 0;i < allOf.length; i++) {
      locations.push(allOfsLocation.getPropertyLocation(i));
    }
    const mergedLocation = mergeLocations(context, mergedSchemaId, locations);
    return buildValue(context, mergedLocation, input);
  }
  function buildOneOf(context, location2, input) {
    context.validatorSchemasIds.add(location2.schemaId);
    const schema = location2.schema;
    const type = schema.anyOf ? "anyOf" : "oneOf";
    const { [type]: oneOfs, ...schemaWithoutAnyOf } = location2.schema;
    const locationWithoutOneOf = new Location(schemaWithoutAnyOf, location2.schemaId, location2.jsonPointer);
    const oneOfsLocation = location2.getPropertyLocation(type);
    let code = "";
    for (let index = 0;index < oneOfs.length; index++) {
      const optionLocation = oneOfsLocation.getPropertyLocation(index);
      const optionSchema = optionLocation.schema;
      let mergedSchemaId = context.mergedSchemasIds.get(optionSchema);
      let mergedLocation = null;
      if (mergedSchemaId) {
        mergedLocation = getMergedLocation(context, mergedSchemaId);
      } else {
        mergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
        context.mergedSchemasIds.set(optionSchema, mergedSchemaId);
        mergedLocation = mergeLocations(context, mergedSchemaId, [
          locationWithoutOneOf,
          optionLocation
        ]);
      }
      const nestedResult = buildValue(context, mergedLocation, input);
      const schemaRef2 = optionLocation.getSchemaRef();
      code += `
      ${index === 0 ? "if" : "else if"}(validator.validate("${schemaRef2}", ${input}))
        ${nestedResult}
    `;
    }
    let schemaRef = location2.getSchemaRef();
    if (schemaRef.startsWith(context.rootSchemaId)) {
      schemaRef = schemaRef.replace(context.rootSchemaId, "");
    }
    code += `
    else throw new TypeError(\`The value of '${schemaRef}' does not match schema definition.\`)
  `;
    return code;
  }
  function buildIfThenElse(context, location2, input) {
    context.validatorSchemasIds.add(location2.schemaId);
    const {
      if: ifSchema,
      then: thenSchema,
      else: elseSchema,
      ...schemaWithoutIfThenElse
    } = location2.schema;
    const rootLocation = new Location(schemaWithoutIfThenElse, location2.schemaId, location2.jsonPointer);
    const ifLocation = location2.getPropertyLocation("if");
    const ifSchemaRef = ifLocation.getSchemaRef();
    const thenLocation = location2.getPropertyLocation("then");
    let thenMergedSchemaId = context.mergedSchemasIds.get(thenSchema);
    let thenMergedLocation = null;
    if (thenMergedSchemaId) {
      thenMergedLocation = getMergedLocation(context, thenMergedSchemaId);
    } else {
      thenMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context.mergedSchemasIds.set(thenSchema, thenMergedSchemaId);
      thenMergedLocation = mergeLocations(context, thenMergedSchemaId, [
        rootLocation,
        thenLocation
      ]);
    }
    if (!elseSchema) {
      return `
      if (validator.validate("${ifSchemaRef}", ${input})) {
        ${buildValue(context, thenMergedLocation, input)}
      } else {
        ${buildValue(context, rootLocation, input)}
      }
    `;
    }
    const elseLocation = location2.getPropertyLocation("else");
    let elseMergedSchemaId = context.mergedSchemasIds.get(elseSchema);
    let elseMergedLocation = null;
    if (elseMergedSchemaId) {
      elseMergedLocation = getMergedLocation(context, elseMergedSchemaId);
    } else {
      elseMergedSchemaId = `__fjs_merged_${schemaIdCounter++}`;
      context.mergedSchemasIds.set(elseSchema, elseMergedSchemaId);
      elseMergedLocation = mergeLocations(context, elseMergedSchemaId, [
        rootLocation,
        elseLocation
      ]);
    }
    return `
    if (validator.validate("${ifSchemaRef}", ${input})) {
      ${buildValue(context, thenMergedLocation, input)}
    } else {
      ${buildValue(context, elseMergedLocation, input)}
    }
  `;
  }
  function buildValue(context, location2, input) {
    let schema = location2.schema;
    if (typeof schema === "boolean") {
      return `json += JSON.stringify(${input})`;
    }
    if (schema.$ref) {
      location2 = resolveRef(context, location2);
      schema = location2.schema;
    }
    if (schema.allOf) {
      return buildAllOf(context, location2, input);
    }
    if (schema.anyOf || schema.oneOf) {
      return buildOneOf(context, location2, input);
    }
    if (schema.if && schema.then) {
      return buildIfThenElse(context, location2, input);
    }
    if (schema.type === undefined) {
      const inferredType = inferTypeByKeyword(schema);
      if (inferredType) {
        schema.type = inferredType;
      }
    }
    let code = "";
    const type = schema.type;
    const nullable = schema.nullable === true;
    if (nullable) {
      code += `
      if (${input} === null) {
        json += JSON_STR_NULL
      } else {
    `;
    }
    if (schema.const !== undefined) {
      code += buildConstSerializer(location2, input);
    } else if (Array.isArray(type)) {
      code += buildMultiTypeSerializer(context, location2, input);
    } else {
      code += buildSingleTypeSerializer(context, location2, input);
    }
    if (nullable) {
      code += `
      }
    `;
    }
    return code;
  }
  module.exports = build;
  module.exports.default = build;
  module.exports.build = build;
  module.exports.validLargeArrayMechanisms = validLargeArrayMechanisms;
  module.exports.restore = function({ code, validator, serializer }) {
    return Function.apply(null, ["validator", "serializer", code]).apply(null, [validator, serializer]);
  };
});

// node_modules/@fastify/fast-json-stringify-compiler/standalone.js
var require_standalone2 = __commonJS((exports, module) => {
  var fastJsonStringify = require_fast_json_stringify();
  function SerializerSelector() {
    return function buildSerializerFactory(externalSchemas, serializerOpts) {
      const fjsOpts = Object.assign({}, serializerOpts, { schema: externalSchemas });
      return responseSchemaCompiler.bind(null, fjsOpts);
    };
  }
  function responseSchemaCompiler(fjsOpts, { schema }) {
    if (fjsOpts.schema && schema.$id && fjsOpts.schema[schema.$id]) {
      fjsOpts.schema = { ...fjsOpts.schema };
      delete fjsOpts.schema[schema.$id];
    }
    return fastJsonStringify(schema, fjsOpts);
  }
  function StandaloneSerializer(options = { readMode: true }) {
    if (options.readMode === true && typeof options.restoreFunction !== "function") {
      throw new Error("You must provide a function for the restoreFunction-option when readMode ON");
    }
    if (options.readMode !== true && typeof options.storeFunction !== "function") {
      throw new Error("You must provide a function for the storeFunction-option when readMode OFF");
    }
    if (options.readMode === true) {
      return function wrapper() {
        return function(opts) {
          return options.restoreFunction(opts);
        };
      };
    }
    const factory = SerializerSelector();
    return function wrapper(externalSchemas, serializerOpts = {}) {
      serializerOpts.mode = "standalone";
      const compiler = factory(externalSchemas, serializerOpts);
      return function(opts) {
        const serializeFuncCode = compiler(opts);
        options.storeFunction(opts, serializeFuncCode);
        return new Function(serializeFuncCode);
      };
    };
  }
  exports.SerializerSelector = SerializerSelector;
  exports.StandaloneSerializer = StandaloneSerializer;
  exports.default = StandaloneSerializer;
});

// node_modules/@fastify/fast-json-stringify-compiler/index.js
var require_fast_json_stringify_compiler = __commonJS((exports, module) => {
  var { SerializerSelector, StandaloneSerializer } = require_standalone2();
  module.exports = SerializerSelector;
  module.exports.default = SerializerSelector;
  module.exports.SerializerSelector = SerializerSelector;
  module.exports.StandaloneSerializer = StandaloneSerializer;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/codegen/code.js
var require_code5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = undefined;

  class _CodeOrName {
  }
  exports._CodeOrName = _CodeOrName;
  exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;

  class Name extends _CodeOrName {
    constructor(s2) {
      super();
      if (!exports.IDENTIFIER.test(s2))
        throw new Error("CodeGen: name must be a valid identifier");
      this.str = s2;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  exports.Name = Name;

  class _Code extends _CodeOrName {
    constructor(code) {
      super();
      this._items = typeof code === "string" ? [code] : code;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1)
        return false;
      const item = this._items[0];
      return item === "" || item === '""';
    }
    get str() {
      var _a;
      return (_a = this._str) !== null && _a !== undefined ? _a : this._str = this._items.reduce((s2, c2) => `${s2}${c2}`, "");
    }
    get names() {
      var _a;
      return (_a = this._names) !== null && _a !== undefined ? _a : this._names = this._items.reduce((names, c2) => {
        if (c2 instanceof Name)
          names[c2.str] = (names[c2.str] || 0) + 1;
        return names;
      }, {});
    }
  }
  exports._Code = _Code;
  exports.nil = new _Code("");
  function _3(strs, ...args) {
    const code = [strs[0]];
    let i = 0;
    while (i < args.length) {
      addCodeArg(code, args[i]);
      code.push(strs[++i]);
    }
    return new _Code(code);
  }
  exports._ = _3;
  var plus = new _Code("+");
  function str(strs, ...args) {
    const expr = [safeStringify(strs[0])];
    let i = 0;
    while (i < args.length) {
      expr.push(plus);
      addCodeArg(expr, args[i]);
      expr.push(plus, safeStringify(strs[++i]));
    }
    optimize(expr);
    return new _Code(expr);
  }
  exports.str = str;
  function addCodeArg(code, arg) {
    if (arg instanceof _Code)
      code.push(...arg._items);
    else if (arg instanceof Name)
      code.push(arg);
    else
      code.push(interpolate(arg));
  }
  exports.addCodeArg = addCodeArg;
  function optimize(expr) {
    let i = 1;
    while (i < expr.length - 1) {
      if (expr[i] === plus) {
        const res = mergeExprItems(expr[i - 1], expr[i + 1]);
        if (res !== undefined) {
          expr.splice(i - 1, 3, res);
          continue;
        }
        expr[i++] = "+";
      }
      i++;
    }
  }
  function mergeExprItems(a3, b5) {
    if (b5 === '""')
      return a3;
    if (a3 === '""')
      return b5;
    if (typeof a3 == "string") {
      if (b5 instanceof Name || a3[a3.length - 1] !== '"')
        return;
      if (typeof b5 != "string")
        return `${a3.slice(0, -1)}${b5}"`;
      if (b5[0] === '"')
        return a3.slice(0, -1) + b5.slice(1);
      return;
    }
    if (typeof b5 == "string" && b5[0] === '"' && !(a3 instanceof Name))
      return `"${a3}${b5.slice(1)}`;
    return;
  }
  function strConcat(c1, c2) {
    return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
  }
  exports.strConcat = strConcat;
  function interpolate(x3) {
    return typeof x3 == "number" || typeof x3 == "boolean" || x3 === null ? x3 : safeStringify(Array.isArray(x3) ? x3.join(",") : x3);
  }
  function stringify(x3) {
    return new _Code(safeStringify(x3));
  }
  exports.stringify = stringify;
  function safeStringify(x3) {
    return JSON.stringify(x3).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  exports.safeStringify = safeStringify;
  function getProperty(key) {
    return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _3`[${key}]`;
  }
  exports.getProperty = getProperty;
  function getEsmExportName(key) {
    if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
      return new _Code(`${key}`);
    }
    throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
  }
  exports.getEsmExportName = getEsmExportName;
  function regexpCode(rx) {
    return new _Code(rx.toString());
  }
  exports.regexpCode = regexpCode;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = undefined;
  var code_1 = require_code5();

  class ValueError extends Error {
    constructor(name) {
      super(`CodeGen: "code" for ${name} not defined`);
      this.value = name.value;
    }
  }
  var UsedValueState;
  (function(UsedValueState2) {
    UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
    UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
  })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
  exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var")
  };

  class Scope {
    constructor({ prefixes, parent } = {}) {
      this._names = {};
      this._prefixes = prefixes;
      this._parent = parent;
    }
    toName(nameOrPrefix) {
      return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    }
    name(prefix) {
      return new code_1.Name(this._newName(prefix));
    }
    _newName(prefix) {
      const ng = this._names[prefix] || this._nameGroup(prefix);
      return `${prefix}${ng.index++}`;
    }
    _nameGroup(prefix) {
      var _a, _b;
      if (((_b = (_a = this._parent) === null || _a === undefined ? undefined : _a._prefixes) === null || _b === undefined ? undefined : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
        throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
      }
      return this._names[prefix] = { prefix, index: 0 };
    }
  }
  exports.Scope = Scope;

  class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
      super(nameStr);
      this.prefix = prefix;
    }
    setValue(value, { property, itemIndex }) {
      this.value = value;
      this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
    }
  }
  exports.ValueScopeName = ValueScopeName;
  var line = (0, code_1._)`\n`;

  class ValueScope extends Scope {
    constructor(opts) {
      super(opts);
      this._values = {};
      this._scope = opts.scope;
      this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
    }
    get() {
      return this._scope;
    }
    name(prefix) {
      return new ValueScopeName(prefix, this._newName(prefix));
    }
    value(nameOrPrefix, value) {
      var _a;
      if (value.ref === undefined)
        throw new Error("CodeGen: ref must be passed in value");
      const name = this.toName(nameOrPrefix);
      const { prefix } = name;
      const valueKey = (_a = value.key) !== null && _a !== undefined ? _a : value.ref;
      let vs = this._values[prefix];
      if (vs) {
        const _name = vs.get(valueKey);
        if (_name)
          return _name;
      } else {
        vs = this._values[prefix] = new Map;
      }
      vs.set(valueKey, name);
      const s2 = this._scope[prefix] || (this._scope[prefix] = []);
      const itemIndex = s2.length;
      s2[itemIndex] = value.ref;
      name.setValue(value, { property: prefix, itemIndex });
      return name;
    }
    getValue(prefix, keyOrRef) {
      const vs = this._values[prefix];
      if (!vs)
        return;
      return vs.get(keyOrRef);
    }
    scopeRefs(scopeName, values = this._values) {
      return this._reduceValues(values, (name) => {
        if (name.scopePath === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return (0, code_1._)`${scopeName}${name.scopePath}`;
      });
    }
    scopeCode(values = this._values, usedValues, getCode) {
      return this._reduceValues(values, (name) => {
        if (name.value === undefined)
          throw new Error(`CodeGen: name "${name}" has no value`);
        return name.value.code;
      }, usedValues, getCode);
    }
    _reduceValues(values, valueCode, usedValues = {}, getCode) {
      let code = code_1.nil;
      for (const prefix in values) {
        const vs = values[prefix];
        if (!vs)
          continue;
        const nameSet = usedValues[prefix] = usedValues[prefix] || new Map;
        vs.forEach((name) => {
          if (nameSet.has(name))
            return;
          nameSet.set(name, UsedValueState.Started);
          let c2 = valueCode(name);
          if (c2) {
            const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
            code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
          } else if (c2 = getCode === null || getCode === undefined ? undefined : getCode(name)) {
            code = (0, code_1._)`${code}${c2}${this.opts._n}`;
          } else {
            throw new ValueError(name);
          }
          nameSet.set(name, UsedValueState.Completed);
        });
      }
      return code;
    }
  }
  exports.ValueScope = ValueScope;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = undefined;
  var code_1 = require_code5();
  var scope_1 = require_scope3();
  var code_2 = require_code5();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return code_2._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return code_2.str;
  } });
  Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
    return code_2.strConcat;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return code_2.nil;
  } });
  Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
    return code_2.getProperty;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return code_2.stringify;
  } });
  Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
    return code_2.regexpCode;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return code_2.Name;
  } });
  var scope_2 = require_scope3();
  Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
    return scope_2.Scope;
  } });
  Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
    return scope_2.ValueScope;
  } });
  Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
    return scope_2.ValueScopeName;
  } });
  Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
    return scope_2.varKinds;
  } });
  exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+")
  };

  class Node {
    optimizeNodes() {
      return this;
    }
    optimizeNames(_names, _constants) {
      return this;
    }
  }

  class Def extends Node {
    constructor(varKind, name, rhs) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.rhs = rhs;
    }
    render({ es5, _n: _n2 }) {
      const varKind = es5 ? scope_1.varKinds.var : this.varKind;
      const rhs = this.rhs === undefined ? "" : ` = ${this.rhs}`;
      return `${varKind} ${this.name}${rhs};` + _n2;
    }
    optimizeNames(names, constants) {
      if (!names[this.name.str])
        return;
      if (this.rhs)
        this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
    }
  }

  class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
      super();
      this.lhs = lhs;
      this.rhs = rhs;
      this.sideEffects = sideEffects;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} = ${this.rhs};` + _n2;
    }
    optimizeNames(names, constants) {
      if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
        return;
      this.rhs = optimizeExpr(this.rhs, names, constants);
      return this;
    }
    get names() {
      const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
      return addExprNames(names, this.rhs);
    }
  }

  class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
      super(lhs, rhs, sideEffects);
      this.op = op;
    }
    render({ _n: _n2 }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + _n2;
    }
  }

  class Label extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      return `${this.label}:` + _n2;
    }
  }

  class Break extends Node {
    constructor(label) {
      super();
      this.label = label;
      this.names = {};
    }
    render({ _n: _n2 }) {
      const label = this.label ? ` ${this.label}` : "";
      return `break${label};` + _n2;
    }
  }

  class Throw extends Node {
    constructor(error) {
      super();
      this.error = error;
    }
    render({ _n: _n2 }) {
      return `throw ${this.error};` + _n2;
    }
    get names() {
      return this.error.names;
    }
  }

  class AnyCode extends Node {
    constructor(code) {
      super();
      this.code = code;
    }
    render({ _n: _n2 }) {
      return `${this.code};` + _n2;
    }
    optimizeNodes() {
      return `${this.code}` ? this : undefined;
    }
    optimizeNames(names, constants) {
      this.code = optimizeExpr(this.code, names, constants);
      return this;
    }
    get names() {
      return this.code instanceof code_1._CodeOrName ? this.code.names : {};
    }
  }

  class ParentNode extends Node {
    constructor(nodes = []) {
      super();
      this.nodes = nodes;
    }
    render(opts) {
      return this.nodes.reduce((code, n) => code + n.render(opts), "");
    }
    optimizeNodes() {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i].optimizeNodes();
        if (Array.isArray(n))
          nodes.splice(i, 1, ...n);
        else if (n)
          nodes[i] = n;
        else
          nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    optimizeNames(names, constants) {
      const { nodes } = this;
      let i = nodes.length;
      while (i--) {
        const n = nodes[i];
        if (n.optimizeNames(names, constants))
          continue;
        subtractNames(names, n.names);
        nodes.splice(i, 1);
      }
      return nodes.length > 0 ? this : undefined;
    }
    get names() {
      return this.nodes.reduce((names, n) => addNames(names, n.names), {});
    }
  }

  class BlockNode extends ParentNode {
    render(opts) {
      return "{" + opts._n + super.render(opts) + "}" + opts._n;
    }
  }

  class Root extends ParentNode {
  }

  class Else extends BlockNode {
  }
  Else.kind = "else";

  class If extends BlockNode {
    constructor(condition, nodes) {
      super(nodes);
      this.condition = condition;
    }
    render(opts) {
      let code = `if(${this.condition})` + super.render(opts);
      if (this.else)
        code += "else " + this.else.render(opts);
      return code;
    }
    optimizeNodes() {
      super.optimizeNodes();
      const cond = this.condition;
      if (cond === true)
        return this.nodes;
      let e = this.else;
      if (e) {
        const ns = e.optimizeNodes();
        e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
      }
      if (e) {
        if (cond === false)
          return e instanceof If ? e : e.nodes;
        if (this.nodes.length)
          return this;
        return new If(not(cond), e instanceof If ? [e] : e.nodes);
      }
      if (cond === false || !this.nodes.length)
        return;
      return this;
    }
    optimizeNames(names, constants) {
      var _a;
      this.else = (_a = this.else) === null || _a === undefined ? undefined : _a.optimizeNames(names, constants);
      if (!(super.optimizeNames(names, constants) || this.else))
        return;
      this.condition = optimizeExpr(this.condition, names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      addExprNames(names, this.condition);
      if (this.else)
        addNames(names, this.else.names);
      return names;
    }
  }
  If.kind = "if";

  class For extends BlockNode {
  }
  For.kind = "for";

  class ForLoop extends For {
    constructor(iteration) {
      super();
      this.iteration = iteration;
    }
    render(opts) {
      return `for(${this.iteration})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iteration = optimizeExpr(this.iteration, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iteration.names);
    }
  }

  class ForRange extends For {
    constructor(varKind, name, from, to2) {
      super();
      this.varKind = varKind;
      this.name = name;
      this.from = from;
      this.to = to2;
    }
    render(opts) {
      const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
      const { name, from, to: to2 } = this;
      return `for(${varKind} ${name}=${from}; ${name}<${to2}; ${name}++)` + super.render(opts);
    }
    get names() {
      const names = addExprNames(super.names, this.from);
      return addExprNames(names, this.to);
    }
  }

  class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
      super();
      this.loop = loop;
      this.varKind = varKind;
      this.name = name;
      this.iterable = iterable;
    }
    render(opts) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
    }
    optimizeNames(names, constants) {
      if (!super.optimizeNames(names, constants))
        return;
      this.iterable = optimizeExpr(this.iterable, names, constants);
      return this;
    }
    get names() {
      return addNames(super.names, this.iterable.names);
    }
  }

  class Func extends BlockNode {
    constructor(name, args, async) {
      super();
      this.name = name;
      this.args = args;
      this.async = async;
    }
    render(opts) {
      const _async = this.async ? "async " : "";
      return `${_async}function ${this.name}(${this.args})` + super.render(opts);
    }
  }
  Func.kind = "func";

  class Return extends ParentNode {
    render(opts) {
      return "return " + super.render(opts);
    }
  }
  Return.kind = "return";

  class Try extends BlockNode {
    render(opts) {
      let code = "try" + super.render(opts);
      if (this.catch)
        code += this.catch.render(opts);
      if (this.finally)
        code += this.finally.render(opts);
      return code;
    }
    optimizeNodes() {
      var _a, _b;
      super.optimizeNodes();
      (_a = this.catch) === null || _a === undefined || _a.optimizeNodes();
      (_b = this.finally) === null || _b === undefined || _b.optimizeNodes();
      return this;
    }
    optimizeNames(names, constants) {
      var _a, _b;
      super.optimizeNames(names, constants);
      (_a = this.catch) === null || _a === undefined || _a.optimizeNames(names, constants);
      (_b = this.finally) === null || _b === undefined || _b.optimizeNames(names, constants);
      return this;
    }
    get names() {
      const names = super.names;
      if (this.catch)
        addNames(names, this.catch.names);
      if (this.finally)
        addNames(names, this.finally.names);
      return names;
    }
  }

  class Catch extends BlockNode {
    constructor(error) {
      super();
      this.error = error;
    }
    render(opts) {
      return `catch(${this.error})` + super.render(opts);
    }
  }
  Catch.kind = "catch";

  class Finally extends BlockNode {
    render(opts) {
      return "finally" + super.render(opts);
    }
  }
  Finally.kind = "finally";

  class CodeGen {
    constructor(extScope, opts = {}) {
      this._values = {};
      this._blockStarts = [];
      this._constants = {};
      this.opts = { ...opts, _n: opts.lines ? `
` : "" };
      this._extScope = extScope;
      this._scope = new scope_1.Scope({ parent: extScope });
      this._nodes = [new Root];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(prefix) {
      return this._scope.name(prefix);
    }
    scopeName(prefix) {
      return this._extScope.name(prefix);
    }
    scopeValue(prefixOrName, value) {
      const name = this._extScope.value(prefixOrName, value);
      const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set);
      vs.add(name);
      return name;
    }
    getScopeValue(prefix, keyOrRef) {
      return this._extScope.getValue(prefix, keyOrRef);
    }
    scopeRefs(scopeName) {
      return this._extScope.scopeRefs(scopeName, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(varKind, nameOrPrefix, rhs, constant) {
      const name = this._scope.toName(nameOrPrefix);
      if (rhs !== undefined && constant)
        this._constants[name.str] = rhs;
      this._leafNode(new Def(varKind, name, rhs));
      return name;
    }
    const(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    }
    let(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    }
    var(nameOrPrefix, rhs, _constant) {
      return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    }
    assign(lhs, rhs, sideEffects) {
      return this._leafNode(new Assign(lhs, rhs, sideEffects));
    }
    add(lhs, rhs) {
      return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    }
    code(c2) {
      if (typeof c2 == "function")
        c2();
      else if (c2 !== code_1.nil)
        this._leafNode(new AnyCode(c2));
      return this;
    }
    object(...keyValues) {
      const code = ["{"];
      for (const [key, value] of keyValues) {
        if (code.length > 1)
          code.push(",");
        code.push(key);
        if (key !== value || this.opts.es5) {
          code.push(":");
          (0, code_1.addCodeArg)(code, value);
        }
      }
      code.push("}");
      return new code_1._Code(code);
    }
    if(condition, thenBody, elseBody) {
      this._blockNode(new If(condition));
      if (thenBody && elseBody) {
        this.code(thenBody).else().code(elseBody).endIf();
      } else if (thenBody) {
        this.code(thenBody).endIf();
      } else if (elseBody) {
        throw new Error('CodeGen: "else" body without "then" body');
      }
      return this;
    }
    elseIf(condition) {
      return this._elseNode(new If(condition));
    }
    else() {
      return this._elseNode(new Else);
    }
    endIf() {
      return this._endBlockNode(If, Else);
    }
    _for(node, forBody) {
      this._blockNode(node);
      if (forBody)
        this.code(forBody).endFor();
      return this;
    }
    for(iteration, forBody) {
      return this._for(new ForLoop(iteration), forBody);
    }
    forRange(nameOrPrefix, from, to2, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForRange(varKind, name, from, to2), () => forBody(name));
    }
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
      const name = this._scope.toName(nameOrPrefix);
      if (this.opts.es5) {
        const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
        return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
          this.var(name, (0, code_1._)`${arr}[${i}]`);
          forBody(name);
        });
      }
      return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    }
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
      if (this.opts.ownProperties) {
        return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
      }
      const name = this._scope.toName(nameOrPrefix);
      return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    }
    endFor() {
      return this._endBlockNode(For);
    }
    label(label) {
      return this._leafNode(new Label(label));
    }
    break(label) {
      return this._leafNode(new Break(label));
    }
    return(value) {
      const node = new Return;
      this._blockNode(node);
      this.code(value);
      if (node.nodes.length !== 1)
        throw new Error('CodeGen: "return" should have one node');
      return this._endBlockNode(Return);
    }
    try(tryBody, catchCode, finallyCode) {
      if (!catchCode && !finallyCode)
        throw new Error('CodeGen: "try" without "catch" and "finally"');
      const node = new Try;
      this._blockNode(node);
      this.code(tryBody);
      if (catchCode) {
        const error = this.name("e");
        this._currNode = node.catch = new Catch(error);
        catchCode(error);
      }
      if (finallyCode) {
        this._currNode = node.finally = new Finally;
        this.code(finallyCode);
      }
      return this._endBlockNode(Catch, Finally);
    }
    throw(error) {
      return this._leafNode(new Throw(error));
    }
    block(body, nodeCount) {
      this._blockStarts.push(this._nodes.length);
      if (body)
        this.code(body).endBlock(nodeCount);
      return this;
    }
    endBlock(nodeCount) {
      const len = this._blockStarts.pop();
      if (len === undefined)
        throw new Error("CodeGen: not in self-balancing block");
      const toClose = this._nodes.length - len;
      if (toClose < 0 || nodeCount !== undefined && toClose !== nodeCount) {
        throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
      }
      this._nodes.length = len;
      return this;
    }
    func(name, args = code_1.nil, async, funcBody) {
      this._blockNode(new Func(name, args, async));
      if (funcBody)
        this.code(funcBody).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(Func);
    }
    optimize(n = 1) {
      while (n-- > 0) {
        this._root.optimizeNodes();
        this._root.optimizeNames(this._root.names, this._constants);
      }
    }
    _leafNode(node) {
      this._currNode.nodes.push(node);
      return this;
    }
    _blockNode(node) {
      this._currNode.nodes.push(node);
      this._nodes.push(node);
    }
    _endBlockNode(N1, N22) {
      const n = this._currNode;
      if (n instanceof N1 || N22 && n instanceof N22) {
        this._nodes.pop();
        return this;
      }
      throw new Error(`CodeGen: not in block "${N22 ? `${N1.kind}/${N22.kind}` : N1.kind}"`);
    }
    _elseNode(node) {
      const n = this._currNode;
      if (!(n instanceof If)) {
        throw new Error('CodeGen: "else" without "if"');
      }
      this._currNode = n.else = node;
      return this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      const ns = this._nodes;
      return ns[ns.length - 1];
    }
    set _currNode(node) {
      const ns = this._nodes;
      ns[ns.length - 1] = node;
    }
  }
  exports.CodeGen = CodeGen;
  function addNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
  }
  function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
  }
  function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
      return replaceName(expr);
    if (!canOptimize(expr))
      return expr;
    return new code_1._Code(expr._items.reduce((items, c2) => {
      if (c2 instanceof code_1.Name)
        c2 = replaceName(c2);
      if (c2 instanceof code_1._Code)
        items.push(...c2._items);
      else
        items.push(c2);
      return items;
    }, []));
    function replaceName(n) {
      const c2 = constants[n.str];
      if (c2 === undefined || names[n.str] !== 1)
        return n;
      delete names[n.str];
      return c2;
    }
    function canOptimize(e) {
      return e instanceof code_1._Code && e._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== undefined);
    }
  }
  function subtractNames(names, from) {
    for (const n in from)
      names[n] = (names[n] || 0) - (from[n] || 0);
  }
  function not(x3) {
    return typeof x3 == "boolean" || typeof x3 == "number" || x3 === null ? !x3 : (0, code_1._)`!${par(x3)}`;
  }
  exports.not = not;
  var andCode = mappend(exports.operators.AND);
  function and(...args) {
    return args.reduce(andCode);
  }
  exports.and = and;
  var orCode = mappend(exports.operators.OR);
  function or(...args) {
    return args.reduce(orCode);
  }
  exports.or = or;
  function mappend(op) {
    return (x3, y3) => x3 === code_1.nil ? y3 : y3 === code_1.nil ? x3 : (0, code_1._)`${par(x3)} ${op} ${par(y3)}`;
  }
  function par(x3) {
    return x3 instanceof code_1.Name ? x3 : (0, code_1._)`(${x3})`;
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/util.js
var require_util3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = undefined;
  var codegen_1 = require_codegen3();
  var code_1 = require_code5();
  function toHash(arr) {
    const hash = {};
    for (const item of arr)
      hash[item] = true;
    return hash;
  }
  exports.toHash = toHash;
  function alwaysValidSchema(it2, schema) {
    if (typeof schema == "boolean")
      return schema;
    if (Object.keys(schema).length === 0)
      return true;
    checkUnknownRules(it2, schema);
    return !schemaHasRules(schema, it2.self.RULES.all);
  }
  exports.alwaysValidSchema = alwaysValidSchema;
  function checkUnknownRules(it2, schema = it2.schema) {
    const { opts, self: self2 } = it2;
    if (!opts.strictSchema)
      return;
    if (typeof schema === "boolean")
      return;
    const rules = self2.RULES.keywords;
    for (const key in schema) {
      if (!rules[key])
        checkStrictMode(it2, `unknown keyword: "${key}"`);
    }
  }
  exports.checkUnknownRules = checkUnknownRules;
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (rules[key])
        return true;
    return false;
  }
  exports.schemaHasRules = schemaHasRules;
  function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (key !== "$ref" && RULES.all[key])
        return true;
    return false;
  }
  exports.schemaHasRulesButRef = schemaHasRulesButRef;
  function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
    if (!$data) {
      if (typeof schema == "number" || typeof schema == "boolean")
        return schema;
      if (typeof schema == "string")
        return (0, codegen_1._)`${schema}`;
    }
    return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
  }
  exports.schemaRefOrVal = schemaRefOrVal;
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  exports.unescapeFragment = unescapeFragment;
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  exports.escapeFragment = escapeFragment;
  function escapeJsonPointer(str) {
    if (typeof str == "number")
      return `${str}`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  exports.escapeJsonPointer = escapeJsonPointer;
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  exports.unescapeJsonPointer = unescapeJsonPointer;
  function eachItem(xs, f2) {
    if (Array.isArray(xs)) {
      for (const x3 of xs)
        f2(x3);
    } else {
      f2(xs);
    }
  }
  exports.eachItem = eachItem;
  function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
    return (gen, from, to2, toName) => {
      const res = to2 === undefined ? from : to2 instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to2) : mergeToName(gen, from, to2), to2) : from instanceof codegen_1.Name ? (mergeToName(gen, to2, from), from) : mergeValues(from, to2);
      return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    };
  }
  exports.mergeEvaluated = {
    props: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => {
        gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to2, true), () => gen.assign(to2, (0, codegen_1._)`${to2} || {}`).code((0, codegen_1._)`Object.assign(${to2}, ${from})`));
      }),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => {
        if (from === true) {
          gen.assign(to2, true);
        } else {
          gen.assign(to2, (0, codegen_1._)`${to2} || {}`);
          setEvaluated(gen, to2, from);
        }
      }),
      mergeValues: (from, to2) => from === true ? true : { ...from, ...to2 },
      resultToName: evaluatedPropsToName
    }),
    items: makeMergeEvaluated({
      mergeNames: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true && ${from} !== undefined`, () => gen.assign(to2, (0, codegen_1._)`${from} === true ? true : ${to2} > ${from} ? ${to2} : ${from}`)),
      mergeToName: (gen, from, to2) => gen.if((0, codegen_1._)`${to2} !== true`, () => gen.assign(to2, from === true ? true : (0, codegen_1._)`${to2} > ${from} ? ${to2} : ${from}`)),
      mergeValues: (from, to2) => from === true ? true : Math.max(from, to2),
      resultToName: (gen, items) => gen.var("items", items)
    })
  };
  function evaluatedPropsToName(gen, ps) {
    if (ps === true)
      return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._)`{}`);
    if (ps !== undefined)
      setEvaluated(gen, props, ps);
    return props;
  }
  exports.evaluatedPropsToName = evaluatedPropsToName;
  function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p3) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p3)}`, true));
  }
  exports.setEvaluated = setEvaluated;
  var snippets = {};
  function useFunc(gen, f2) {
    return gen.scopeValue("func", {
      ref: f2,
      code: snippets[f2.code] || (snippets[f2.code] = new code_1._Code(f2.code))
    });
  }
  exports.useFunc = useFunc;
  var Type;
  (function(Type2) {
    Type2[Type2["Num"] = 0] = "Num";
    Type2[Type2["Str"] = 1] = "Str";
  })(Type || (exports.Type = Type = {}));
  function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    if (dataProp instanceof codegen_1.Name) {
      const isNumber = dataPropType === Type.Num;
      return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
  }
  exports.getErrorPath = getErrorPath;
  function checkStrictMode(it2, msg, mode = it2.opts.strictSchema) {
    if (!mode)
      return;
    msg = `strict mode: ${msg}`;
    if (mode === true)
      throw new Error(msg);
    it2.self.logger.warn(msg);
  }
  exports.checkStrictMode = checkStrictMode;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/names.js
var require_names3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var names = {
    data: new codegen_1.Name("data"),
    valCxt: new codegen_1.Name("valCxt"),
    instancePath: new codegen_1.Name("instancePath"),
    parentData: new codegen_1.Name("parentData"),
    parentDataProperty: new codegen_1.Name("parentDataProperty"),
    rootData: new codegen_1.Name("rootData"),
    dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
    vErrors: new codegen_1.Name("vErrors"),
    errors: new codegen_1.Name("errors"),
    this: new codegen_1.Name("this"),
    self: new codegen_1.Name("self"),
    scope: new codegen_1.Name("scope"),
    json: new codegen_1.Name("json"),
    jsonPos: new codegen_1.Name("jsonPos"),
    jsonLen: new codegen_1.Name("jsonLen"),
    jsonPart: new codegen_1.Name("jsonPart")
  };
  exports.default = names;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/errors.js
var require_errors6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = undefined;
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var names_1 = require_names3();
  exports.keywordError = {
    message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
  };
  exports.keyword$DataError = {
    message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
  };
  function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== undefined ? overrideAllErrors : compositeRule || allErrors) {
      addError(gen, errObj);
    } else {
      returnErrors(it2, (0, codegen_1._)`[${errObj}]`);
    }
  }
  exports.reportError = reportError;
  function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
    const { it: it2 } = cxt;
    const { gen, compositeRule, allErrors } = it2;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
      returnErrors(it2, names_1.default.vErrors);
    }
  }
  exports.reportExtraError = reportExtraError;
  function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
  }
  exports.resetErrorsCount = resetErrorsCount;
  function extendErrors({ gen, keyword, schemaValue, data, errsCount, it: it2 }) {
    if (errsCount === undefined)
      throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
      gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
      gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it2.errorPath)));
      gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it2.errSchemaPath}/${keyword}`);
      if (it2.opts.verbose) {
        gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
        gen.assign((0, codegen_1._)`${err}.data`, data);
      }
    });
  }
  exports.extendErrors = extendErrors;
  function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
    gen.code((0, codegen_1._)`${names_1.default.errors}++`);
  }
  function returnErrors(it2, errs) {
    const { gen, validateName, schemaEnv } = it2;
    if (schemaEnv.$async) {
      gen.throw((0, codegen_1._)`new ${it2.ValidationError}(${errs})`);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
      gen.return(false);
    }
  }
  var E5 = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"),
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema")
  };
  function errorObjectCode(cxt, error, errorPaths) {
    const { createErrors } = cxt.it;
    if (createErrors === false)
      return (0, codegen_1._)`{}`;
    return errorObject(cxt, error, errorPaths);
  }
  function errorObject(cxt, error, errorPaths = {}) {
    const { gen, it: it2 } = cxt;
    const keyValues = [
      errorInstancePath(it2, errorPaths),
      errorSchemaPath(cxt, errorPaths)
    ];
    extraErrorProps(cxt, error, keyValues);
    return gen.object(...keyValues);
  }
  function errorInstancePath({ errorPath }, { instancePath }) {
    const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
  }
  function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
    if (schemaPath) {
      schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
    }
    return [E5.schemaPath, schPath];
  }
  function extraErrorProps(cxt, { params, message }, keyValues) {
    const { keyword, data, schemaValue, it: it2 } = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath } = it2;
    keyValues.push([E5.keyword, keyword], [E5.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
    if (opts.messages) {
      keyValues.push([E5.message, typeof message == "function" ? message(cxt) : message]);
    }
    if (opts.verbose) {
      keyValues.push([E5.schema, schemaValue], [E5.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
    }
    if (propertyName)
      keyValues.push([E5.propertyName, propertyName]);
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = undefined;
  var errors_1 = require_errors6();
  var codegen_1 = require_codegen3();
  var names_1 = require_names3();
  var boolError = {
    message: "boolean schema is false"
  };
  function topBoolOrEmptySchema(it2) {
    const { gen, schema, validateName } = it2;
    if (schema === false) {
      falseSchemaError(it2, false);
    } else if (typeof schema == "object" && schema.$async === true) {
      gen.return(names_1.default.data);
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, null);
      gen.return(true);
    }
  }
  exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
  function boolOrEmptySchema(it2, valid) {
    const { gen, schema } = it2;
    if (schema === false) {
      gen.var(valid, false);
      falseSchemaError(it2);
    } else {
      gen.var(valid, true);
    }
  }
  exports.boolOrEmptySchema = boolOrEmptySchema;
  function falseSchemaError(it2, overrideAllErrors) {
    const { gen, data } = it2;
    const cxt = {
      gen,
      keyword: "false schema",
      data,
      schema: false,
      schemaCode: false,
      schemaValue: false,
      params: {},
      it: it2
    };
    (0, errors_1.reportError)(cxt, boolError, undefined, overrideAllErrors);
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/rules.js
var require_rules3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getRules = exports.isJSONType = undefined;
  var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
  var jsonTypes = new Set(_jsonTypes);
  function isJSONType(x3) {
    return typeof x3 == "string" && jsonTypes.has(x3);
  }
  exports.isJSONType = isJSONType;
  function getRules() {
    const groups = {
      number: { type: "number", rules: [] },
      string: { type: "string", rules: [] },
      array: { type: "array", rules: [] },
      object: { type: "object", rules: [] }
    };
    return {
      types: { ...groups, integer: true, boolean: true, null: true },
      rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
      post: { rules: [] },
      all: {},
      keywords: {}
    };
  }
  exports.getRules = getRules;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = undefined;
  function schemaHasRulesForType({ schema, self: self2 }, type) {
    const group = self2.RULES.types[type];
    return group && group !== true && shouldUseGroup(schema, group);
  }
  exports.schemaHasRulesForType = schemaHasRulesForType;
  function shouldUseGroup(schema, group) {
    return group.rules.some((rule) => shouldUseRule(schema, rule));
  }
  exports.shouldUseGroup = shouldUseGroup;
  function shouldUseRule(schema, rule) {
    var _a;
    return schema[rule.keyword] !== undefined || ((_a = rule.definition.implements) === null || _a === undefined ? undefined : _a.some((kwd) => schema[kwd] !== undefined));
  }
  exports.shouldUseRule = shouldUseRule;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = undefined;
  var rules_1 = require_rules3();
  var applicability_1 = require_applicability3();
  var errors_1 = require_errors6();
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var DataType;
  (function(DataType2) {
    DataType2[DataType2["Correct"] = 0] = "Correct";
    DataType2[DataType2["Wrong"] = 1] = "Wrong";
  })(DataType || (exports.DataType = DataType = {}));
  function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
      if (schema.nullable === false)
        throw new Error("type: null contradicts nullable: false");
    } else {
      if (!types.length && schema.nullable !== undefined) {
        throw new Error('"nullable" cannot be used without "type"');
      }
      if (schema.nullable === true)
        types.push("null");
    }
    return types;
  }
  exports.getSchemaTypes = getSchemaTypes;
  function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
      return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
  }
  exports.getJSONTypes = getJSONTypes;
  function coerceAndCheckDataType(it2, types) {
    const { gen, data, opts } = it2;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it2, types[0]));
    if (checkTypes) {
      const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
      gen.if(wrongType, () => {
        if (coerceTo.length)
          coerceData(it2, types, coerceTo);
        else
          reportTypeError(it2);
      });
    }
    return checkTypes;
  }
  exports.coerceAndCheckDataType = coerceAndCheckDataType;
  var COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(types, coerceTypes) {
    return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
  }
  function coerceData(it2, types, coerceTo) {
    const { gen, data, opts } = it2;
    const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
    const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
    if (opts.coerceTypes === "array") {
      gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    }
    gen.if((0, codegen_1._)`${coerced} !== undefined`);
    for (const t of coerceTo) {
      if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
        coerceSpecificType(t);
      }
    }
    gen.else();
    reportTypeError(it2);
    gen.endIf();
    gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
      gen.assign(data, coerced);
      assignParentData(it2, coerced);
    });
    function coerceSpecificType(t) {
      switch (t) {
        case "string":
          gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
          return;
        case "number":
          gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "integer":
          gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
          return;
        case "boolean":
          gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
          return;
        case "null":
          gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
          gen.assign(coerced, null);
          return;
        case "array":
          gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
      }
    }
  }
  function assignParentData({ gen, parentData, parentDataProperty }, expr) {
    gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
  }
  function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
      case "null":
        return (0, codegen_1._)`${data} ${EQ} null`;
      case "array":
        cond = (0, codegen_1._)`Array.isArray(${data})`;
        break;
      case "object":
        cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
        break;
      case "integer":
        cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
        break;
      case "number":
        cond = numCond();
        break;
      default:
        return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
    }
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
      return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
    }
  }
  exports.checkDataType = checkDataType;
  function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
      return checkDataType(dataTypes[0], data, strictNums, correct);
    }
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
      const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
      cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
      delete types.null;
      delete types.array;
      delete types.object;
    } else {
      cond = codegen_1.nil;
    }
    if (types.number)
      delete types.integer;
    for (const t in types)
      cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
  }
  exports.checkDataTypes = checkDataTypes;
  var typeError = {
    message: ({ schema }) => `must be ${schema}`,
    params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
  };
  function reportTypeError(it2) {
    const cxt = getTypeErrorContext(it2);
    (0, errors_1.reportError)(cxt, typeError);
  }
  exports.reportTypeError = reportTypeError;
  function getTypeErrorContext(it2) {
    const { gen, data, schema } = it2;
    const schemaCode = (0, util_1.schemaRefOrVal)(it2, schema, "type");
    return {
      gen,
      keyword: "type",
      data,
      schema: schema.type,
      schemaCode,
      schemaValue: schemaCode,
      parentSchema: schema,
      params: {},
      it: it2
    };
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.assignDefaults = undefined;
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  function assignDefaults(it2, ty) {
    const { properties, items } = it2.schema;
    if (ty === "object" && properties) {
      for (const key in properties) {
        assignDefault(it2, key, properties[key].default);
      }
    } else if (ty === "array" && Array.isArray(items)) {
      items.forEach((sch, i) => assignDefault(it2, i, sch.default));
    }
  }
  exports.assignDefaults = assignDefaults;
  function assignDefault(it2, prop, defaultValue) {
    const { gen, compositeRule, data, opts } = it2;
    if (defaultValue === undefined)
      return;
    const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
    if (compositeRule) {
      (0, util_1.checkStrictMode)(it2, `default is ignored for: ${childData}`);
      return;
    }
    let condition = (0, codegen_1._)`${childData} === undefined`;
    if (opts.useDefaults === "empty") {
      condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
    }
    gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/code.js
var require_code6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = undefined;
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var names_1 = require_names3();
  var util_2 = require_util3();
  function checkReportMissingProp(cxt, prop) {
    const { gen, data, it: it2 } = cxt;
    gen.if(noPropertyInData(gen, data, prop, it2.opts.ownProperties), () => {
      cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
      cxt.error();
    });
  }
  exports.checkReportMissingProp = checkReportMissingProp;
  function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
  }
  exports.checkMissingProp = checkMissingProp;
  function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing }, true);
    cxt.error();
  }
  exports.reportMissingProp = reportMissingProp;
  function hasPropFunc(gen) {
    return gen.scopeValue("func", {
      ref: Object.prototype.hasOwnProperty,
      code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
    });
  }
  exports.hasPropFunc = hasPropFunc;
  function isOwnProperty(gen, data, property) {
    return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
  }
  exports.isOwnProperty = isOwnProperty;
  function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
    return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
  }
  exports.propertyInData = propertyInData;
  function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
  }
  exports.noPropertyInData = noPropertyInData;
  function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p3) => p3 !== "__proto__") : [];
  }
  exports.allSchemaProperties = allSchemaProperties;
  function schemaProperties(it2, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schemaMap[p3]));
  }
  exports.schemaProperties = schemaProperties;
  function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it: it2 }, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
    const valCxt = [
      [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
      [names_1.default.parentData, it2.parentData],
      [names_1.default.parentDataProperty, it2.parentDataProperty],
      [names_1.default.rootData, names_1.default.rootData]
    ];
    if (it2.opts.dynamicRef)
      valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
    return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
  }
  exports.callValidateCode = callValidateCode;
  var newRegExp = (0, codegen_1._)`new RegExp`;
  function usePattern({ gen, it: { opts } }, pattern) {
    const u2 = opts.unicodeRegExp ? "u" : "";
    const { regExp } = opts.code;
    const rx = regExp(pattern, u2);
    return gen.scopeValue("pattern", {
      key: rx.toString(),
      ref: rx,
      code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u2})`
    });
  }
  exports.usePattern = usePattern;
  function validateArray(cxt) {
    const { gen, data, keyword, it: it2 } = cxt;
    const valid = gen.name("valid");
    if (it2.allErrors) {
      const validArr = gen.let("valid", true);
      validateItems(() => gen.assign(validArr, false));
      return validArr;
    }
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema({
          keyword,
          dataProp: i,
          dataPropType: util_1.Type.Num
        }, valid);
        gen.if((0, codegen_1.not)(valid), notValid);
      });
    }
  }
  exports.validateArray = validateArray;
  function validateUnion(cxt) {
    const { gen, schema, keyword, it: it2 } = cxt;
    if (!Array.isArray(schema))
      throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it2, sch));
    if (alwaysValid && !it2.opts.unevaluated)
      return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
      const schCxt = cxt.subschema({
        keyword,
        schemaProp: i,
        compositeRule: true
      }, schValid);
      gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
      const merged = cxt.mergeValidEvaluated(schCxt, schValid);
      if (!merged)
        gen.if((0, codegen_1.not)(valid));
    }));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
  }
  exports.validateUnion = validateUnion;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = undefined;
  var codegen_1 = require_codegen3();
  var names_1 = require_names3();
  var code_1 = require_code6();
  var errors_1 = require_errors6();
  function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it: it2 } = cxt;
    const macroSchema = def.macro.call(it2.self, schema, parentSchema, it2);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it2.opts.validateSchema !== false)
      it2.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
      schema: macroSchema,
      schemaPath: codegen_1.nil,
      errSchemaPath: `${it2.errSchemaPath}/${keyword}`,
      topSchemaRef: schemaRef,
      compositeRule: true
    }, valid);
    cxt.pass(valid, () => cxt.error(true));
  }
  exports.macroKeywordCode = macroKeywordCode;
  function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it: it2 } = cxt;
    checkAsyncKeyword(it2, def);
    const validate = !$data && def.compile ? def.compile.call(it2.self, schema, parentSchema, it2) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== undefined ? _a : valid);
    function validateKeyword() {
      if (def.errors === false) {
        assignValid();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => cxt.error());
      } else {
        const ruleErrs = def.async ? validateAsync() : validateSync();
        if (def.modifying)
          modifyData(cxt);
        reportErrs(() => addErrs(cxt, ruleErrs));
      }
    }
    function validateAsync() {
      const ruleErrs = gen.let("ruleErrs", null);
      gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it2.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
      return ruleErrs;
    }
    function validateSync() {
      const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
      gen.assign(validateErrs, null);
      assignValid(codegen_1.nil);
      return validateErrs;
    }
    function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
      const passCxt = it2.opts.passContext ? names_1.default.this : names_1.default.self;
      const passSchema = !(("compile" in def) && !$data || def.schema === false);
      gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
    }
    function reportErrs(errors) {
      var _a2;
      gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== undefined ? _a2 : valid), errors);
    }
  }
  exports.funcKeywordCode = funcKeywordCode;
  function modifyData(cxt) {
    const { gen, data, it: it2 } = cxt;
    gen.if(it2.parentData, () => gen.assign(data, (0, codegen_1._)`${it2.parentData}[${it2.parentDataProperty}]`));
  }
  function addErrs(cxt, errs) {
    const { gen } = cxt;
    gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      (0, errors_1.extendErrors)(cxt);
    }, () => cxt.error());
  }
  function checkAsyncKeyword({ schemaEnv }, def) {
    if (def.async && !schemaEnv.$async)
      throw new Error("async keyword in sync schema");
  }
  function useKeyword(gen, keyword, result) {
    if (result === undefined)
      throw new Error(`keyword "${keyword}" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
  }
  function validSchemaType(schema, schemaType, allowUndefined = false) {
    return !schemaType.length || schemaType.some((st2) => st2 === "array" ? Array.isArray(schema) : st2 === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st2 || allowUndefined && typeof schema == "undefined");
  }
  exports.validSchemaType = validSchemaType;
  function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
      throw new Error("ajv implementation error");
    }
    const deps = def.dependencies;
    if (deps === null || deps === undefined ? undefined : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
      throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
    }
    if (def.validateSchema) {
      const valid = def.validateSchema(schema[keyword]);
      if (!valid) {
        const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self2.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
  }
  exports.validateKeywordUsage = validateKeywordUsage;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = undefined;
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  function getSubschema(it2, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
    if (keyword !== undefined && schema !== undefined) {
      throw new Error('both "keyword" and "schema" passed, only one allowed');
    }
    if (keyword !== undefined) {
      const sch = it2.schema[keyword];
      return schemaProp === undefined ? {
        schema: sch,
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}`
      } : {
        schema: sch[schemaProp],
        schemaPath: (0, codegen_1._)`${it2.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
        errSchemaPath: `${it2.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
      };
    }
    if (schema !== undefined) {
      if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
        throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      }
      return {
        schema,
        schemaPath,
        topSchemaRef,
        errSchemaPath
      };
    }
    throw new Error('either "keyword" or "schema" must be passed');
  }
  exports.getSubschema = getSubschema;
  function extendSubschemaData(subschema, it2, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
    if (data !== undefined && dataProp !== undefined) {
      throw new Error('both "data" and "dataProp" passed, only one allowed');
    }
    const { gen } = it2;
    if (dataProp !== undefined) {
      const { errorPath, dataPathArr, opts } = it2;
      const nextData = gen.let("data", (0, codegen_1._)`${it2.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
      dataContextProps(nextData);
      subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
      subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
      subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    }
    if (data !== undefined) {
      const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
      dataContextProps(nextData);
      if (propertyName !== undefined)
        subschema.propertyName = propertyName;
    }
    if (dataTypes)
      subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
      subschema.data = _nextData;
      subschema.dataLevel = it2.dataLevel + 1;
      subschema.dataTypes = [];
      it2.definedProperties = new Set;
      subschema.parentData = it2.data;
      subschema.dataNames = [...it2.dataNames, _nextData];
    }
  }
  exports.extendSubschemaData = extendSubschemaData;
  function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
    if (compositeRule !== undefined)
      subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
      subschema.createErrors = createErrors;
    if (allErrors !== undefined)
      subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator;
    subschema.jtdMetadata = jtdMetadata;
  }
  exports.extendSubschemaMode = extendSubschemaMode;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse3 = __commonJS((exports, module) => {
  var traverse = module.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0;i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/resolve.js
var require_resolve3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = undefined;
  var util_1 = require_util3();
  var equal = require_fast_deep_equal();
  var traverse = require_json_schema_traverse3();
  var SIMPLE_INLINED = new Set([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum",
    "const"
  ]);
  function inlineRef(schema, limit = true) {
    if (typeof schema == "boolean")
      return true;
    if (limit === true)
      return !hasRef(schema);
    if (!limit)
      return false;
    return countKeys(schema) <= limit;
  }
  exports.inlineRef = inlineRef;
  var REF_KEYWORDS = new Set([
    "$ref",
    "$recursiveRef",
    "$recursiveAnchor",
    "$dynamicRef",
    "$dynamicAnchor"
  ]);
  function hasRef(schema) {
    for (const key in schema) {
      if (REF_KEYWORDS.has(key))
        return true;
      const sch = schema[key];
      if (Array.isArray(sch) && sch.some(hasRef))
        return true;
      if (typeof sch == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  function countKeys(schema) {
    let count = 0;
    for (const key in schema) {
      if (key === "$ref")
        return Infinity;
      count++;
      if (SIMPLE_INLINED.has(key))
        continue;
      if (typeof schema[key] == "object") {
        (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
      }
      if (count === Infinity)
        return Infinity;
    }
    return count;
  }
  function getFullPath(resolver, id = "", normalize) {
    if (normalize !== false)
      id = normalizeId(id);
    const p3 = resolver.parse(id);
    return _getFullPath(resolver, p3);
  }
  exports.getFullPath = getFullPath;
  function _getFullPath(resolver, p3) {
    const serialized = resolver.serialize(p3);
    return serialized.split("#")[0] + "#";
  }
  exports._getFullPath = _getFullPath;
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  exports.normalizeId = normalizeId;
  function resolveUrl(resolver, baseId, id) {
    id = normalizeId(id);
    return resolver.resolve(baseId, id);
  }
  exports.resolveUrl = resolveUrl;
  var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
  function getSchemaRefs(schema, baseId) {
    if (typeof schema == "boolean")
      return {};
    const { schemaId, uriResolver } = this.opts;
    const schId = normalizeId(schema[schemaId] || baseId);
    const baseIds = { "": schId };
    const pathPrefix = getFullPath(uriResolver, schId, false);
    const localRefs = {};
    const schemaRefs = new Set;
    traverse(schema, { allKeys: true }, (sch, jsonPtr, _3, parentJsonPtr) => {
      if (parentJsonPtr === undefined)
        return;
      const fullPath = pathPrefix + jsonPtr;
      let innerBaseId = baseIds[parentJsonPtr];
      if (typeof sch[schemaId] == "string")
        innerBaseId = addRef.call(this, sch[schemaId]);
      addAnchor.call(this, sch.$anchor);
      addAnchor.call(this, sch.$dynamicAnchor);
      baseIds[jsonPtr] = innerBaseId;
      function addRef(ref) {
        const _resolve = this.opts.uriResolver.resolve;
        ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
        if (schemaRefs.has(ref))
          throw ambiguos(ref);
        schemaRefs.add(ref);
        let schOrRef = this.refs[ref];
        if (typeof schOrRef == "string")
          schOrRef = this.refs[schOrRef];
        if (typeof schOrRef == "object") {
          checkAmbiguosRef(sch, schOrRef.schema, ref);
        } else if (ref !== normalizeId(fullPath)) {
          if (ref[0] === "#") {
            checkAmbiguosRef(sch, localRefs[ref], ref);
            localRefs[ref] = sch;
          } else {
            this.refs[ref] = fullPath;
          }
        }
        return ref;
      }
      function addAnchor(anchor) {
        if (typeof anchor == "string") {
          if (!ANCHOR.test(anchor))
            throw new Error(`invalid anchor "${anchor}"`);
          addRef.call(this, `#${anchor}`);
        }
      }
    });
    return localRefs;
    function checkAmbiguosRef(sch1, sch2, ref) {
      if (sch2 !== undefined && !equal(sch1, sch2))
        throw ambiguos(ref);
    }
    function ambiguos(ref) {
      return new Error(`reference "${ref}" resolves to more than one schema`);
    }
  }
  exports.getSchemaRefs = getSchemaRefs;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/validate/index.js
var require_validate3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getData = exports.KeywordCxt = exports.validateFunctionCode = undefined;
  var boolSchema_1 = require_boolSchema3();
  var dataType_1 = require_dataType3();
  var applicability_1 = require_applicability3();
  var dataType_2 = require_dataType3();
  var defaults_1 = require_defaults3();
  var keyword_1 = require_keyword3();
  var subschema_1 = require_subschema3();
  var codegen_1 = require_codegen3();
  var names_1 = require_names3();
  var resolve_1 = require_resolve3();
  var util_1 = require_util3();
  var errors_1 = require_errors6();
  function validateFunctionCode(it2) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        topSchemaObjCode(it2);
        return;
      }
    }
    validateFunction(it2, () => (0, boolSchema_1.topBoolOrEmptySchema)(it2));
  }
  exports.validateFunctionCode = validateFunctionCode;
  function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
    if (opts.code.es5) {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
        destructureValCxtES5(gen, opts);
        gen.code(body);
      });
    } else {
      gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
  }
  function destructureValCxt(opts) {
    return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
  }
  function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
      gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
    }, () => {
      gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
      gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
      gen.var(names_1.default.rootData, names_1.default.data);
      if (opts.dynamicRef)
        gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
    });
  }
  function topSchemaObjCode(it2) {
    const { schema, opts, gen } = it2;
    validateFunction(it2, () => {
      if (opts.$comment && schema.$comment)
        commentKeyword(it2);
      checkNoDefault(it2);
      gen.let(names_1.default.vErrors, null);
      gen.let(names_1.default.errors, 0);
      if (opts.unevaluated)
        resetEvaluated(it2);
      typeAndKeywords(it2);
      returnResults(it2);
    });
    return;
  }
  function resetEvaluated(it2) {
    const { gen, validateName } = it2;
    it2.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.props`, (0, codegen_1._)`undefined`));
    gen.if((0, codegen_1._)`${it2.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it2.evaluated}.items`, (0, codegen_1._)`undefined`));
  }
  function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
  }
  function subschemaCode(it2, valid) {
    if (isSchemaObj(it2)) {
      checkKeywords(it2);
      if (schemaCxtHasRules(it2)) {
        subSchemaObjCode(it2, valid);
        return;
      }
    }
    (0, boolSchema_1.boolOrEmptySchema)(it2, valid);
  }
  function schemaCxtHasRules({ schema, self: self2 }) {
    if (typeof schema == "boolean")
      return !schema;
    for (const key in schema)
      if (self2.RULES.all[key])
        return true;
    return false;
  }
  function isSchemaObj(it2) {
    return typeof it2.schema != "boolean";
  }
  function subSchemaObjCode(it2, valid) {
    const { schema, gen, opts } = it2;
    if (opts.$comment && schema.$comment)
      commentKeyword(it2);
    updateContext(it2);
    checkAsyncSchema(it2);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it2, errsCount);
    gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
  }
  function checkKeywords(it2) {
    (0, util_1.checkUnknownRules)(it2);
    checkRefsAndKeywords(it2);
  }
  function typeAndKeywords(it2, errsCount) {
    if (it2.opts.jtd)
      return schemaKeywords(it2, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it2.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it2, types);
    schemaKeywords(it2, types, !checkedTypes, errsCount);
  }
  function checkRefsAndKeywords(it2) {
    const { schema, errSchemaPath, opts, self: self2 } = it2;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
      self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
  }
  function checkNoDefault(it2) {
    const { schema, opts } = it2;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
      (0, util_1.checkStrictMode)(it2, "default is ignored in the schema root");
    }
  }
  function updateContext(it2) {
    const schId = it2.schema[it2.opts.schemaId];
    if (schId)
      it2.baseId = (0, resolve_1.resolveUrl)(it2.opts.uriResolver, it2.baseId, schId);
  }
  function checkAsyncSchema(it2) {
    if (it2.schema.$async && !it2.schemaEnv.$async)
      throw new Error("async schema in sync schema");
  }
  function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
      gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
    } else if (typeof opts.$comment == "function") {
      const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
      const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
      gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
    }
  }
  function returnResults(it2) {
    const { gen, schemaEnv, validateName, ValidationError, opts } = it2;
    if (schemaEnv.$async) {
      gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
    } else {
      gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
      if (opts.unevaluated)
        assignEvaluated(it2);
      gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
    }
  }
  function assignEvaluated({ gen, evaluated, props, items }) {
    if (props instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.props`, props);
    if (items instanceof codegen_1.Name)
      gen.assign((0, codegen_1._)`${evaluated}.items`, items);
  }
  function schemaKeywords(it2, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self: self2 } = it2;
    const { RULES } = self2;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
      gen.block(() => keywordCode(it2, "$ref", RULES.all.$ref.definition));
      return;
    }
    if (!opts.jtd)
      checkStrictTypes(it2, types);
    gen.block(() => {
      for (const group of RULES.rules)
        groupKeywords(group);
      groupKeywords(RULES.post);
    });
    function groupKeywords(group) {
      if (!(0, applicability_1.shouldUseGroup)(schema, group))
        return;
      if (group.type) {
        gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
        iterateKeywords(it2, group);
        if (types.length === 1 && types[0] === group.type && typeErrors) {
          gen.else();
          (0, dataType_2.reportTypeError)(it2);
        }
        gen.endIf();
      } else {
        iterateKeywords(it2, group);
      }
      if (!allErrors)
        gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
    }
  }
  function iterateKeywords(it2, group) {
    const { gen, schema, opts: { useDefaults } } = it2;
    if (useDefaults)
      (0, defaults_1.assignDefaults)(it2, group.type);
    gen.block(() => {
      for (const rule of group.rules) {
        if ((0, applicability_1.shouldUseRule)(schema, rule)) {
          keywordCode(it2, rule.keyword, rule.definition, group.type);
        }
      }
    });
  }
  function checkStrictTypes(it2, types) {
    if (it2.schemaEnv.meta || !it2.opts.strictTypes)
      return;
    checkContextTypes(it2, types);
    if (!it2.opts.allowUnionTypes)
      checkMultipleTypes(it2, types);
    checkKeywordTypes(it2, it2.dataTypes);
  }
  function checkContextTypes(it2, types) {
    if (!types.length)
      return;
    if (!it2.dataTypes.length) {
      it2.dataTypes = types;
      return;
    }
    types.forEach((t) => {
      if (!includesType(it2.dataTypes, t)) {
        strictTypesError(it2, `type "${t}" not allowed by context "${it2.dataTypes.join(",")}"`);
      }
    });
    narrowSchemaTypes(it2, types);
  }
  function checkMultipleTypes(it2, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
      strictTypesError(it2, "use allowUnionTypes to allow union type keyword");
    }
  }
  function checkKeywordTypes(it2, ts) {
    const rules = it2.self.RULES.all;
    for (const keyword in rules) {
      const rule = rules[keyword];
      if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it2.schema, rule)) {
        const { type } = rule.definition;
        if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
          strictTypesError(it2, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
  }
  function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
  }
  function includesType(ts, t) {
    return ts.includes(t) || t === "integer" && ts.includes("number");
  }
  function narrowSchemaTypes(it2, withTypes) {
    const ts = [];
    for (const t of it2.dataTypes) {
      if (includesType(withTypes, t))
        ts.push(t);
      else if (withTypes.includes("integer") && t === "number")
        ts.push("integer");
    }
    it2.dataTypes = ts;
  }
  function strictTypesError(it2, msg) {
    const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
    msg += ` at "${schemaPath}" (strictTypes)`;
    (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictTypes);
  }

  class KeywordCxt {
    constructor(it2, def, keyword) {
      (0, keyword_1.validateKeywordUsage)(it2, def, keyword);
      this.gen = it2.gen;
      this.allErrors = it2.allErrors;
      this.keyword = keyword;
      this.data = it2.data;
      this.schema = it2.schema[keyword];
      this.$data = def.$data && it2.opts.$data && this.schema && this.schema.$data;
      this.schemaValue = (0, util_1.schemaRefOrVal)(it2, this.schema, keyword, this.$data);
      this.schemaType = def.schemaType;
      this.parentSchema = it2.schema;
      this.params = {};
      this.it = it2;
      this.def = def;
      if (this.$data) {
        this.schemaCode = it2.gen.const("vSchema", getData(this.$data, it2));
      } else {
        this.schemaCode = this.schemaValue;
        if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        }
      }
      if ("code" in def ? def.trackErrors : def.errors !== false) {
        this.errsCount = it2.gen.const("_errs", names_1.default.errors);
      }
    }
    result(condition, successAction, failAction) {
      this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    }
    failResult(condition, successAction, failAction) {
      this.gen.if(condition);
      if (failAction)
        failAction();
      else
        this.error();
      if (successAction) {
        this.gen.else();
        successAction();
        if (this.allErrors)
          this.gen.endIf();
      } else {
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
    }
    pass(condition, failAction) {
      this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    }
    fail(condition) {
      if (condition === undefined) {
        this.error();
        if (!this.allErrors)
          this.gen.if(false);
        return;
      }
      this.gen.if(condition);
      this.error();
      if (this.allErrors)
        this.gen.endIf();
      else
        this.gen.else();
    }
    fail$data(condition) {
      if (!this.$data)
        return this.fail(condition);
      const { schemaCode } = this;
      this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
    }
    error(append, errorParams, errorPaths) {
      if (errorParams) {
        this.setParams(errorParams);
        this._error(append, errorPaths);
        this.setParams({});
        return;
      }
      this._error(append, errorPaths);
    }
    _error(append, errorPaths) {
      (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    }
    $dataError() {
      (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    }
    reset() {
      if (this.errsCount === undefined)
        throw new Error('add "trackErrors" to keyword definition');
      (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(cond) {
      if (!this.allErrors)
        this.gen.if(cond);
    }
    setParams(obj, assign) {
      if (assign)
        Object.assign(this.params, obj);
      else
        this.params = obj;
    }
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
      this.gen.block(() => {
        this.check$data(valid, $dataValid);
        codeBlock();
      });
    }
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
      if (!this.$data)
        return;
      const { gen, schemaCode, schemaType, def } = this;
      gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
      if (valid !== codegen_1.nil)
        gen.assign(valid, true);
      if (schemaType.length || def.validateSchema) {
        gen.elseIf(this.invalid$data());
        this.$dataError();
        if (valid !== codegen_1.nil)
          gen.assign(valid, false);
      }
      gen.else();
    }
    invalid$data() {
      const { gen, schemaCode, schemaType, def, it: it2 } = this;
      return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
      function wrong$DataType() {
        if (schemaType.length) {
          if (!(schemaCode instanceof codegen_1.Name))
            throw new Error("ajv implementation error");
          const st2 = Array.isArray(schemaType) ? schemaType : [schemaType];
          return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st2, schemaCode, it2.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
        }
        return codegen_1.nil;
      }
      function invalid$DataSchema() {
        if (def.validateSchema) {
          const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
          return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
        }
        return codegen_1.nil;
      }
    }
    subschema(appl, valid) {
      const subschema = (0, subschema_1.getSubschema)(this.it, appl);
      (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
      (0, subschema_1.extendSubschemaMode)(subschema, appl);
      const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };
      subschemaCode(nextContext, valid);
      return nextContext;
    }
    mergeEvaluated(schemaCxt, toName) {
      const { it: it2, gen } = this;
      if (!it2.opts.unevaluated)
        return;
      if (it2.props !== true && schemaCxt.props !== undefined) {
        it2.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it2.props, toName);
      }
      if (it2.items !== true && schemaCxt.items !== undefined) {
        it2.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it2.items, toName);
      }
    }
    mergeValidEvaluated(schemaCxt, valid) {
      const { it: it2, gen } = this;
      if (it2.opts.unevaluated && (it2.props !== true || it2.items !== true)) {
        gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
        return true;
      }
    }
  }
  exports.KeywordCxt = KeywordCxt;
  function keywordCode(it2, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it2, def, keyword);
    if ("code" in def) {
      def.code(cxt, ruleType);
    } else if (cxt.$data && def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    } else if ("macro" in def) {
      (0, keyword_1.macroKeywordCode)(cxt, def);
    } else if (def.compile || def.validate) {
      (0, keyword_1.funcKeywordCode)(cxt, def);
    }
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, { dataLevel, dataNames, dataPathArr }) {
    let jsonPointer;
    let data;
    if ($data === "")
      return names_1.default.rootData;
    if ($data[0] === "/") {
      if (!JSON_POINTER.test($data))
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      jsonPointer = $data;
      data = names_1.default.rootData;
    } else {
      const matches = RELATIVE_JSON_POINTER.exec($data);
      if (!matches)
        throw new Error(`Invalid JSON-pointer: ${$data}`);
      const up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer === "#") {
        if (up >= dataLevel)
          throw new Error(errorMsg("property/index", up));
        return dataPathArr[dataLevel - up];
      }
      if (up > dataLevel)
        throw new Error(errorMsg("data", up));
      data = dataNames[dataLevel - up];
      if (!jsonPointer)
        return data;
    }
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
      if (segment) {
        data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
        expr = (0, codegen_1._)`${expr} && ${data}`;
      }
    }
    return expr;
    function errorMsg(pointerType, up) {
      return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
    }
  }
  exports.getData = getData;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class ValidationError extends Error {
    constructor(errors) {
      super("validation failed");
      this.errors = errors;
      this.ajv = this.validation = true;
    }
  }
  exports.default = ValidationError;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var resolve_1 = require_resolve3();

  class MissingRefError extends Error {
    constructor(resolver, baseId, ref, msg) {
      super(msg || `can't resolve reference ${ref} from id ${baseId}`);
      this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
      this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
    }
  }
  exports.default = MissingRefError;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/index.js
var require_compile3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = undefined;
  var codegen_1 = require_codegen3();
  var validation_error_1 = require_validation_error3();
  var names_1 = require_names3();
  var resolve_1 = require_resolve3();
  var util_1 = require_util3();
  var validate_1 = require_validate3();

  class SchemaEnv {
    constructor(env) {
      var _a;
      this.refs = {};
      this.dynamicAnchors = {};
      let schema;
      if (typeof env.schema == "object")
        schema = env.schema;
      this.schema = env.schema;
      this.schemaId = env.schemaId;
      this.root = env.root || this;
      this.baseId = (_a = env.baseId) !== null && _a !== undefined ? _a : (0, resolve_1.normalizeId)(schema === null || schema === undefined ? undefined : schema[env.schemaId || "$id"]);
      this.schemaPath = env.schemaPath;
      this.localRefs = env.localRefs;
      this.meta = env.meta;
      this.$async = schema === null || schema === undefined ? undefined : schema.$async;
      this.refs = {};
    }
  }
  exports.SchemaEnv = SchemaEnv;
  function compileSchema(sch) {
    const _sch = getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    let _ValidationError;
    if (sch.$async) {
      _ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      });
    }
    const validateName = gen.scopeName("validate");
    sch.validateName = validateName;
    const schemaCxt = {
      gen,
      allErrors: this.opts.allErrors,
      data: names_1.default.data,
      parentData: names_1.default.parentData,
      parentDataProperty: names_1.default.parentDataProperty,
      dataNames: [names_1.default.data],
      dataPathArr: [codegen_1.nil],
      dataLevel: 0,
      dataTypes: [],
      definedProperties: new Set,
      topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
      validateName,
      ValidationError: _ValidationError,
      schema: sch.schema,
      schemaEnv: sch,
      rootId,
      baseId: sch.baseId || rootId,
      schemaPath: codegen_1.nil,
      errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
      errorPath: (0, codegen_1._)`""`,
      opts: this.opts,
      self: this
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      (0, validate_1.validateFunctionCode)(schemaCxt);
      gen.optimize(this.opts.code.optimize);
      const validateCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
      if (this.opts.code.process)
        sourceCode = this.opts.code.process(sourceCode, sch);
      const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
      const validate = makeValidate(this, this.scope.get());
      this.scope.value(validateName, { ref: validate });
      validate.errors = null;
      validate.schema = sch.schema;
      validate.schemaEnv = sch;
      if (sch.$async)
        validate.$async = true;
      if (this.opts.code.source === true) {
        validate.source = { validateName, validateCode, scopeValues: gen._values };
      }
      if (this.opts.unevaluated) {
        const { props, items } = schemaCxt;
        validate.evaluated = {
          props: props instanceof codegen_1.Name ? undefined : props,
          items: items instanceof codegen_1.Name ? undefined : items,
          dynamicProps: props instanceof codegen_1.Name,
          dynamicItems: items instanceof codegen_1.Name
        };
        if (validate.source)
          validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
      }
      sch.validate = validate;
      return sch;
    } catch (e) {
      delete sch.validate;
      delete sch.validateName;
      if (sourceCode)
        this.logger.error("Error compiling schema, function code:", sourceCode);
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
  }
  exports.compileSchema = compileSchema;
  function resolveRef(root, baseId, ref) {
    var _a;
    ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
    const schOrFunc = root.refs[ref];
    if (schOrFunc)
      return schOrFunc;
    let _sch = resolve.call(this, root, ref);
    if (_sch === undefined) {
      const schema = (_a = root.localRefs) === null || _a === undefined ? undefined : _a[ref];
      const { schemaId } = this.opts;
      if (schema)
        _sch = new SchemaEnv({ schema, schemaId, root, baseId });
    }
    if (_sch === undefined)
      return;
    return root.refs[ref] = inlineOrCompile.call(this, _sch);
  }
  exports.resolveRef = resolveRef;
  function inlineOrCompile(sch) {
    if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
      return sch.schema;
    return sch.validate ? sch : compileSchema.call(this, sch);
  }
  function getCompilingSchema(schEnv) {
    for (const sch of this._compilations) {
      if (sameSchemaEnv(sch, schEnv))
        return sch;
    }
  }
  exports.getCompilingSchema = getCompilingSchema;
  function sameSchemaEnv(s1, s2) {
    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
  }
  function resolve(root, ref) {
    let sch;
    while (typeof (sch = this.refs[ref]) == "string")
      ref = sch;
    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
  }
  function resolveSchema(root, ref) {
    const p3 = this.opts.uriResolver.parse(ref);
    const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p3);
    let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, undefined);
    if (Object.keys(root.schema).length > 0 && refPath === baseId) {
      return getJsonPointer.call(this, p3, root);
    }
    const id = (0, resolve_1.normalizeId)(refPath);
    const schOrRef = this.refs[id] || this.schemas[id];
    if (typeof schOrRef == "string") {
      const sch = resolveSchema.call(this, root, schOrRef);
      if (typeof (sch === null || sch === undefined ? undefined : sch.schema) !== "object")
        return;
      return getJsonPointer.call(this, p3, sch);
    }
    if (typeof (schOrRef === null || schOrRef === undefined ? undefined : schOrRef.schema) !== "object")
      return;
    if (!schOrRef.validate)
      compileSchema.call(this, schOrRef);
    if (id === (0, resolve_1.normalizeId)(ref)) {
      const { schema } = schOrRef;
      const { schemaId } = this.opts;
      const schId = schema[schemaId];
      if (schId)
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      return new SchemaEnv({ schema, schemaId, root, baseId });
    }
    return getJsonPointer.call(this, p3, schOrRef);
  }
  exports.resolveSchema = resolveSchema;
  var PREVENT_SCOPE_CHANGE = new Set([
    "properties",
    "patternProperties",
    "enum",
    "dependencies",
    "definitions"
  ]);
  function getJsonPointer(parsedRef, { baseId, schema, root }) {
    var _a;
    if (((_a = parsedRef.fragment) === null || _a === undefined ? undefined : _a[0]) !== "/")
      return;
    for (const part of parsedRef.fragment.slice(1).split("/")) {
      if (typeof schema === "boolean")
        return;
      const partSchema = schema[(0, util_1.unescapeFragment)(part)];
      if (partSchema === undefined)
        return;
      schema = partSchema;
      const schId = typeof schema === "object" && schema[this.opts.schemaId];
      if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
        baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
      }
    }
    let env;
    if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
      const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
      env = resolveSchema.call(this, root, $ref);
    }
    const { schemaId } = this.opts;
    env = env || new SchemaEnv({ schema, schemaId, root, baseId });
    if (env.schema !== env.root.schema)
      return env;
    return;
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/refs/data.json
var require_data3 = __commonJS((exports, module) => {
  module.exports = {
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
      }
    },
    additionalProperties: false
  };
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/runtime/uri.js
var require_uri3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var uri = require_fast_uri();
  uri.code = 'require("ajv/dist/runtime/uri").default';
  exports.default = uri;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/core.js
var require_core5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = undefined;
  var validate_1 = require_validate3();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen3();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error3();
  var ref_error_1 = require_ref_error3();
  var rules_1 = require_rules3();
  var compile_1 = require_compile3();
  var codegen_2 = require_codegen3();
  var resolve_1 = require_resolve3();
  var dataType_1 = require_dataType3();
  var util_1 = require_util3();
  var $dataRefSchema = require_data3();
  var uri_1 = require_uri3();
  var defaultRegExp = (str, flags) => new RegExp(str, flags);
  defaultRegExp.code = "new RegExp";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
  var EXT_SCOPE_NAMES = new Set([
    "validate",
    "serialize",
    "parse",
    "wrapper",
    "root",
    "schema",
    "keyword",
    "pattern",
    "formats",
    "validate$data",
    "func",
    "obj",
    "Error"
  ]);
  var removedOptions = {
    errorDataPath: "",
    format: "`validateFormats: false` can be used instead.",
    nullable: '"nullable" keyword is supported by default.',
    jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
    extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
    missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
    processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
    sourceCode: "Use option `code: {source: true}`",
    strictDefaults: "It is default now, see option `strict`.",
    strictKeywords: "It is default now, see option `strict`.",
    uniqueItems: '"uniqueItems" keyword is always validated.',
    unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
    cache: "Map is used as cache, schema object as key.",
    serialize: "Map is used as cache, schema object as key.",
    ajvErrors: "It is default now."
  };
  var deprecatedOptions = {
    ignoreKeywordsWithRef: "",
    jsPropertySyntax: "",
    unicode: '"minLength"/"maxLength" account for unicode characters by default.'
  };
  var MAX_EXPRESSION = 200;
  function requiredOptions(o2) {
    var _a, _b, _c, _d, _e3, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r3, _s, _t3, _u, _v, _w, _x, _y, _z, _0;
    const s2 = o2.strict;
    const _optz = (_a = o2.code) === null || _a === undefined ? undefined : _a.optimize;
    const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0;
    const regExp = (_c = (_b = o2.code) === null || _b === undefined ? undefined : _b.regExp) !== null && _c !== undefined ? _c : defaultRegExp;
    const uriResolver = (_d = o2.uriResolver) !== null && _d !== undefined ? _d : uri_1.default;
    return {
      strictSchema: (_f = (_e3 = o2.strictSchema) !== null && _e3 !== undefined ? _e3 : s2) !== null && _f !== undefined ? _f : true,
      strictNumbers: (_h = (_g = o2.strictNumbers) !== null && _g !== undefined ? _g : s2) !== null && _h !== undefined ? _h : true,
      strictTypes: (_k = (_j = o2.strictTypes) !== null && _j !== undefined ? _j : s2) !== null && _k !== undefined ? _k : "log",
      strictTuples: (_m = (_l = o2.strictTuples) !== null && _l !== undefined ? _l : s2) !== null && _m !== undefined ? _m : "log",
      strictRequired: (_p = (_o = o2.strictRequired) !== null && _o !== undefined ? _o : s2) !== null && _p !== undefined ? _p : false,
      code: o2.code ? { ...o2.code, optimize, regExp } : { optimize, regExp },
      loopRequired: (_q = o2.loopRequired) !== null && _q !== undefined ? _q : MAX_EXPRESSION,
      loopEnum: (_r3 = o2.loopEnum) !== null && _r3 !== undefined ? _r3 : MAX_EXPRESSION,
      meta: (_s = o2.meta) !== null && _s !== undefined ? _s : true,
      messages: (_t3 = o2.messages) !== null && _t3 !== undefined ? _t3 : true,
      inlineRefs: (_u = o2.inlineRefs) !== null && _u !== undefined ? _u : true,
      schemaId: (_v = o2.schemaId) !== null && _v !== undefined ? _v : "$id",
      addUsedSchema: (_w = o2.addUsedSchema) !== null && _w !== undefined ? _w : true,
      validateSchema: (_x = o2.validateSchema) !== null && _x !== undefined ? _x : true,
      validateFormats: (_y = o2.validateFormats) !== null && _y !== undefined ? _y : true,
      unicodeRegExp: (_z = o2.unicodeRegExp) !== null && _z !== undefined ? _z : true,
      int32range: (_0 = o2.int32range) !== null && _0 !== undefined ? _0 : true,
      uriResolver
    };
  }

  class Ajv {
    constructor(opts = {}) {
      this.schemas = {};
      this.refs = {};
      this.formats = {};
      this._compilations = new Set;
      this._loading = {};
      this._cache = new Map;
      opts = this.opts = { ...opts, ...requiredOptions(opts) };
      const { es5, lines } = this.opts.code;
      this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
      this.logger = getLogger(opts.logger);
      const formatOpt = opts.validateFormats;
      opts.validateFormats = false;
      this.RULES = (0, rules_1.getRules)();
      checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
      checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
      this._metaOpts = getMetaSchemaOptions.call(this);
      if (opts.formats)
        addInitialFormats.call(this);
      this._addVocabularies();
      this._addDefaultMetaSchema();
      if (opts.keywords)
        addInitialKeywords.call(this, opts.keywords);
      if (typeof opts.meta == "object")
        this.addMetaSchema(opts.meta);
      addInitialSchemas.call(this);
      opts.validateFormats = formatOpt;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      const { $data, meta, schemaId } = this.opts;
      let _dataRefSchema = $dataRefSchema;
      if (schemaId === "id") {
        _dataRefSchema = { ...$dataRefSchema };
        _dataRefSchema.id = _dataRefSchema.$id;
        delete _dataRefSchema.$id;
      }
      if (meta && $data)
        this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
    }
    defaultMeta() {
      const { meta, schemaId } = this.opts;
      return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : undefined;
    }
    validate(schemaKeyRef, data) {
      let v2;
      if (typeof schemaKeyRef == "string") {
        v2 = this.getSchema(schemaKeyRef);
        if (!v2)
          throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
      } else {
        v2 = this.compile(schemaKeyRef);
      }
      const valid = v2(data);
      if (!("$async" in v2))
        this.errors = v2.errors;
      return valid;
    }
    compile(schema, _meta) {
      const sch = this._addSchema(schema, _meta);
      return sch.validate || this._compileSchemaEnv(sch);
    }
    compileAsync(schema, meta) {
      if (typeof this.opts.loadSchema != "function") {
        throw new Error("options.loadSchema should be a function");
      }
      const { loadSchema } = this.opts;
      return runCompileAsync.call(this, schema, meta);
      async function runCompileAsync(_schema, _meta) {
        await loadMetaSchema.call(this, _schema.$schema);
        const sch = this._addSchema(_schema, _meta);
        return sch.validate || _compileAsync.call(this, sch);
      }
      async function loadMetaSchema($ref) {
        if ($ref && !this.getSchema($ref)) {
          await runCompileAsync.call(this, { $ref }, true);
        }
      }
      async function _compileAsync(sch) {
        try {
          return this._compileSchemaEnv(sch);
        } catch (e) {
          if (!(e instanceof ref_error_1.default))
            throw e;
          checkLoaded.call(this, e);
          await loadMissingSchema.call(this, e.missingSchema);
          return _compileAsync.call(this, sch);
        }
      }
      function checkLoaded({ missingSchema: ref, missingRef }) {
        if (this.refs[ref]) {
          throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
      }
      async function loadMissingSchema(ref) {
        const _schema = await _loadSchema.call(this, ref);
        if (!this.refs[ref])
          await loadMetaSchema.call(this, _schema.$schema);
        if (!this.refs[ref])
          this.addSchema(_schema, ref, meta);
      }
      async function _loadSchema(ref) {
        const p3 = this._loading[ref];
        if (p3)
          return p3;
        try {
          return await (this._loading[ref] = loadSchema(ref));
        } finally {
          delete this._loading[ref];
        }
      }
    }
    addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
      if (Array.isArray(schema)) {
        for (const sch of schema)
          this.addSchema(sch, undefined, _meta, _validateSchema);
        return this;
      }
      let id;
      if (typeof schema === "object") {
        const { schemaId } = this.opts;
        id = schema[schemaId];
        if (id !== undefined && typeof id != "string") {
          throw new Error(`schema ${schemaId} must be string`);
        }
      }
      key = (0, resolve_1.normalizeId)(key || id);
      this._checkUnique(key);
      this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
      return this;
    }
    addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
      this.addSchema(schema, key, true, _validateSchema);
      return this;
    }
    validateSchema(schema, throwOrLogError) {
      if (typeof schema == "boolean")
        return true;
      let $schema;
      $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != "string") {
        throw new Error("$schema must be a string");
      }
      $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
      if (!$schema) {
        this.logger.warn("meta-schema not available");
        this.errors = null;
        return true;
      }
      const valid = this.validate($schema, schema);
      if (!valid && throwOrLogError) {
        const message = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log")
          this.logger.error(message);
        else
          throw new Error(message);
      }
      return valid;
    }
    getSchema(keyRef) {
      let sch;
      while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
        keyRef = sch;
      if (sch === undefined) {
        const { schemaId } = this.opts;
        const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
        sch = compile_1.resolveSchema.call(this, root, keyRef);
        if (!sch)
          return;
        this.refs[keyRef] = sch;
      }
      return sch.validate || this._compileSchemaEnv(sch);
    }
    removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        this._removeAllSchemas(this.schemas, schemaKeyRef);
        this._removeAllSchemas(this.refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case "undefined":
          this._removeAllSchemas(this.schemas);
          this._removeAllSchemas(this.refs);
          this._cache.clear();
          return this;
        case "string": {
          const sch = getSchEnv.call(this, schemaKeyRef);
          if (typeof sch == "object")
            this._cache.delete(sch.schema);
          delete this.schemas[schemaKeyRef];
          delete this.refs[schemaKeyRef];
          return this;
        }
        case "object": {
          const cacheKey = schemaKeyRef;
          this._cache.delete(cacheKey);
          let id = schemaKeyRef[this.opts.schemaId];
          if (id) {
            id = (0, resolve_1.normalizeId)(id);
            delete this.schemas[id];
            delete this.refs[id];
          }
          return this;
        }
        default:
          throw new Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(definitions) {
      for (const def of definitions)
        this.addKeyword(def);
      return this;
    }
    addKeyword(kwdOrDef, def) {
      let keyword;
      if (typeof kwdOrDef == "string") {
        keyword = kwdOrDef;
        if (typeof def == "object") {
          this.logger.warn("these parameters are deprecated, see docs for addKeyword");
          def.keyword = keyword;
        }
      } else if (typeof kwdOrDef == "object" && def === undefined) {
        def = kwdOrDef;
        keyword = def.keyword;
        if (Array.isArray(keyword) && !keyword.length) {
          throw new Error("addKeywords: keyword must be string or non-empty array");
        }
      } else {
        throw new Error("invalid addKeywords parameters");
      }
      checkKeyword.call(this, keyword, def);
      if (!def) {
        (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
        return this;
      }
      keywordMetaschema.call(this, def);
      const definition = {
        ...def,
        type: (0, dataType_1.getJSONTypes)(def.type),
        schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
      };
      (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k3) => addRule.call(this, k3, definition) : (k3) => definition.type.forEach((t) => addRule.call(this, k3, definition, t)));
      return this;
    }
    getKeyword(keyword) {
      const rule = this.RULES.all[keyword];
      return typeof rule == "object" ? rule.definition : !!rule;
    }
    removeKeyword(keyword) {
      const { RULES } = this;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      for (const group of RULES.rules) {
        const i = group.rules.findIndex((rule) => rule.keyword === keyword);
        if (i >= 0)
          group.rules.splice(i, 1);
      }
      return this;
    }
    addFormat(name, format) {
      if (typeof format == "string")
        format = new RegExp(format);
      this.formats[name] = format;
      return this;
    }
    errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
      if (!errors || errors.length === 0)
        return "No errors";
      return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
    }
    $dataMetaSchema(metaSchema, keywordsJsonPointers) {
      const rules = this.RULES.all;
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      for (const jsonPointer of keywordsJsonPointers) {
        const segments = jsonPointer.split("/").slice(1);
        let keywords = metaSchema;
        for (const seg of segments)
          keywords = keywords[seg];
        for (const key in rules) {
          const rule = rules[key];
          if (typeof rule != "object")
            continue;
          const { $data } = rule.definition;
          const schema = keywords[key];
          if ($data && schema)
            keywords[key] = schemaOrData(schema);
        }
      }
      return metaSchema;
    }
    _removeAllSchemas(schemas, regex) {
      for (const keyRef in schemas) {
        const sch = schemas[keyRef];
        if (!regex || regex.test(keyRef)) {
          if (typeof sch == "string") {
            delete schemas[keyRef];
          } else if (sch && !sch.meta) {
            this._cache.delete(sch.schema);
            delete schemas[keyRef];
          }
        }
      }
    }
    _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
      let id;
      const { schemaId } = this.opts;
      if (typeof schema == "object") {
        id = schema[schemaId];
      } else {
        if (this.opts.jtd)
          throw new Error("schema must be object");
        else if (typeof schema != "boolean")
          throw new Error("schema must be object or boolean");
      }
      let sch = this._cache.get(schema);
      if (sch !== undefined)
        return sch;
      baseId = (0, resolve_1.normalizeId)(id || baseId);
      const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
      sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
      this._cache.set(sch.schema, sch);
      if (addSchema && !baseId.startsWith("#")) {
        if (baseId)
          this._checkUnique(baseId);
        this.refs[baseId] = sch;
      }
      if (validateSchema)
        this.validateSchema(schema, true);
      return sch;
    }
    _checkUnique(id) {
      if (this.schemas[id] || this.refs[id]) {
        throw new Error(`schema with key or id "${id}" already exists`);
      }
    }
    _compileSchemaEnv(sch) {
      if (sch.meta)
        this._compileMetaSchema(sch);
      else
        compile_1.compileSchema.call(this, sch);
      if (!sch.validate)
        throw new Error("ajv implementation error");
      return sch.validate;
    }
    _compileMetaSchema(sch) {
      const currentOpts = this.opts;
      this.opts = this._metaOpts;
      try {
        compile_1.compileSchema.call(this, sch);
      } finally {
        this.opts = currentOpts;
      }
    }
  }
  Ajv.ValidationError = validation_error_1.default;
  Ajv.MissingRefError = ref_error_1.default;
  exports.default = Ajv;
  function checkOptions(checkOpts, options, msg, log = "error") {
    for (const key in checkOpts) {
      const opt = key;
      if (opt in options)
        this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
    }
  }
  function getSchEnv(keyRef) {
    keyRef = (0, resolve_1.normalizeId)(keyRef);
    return this.schemas[keyRef] || this.refs[keyRef];
  }
  function addInitialSchemas() {
    const optsSchemas = this.opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      this.addSchema(optsSchemas);
    else
      for (const key in optsSchemas)
        this.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats() {
    for (const name in this.opts.formats) {
      const format = this.opts.formats[name];
      if (format)
        this.addFormat(name, format);
    }
  }
  function addInitialKeywords(defs) {
    if (Array.isArray(defs)) {
      this.addVocabulary(defs);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (const keyword in defs) {
      const def = defs[keyword];
      if (!def.keyword)
        def.keyword = keyword;
      this.addKeyword(def);
    }
  }
  function getMetaSchemaOptions() {
    const metaOpts = { ...this.opts };
    for (const opt of META_IGNORE_OPTIONS)
      delete metaOpts[opt];
    return metaOpts;
  }
  var noLogs = { log() {}, warn() {}, error() {} };
  function getLogger(logger) {
    if (logger === false)
      return noLogs;
    if (logger === undefined)
      return console;
    if (logger.log && logger.warn && logger.error)
      return logger;
    throw new Error("logger must implement log, warn and error methods");
  }
  var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
  function checkKeyword(keyword, def) {
    const { RULES } = this;
    (0, util_1.eachItem)(keyword, (kwd) => {
      if (RULES.keywords[kwd])
        throw new Error(`Keyword ${kwd} is already defined`);
      if (!KEYWORD_NAME.test(kwd))
        throw new Error(`Keyword ${kwd} has invalid name`);
    });
    if (!def)
      return;
    if (def.$data && !(("code" in def) || ("validate" in def))) {
      throw new Error('$data keyword must have "code" or "validate" function');
    }
  }
  function addRule(keyword, definition, dataType) {
    var _a;
    const post = definition === null || definition === undefined ? undefined : definition.post;
    if (dataType && post)
      throw new Error('keyword with "post" flag cannot have "type"');
    const { RULES } = this;
    let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.rules.push(ruleGroup);
    }
    RULES.keywords[keyword] = true;
    if (!definition)
      return;
    const rule = {
      keyword,
      definition: {
        ...definition,
        type: (0, dataType_1.getJSONTypes)(definition.type),
        schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
      }
    };
    if (definition.before)
      addBeforeRule.call(this, ruleGroup, rule, definition.before);
    else
      ruleGroup.rules.push(rule);
    RULES.all[keyword] = rule;
    (_a = definition.implements) === null || _a === undefined || _a.forEach((kwd) => this.addKeyword(kwd));
  }
  function addBeforeRule(ruleGroup, rule, before) {
    const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
    if (i >= 0) {
      ruleGroup.rules.splice(i, 0, rule);
    } else {
      ruleGroup.rules.push(rule);
      this.logger.warn(`rule ${before} is not defined`);
    }
  }
  function keywordMetaschema(def) {
    let { metaSchema } = def;
    if (metaSchema === undefined)
      return;
    if (def.$data && this.opts.$data)
      metaSchema = schemaOrData(metaSchema);
    def.validateSchema = this.compile(metaSchema, true);
  }
  var $dataRef = {
    $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
  };
  function schemaOrData(schema) {
    return { anyOf: [schema, $dataRef] };
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/core/id.js
var require_id3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var def = {
    keyword: "id",
    code() {
      throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.callRef = exports.getValidate = undefined;
  var ref_error_1 = require_ref_error3();
  var code_1 = require_code6();
  var codegen_1 = require_codegen3();
  var names_1 = require_names3();
  var compile_1 = require_compile3();
  var util_1 = require_util3();
  var def = {
    keyword: "$ref",
    schemaType: "string",
    code(cxt) {
      const { gen, schema: $ref, it: it2 } = cxt;
      const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it2;
      const { root } = env;
      if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
        return callRootRef();
      const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
      if (schOrEnv === undefined)
        throw new ref_error_1.default(it2.opts.uriResolver, baseId, $ref);
      if (schOrEnv instanceof compile_1.SchemaEnv)
        return callValidate(schOrEnv);
      return inlineRefSchema(schOrEnv);
      function callRootRef() {
        if (env === root)
          return callRef(cxt, validateName, env, env.$async);
        const rootName = gen.scopeValue("root", { ref: root });
        return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
      }
      function callValidate(sch) {
        const v2 = getValidate(cxt, sch);
        callRef(cxt, v2, sch, sch.$async);
      }
      function inlineRefSchema(sch) {
        const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
        const valid = gen.name("valid");
        const schCxt = cxt.subschema({
          schema: sch,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: $ref
        }, valid);
        cxt.mergeEvaluated(schCxt);
        cxt.ok(valid);
      }
    }
  };
  function getValidate(cxt, sch) {
    const { gen } = cxt;
    return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
  }
  exports.getValidate = getValidate;
  function callRef(cxt, v2, sch, $async) {
    const { gen, it: it2 } = cxt;
    const { allErrors, schemaEnv: env, opts } = it2;
    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
    if ($async)
      callAsyncRef();
    else
      callSyncRef();
    function callAsyncRef() {
      if (!env.$async)
        throw new Error("async schema referenced by sync schema");
      const valid = gen.let("valid");
      gen.try(() => {
        gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v2, passCxt)}`);
        addEvaluatedFrom(v2);
        if (!allErrors)
          gen.assign(valid, true);
      }, (e) => {
        gen.if((0, codegen_1._)`!(${e} instanceof ${it2.ValidationError})`, () => gen.throw(e));
        addErrorsFrom(e);
        if (!allErrors)
          gen.assign(valid, false);
      });
      cxt.ok(valid);
    }
    function callSyncRef() {
      cxt.result((0, code_1.callValidateCode)(cxt, v2, passCxt), () => addEvaluatedFrom(v2), () => addErrorsFrom(v2));
    }
    function addErrorsFrom(source) {
      const errs = (0, codegen_1._)`${source}.errors`;
      gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
      gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
    }
    function addEvaluatedFrom(source) {
      var _a;
      if (!it2.opts.unevaluated)
        return;
      const schEvaluated = (_a = sch === null || sch === undefined ? undefined : sch.validate) === null || _a === undefined ? undefined : _a.evaluated;
      if (it2.props !== true) {
        if (schEvaluated && !schEvaluated.dynamicProps) {
          if (schEvaluated.props !== undefined) {
            it2.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it2.props);
          }
        } else {
          const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
          it2.props = util_1.mergeEvaluated.props(gen, props, it2.props, codegen_1.Name);
        }
      }
      if (it2.items !== true) {
        if (schEvaluated && !schEvaluated.dynamicItems) {
          if (schEvaluated.items !== undefined) {
            it2.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it2.items);
          }
        } else {
          const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
          it2.items = util_1.mergeEvaluated.items(gen, items, it2.items, codegen_1.Name);
        }
      }
    }
  }
  exports.callRef = callRef;
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/core/index.js
var require_core6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var id_1 = require_id3();
  var ref_1 = require_ref3();
  var core = [
    "$schema",
    "$id",
    "$defs",
    "$vocabulary",
    { keyword: "$comment" },
    "definitions",
    id_1.default,
    ref_1.default
  ];
  exports.default = core;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var ops = codegen_1.operators;
  var KWDs = {
    maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
  };
  var error = {
    message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
  };
  var def = {
    keyword: Object.keys(KWDs),
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
    params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
  };
  var def = {
    keyword: "multipleOf",
    type: "number",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, schemaCode, it: it2 } = cxt;
      const prec = it2.opts.multipleOfPrecision;
      const res = gen.let("res");
      const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
      cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  function ucs2length(str) {
    const len = str.length;
    let length = 0;
    let pos = 0;
    let value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) === 56320)
          pos++;
      }
    }
    return length;
  }
  exports.default = ucs2length;
  ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var ucs2length_1 = require_ucs2length3();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxLength" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxLength", "minLength"],
    type: "string",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode, it: it2 } = cxt;
      const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
      const len = it2.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
      cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code6();
  var codegen_1 = require_codegen3();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
  };
  var def = {
    keyword: "pattern",
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
      const { data, $data, schema, schemaCode, it: it2 } = cxt;
      const u2 = it2.opts.unicodeRegExp ? "u" : "";
      const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1.usePattern)(cxt, schema);
      cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxProperties" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxProperties", "minProperties"],
    type: "object",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code6();
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
    params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
  };
  var def = {
    keyword: "required",
    type: "object",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, schema, schemaCode, data, $data, it: it2 } = cxt;
      const { opts } = it2;
      if (!$data && schema.length === 0)
        return;
      const useLoop = schema.length >= opts.loopRequired;
      if (it2.allErrors)
        allErrorsMode();
      else
        exitOnErrorMode();
      if (opts.strictRequired) {
        const props = cxt.parentSchema.properties;
        const { definedProperties } = cxt.it;
        for (const requiredKey of schema) {
          if ((props === null || props === undefined ? undefined : props[requiredKey]) === undefined && !definedProperties.has(requiredKey)) {
            const schemaPath = it2.schemaEnv.baseId + it2.errSchemaPath;
            const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
            (0, util_1.checkStrictMode)(it2, msg, it2.opts.strictRequired);
          }
        }
      }
      function allErrorsMode() {
        if (useLoop || $data) {
          cxt.block$data(codegen_1.nil, loopAllRequired);
        } else {
          for (const prop of schema) {
            (0, code_1.checkReportMissingProp)(cxt, prop);
          }
        }
      }
      function exitOnErrorMode() {
        const missing = gen.let("missing");
        if (useLoop || $data) {
          const valid = gen.let("valid", true);
          cxt.block$data(valid, () => loopUntilMissing(missing, valid));
          cxt.ok(valid);
        } else {
          gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
      function loopAllRequired() {
        gen.forOf("prop", schemaCode, (prop) => {
          cxt.setParams({ missingProperty: prop });
          gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
        });
      }
      function loopUntilMissing(missing, valid) {
        cxt.setParams({ missingProperty: missing });
        gen.forOf(missing, schemaCode, () => {
          gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error();
            gen.break();
          });
        }, codegen_1.nil);
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var error = {
    message({ keyword, schemaCode }) {
      const comp = keyword === "maxItems" ? "more" : "fewer";
      return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
    },
    params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
  };
  var def = {
    keyword: ["maxItems", "minItems"],
    type: "array",
    schemaType: "number",
    $data: true,
    error,
    code(cxt) {
      const { keyword, data, schemaCode } = cxt;
      const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
      cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/runtime/equal.js
var require_equal3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var equal = require_fast_deep_equal();
  equal.code = 'require("ajv/dist/runtime/equal").default';
  exports.default = equal;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var dataType_1 = require_dataType3();
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var equal_1 = require_equal3();
  var error = {
    message: ({ params: { i, j: j3 } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j3} and ${i} are identical)`,
    params: ({ params: { i, j: j3 } }) => (0, codegen_1._)`{i: ${i}, j: ${j3}}`
  };
  var def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schema, parentSchema, schemaCode, it: it2 } = cxt;
      if (!$data && !schema)
        return;
      const valid = gen.let("valid");
      const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
      cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
      cxt.ok(valid);
      function validateUniqueItems() {
        const i = gen.let("i", (0, codegen_1._)`${data}.length`);
        const j3 = gen.let("j");
        cxt.setParams({ i, j: j3 });
        gen.assign(valid, true);
        gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j3));
      }
      function canOptimize() {
        return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
      }
      function loopN(i, j3) {
        const item = gen.name("item");
        const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it2.opts.strictNumbers, dataType_1.DataType.Wrong);
        const indices = gen.const("indices", (0, codegen_1._)`{}`);
        gen.for((0, codegen_1._)`;${i}--;`, () => {
          gen.let(item, (0, codegen_1._)`${data}[${i}]`);
          gen.if(wrongType, (0, codegen_1._)`continue`);
          if (itemTypes.length > 1)
            gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
          gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
            gen.assign(j3, (0, codegen_1._)`${indices}[${item}]`);
            cxt.error();
            gen.assign(valid, false).break();
          }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
        });
      }
      function loopN2(i, j3) {
        const eql = (0, util_1.useFunc)(gen, equal_1.default);
        const outer = gen.name("outer");
        gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j3} = ${i}; ${j3}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j3}])`, () => {
          cxt.error();
          gen.assign(valid, false).break(outer);
        })));
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var equal_1 = require_equal3();
  var error = {
    message: "must be equal to constant",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
  };
  var def = {
    keyword: "const",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schemaCode, schema } = cxt;
      if ($data || schema && typeof schema == "object") {
        cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
      } else {
        cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var equal_1 = require_equal3();
  var error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    $data: true,
    error,
    code(cxt) {
      const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
      if (!$data && schema.length === 0)
        throw new Error("enum must have non-empty array");
      const useLoop = schema.length >= it2.opts.loopEnum;
      let eql;
      const getEql = () => eql !== null && eql !== undefined ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
      let valid;
      if (useLoop || $data) {
        valid = gen.let("valid");
        cxt.block$data(valid, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const vSchema = gen.const("vSchema", schemaCode);
        valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.assign(valid, false);
        gen.forOf("v", schemaCode, (v2) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v2})`, () => gen.assign(valid, true).break()));
      }
      function equalCode(vSchema, i) {
        const sch = schema[i];
        return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var limitNumber_1 = require_limitNumber3();
  var multipleOf_1 = require_multipleOf3();
  var limitLength_1 = require_limitLength3();
  var pattern_1 = require_pattern3();
  var limitProperties_1 = require_limitProperties3();
  var required_1 = require_required3();
  var limitItems_1 = require_limitItems3();
  var uniqueItems_1 = require_uniqueItems3();
  var const_1 = require_const3();
  var enum_1 = require_enum3();
  var validation = [
    limitNumber_1.default,
    multipleOf_1.default,
    limitLength_1.default,
    pattern_1.default,
    limitProperties_1.default,
    required_1.default,
    limitItems_1.default,
    uniqueItems_1.default,
    { keyword: "type", schemaType: ["string", "array"] },
    { keyword: "nullable", schemaType: "boolean" },
    const_1.default,
    enum_1.default
  ];
  exports.default = validation;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateAdditionalItems = undefined;
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "additionalItems",
    type: "array",
    schemaType: ["boolean", "object"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { parentSchema, it: it2 } = cxt;
      const { items } = parentSchema;
      if (!Array.isArray(items)) {
        (0, util_1.checkStrictMode)(it2, '"additionalItems" is ignored when "items" is not an array of schemas');
        return;
      }
      validateAdditionalItems(cxt, items);
    }
  };
  function validateAdditionalItems(cxt, items) {
    const { gen, schema, data, keyword, it: it2 } = cxt;
    it2.items = true;
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    if (schema === false) {
      cxt.setParams({ len: items.length });
      cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
    } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
      const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
      gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
      cxt.ok(valid);
    }
    function validateItems(valid) {
      gen.forRange("i", items.length, len, (i) => {
        cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
        if (!it2.allErrors)
          gen.if((0, codegen_1.not)(valid), () => gen.break());
      });
    }
  }
  exports.validateAdditionalItems = validateAdditionalItems;
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateTuple = undefined;
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var code_1 = require_code6();
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "array", "boolean"],
    before: "uniqueItems",
    code(cxt) {
      const { schema, it: it2 } = cxt;
      if (Array.isArray(schema))
        return validateTuple(cxt, "additionalItems", schema);
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  function validateTuple(cxt, extraItems, schArr = cxt.schema) {
    const { gen, parentSchema, data, keyword, it: it2 } = cxt;
    checkStrictTuple(parentSchema);
    if (it2.opts.unevaluated && schArr.length && it2.items !== true) {
      it2.items = util_1.mergeEvaluated.items(gen, schArr.length, it2.items);
    }
    const valid = gen.name("valid");
    const len = gen.const("len", (0, codegen_1._)`${data}.length`);
    schArr.forEach((sch, i) => {
      if ((0, util_1.alwaysValidSchema)(it2, sch))
        return;
      gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
        keyword,
        schemaProp: i,
        dataProp: i
      }, valid));
      cxt.ok(valid);
    });
    function checkStrictTuple(sch) {
      const { opts, errSchemaPath } = it2;
      const l3 = schArr.length;
      const fullTuple = l3 === sch.minItems && (l3 === sch.maxItems || sch[extraItems] === false);
      if (opts.strictTuples && !fullTuple) {
        const msg = `"${keyword}" is ${l3}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
        (0, util_1.checkStrictMode)(it2, msg, opts.strictTuples);
      }
    }
  }
  exports.validateTuple = validateTuple;
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var items_1 = require_items3();
  var def = {
    keyword: "prefixItems",
    type: "array",
    schemaType: ["array"],
    before: "uniqueItems",
    code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items20203 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var code_1 = require_code6();
  var additionalItems_1 = require_additionalItems3();
  var error = {
    message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
    params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
  };
  var def = {
    keyword: "items",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    error,
    code(cxt) {
      const { schema, parentSchema, it: it2 } = cxt;
      const { prefixItems } = parentSchema;
      it2.items = true;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      if (prefixItems)
        (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
      else
        cxt.ok((0, code_1.validateArray)(cxt));
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { min, max } }) => max === undefined ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
    params: ({ params: { min, max } }) => max === undefined ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
  };
  var def = {
    keyword: "contains",
    type: "array",
    schemaType: ["object", "boolean"],
    before: "uniqueItems",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data, it: it2 } = cxt;
      let min;
      let max;
      const { minContains, maxContains } = parentSchema;
      if (it2.opts.next) {
        min = minContains === undefined ? 1 : minContains;
        max = maxContains;
      } else {
        min = 1;
      }
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      cxt.setParams({ min, max });
      if (max === undefined && min === 0) {
        (0, util_1.checkStrictMode)(it2, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
        return;
      }
      if (max !== undefined && min > max) {
        (0, util_1.checkStrictMode)(it2, `"minContains" > "maxContains" is always invalid`);
        cxt.fail();
        return;
      }
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        let cond = (0, codegen_1._)`${len} >= ${min}`;
        if (max !== undefined)
          cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
        cxt.pass(cond);
        return;
      }
      it2.items = true;
      const valid = gen.name("valid");
      if (max === undefined && min === 1) {
        validateItems(valid, () => gen.if(valid, () => gen.break()));
      } else if (min === 0) {
        gen.let(valid, true);
        if (max !== undefined)
          gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
      } else {
        gen.let(valid, false);
        validateItemsWithCount();
      }
      cxt.result(valid, () => cxt.reset());
      function validateItemsWithCount() {
        const schValid = gen.name("_valid");
        const count = gen.let("count", 0);
        validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
      }
      function validateItems(_valid, block) {
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword: "contains",
            dataProp: i,
            dataPropType: util_1.Type.Num,
            compositeRule: true
          }, _valid);
          block();
        });
      }
      function checkLimits(count) {
        gen.code((0, codegen_1._)`${count}++`);
        if (max === undefined) {
          gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
        } else {
          gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
          if (min === 1)
            gen.assign(valid, true);
          else
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = undefined;
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var code_1 = require_code6();
  exports.error = {
    message: ({ params: { property, depsCount, deps } }) => {
      const property_ies = depsCount === 1 ? "property" : "properties";
      return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
    },
    params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
  };
  var def = {
    keyword: "dependencies",
    type: "object",
    schemaType: "object",
    error: exports.error,
    code(cxt) {
      const [propDeps, schDeps] = splitDependencies(cxt);
      validatePropertyDeps(cxt, propDeps);
      validateSchemaDeps(cxt, schDeps);
    }
  };
  function splitDependencies({ schema }) {
    const propertyDeps = {};
    const schemaDeps = {};
    for (const key in schema) {
      if (key === "__proto__")
        continue;
      const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
      deps[key] = schema[key];
    }
    return [propertyDeps, schemaDeps];
  }
  function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
    const { gen, data, it: it2 } = cxt;
    if (Object.keys(propertyDeps).length === 0)
      return;
    const missing = gen.let("missing");
    for (const prop in propertyDeps) {
      const deps = propertyDeps[prop];
      if (deps.length === 0)
        continue;
      const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties);
      cxt.setParams({
        property: prop,
        depsCount: deps.length,
        deps: deps.join(", ")
      });
      if (it2.allErrors) {
        gen.if(hasProperty, () => {
          for (const depProp of deps) {
            (0, code_1.checkReportMissingProp)(cxt, depProp);
          }
        });
      } else {
        gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
        (0, code_1.reportMissingProp)(cxt, missing);
        gen.else();
      }
    }
  }
  exports.validatePropertyDeps = validatePropertyDeps;
  function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
    const { gen, data, keyword, it: it2 } = cxt;
    const valid = gen.name("valid");
    for (const prop in schemaDeps) {
      if ((0, util_1.alwaysValidSchema)(it2, schemaDeps[prop]))
        continue;
      gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties), () => {
        const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
        cxt.mergeValidEvaluated(schCxt, valid);
      }, () => gen.var(valid, true));
      cxt.ok(valid);
    }
  }
  exports.validateSchemaDeps = validateSchemaDeps;
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var error = {
    message: "property name must be valid",
    params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
  };
  var def = {
    keyword: "propertyNames",
    type: "object",
    schemaType: ["object", "boolean"],
    error,
    code(cxt) {
      const { gen, schema, data, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const valid = gen.name("valid");
      gen.forIn("key", data, (key) => {
        cxt.setParams({ propertyName: key });
        cxt.subschema({
          keyword: "propertyNames",
          data: key,
          dataTypes: ["string"],
          propertyName: key,
          compositeRule: true
        }, valid);
        gen.if((0, codegen_1.not)(valid), () => {
          cxt.error(true);
          if (!it2.allErrors)
            gen.break();
        });
      });
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code6();
  var codegen_1 = require_codegen3();
  var names_1 = require_names3();
  var util_1 = require_util3();
  var error = {
    message: "must NOT have additional properties",
    params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
  };
  var def = {
    keyword: "additionalProperties",
    type: ["object"],
    schemaType: ["boolean", "object"],
    allowUndefined: true,
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, data, errsCount, it: it2 } = cxt;
      if (!errsCount)
        throw new Error("ajv implementation error");
      const { allErrors, opts } = it2;
      it2.props = true;
      if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
      const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
      checkAdditionalProperties();
      cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      function checkAdditionalProperties() {
        gen.forIn("key", data, (key) => {
          if (!props.length && !patProps.length)
            additionalPropertyCode(key);
          else
            gen.if(isAdditional(key), () => additionalPropertyCode(key));
        });
      }
      function isAdditional(key) {
        let definedProp;
        if (props.length > 8) {
          const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema.properties, "properties");
          definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
        } else if (props.length) {
          definedProp = (0, codegen_1.or)(...props.map((p3) => (0, codegen_1._)`${key} === ${p3}`));
        } else {
          definedProp = codegen_1.nil;
        }
        if (patProps.length) {
          definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p3) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p3)}.test(${key})`));
        }
        return (0, codegen_1.not)(definedProp);
      }
      function deleteAdditional(key) {
        gen.code((0, codegen_1._)`delete ${data}[${key}]`);
      }
      function additionalPropertyCode(key) {
        if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
          deleteAdditional(key);
          return;
        }
        if (schema === false) {
          cxt.setParams({ additionalProperty: key });
          cxt.error();
          if (!allErrors)
            gen.break();
          return;
        }
        if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it2, schema)) {
          const valid = gen.name("valid");
          if (opts.removeAdditional === "failing") {
            applyAdditionalSchema(key, valid, false);
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset();
              deleteAdditional(key);
            });
          } else {
            applyAdditionalSchema(key, valid);
            if (!allErrors)
              gen.if((0, codegen_1.not)(valid), () => gen.break());
          }
        }
      }
      function applyAdditionalSchema(key, valid, errors) {
        const subschema = {
          keyword: "additionalProperties",
          dataProp: key,
          dataPropType: util_1.Type.Str
        };
        if (errors === false) {
          Object.assign(subschema, {
            compositeRule: true,
            createErrors: false,
            allErrors: false
          });
        }
        cxt.subschema(subschema, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var validate_1 = require_validate3();
  var code_1 = require_code6();
  var util_1 = require_util3();
  var additionalProperties_1 = require_additionalProperties3();
  var def = {
    keyword: "properties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, parentSchema, data, it: it2 } = cxt;
      if (it2.opts.removeAdditional === "all" && parentSchema.additionalProperties === undefined) {
        additionalProperties_1.default.code(new validate_1.KeywordCxt(it2, additionalProperties_1.default, "additionalProperties"));
      }
      const allProps = (0, code_1.allSchemaProperties)(schema);
      for (const prop of allProps) {
        it2.definedProperties.add(prop);
      }
      if (it2.opts.unevaluated && allProps.length && it2.props !== true) {
        it2.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it2.props);
      }
      const properties = allProps.filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schema[p3]));
      if (properties.length === 0)
        return;
      const valid = gen.name("valid");
      for (const prop of properties) {
        if (hasDefault(prop)) {
          applyPropertySchema(prop);
        } else {
          gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties));
          applyPropertySchema(prop);
          if (!it2.allErrors)
            gen.else().var(valid, true);
          gen.endIf();
        }
        cxt.it.definedProperties.add(prop);
        cxt.ok(valid);
      }
      function hasDefault(prop) {
        return it2.opts.useDefaults && !it2.compositeRule && schema[prop].default !== undefined;
      }
      function applyPropertySchema(prop) {
        cxt.subschema({
          keyword: "properties",
          schemaProp: prop,
          dataProp: prop
        }, valid);
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code6();
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var util_2 = require_util3();
  var def = {
    keyword: "patternProperties",
    type: "object",
    schemaType: "object",
    code(cxt) {
      const { gen, schema, data, parentSchema, it: it2 } = cxt;
      const { opts } = it2;
      const patterns = (0, code_1.allSchemaProperties)(schema);
      const alwaysValidPatterns = patterns.filter((p3) => (0, util_1.alwaysValidSchema)(it2, schema[p3]));
      if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it2.opts.unevaluated || it2.props === true)) {
        return;
      }
      const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
      const valid = gen.name("valid");
      if (it2.props !== true && !(it2.props instanceof codegen_1.Name)) {
        it2.props = (0, util_2.evaluatedPropsToName)(gen, it2.props);
      }
      const { props } = it2;
      validatePatternProperties();
      function validatePatternProperties() {
        for (const pat of patterns) {
          if (checkProperties)
            checkMatchingProperties(pat);
          if (it2.allErrors) {
            validateProperties(pat);
          } else {
            gen.var(valid, true);
            validateProperties(pat);
            gen.if(valid);
          }
        }
      }
      function checkMatchingProperties(pat) {
        for (const prop in checkProperties) {
          if (new RegExp(pat).test(prop)) {
            (0, util_1.checkStrictMode)(it2, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
          }
        }
      }
      function validateProperties(pat) {
        gen.forIn("key", data, (key) => {
          gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
            const alwaysValid = alwaysValidPatterns.includes(pat);
            if (!alwaysValid) {
              cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid);
            }
            if (it2.opts.unevaluated && props !== true) {
              gen.assign((0, codegen_1._)`${props}[${key}]`, true);
            } else if (!alwaysValid && !it2.allErrors) {
              gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var def = {
    keyword: "not",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        cxt.fail();
        return;
      }
      const valid = gen.name("valid");
      cxt.subschema({
        keyword: "not",
        compositeRule: true,
        createErrors: false,
        allErrors: false
      }, valid);
      cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
    },
    error: { message: "must NOT be valid" }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code6();
  var def = {
    keyword: "anyOf",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in anyOf" }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var error = {
    message: "must match exactly one schema in oneOf",
    params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
  };
  var def = {
    keyword: "oneOf",
    schemaType: "array",
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, schema, parentSchema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (it2.opts.discriminator && parentSchema.discriminator)
        return;
      const schArr = schema;
      const valid = gen.let("valid", false);
      const passing = gen.let("passing", null);
      const schValid = gen.name("_valid");
      cxt.setParams({ passing });
      gen.block(validateOneOf);
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
      function validateOneOf() {
        schArr.forEach((sch, i) => {
          let schCxt;
          if ((0, util_1.alwaysValidSchema)(it2, sch)) {
            gen.var(schValid, true);
          } else {
            schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true
            }, schValid);
          }
          if (i > 0) {
            gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
          }
          gen.if(schValid, () => {
            gen.assign(valid, true);
            gen.assign(passing, i);
            if (schCxt)
              cxt.mergeEvaluated(schCxt, codegen_1.Name);
          });
        });
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var def = {
    keyword: "allOf",
    schemaType: "array",
    code(cxt) {
      const { gen, schema, it: it2 } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const valid = gen.name("valid");
      schema.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it2, sch))
          return;
        const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
        cxt.ok(valid);
        cxt.mergeEvaluated(schCxt);
      });
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var util_1 = require_util3();
  var error = {
    message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
    params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
  };
  var def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
      const { gen, parentSchema, it: it2 } = cxt;
      if (parentSchema.then === undefined && parentSchema.else === undefined) {
        (0, util_1.checkStrictMode)(it2, '"if" without "then" and "else" is ignored');
      }
      const hasThen = hasSchema(it2, "then");
      const hasElse = hasSchema(it2, "else");
      if (!hasThen && !hasElse)
        return;
      const valid = gen.let("valid", true);
      const schValid = gen.name("_valid");
      validateIf();
      cxt.reset();
      if (hasThen && hasElse) {
        const ifClause = gen.let("ifClause");
        cxt.setParams({ ifClause });
        gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
      } else if (hasThen) {
        gen.if(schValid, validateClause("then"));
      } else {
        gen.if((0, codegen_1.not)(schValid), validateClause("else"));
      }
      cxt.pass(valid, () => cxt.error(true));
      function validateIf() {
        const schCxt = cxt.subschema({
          keyword: "if",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, schValid);
        cxt.mergeEvaluated(schCxt);
      }
      function validateClause(keyword, ifClause) {
        return () => {
          const schCxt = cxt.subschema({ keyword }, schValid);
          gen.assign(valid, schValid);
          cxt.mergeValidEvaluated(schCxt, valid);
          if (ifClause)
            gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
          else
            cxt.setParams({ ifClause: keyword });
        };
      }
    }
  };
  function hasSchema(it2, keyword) {
    const schema = it2.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it2, schema);
  }
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var def = {
    keyword: ["then", "else"],
    schemaType: ["object", "boolean"],
    code({ keyword, parentSchema, it: it2 }) {
      if (parentSchema.if === undefined)
        (0, util_1.checkStrictMode)(it2, `"${keyword}" without "if" is ignored`);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var additionalItems_1 = require_additionalItems3();
  var prefixItems_1 = require_prefixItems3();
  var items_1 = require_items3();
  var items2020_1 = require_items20203();
  var contains_1 = require_contains3();
  var dependencies_1 = require_dependencies3();
  var propertyNames_1 = require_propertyNames3();
  var additionalProperties_1 = require_additionalProperties3();
  var properties_1 = require_properties3();
  var patternProperties_1 = require_patternProperties3();
  var not_1 = require_not3();
  var anyOf_1 = require_anyOf3();
  var oneOf_1 = require_oneOf3();
  var allOf_1 = require_allOf3();
  var if_1 = require_if3();
  var thenElse_1 = require_thenElse3();
  function getApplicator(draft2020 = false) {
    const applicator = [
      not_1.default,
      anyOf_1.default,
      oneOf_1.default,
      allOf_1.default,
      if_1.default,
      thenElse_1.default,
      propertyNames_1.default,
      additionalProperties_1.default,
      dependencies_1.default,
      properties_1.default,
      patternProperties_1.default
    ];
    if (draft2020)
      applicator.push(prefixItems_1.default, items2020_1.default);
    else
      applicator.push(additionalItems_1.default, items_1.default);
    applicator.push(contains_1.default);
    return applicator;
  }
  exports.default = getApplicator;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/format/format.js
var require_format5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var error = {
    message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
    params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
  };
  var def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
      const { gen, data, $data, schema, schemaCode, it: it2 } = cxt;
      const { opts, errSchemaPath, schemaEnv, self: self2 } = it2;
      if (!opts.validateFormats)
        return;
      if ($data)
        validate$DataFormat();
      else
        validateFormat();
      function validate$DataFormat() {
        const fmts = gen.scopeValue("formats", {
          ref: self2.formats,
          code: opts.code.formats
        });
        const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
        const fType = gen.let("fType");
        const format = gen.let("format");
        gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
        cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
        function unknownFmt() {
          if (opts.strictSchema === false)
            return codegen_1.nil;
          return (0, codegen_1._)`${schemaCode} && !${format}`;
        }
        function invalidFmt() {
          const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
          const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
          return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
        }
      }
      function validateFormat() {
        const formatDef = self2.formats[schema];
        if (!formatDef) {
          unknownFormat();
          return;
        }
        if (formatDef === true)
          return;
        const [fmtType, format, fmtRef] = getFormat(formatDef);
        if (fmtType === ruleType)
          cxt.pass(validCondition());
        function unknownFormat() {
          if (opts.strictSchema === false) {
            self2.logger.warn(unknownMsg());
            return;
          }
          throw new Error(unknownMsg());
          function unknownMsg() {
            return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
          }
        }
        function getFormat(fmtDef) {
          const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : undefined;
          const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
          if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
            return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
          }
          return ["string", fmtDef, fmt];
        }
        function validCondition() {
          if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
            if (!schemaEnv.$async)
              throw new Error("async format in sync schema");
            return (0, codegen_1._)`await ${fmtRef}(${data})`;
          }
          return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/format/index.js
var require_format6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var format_1 = require_format5();
  var format = [format_1.default];
  exports.default = format;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.contentVocabulary = exports.metadataVocabulary = undefined;
  exports.metadataVocabulary = [
    "title",
    "description",
    "default",
    "deprecated",
    "readOnly",
    "writeOnly",
    "examples"
  ];
  exports.contentVocabulary = [
    "contentMediaType",
    "contentEncoding",
    "contentSchema"
  ];
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft73 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var core_1 = require_core6();
  var validation_1 = require_validation4();
  var applicator_1 = require_applicator3();
  var format_1 = require_format6();
  var metadata_1 = require_metadata3();
  var draft7Vocabularies = [
    core_1.default,
    validation_1.default,
    (0, applicator_1.default)(),
    format_1.default,
    metadata_1.metadataVocabulary,
    metadata_1.contentVocabulary
  ];
  exports.default = draft7Vocabularies;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DiscrError = undefined;
  var DiscrError;
  (function(DiscrError2) {
    DiscrError2["Tag"] = "tag";
    DiscrError2["Mapping"] = "mapping";
  })(DiscrError || (exports.DiscrError = DiscrError = {}));
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var types_1 = require_types3();
  var compile_1 = require_compile3();
  var ref_error_1 = require_ref_error3();
  var util_1 = require_util3();
  var error = {
    message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
  };
  var def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
      const { gen, data, schema, parentSchema, it: it2 } = cxt;
      const { oneOf } = parentSchema;
      if (!it2.opts.discriminator) {
        throw new Error("discriminator: requires discriminator option");
      }
      const tagName = schema.propertyName;
      if (typeof tagName != "string")
        throw new Error("discriminator: requires propertyName");
      if (schema.mapping)
        throw new Error("discriminator: mapping is not supported");
      if (!oneOf)
        throw new Error("discriminator: requires oneOf keyword");
      const valid = gen.let("valid", false);
      const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
      gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
      cxt.ok(valid);
      function validateMapping() {
        const mapping = getMapping();
        gen.if(false);
        for (const tagValue in mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(mapping[tagValue]));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
        cxt.mergeEvaluated(schCxt, codegen_1.Name);
        return _valid;
      }
      function getMapping() {
        var _a;
        const oneOfMapping = {};
        const topRequired = hasRequired(parentSchema);
        let tagRequired = true;
        for (let i = 0;i < oneOf.length; i++) {
          let sch = oneOf[i];
          if ((sch === null || sch === undefined ? undefined : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it2.self.RULES)) {
            const ref = sch.$ref;
            sch = compile_1.resolveRef.call(it2.self, it2.schemaEnv.root, it2.baseId, ref);
            if (sch instanceof compile_1.SchemaEnv)
              sch = sch.schema;
            if (sch === undefined)
              throw new ref_error_1.default(it2.opts.uriResolver, it2.baseId, ref);
          }
          const propSch = (_a = sch === null || sch === undefined ? undefined : sch.properties) === null || _a === undefined ? undefined : _a[tagName];
          if (typeof propSch != "object") {
            throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
          }
          tagRequired = tagRequired && (topRequired || hasRequired(sch));
          addMappings(propSch, i);
        }
        if (!tagRequired)
          throw new Error(`discriminator: "${tagName}" must be required`);
        return oneOfMapping;
        function hasRequired({ required }) {
          return Array.isArray(required) && required.includes(tagName);
        }
        function addMappings(sch, i) {
          if (sch.const) {
            addMapping(sch.const, i);
          } else if (sch.enum) {
            for (const tagValue of sch.enum) {
              addMapping(tagValue, i);
            }
          } else {
            throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
        }
        function addMapping(tagValue, i) {
          if (typeof tagValue != "string" || tagValue in oneOfMapping) {
            throw new Error(`discriminator: "${tagName}" values must be unique strings`);
          }
          oneOfMapping[tagValue] = i;
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_073 = __commonJS((exports, module) => {
  module.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: { $ref: "#" }
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: { type: "string" },
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: { $ref: "#/definitions/nonNegativeInteger" },
      minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: { $ref: "#" },
      items: {
        anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
        default: true
      },
      maxItems: { $ref: "#/definitions/nonNegativeInteger" },
      minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: { $ref: "#" },
      maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
      minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
      required: { $ref: "#/definitions/stringArray" },
      additionalProperties: { $ref: "#" },
      definitions: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: { $ref: "#" },
        propertyNames: { format: "regex" },
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
        }
      },
      propertyNames: { $ref: "#" },
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          { $ref: "#/definitions/simpleTypes" },
          {
            type: "array",
            items: { $ref: "#/definitions/simpleTypes" },
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: { type: "string" },
      contentMediaType: { type: "string" },
      contentEncoding: { type: "string" },
      if: { $ref: "#" },
      then: { $ref: "#" },
      else: { $ref: "#" },
      allOf: { $ref: "#/definitions/schemaArray" },
      anyOf: { $ref: "#/definitions/schemaArray" },
      oneOf: { $ref: "#/definitions/schemaArray" },
      not: { $ref: "#" }
    },
    default: true
  };
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/ajv.js
var require_ajv3 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = undefined;
  var core_1 = require_core5();
  var draft7_1 = require_draft73();
  var discriminator_1 = require_discriminator3();
  var draft7MetaSchema = require_json_schema_draft_073();
  var META_SUPPORT_DATA = ["/properties"];
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";

  class Ajv extends core_1.default {
    _addVocabularies() {
      super._addVocabularies();
      draft7_1.default.forEach((v2) => this.addVocabulary(v2));
      if (this.opts.discriminator)
        this.addKeyword(discriminator_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
      this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
      this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
  }
  exports.Ajv = Ajv;
  module.exports = exports = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate3();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen3();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error3();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error3();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/metadata.js
var require_metadata4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkMetadata = undefined;
  var util_1 = require_util3();
  var def = {
    keyword: "metadata",
    schemaType: "object",
    code(cxt) {
      checkMetadata(cxt);
      const { gen, schema, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const valid = gen.name("valid");
      cxt.subschema({ keyword: "metadata", jtdMetadata: true }, valid);
      cxt.ok(valid);
    }
  };
  function checkMetadata({ it: it2, keyword }, metadata) {
    if (it2.jtdMetadata !== metadata) {
      throw new Error(`JTD: "${keyword}" cannot be used in this schema location`);
    }
  }
  exports.checkMetadata = checkMetadata;
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/ref.js
var require_ref4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasRef = undefined;
  var compile_1 = require_compile3();
  var codegen_1 = require_codegen3();
  var ref_error_1 = require_ref_error3();
  var names_1 = require_names3();
  var ref_1 = require_ref3();
  var metadata_1 = require_metadata4();
  var def = {
    keyword: "ref",
    schemaType: "string",
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema: ref, parentSchema, it: it2 } = cxt;
      const { schemaEnv: { root } } = it2;
      const valid = gen.name("valid");
      if (parentSchema.nullable) {
        gen.var(valid, (0, codegen_1._)`${data} === null`);
        gen.if((0, codegen_1.not)(valid), validateJtdRef);
      } else {
        gen.var(valid, false);
        validateJtdRef();
      }
      cxt.ok(valid);
      function validateJtdRef() {
        var _a;
        const refSchema = (_a = root.schema.definitions) === null || _a === undefined ? undefined : _a[ref];
        if (!refSchema) {
          throw new ref_error_1.default(it2.opts.uriResolver, "", ref, `No definition ${ref}`);
        }
        if (hasRef(refSchema) || !it2.opts.inlineRefs)
          callValidate(refSchema);
        else
          inlineRefSchema(refSchema);
      }
      function callValidate(schema) {
        const sch = compile_1.compileSchema.call(it2.self, new compile_1.SchemaEnv({ schema, root, schemaPath: `/definitions/${ref}` }));
        const v2 = (0, ref_1.getValidate)(cxt, sch);
        const errsCount = gen.const("_errs", names_1.default.errors);
        (0, ref_1.callRef)(cxt, v2, sch, sch.$async);
        gen.assign(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
      }
      function inlineRefSchema(schema) {
        const schName = gen.scopeValue("schema", it2.opts.code.source === true ? { ref: schema, code: (0, codegen_1.stringify)(schema) } : { ref: schema });
        cxt.subschema({
          schema,
          dataTypes: [],
          schemaPath: codegen_1.nil,
          topSchemaRef: schName,
          errSchemaPath: `/definitions/${ref}`
        }, valid);
      }
    }
  };
  function hasRef(schema) {
    for (const key in schema) {
      let sch;
      if (key === "ref" || typeof (sch = schema[key]) == "object" && hasRef(sch))
        return true;
    }
    return false;
  }
  exports.hasRef = hasRef;
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/runtime/timestamp.js
var require_timestamp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var DT_SEPARATOR = /t|\s/i;
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var TIME = /^(\d\d):(\d\d):(\d\d)(?:\.\d+)?(?:z|([+-]\d\d)(?::?(\d\d))?)$/i;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function validTimestamp(str, allowDate) {
    const dt3 = str.split(DT_SEPARATOR);
    return dt3.length === 2 && validDate(dt3[0]) && validTime(dt3[1]) || allowDate && dt3.length === 1 && validDate(dt3[0]);
  }
  exports.default = validTimestamp;
  function validDate(str) {
    const matches = DATE.exec(str);
    if (!matches)
      return false;
    const y3 = +matches[1];
    const m3 = +matches[2];
    const d3 = +matches[3];
    return m3 >= 1 && m3 <= 12 && d3 >= 1 && (d3 <= DAYS[m3] || m3 === 2 && d3 === 29 && (y3 % 100 === 0 ? y3 % 400 === 0 : y3 % 4 === 0));
  }
  function validTime(str) {
    const matches = TIME.exec(str);
    if (!matches)
      return false;
    const hr3 = +matches[1];
    const min = +matches[2];
    const sec = +matches[3];
    const tzH = +(matches[4] || 0);
    const tzM = +(matches[5] || 0);
    return hr3 <= 23 && min <= 59 && sec <= 59 || hr3 - tzH === 23 && min - tzM === 59 && sec === 60;
  }
  validTimestamp.code = 'require("ajv/dist/runtime/timestamp").default';
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/error.js
var require_error2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.typeErrorParams = exports.typeErrorMessage = exports.typeError = undefined;
  var codegen_1 = require_codegen3();
  function typeError(t) {
    return {
      message: (cxt) => typeErrorMessage(cxt, t),
      params: (cxt) => typeErrorParams(cxt, t)
    };
  }
  exports.typeError = typeError;
  function typeErrorMessage({ parentSchema }, t) {
    return (parentSchema === null || parentSchema === undefined ? undefined : parentSchema.nullable) ? `must be ${t} or null` : `must be ${t}`;
  }
  exports.typeErrorMessage = typeErrorMessage;
  function typeErrorParams({ parentSchema }, t) {
    return (0, codegen_1._)`{type: ${t}, nullable: ${!!(parentSchema === null || parentSchema === undefined ? undefined : parentSchema.nullable)}}`;
  }
  exports.typeErrorParams = typeErrorParams;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/type.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.intRange = undefined;
  var codegen_1 = require_codegen3();
  var timestamp_1 = require_timestamp();
  var util_1 = require_util3();
  var metadata_1 = require_metadata4();
  var error_1 = require_error2();
  exports.intRange = {
    int8: [-128, 127, 3],
    uint8: [0, 255, 3],
    int16: [-32768, 32767, 5],
    uint16: [0, 65535, 5],
    int32: [-2147483648, 2147483647, 10],
    uint32: [0, 4294967295, 10]
  };
  var error = {
    message: (cxt) => (0, error_1.typeErrorMessage)(cxt, cxt.schema),
    params: (cxt) => (0, error_1.typeErrorParams)(cxt, cxt.schema)
  };
  function timestampCode(cxt) {
    const { gen, data, it: it2 } = cxt;
    const { timestamp, allowDate } = it2.opts;
    if (timestamp === "date")
      return (0, codegen_1._)`${data} instanceof Date `;
    const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
    const allowDateArg = allowDate ? (0, codegen_1._)`, true` : codegen_1.nil;
    const validString = (0, codegen_1._)`typeof ${data} == "string" && ${vts}(${data}${allowDateArg})`;
    return timestamp === "string" ? validString : (0, codegen_1.or)((0, codegen_1._)`${data} instanceof Date`, validString);
  }
  var def = {
    keyword: "type",
    schemaType: "string",
    error,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { data, schema, parentSchema, it: it2 } = cxt;
      let cond;
      switch (schema) {
        case "boolean":
        case "string":
          cond = (0, codegen_1._)`typeof ${data} == ${schema}`;
          break;
        case "timestamp": {
          cond = timestampCode(cxt);
          break;
        }
        case "float32":
        case "float64":
          cond = (0, codegen_1._)`typeof ${data} == "number"`;
          break;
        default: {
          const sch = schema;
          cond = (0, codegen_1._)`typeof ${data} == "number" && isFinite(${data}) && !(${data} % 1)`;
          if (!it2.opts.int32range && (sch === "int32" || sch === "uint32")) {
            if (sch === "uint32")
              cond = (0, codegen_1._)`${cond} && ${data} >= 0`;
          } else {
            const [min, max] = exports.intRange[sch];
            cond = (0, codegen_1._)`${cond} && ${data} >= ${min} && ${data} <= ${max}`;
          }
        }
      }
      cxt.pass(parentSchema.nullable ? (0, codegen_1.or)((0, codegen_1._)`${data} === null`, cond) : cond);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/nullable.js
var require_nullable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.checkNullableObject = exports.checkNullable = undefined;
  var codegen_1 = require_codegen3();
  function checkNullable({ gen, data, parentSchema }, cond = codegen_1.nil) {
    const valid = gen.name("valid");
    if (parentSchema.nullable) {
      gen.let(valid, (0, codegen_1._)`${data} === null`);
      cond = (0, codegen_1.not)(valid);
    } else {
      gen.let(valid, false);
    }
    return [valid, cond];
  }
  exports.checkNullable = checkNullable;
  function checkNullableObject(cxt, cond) {
    const [valid, cond_] = checkNullable(cxt, cond);
    return [valid, (0, codegen_1._)`${cond_} && typeof ${cxt.data} == "object" && !Array.isArray(${cxt.data})`];
  }
  exports.checkNullableObject = checkNullableObject;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/enum.js
var require_enum4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
  };
  var def = {
    keyword: "enum",
    schemaType: "array",
    error,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, schemaValue, parentSchema, it: it2 } = cxt;
      if (schema.length === 0)
        throw new Error("enum must have non-empty array");
      if (schema.length !== new Set(schema).size)
        throw new Error("enum items must be unique");
      let valid;
      const isString = (0, codegen_1._)`typeof ${data} == "string"`;
      if (schema.length >= it2.opts.loopEnum) {
        let cond;
        [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
        gen.if(cond, loopEnum);
      } else {
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._)`${data} === ${value}`)));
        if (parentSchema.nullable)
          valid = (0, codegen_1.or)((0, codegen_1._)`${data} === null`, valid);
      }
      cxt.pass(valid);
      function loopEnum() {
        gen.forOf("v", schemaValue, (v2) => gen.if((0, codegen_1._)`${valid} = ${data} === ${v2}`, () => gen.break()));
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/elements.js
var require_elements = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var code_1 = require_code6();
  var codegen_1 = require_codegen3();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error2();
  var def = {
    keyword: "elements",
    schemaType: "object",
    error: (0, error_1.typeError)("array"),
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, it: it2 } = cxt;
      if ((0, util_1.alwaysValidSchema)(it2, schema))
        return;
      const [valid] = (0, nullable_1.checkNullable)(cxt);
      gen.if((0, codegen_1.not)(valid), () => gen.if((0, codegen_1._)`Array.isArray(${data})`, () => gen.assign(valid, (0, code_1.validateArray)(cxt)), () => cxt.error()));
      cxt.ok(valid);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/properties.js
var require_properties4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateProperties = exports.error = undefined;
  var code_1 = require_code6();
  var util_1 = require_util3();
  var codegen_1 = require_codegen3();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error2();
  var PropError;
  (function(PropError2) {
    PropError2["Additional"] = "additional";
    PropError2["Missing"] = "missing";
  })(PropError || (PropError = {}));
  exports.error = {
    message: (cxt) => {
      const { params } = cxt;
      return params.propError ? params.propError === PropError.Additional ? "must NOT have additional properties" : `must have property '${params.missingProperty}'` : (0, error_1.typeErrorMessage)(cxt, "object");
    },
    params: (cxt) => {
      const { params } = cxt;
      return params.propError ? params.propError === PropError.Additional ? (0, codegen_1._)`{error: ${params.propError}, additionalProperty: ${params.additionalProperty}}` : (0, codegen_1._)`{error: ${params.propError}, missingProperty: ${params.missingProperty}}` : (0, error_1.typeErrorParams)(cxt, "object");
    }
  };
  var def = {
    keyword: "properties",
    schemaType: "object",
    error: exports.error,
    code: validateProperties
  };
  function validateProperties(cxt) {
    (0, metadata_1.checkMetadata)(cxt);
    const { gen, data, parentSchema, it: it2 } = cxt;
    const { additionalProperties, nullable } = parentSchema;
    if (it2.jtdDiscriminator && nullable)
      throw new Error("JTD: nullable inside discriminator mapping");
    if (commonProperties()) {
      throw new Error("JTD: properties and optionalProperties have common members");
    }
    const [allProps, properties] = schemaProperties("properties");
    const [allOptProps, optProperties] = schemaProperties("optionalProperties");
    if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
      return;
    }
    const [valid, cond] = it2.jtdDiscriminator === undefined ? (0, nullable_1.checkNullableObject)(cxt, data) : [gen.let("valid", false), true];
    gen.if(cond, () => gen.assign(valid, true).block(() => {
      validateProps(properties, "properties", true);
      validateProps(optProperties, "optionalProperties");
      if (!additionalProperties)
        validateAdditional();
    }));
    cxt.pass(valid);
    function commonProperties() {
      const props = parentSchema.properties;
      const optProps = parentSchema.optionalProperties;
      if (!(props && optProps))
        return false;
      for (const p3 in props) {
        if (Object.prototype.hasOwnProperty.call(optProps, p3))
          return true;
      }
      return false;
    }
    function schemaProperties(keyword) {
      const schema = parentSchema[keyword];
      const allPs = schema ? (0, code_1.allSchemaProperties)(schema) : [];
      if (it2.jtdDiscriminator && allPs.some((p3) => p3 === it2.jtdDiscriminator)) {
        throw new Error(`JTD: discriminator tag used in ${keyword}`);
      }
      const ps = allPs.filter((p3) => !(0, util_1.alwaysValidSchema)(it2, schema[p3]));
      return [allPs, ps];
    }
    function validateProps(props, keyword, required) {
      const _valid = gen.var("valid");
      for (const prop of props) {
        gen.if((0, code_1.propertyInData)(gen, data, prop, it2.opts.ownProperties), () => applyPropertySchema(prop, keyword, _valid), () => missingProperty(prop));
        cxt.ok(_valid);
      }
      function missingProperty(prop) {
        if (required) {
          gen.assign(_valid, false);
          cxt.error(false, { propError: PropError.Missing, missingProperty: prop }, { schemaPath: prop });
        } else {
          gen.assign(_valid, true);
        }
      }
    }
    function applyPropertySchema(prop, keyword, _valid) {
      cxt.subschema({
        keyword,
        schemaProp: prop,
        dataProp: prop
      }, _valid);
    }
    function validateAdditional() {
      gen.forIn("key", data, (key) => {
        const addProp = isAdditional(key, allProps, "properties", it2.jtdDiscriminator);
        const addOptProp = isAdditional(key, allOptProps, "optionalProperties");
        const extra = addProp === true ? addOptProp : addOptProp === true ? addProp : (0, codegen_1.and)(addProp, addOptProp);
        gen.if(extra, () => {
          if (it2.opts.removeAdditional) {
            gen.code((0, codegen_1._)`delete ${data}[${key}]`);
          } else {
            cxt.error(false, { propError: PropError.Additional, additionalProperty: key }, { instancePath: key, parentSchema: true });
            if (!it2.opts.allErrors)
              gen.break();
          }
        });
      });
    }
    function isAdditional(key, props, keyword, jtdDiscriminator) {
      let additional;
      if (props.length > 8) {
        const propsSchema = (0, util_1.schemaRefOrVal)(it2, parentSchema[keyword], keyword);
        additional = (0, codegen_1.not)((0, code_1.isOwnProperty)(gen, propsSchema, key));
        if (jtdDiscriminator !== undefined) {
          additional = (0, codegen_1.and)(additional, (0, codegen_1._)`${key} !== ${jtdDiscriminator}`);
        }
      } else if (props.length || jtdDiscriminator !== undefined) {
        const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props);
        additional = (0, codegen_1.and)(...ps.map((p3) => (0, codegen_1._)`${key} !== ${p3}`));
      } else {
        additional = true;
      }
      return additional;
    }
  }
  exports.validateProperties = validateProperties;
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/optionalProperties.js
var require_optionalProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var properties_1 = require_properties4();
  var def = {
    keyword: "optionalProperties",
    schemaType: "object",
    error: properties_1.error,
    code(cxt) {
      if (cxt.parentSchema.properties)
        return;
      (0, properties_1.validateProperties)(cxt);
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/discriminator.js
var require_discriminator4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var codegen_1 = require_codegen3();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error2();
  var types_1 = require_types3();
  var error = {
    message: (cxt) => {
      const { schema, params } = cxt;
      return params.discrError ? params.discrError === types_1.DiscrError.Tag ? `tag "${schema}" must be string` : `value of tag "${schema}" must be in mapping` : (0, error_1.typeErrorMessage)(cxt, "object");
    },
    params: (cxt) => {
      const { schema, params } = cxt;
      return params.discrError ? (0, codegen_1._)`{error: ${params.discrError}, tag: ${schema}, tagValue: ${params.tag}}` : (0, error_1.typeErrorParams)(cxt, "object");
    }
  };
  var def = {
    keyword: "discriminator",
    schemaType: "string",
    implements: ["mapping"],
    error,
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, parentSchema } = cxt;
      const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
      gen.if(cond);
      validateDiscriminator();
      gen.elseIf((0, codegen_1.not)(valid));
      cxt.error();
      gen.endIf();
      cxt.ok(valid);
      function validateDiscriminator() {
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(schema)}`);
        gen.if((0, codegen_1._)`${tag} === undefined`);
        cxt.error(false, { discrError: types_1.DiscrError.Tag, tag });
        gen.elseIf((0, codegen_1._)`typeof ${tag} == "string"`);
        validateMapping(tag);
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Tag, tag }, { instancePath: schema });
        gen.endIf();
      }
      function validateMapping(tag) {
        gen.if(false);
        for (const tagValue in parentSchema.mapping) {
          gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
          gen.assign(valid, applyTagSchema(tagValue));
        }
        gen.else();
        cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag }, { instancePath: schema, schemaPath: "mapping", parentSchema: true });
        gen.endIf();
      }
      function applyTagSchema(schemaProp) {
        const _valid = gen.name("valid");
        cxt.subschema({
          keyword: "mapping",
          schemaProp,
          jtdDiscriminator: schema
        }, _valid);
        return _valid;
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/values.js
var require_values = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util3();
  var codegen_1 = require_codegen3();
  var metadata_1 = require_metadata4();
  var nullable_1 = require_nullable();
  var error_1 = require_error2();
  var def = {
    keyword: "values",
    schemaType: "object",
    error: (0, error_1.typeError)("object"),
    code(cxt) {
      (0, metadata_1.checkMetadata)(cxt);
      const { gen, data, schema, it: it2 } = cxt;
      const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
      if ((0, util_1.alwaysValidSchema)(it2, schema)) {
        gen.if((0, codegen_1.not)((0, codegen_1.or)(cond, valid)), () => cxt.error());
      } else {
        gen.if(cond);
        gen.assign(valid, validateMap());
        gen.elseIf((0, codegen_1.not)(valid));
        cxt.error();
        gen.endIf();
      }
      cxt.ok(valid);
      function validateMap() {
        const _valid = gen.name("valid");
        if (it2.allErrors) {
          const validMap = gen.let("valid", true);
          validateValues(() => gen.assign(validMap, false));
          return validMap;
        }
        gen.var(_valid, true);
        validateValues(() => gen.break());
        return _valid;
        function validateValues(notValid) {
          gen.forIn("key", data, (key) => {
            cxt.subschema({
              keyword: "values",
              dataProp: key,
              dataPropType: util_1.Type.Str
            }, _valid);
            gen.if((0, codegen_1.not)(_valid), notValid);
          });
        }
      }
    }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/union.js
var require_union = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var code_1 = require_code6();
  var def = {
    keyword: "union",
    schemaType: "array",
    trackErrors: true,
    code: code_1.validateUnion,
    error: { message: "must match a schema in union" }
  };
  exports.default = def;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/vocabularies/jtd/index.js
var require_jtd = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var ref_1 = require_ref4();
  var type_1 = require_type();
  var enum_1 = require_enum4();
  var elements_1 = require_elements();
  var properties_1 = require_properties4();
  var optionalProperties_1 = require_optionalProperties();
  var discriminator_1 = require_discriminator4();
  var values_1 = require_values();
  var union_1 = require_union();
  var metadata_1 = require_metadata4();
  var jtdVocabulary = [
    "definitions",
    ref_1.default,
    type_1.default,
    enum_1.default,
    elements_1.default,
    properties_1.default,
    optionalProperties_1.default,
    discriminator_1.default,
    values_1.default,
    union_1.default,
    metadata_1.default,
    { keyword: "additionalProperties", schemaType: "boolean" },
    { keyword: "nullable", schemaType: "boolean" }
  ];
  exports.default = jtdVocabulary;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/refs/jtd-schema.js
var require_jtd_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var shared = (root) => {
    const sch = {
      nullable: { type: "boolean" },
      metadata: {
        optionalProperties: {
          union: { elements: { ref: "schema" } }
        },
        additionalProperties: true
      }
    };
    if (root)
      sch.definitions = { values: { ref: "schema" } };
    return sch;
  };
  var emptyForm = (root) => ({
    optionalProperties: shared(root)
  });
  var refForm = (root) => ({
    properties: {
      ref: { type: "string" }
    },
    optionalProperties: shared(root)
  });
  var typeForm = (root) => ({
    properties: {
      type: {
        enum: [
          "boolean",
          "timestamp",
          "string",
          "float32",
          "float64",
          "int8",
          "uint8",
          "int16",
          "uint16",
          "int32",
          "uint32"
        ]
      }
    },
    optionalProperties: shared(root)
  });
  var enumForm = (root) => ({
    properties: {
      enum: { elements: { type: "string" } }
    },
    optionalProperties: shared(root)
  });
  var elementsForm = (root) => ({
    properties: {
      elements: { ref: "schema" }
    },
    optionalProperties: shared(root)
  });
  var propertiesForm = (root) => ({
    properties: {
      properties: { values: { ref: "schema" } }
    },
    optionalProperties: {
      optionalProperties: { values: { ref: "schema" } },
      additionalProperties: { type: "boolean" },
      ...shared(root)
    }
  });
  var optionalPropertiesForm = (root) => ({
    properties: {
      optionalProperties: { values: { ref: "schema" } }
    },
    optionalProperties: {
      additionalProperties: { type: "boolean" },
      ...shared(root)
    }
  });
  var discriminatorForm = (root) => ({
    properties: {
      discriminator: { type: "string" },
      mapping: {
        values: {
          metadata: {
            union: [propertiesForm(false), optionalPropertiesForm(false)]
          }
        }
      }
    },
    optionalProperties: shared(root)
  });
  var valuesForm = (root) => ({
    properties: {
      values: { ref: "schema" }
    },
    optionalProperties: shared(root)
  });
  var schema = (root) => ({
    metadata: {
      union: [
        emptyForm,
        refForm,
        typeForm,
        enumForm,
        elementsForm,
        propertiesForm,
        optionalPropertiesForm,
        discriminatorForm,
        valuesForm
      ].map((s2) => s2(root))
    }
  });
  var jtdMetaSchema = {
    definitions: {
      schema: schema(false)
    },
    ...schema(true)
  };
  exports.default = jtdMetaSchema;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/jtd/types.js
var require_types4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.jtdForms = undefined;
  exports.jtdForms = [
    "elements",
    "values",
    "discriminator",
    "properties",
    "optionalProperties",
    "enum",
    "type",
    "ref"
  ];
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/runtime/quote.js
var require_quote = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var rxEscapable = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
  var escaped = {
    "\b": "\\b",
    "\t": "\\t",
    "\n": "\\n",
    "\f": "\\f",
    "\r": "\\r",
    '"': "\\\"",
    "\\": "\\\\"
  };
  function quote(s2) {
    rxEscapable.lastIndex = 0;
    return '"' + (rxEscapable.test(s2) ? s2.replace(rxEscapable, (a3) => {
      const c2 = escaped[a3];
      return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a3.charCodeAt(0).toString(16)).slice(-4);
    }) : s2) + '"';
  }
  exports.default = quote;
  quote.code = 'require("ajv/dist/runtime/quote").default';
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/jtd/serialize.js
var require_serialize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var types_1 = require_types4();
  var __1 = require_compile3();
  var codegen_1 = require_codegen3();
  var ref_error_1 = require_ref_error3();
  var names_1 = require_names3();
  var code_1 = require_code6();
  var ref_1 = require_ref4();
  var util_1 = require_util3();
  var quote_1 = require_quote();
  var genSerialize = {
    elements: serializeElements,
    values: serializeValues,
    discriminator: serializeDiscriminator,
    properties: serializeProperties,
    optionalProperties: serializeProperties,
    enum: serializeString,
    type: serializeType,
    ref: serializeRef
  };
  function compileSerializer(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const serializeName = gen.scopeName("serialize");
    const cxt = {
      self: this,
      gen,
      schema: sch.schema,
      schemaEnv: sch,
      definitions,
      data: names_1.default.data
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      sch.serializeName = serializeName;
      gen.func(serializeName, names_1.default.data, false, () => {
        gen.let(names_1.default.json, (0, codegen_1.str)``);
        serializeCode(cxt);
        gen.return(names_1.default.json);
      });
      gen.optimize(this.opts.code.optimize);
      const serializeFuncCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${serializeFuncCode}`;
      const makeSerialize = new Function(`${names_1.default.scope}`, sourceCode);
      const serialize = makeSerialize(this.scope.get());
      this.scope.value(serializeName, { ref: serialize });
      sch.serialize = serialize;
    } catch (e) {
      if (sourceCode)
        this.logger.error("Error compiling serializer, function code:", sourceCode);
      delete sch.serialize;
      delete sch.serializeName;
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
    return sch;
  }
  exports.default = compileSerializer;
  function serializeCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
      if (key in cxt.schema) {
        form = key;
        break;
      }
    }
    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
  }
  function serializeNullable(cxt, serializeForm) {
    const { gen, schema, data } = cxt;
    if (!schema.nullable)
      return serializeForm(cxt);
    gen.if((0, codegen_1._)`${data} === undefined || ${data} === null`, () => gen.add(names_1.default.json, (0, codegen_1._)`"null"`), () => serializeForm(cxt));
  }
  function serializeElements(cxt) {
    const { gen, schema, data } = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str)`[`);
    const first = gen.let("first", true);
    gen.forOf("el", data, (el) => {
      addComma(cxt, first);
      serializeCode({ ...cxt, schema: schema.elements, data: el });
    });
    gen.add(names_1.default.json, (0, codegen_1.str)`]`);
  }
  function serializeValues(cxt) {
    const { gen, schema, data } = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str)`{`);
    const first = gen.let("first", true);
    gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
    gen.add(names_1.default.json, (0, codegen_1.str)`}`);
  }
  function serializeKeyValue(cxt, key, schema, first) {
    const { gen, data } = cxt;
    addComma(cxt, first);
    serializeString({ ...cxt, data: key });
    gen.add(names_1.default.json, (0, codegen_1.str)`:`);
    const value = gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
    serializeCode({ ...cxt, schema, data: value });
  }
  function serializeDiscriminator(cxt) {
    const { gen, schema, data } = cxt;
    const { discriminator } = schema;
    gen.add(names_1.default.json, (0, codegen_1.str)`{${JSON.stringify(discriminator)}:`);
    const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(discriminator)}`);
    serializeString({ ...cxt, data: tag });
    gen.if(false);
    for (const tagValue in schema.mapping) {
      gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
      const sch = schema.mapping[tagValue];
      serializeSchemaProperties({ ...cxt, schema: sch }, discriminator);
    }
    gen.endIf();
    gen.add(names_1.default.json, (0, codegen_1.str)`}`);
  }
  function serializeProperties(cxt) {
    const { gen } = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str)`{`);
    serializeSchemaProperties(cxt);
    gen.add(names_1.default.json, (0, codegen_1.str)`}`);
  }
  function serializeSchemaProperties(cxt, discriminator) {
    const { gen, schema, data } = cxt;
    const { properties, optionalProperties } = schema;
    const props = keys(properties);
    const optProps = keys(optionalProperties);
    const allProps = allProperties(props.concat(optProps));
    let first = !discriminator;
    let firstProp;
    for (const key of props) {
      if (first)
        first = false;
      else
        gen.add(names_1.default.json, (0, codegen_1.str)`,`);
      serializeProperty(key, properties[key], keyValue(key));
    }
    if (first)
      firstProp = gen.let("first", true);
    for (const key of optProps) {
      const value = keyValue(key);
      gen.if((0, codegen_1.and)((0, codegen_1._)`${value} !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
        addComma(cxt, firstProp);
        serializeProperty(key, optionalProperties[key], value);
      });
    }
    if (schema.additionalProperties) {
      gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {}, firstProp)));
    }
    function keys(ps) {
      return ps ? Object.keys(ps) : [];
    }
    function allProperties(ps) {
      if (discriminator)
        ps.push(discriminator);
      if (new Set(ps).size !== ps.length) {
        throw new Error("JTD: properties/optionalProperties/disciminator overlap");
      }
      return ps;
    }
    function keyValue(key) {
      return gen.const("value", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(key)}`);
    }
    function serializeProperty(key, propSchema, value) {
      gen.add(names_1.default.json, (0, codegen_1.str)`${JSON.stringify(key)}:`);
      serializeCode({ ...cxt, schema: propSchema, data: value });
    }
    function isAdditional(key, ps) {
      return ps.length ? (0, codegen_1.and)(...ps.map((p3) => (0, codegen_1._)`${key} !== ${p3}`)) : true;
    }
  }
  function serializeType(cxt) {
    const { gen, schema, data } = cxt;
    switch (schema.type) {
      case "boolean":
        gen.add(names_1.default.json, (0, codegen_1._)`${data} ? "true" : "false"`);
        break;
      case "string":
        serializeString(cxt);
        break;
      case "timestamp":
        gen.if((0, codegen_1._)`${data} instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._)`'"' + ${data}.toISOString() + '"'`), () => serializeString(cxt));
        break;
      default:
        serializeNumber(cxt);
    }
  }
  function serializeString({ gen, data }) {
    gen.add(names_1.default.json, (0, codegen_1._)`${(0, util_1.useFunc)(gen, quote_1.default)}(${data})`);
  }
  function serializeNumber({ gen, data }) {
    gen.add(names_1.default.json, (0, codegen_1._)`"" + ${data}`);
  }
  function serializeRef(cxt) {
    const { gen, self: self2, data, definitions, schema, schemaEnv } = cxt;
    const { ref } = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
      throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
    if (!(0, ref_1.hasRef)(refSchema))
      return serializeCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileSerializer.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
    gen.add(names_1.default.json, (0, codegen_1._)`${getSerialize(gen, sch)}(${data})`);
  }
  function getSerialize(gen, sch) {
    return sch.serialize ? gen.scopeValue("serialize", { ref: sch.serialize }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.serialize`;
  }
  function serializeEmpty({ gen, data }) {
    gen.add(names_1.default.json, (0, codegen_1._)`JSON.stringify(${data})`);
  }
  function addComma({ gen }, first) {
    if (first) {
      gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str)`,`));
    } else {
      gen.add(names_1.default.json, (0, codegen_1.str)`,`);
    }
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/runtime/parseJson.js
var require_parseJson = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseJsonString = exports.parseJsonNumber = exports.parseJson = undefined;
  var rxParseJson = /position\s(\d+)(?: \(line \d+ column \d+\))?$/;
  function parseJson(s2, pos) {
    let endPos;
    parseJson.message = undefined;
    let matches;
    if (pos)
      s2 = s2.slice(pos);
    try {
      parseJson.position = pos + s2.length;
      return JSON.parse(s2);
    } catch (e) {
      matches = rxParseJson.exec(e.message);
      if (!matches) {
        parseJson.message = "unexpected end";
        return;
      }
      endPos = +matches[1];
      const c2 = s2[endPos];
      s2 = s2.slice(0, endPos);
      parseJson.position = pos + endPos;
      try {
        return JSON.parse(s2);
      } catch (e1) {
        parseJson.message = `unexpected token ${c2}`;
        return;
      }
    }
  }
  exports.parseJson = parseJson;
  parseJson.message = undefined;
  parseJson.position = 0;
  parseJson.code = 'require("ajv/dist/runtime/parseJson").parseJson';
  function parseJsonNumber(s2, pos, maxDigits) {
    let numStr = "";
    let c2;
    parseJsonNumber.message = undefined;
    if (s2[pos] === "-") {
      numStr += "-";
      pos++;
    }
    if (s2[pos] === "0") {
      numStr += "0";
      pos++;
    } else {
      if (!parseDigits(maxDigits)) {
        errorMessage();
        return;
      }
    }
    if (maxDigits) {
      parseJsonNumber.position = pos;
      return +numStr;
    }
    if (s2[pos] === ".") {
      numStr += ".";
      pos++;
      if (!parseDigits()) {
        errorMessage();
        return;
      }
    }
    if (c2 = s2[pos], c2 === "e" || c2 === "E") {
      numStr += "e";
      pos++;
      if (c2 = s2[pos], c2 === "+" || c2 === "-") {
        numStr += c2;
        pos++;
      }
      if (!parseDigits()) {
        errorMessage();
        return;
      }
    }
    parseJsonNumber.position = pos;
    return +numStr;
    function parseDigits(maxLen) {
      let digit = false;
      while (c2 = s2[pos], c2 >= "0" && c2 <= "9" && (maxLen === undefined || maxLen-- > 0)) {
        digit = true;
        numStr += c2;
        pos++;
      }
      return digit;
    }
    function errorMessage() {
      parseJsonNumber.position = pos;
      parseJsonNumber.message = pos < s2.length ? `unexpected token ${s2[pos]}` : "unexpected end";
    }
  }
  exports.parseJsonNumber = parseJsonNumber;
  parseJsonNumber.message = undefined;
  parseJsonNumber.position = 0;
  parseJsonNumber.code = 'require("ajv/dist/runtime/parseJson").parseJsonNumber';
  var escapedChars = {
    b: "\b",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    '"': '"',
    "/": "/",
    "\\": "\\"
  };
  var CODE_A = 97;
  var CODE_0 = 48;
  function parseJsonString(s2, pos) {
    let str = "";
    let c2;
    parseJsonString.message = undefined;
    while (true) {
      c2 = s2[pos++];
      if (c2 === '"')
        break;
      if (c2 === "\\") {
        c2 = s2[pos];
        if (c2 in escapedChars) {
          str += escapedChars[c2];
          pos++;
        } else if (c2 === "u") {
          pos++;
          let count = 4;
          let code = 0;
          while (count--) {
            code <<= 4;
            c2 = s2[pos];
            if (c2 === undefined) {
              errorMessage("unexpected end");
              return;
            }
            c2 = c2.toLowerCase();
            if (c2 >= "a" && c2 <= "f") {
              code += c2.charCodeAt(0) - CODE_A + 10;
            } else if (c2 >= "0" && c2 <= "9") {
              code += c2.charCodeAt(0) - CODE_0;
            } else {
              errorMessage(`unexpected token ${c2}`);
              return;
            }
            pos++;
          }
          str += String.fromCharCode(code);
        } else {
          errorMessage(`unexpected token ${c2}`);
          return;
        }
      } else if (c2 === undefined) {
        errorMessage("unexpected end");
        return;
      } else {
        if (c2.charCodeAt(0) >= 32) {
          str += c2;
        } else {
          errorMessage(`unexpected token ${c2}`);
          return;
        }
      }
    }
    parseJsonString.position = pos;
    return str;
    function errorMessage(msg) {
      parseJsonString.position = pos;
      parseJsonString.message = msg;
    }
  }
  exports.parseJsonString = parseJsonString;
  parseJsonString.message = undefined;
  parseJsonString.position = 0;
  parseJsonString.code = 'require("ajv/dist/runtime/parseJson").parseJsonString';
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/compile/jtd/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var types_1 = require_types4();
  var __1 = require_compile3();
  var codegen_1 = require_codegen3();
  var ref_error_1 = require_ref_error3();
  var names_1 = require_names3();
  var code_1 = require_code6();
  var ref_1 = require_ref4();
  var type_1 = require_type();
  var parseJson_1 = require_parseJson();
  var util_1 = require_util3();
  var timestamp_1 = require_timestamp();
  var genParse = {
    elements: parseElements,
    values: parseValues,
    discriminator: parseDiscriminator,
    properties: parseProperties,
    optionalProperties: parseProperties,
    enum: parseEnum,
    type: parseType,
    ref: parseRef
  };
  function compileParser(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
      return _sch;
    const { es5, lines } = this.opts.code;
    const { ownProperties } = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
    const parseName = gen.scopeName("parse");
    const cxt = {
      self: this,
      gen,
      schema: sch.schema,
      schemaEnv: sch,
      definitions,
      data: names_1.default.data,
      parseName,
      char: gen.name("c")
    };
    let sourceCode;
    try {
      this._compilations.add(sch);
      sch.parseName = parseName;
      parserFunction(cxt);
      gen.optimize(this.opts.code.optimize);
      const parseFuncCode = gen.toString();
      sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${parseFuncCode}`;
      const makeParse = new Function(`${names_1.default.scope}`, sourceCode);
      const parse = makeParse(this.scope.get());
      this.scope.value(parseName, { ref: parse });
      sch.parse = parse;
    } catch (e) {
      if (sourceCode)
        this.logger.error("Error compiling parser, function code:", sourceCode);
      delete sch.parse;
      delete sch.parseName;
      throw e;
    } finally {
      this._compilations.delete(sch);
    }
    return sch;
  }
  exports.default = compileParser;
  var undef = (0, codegen_1._)`undefined`;
  function parserFunction(cxt) {
    const { gen, parseName, char } = cxt;
    gen.func(parseName, (0, codegen_1._)`${names_1.default.json}, ${names_1.default.jsonPos}, ${names_1.default.jsonPart}`, false, () => {
      gen.let(names_1.default.data);
      gen.let(char);
      gen.assign((0, codegen_1._)`${parseName}.message`, undef);
      gen.assign((0, codegen_1._)`${parseName}.position`, undef);
      gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${names_1.default.jsonPos} || 0`);
      gen.const(names_1.default.jsonLen, (0, codegen_1._)`${names_1.default.json}.length`);
      parseCode(cxt);
      skipWhitespace(cxt);
      gen.if(names_1.default.jsonPart, () => {
        gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
        gen.return(names_1.default.data);
      });
      gen.if((0, codegen_1._)`${names_1.default.jsonPos} === ${names_1.default.jsonLen}`, () => gen.return(names_1.default.data));
      jsonSyntaxError(cxt);
    });
  }
  function parseCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
      if (key in cxt.schema) {
        form = key;
        break;
      }
    }
    if (form)
      parseNullable(cxt, genParse[form]);
    else
      parseEmpty(cxt);
  }
  var parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
  function parseNullable(cxt, parseForm) {
    const { gen, schema, data } = cxt;
    if (!schema.nullable)
      return parseForm(cxt);
    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
  }
  function parseElements(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "[");
    const ix = gen.let("i", 0);
    gen.assign(data, (0, codegen_1._)`[]`);
    parseItems(cxt, "]", () => {
      const el = gen.let("el");
      parseCode({ ...cxt, schema: schema.elements, data: el });
      gen.assign((0, codegen_1._)`${data}[${ix}++]`, el);
    });
  }
  function parseValues(cxt) {
    const { gen, schema, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._)`{}`);
    parseItems(cxt, "}", () => parseKeyValue(cxt, schema.values));
  }
  function parseItems(cxt, endToken, block) {
    tryParseItems(cxt, endToken, block);
    parseToken(cxt, endToken);
  }
  function tryParseItems(cxt, endToken, block) {
    const { gen } = cxt;
    gen.for((0, codegen_1._)`;${names_1.default.jsonPos}<${names_1.default.jsonLen} && ${jsonSlice(1)}!==${endToken};`, () => {
      block();
      tryParseToken(cxt, ",", () => gen.break(), hasItem);
    });
    function hasItem() {
      tryParseToken(cxt, endToken, () => {}, jsonSyntaxError);
    }
  }
  function parseKeyValue(cxt, schema) {
    const { gen } = cxt;
    const key = gen.let("key");
    parseString({ ...cxt, data: key });
    parseToken(cxt, ":");
    parsePropertyValue(cxt, key, schema);
  }
  function parseDiscriminator(cxt) {
    const { gen, data, schema } = cxt;
    const { discriminator, mapping } = schema;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._)`{}`);
    const startPos = gen.const("pos", names_1.default.jsonPos);
    const value = gen.let("value");
    const tag = gen.let("tag");
    tryParseItems(cxt, "}", () => {
      const key = gen.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      gen.if((0, codegen_1._)`${key} === ${discriminator}`, () => {
        parseString({ ...cxt, data: tag });
        gen.assign((0, codegen_1._)`${data}[${key}]`, tag);
        gen.break();
      }, () => parseEmpty({ ...cxt, data: value }));
    });
    gen.assign(names_1.default.jsonPos, startPos);
    gen.if((0, codegen_1._)`${tag} === undefined`);
    parsingError(cxt, (0, codegen_1.str)`discriminator tag not found`);
    for (const tagValue in mapping) {
      gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
      parseSchemaProperties({ ...cxt, schema: mapping[tagValue] }, discriminator);
    }
    gen.else();
    parsingError(cxt, (0, codegen_1.str)`discriminator value not in schema`);
    gen.endIf();
  }
  function parseProperties(cxt) {
    const { gen, data } = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._)`{}`);
    parseSchemaProperties(cxt);
  }
  function parseSchemaProperties(cxt, discriminator) {
    const { gen, schema, data } = cxt;
    const { properties, optionalProperties, additionalProperties } = schema;
    parseItems(cxt, "}", () => {
      const key = gen.let("key");
      parseString({ ...cxt, data: key });
      parseToken(cxt, ":");
      gen.if(false);
      parseDefinedProperty(cxt, key, properties);
      parseDefinedProperty(cxt, key, optionalProperties);
      if (discriminator) {
        gen.elseIf((0, codegen_1._)`${key} === ${discriminator}`);
        const tag = gen.let("tag");
        parseString({ ...cxt, data: tag });
      }
      gen.else();
      if (additionalProperties) {
        parseEmpty({ ...cxt, data: (0, codegen_1._)`${data}[${key}]` });
      } else {
        parsingError(cxt, (0, codegen_1.str)`property ${key} not allowed`);
      }
      gen.endIf();
    });
    if (properties) {
      const hasProp = (0, code_1.hasPropFunc)(gen);
      const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p3) => (0, codegen_1._)`${hasProp}.call(${data}, ${p3})`));
      gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str)`missing required properties`));
    }
  }
  function parseDefinedProperty(cxt, key, schemas = {}) {
    const { gen } = cxt;
    for (const prop in schemas) {
      gen.elseIf((0, codegen_1._)`${key} === ${prop}`);
      parsePropertyValue(cxt, key, schemas[prop]);
    }
  }
  function parsePropertyValue(cxt, key, schema) {
    parseCode({ ...cxt, schema, data: (0, codegen_1._)`${cxt.data}[${key}]` });
  }
  function parseType(cxt) {
    const { gen, schema, data, self: self2 } = cxt;
    switch (schema.type) {
      case "boolean":
        parseBoolean(cxt);
        break;
      case "string":
        parseString(cxt);
        break;
      case "timestamp": {
        parseString(cxt);
        const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
        const { allowDate, parseDate } = self2.opts;
        const notValid = allowDate ? (0, codegen_1._)`!${vts}(${data}, true)` : (0, codegen_1._)`!${vts}(${data})`;
        const fail = parseDate ? (0, codegen_1.or)(notValid, (0, codegen_1._)`(${data} = new Date(${data}), false)`, (0, codegen_1._)`isNaN(${data}.valueOf())`) : notValid;
        gen.if(fail, () => parsingError(cxt, (0, codegen_1.str)`invalid timestamp`));
        break;
      }
      case "float32":
      case "float64":
        parseNumber(cxt);
        break;
      default: {
        const t = schema.type;
        if (!self2.opts.int32range && (t === "int32" || t === "uint32")) {
          parseNumber(cxt, 16);
          if (t === "uint32") {
            gen.if((0, codegen_1._)`${data} < 0`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
          }
        } else {
          const [min, max, maxDigits] = type_1.intRange[t];
          parseNumber(cxt, maxDigits);
          gen.if((0, codegen_1._)`${data} < ${min} || ${data} > ${max}`, () => parsingError(cxt, (0, codegen_1.str)`integer out of range`));
        }
      }
    }
  }
  function parseString(cxt) {
    parseToken(cxt, '"');
    parseWith(cxt, parseJson_1.parseJsonString);
  }
  function parseEnum(cxt) {
    const { gen, data, schema } = cxt;
    const enumSch = schema.enum;
    parseToken(cxt, '"');
    gen.if(false);
    for (const value of enumSch) {
      const valueStr = JSON.stringify(value).slice(1);
      gen.elseIf((0, codegen_1._)`${jsonSlice(valueStr.length)} === ${valueStr}`);
      gen.assign(data, (0, codegen_1.str)`${value}`);
      gen.add(names_1.default.jsonPos, valueStr.length);
    }
    gen.else();
    jsonSyntaxError(cxt);
    gen.endIf();
  }
  function parseNumber(cxt, maxDigits) {
    const { gen } = cxt;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._)`"-0123456789".indexOf(${jsonSlice(1)}) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
  }
  function parseBooleanToken(bool, fail) {
    return (cxt) => {
      const { gen, data } = cxt;
      tryParseToken(cxt, `${bool}`, () => fail(cxt), () => gen.assign(data, bool));
    };
  }
  function parseRef(cxt) {
    const { gen, self: self2, definitions, schema, schemaEnv } = cxt;
    const { ref } = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
      throw new ref_error_1.default(self2.opts.uriResolver, "", ref, `No definition ${ref}`);
    if (!(0, ref_1.hasRef)(refSchema))
      return parseCode({ ...cxt, schema: refSchema });
    const { root } = schemaEnv;
    const sch = compileParser.call(self2, new __1.SchemaEnv({ schema: refSchema, root }), definitions);
    partialParse(cxt, getParser(gen, sch), true);
  }
  function getParser(gen, sch) {
    return sch.parse ? gen.scopeValue("parse", { ref: sch.parse }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.parse`;
  }
  function parseEmpty(cxt) {
    parseWith(cxt, parseJson_1.parseJson);
  }
  function parseWith(cxt, parseFunc, args) {
    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
  }
  function partialParse(cxt, parseFunc, args) {
    const { gen, data } = cxt;
    gen.assign(data, (0, codegen_1._)`${parseFunc}(${names_1.default.json}, ${names_1.default.jsonPos}${args ? (0, codegen_1._)`, ${args}` : codegen_1.nil})`);
    gen.assign(names_1.default.jsonPos, (0, codegen_1._)`${parseFunc}.position`);
    gen.if((0, codegen_1._)`${data} === undefined`, () => parsingError(cxt, (0, codegen_1._)`${parseFunc}.message`));
  }
  function parseToken(cxt, tok) {
    tryParseToken(cxt, tok, jsonSyntaxError);
  }
  function tryParseToken(cxt, tok, fail, success) {
    const { gen } = cxt;
    const n = tok.length;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._)`${jsonSlice(n)} === ${tok}`, () => {
      gen.add(names_1.default.jsonPos, n);
      success === null || success === undefined || success(cxt);
    }, () => fail(cxt));
  }
  function skipWhitespace({ gen, char: c2 }) {
    gen.code((0, codegen_1._)`while((${c2}=${names_1.default.json}[${names_1.default.jsonPos}],${c2}===" "||${c2}==="\\n"||${c2}==="\\r"||${c2}==="\\t"))${names_1.default.jsonPos}++;`);
  }
  function jsonSlice(len) {
    return len === 1 ? (0, codegen_1._)`${names_1.default.json}[${names_1.default.jsonPos}]` : (0, codegen_1._)`${names_1.default.json}.slice(${names_1.default.jsonPos}, ${names_1.default.jsonPos}+${len})`;
  }
  function jsonSyntaxError(cxt) {
    parsingError(cxt, (0, codegen_1._)`"unexpected token " + ${names_1.default.json}[${names_1.default.jsonPos}]`);
  }
  function parsingError({ gen, parseName }, msg) {
    gen.assign((0, codegen_1._)`${parseName}.message`, msg);
    gen.assign((0, codegen_1._)`${parseName}.position`, names_1.default.jsonPos);
    gen.return(undef);
  }
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/jtd.js
var require_jtd2 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = undefined;
  var core_1 = require_core5();
  var jtd_1 = require_jtd();
  var jtd_schema_1 = require_jtd_schema();
  var serialize_1 = require_serialize();
  var parse_1 = require_parse();
  var META_SCHEMA_ID = "JTD-meta-schema";

  class Ajv extends core_1.default {
    constructor(opts = {}) {
      super({
        ...opts,
        jtd: true
      });
    }
    _addVocabularies() {
      super._addVocabularies();
      this.addVocabulary(jtd_1.default);
    }
    _addDefaultMetaSchema() {
      super._addDefaultMetaSchema();
      if (!this.opts.meta)
        return;
      this.addMetaSchema(jtd_schema_1.default, META_SCHEMA_ID, false);
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined);
    }
    compileSerializer(schema) {
      const sch = this._addSchema(schema);
      return sch.serialize || this._compileSerializer(sch);
    }
    compileParser(schema) {
      const sch = this._addSchema(schema);
      return sch.parse || this._compileParser(sch);
    }
    _compileSerializer(sch) {
      serialize_1.default.call(this, sch, sch.schema.definitions || {});
      if (!sch.serialize)
        throw new Error("ajv implementation error");
      return sch.serialize;
    }
    _compileParser(sch) {
      parse_1.default.call(this, sch, sch.schema.definitions || {});
      if (!sch.parse)
        throw new Error("ajv implementation error");
      return sch.parse;
    }
  }
  exports.Ajv = Ajv;
  module.exports = exports = Ajv;
  module.exports.Ajv = Ajv;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = Ajv;
  var validate_1 = require_validate3();
  Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
    return validate_1.KeywordCxt;
  } });
  var codegen_1 = require_codegen3();
  Object.defineProperty(exports, "_", { enumerable: true, get: function() {
    return codegen_1._;
  } });
  Object.defineProperty(exports, "str", { enumerable: true, get: function() {
    return codegen_1.str;
  } });
  Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
    return codegen_1.stringify;
  } });
  Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
    return codegen_1.nil;
  } });
  Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
    return codegen_1.Name;
  } });
  Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
    return codegen_1.CodeGen;
  } });
  var validation_error_1 = require_validation_error3();
  Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
    return validation_error_1.default;
  } });
  var ref_error_1 = require_ref_error3();
  Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
    return ref_error_1.default;
  } });
});

// node_modules/@fastify/ajv-compiler/lib/default-ajv-options.js
var require_default_ajv_options = __commonJS((exports, module) => {
  var fastUri = require_fast_uri();
  module.exports = Object.freeze({
    coerceTypes: "array",
    useDefaults: true,
    removeAdditional: true,
    uriResolver: fastUri,
    addUsedSchema: false,
    allErrors: false
  });
});

// node_modules/@fastify/ajv-compiler/lib/validator-compiler.js
var require_validator_compiler = __commonJS((exports, module) => {
  var Ajv = require_ajv3().default;
  var AjvJTD = require_jtd2();
  var defaultAjvOptions = require_default_ajv_options();

  class ValidatorCompiler {
    constructor(externalSchemas, options) {
      if (options.mode === "JTD") {
        this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options.customOptions));
      } else {
        this.ajv = new Ajv(Object.assign({}, defaultAjvOptions, options.customOptions));
      }
      let addFormatPlugin = true;
      if (options.plugins && options.plugins.length > 0) {
        for (const plugin of options.plugins) {
          if (Array.isArray(plugin)) {
            addFormatPlugin = addFormatPlugin && plugin[0].name !== "formatsPlugin";
            plugin[0](this.ajv, plugin[1]);
          } else {
            addFormatPlugin = addFormatPlugin && plugin.name !== "formatsPlugin";
            plugin(this.ajv);
          }
        }
      }
      if (addFormatPlugin) {
        require_dist2()(this.ajv);
      }
      options.onCreate?.(this.ajv);
      const sourceSchemas = Object.values(externalSchemas);
      for (const extSchema of sourceSchemas) {
        this.ajv.addSchema(extSchema);
      }
    }
    buildValidatorFunction({ schema }) {
      if (schema.$id) {
        const stored = this.ajv.getSchema(schema.$id);
        if (stored) {
          return stored;
        }
      }
      return this.ajv.compile(schema);
    }
  }
  module.exports = ValidatorCompiler;
});

// node_modules/@fastify/ajv-compiler/lib/serializer-compiler.js
var require_serializer_compiler = __commonJS((exports, module) => {
  var AjvJTD = require_jtd2();
  var defaultAjvOptions = require_default_ajv_options();

  class SerializerCompiler {
    constructor(_externalSchemas, options) {
      this.ajv = new AjvJTD(Object.assign({}, defaultAjvOptions, options));
    }
    buildSerializerFunction({ schema }) {
      return this.ajv.compileSerializer(schema);
    }
  }
  module.exports = SerializerCompiler;
});

// node_modules/@fastify/ajv-compiler/node_modules/ajv/dist/standalone/index.js
var require_standalone3 = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var scope_1 = require_scope3();
  var code_1 = require_code5();
  function standaloneCode(ajv, refsOrFunc) {
    if (!ajv.opts.code.source) {
      throw new Error("moduleCode: ajv instance must have code.source option");
    }
    const { _n: _n2 } = ajv.scope.opts;
    return typeof refsOrFunc == "function" ? funcExportCode(refsOrFunc.source) : refsOrFunc !== undefined ? multiExportsCode(refsOrFunc, getValidate) : multiExportsCode(ajv.schemas, (sch) => sch.meta ? undefined : ajv.compile(sch.schema));
    function getValidate(id) {
      const v2 = ajv.getSchema(id);
      if (!v2)
        throw new Error(`moduleCode: no schema with id ${id}`);
      return v2;
    }
    function funcExportCode(source) {
      const usedValues = {};
      const n = source === null || source === undefined ? undefined : source.validateName;
      const vCode = validateCode(usedValues, source);
      if (ajv.opts.code.esm) {
        return `"use strict";${_n2}export const validate = ${n};${_n2}export default ${n};${_n2}${vCode}`;
      }
      return `"use strict";${_n2}module.exports = ${n};${_n2}module.exports.default = ${n};${_n2}${vCode}`;
    }
    function multiExportsCode(schemas, getValidateFunc) {
      var _a;
      const usedValues = {};
      let code = (0, code_1._)`"use strict";`;
      for (const name in schemas) {
        const v2 = getValidateFunc(schemas[name]);
        if (v2) {
          const vCode = validateCode(usedValues, v2.source);
          const exportSyntax = ajv.opts.code.esm ? (0, code_1._)`export const ${(0, code_1.getEsmExportName)(name)}` : (0, code_1._)`exports${(0, code_1.getProperty)(name)}`;
          code = (0, code_1._)`${code}${_n2}${exportSyntax} = ${(_a = v2.source) === null || _a === undefined ? undefined : _a.validateName};${_n2}${vCode}`;
        }
      }
      return `${code}`;
    }
    function validateCode(usedValues, s2) {
      if (!s2)
        throw new Error('moduleCode: function does not have "source" property');
      if (usedState(s2.validateName) === scope_1.UsedValueState.Completed)
        return code_1.nil;
      setUsedState(s2.validateName, scope_1.UsedValueState.Started);
      const scopeCode = ajv.scope.scopeCode(s2.scopeValues, usedValues, refValidateCode);
      const code = new code_1._Code(`${scopeCode}${_n2}${s2.validateCode}`);
      return s2.evaluated ? (0, code_1._)`${code}${s2.validateName}.evaluated = ${s2.evaluated};${_n2}` : code;
      function refValidateCode(n) {
        var _a;
        const vRef = (_a = n.value) === null || _a === undefined ? undefined : _a.ref;
        if (n.prefix === "validate" && typeof vRef == "function") {
          const v2 = vRef;
          return validateCode(usedValues, v2.source);
        } else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
          const { validate, validateName } = vRef;
          if (!validateName)
            throw new Error("ajv internal error");
          const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
          const wrapper = (0, code_1._)`${def} ${n} = {validate: ${validateName}};`;
          if (usedState(validateName) === scope_1.UsedValueState.Started)
            return wrapper;
          const vCode = validateCode(usedValues, validate === null || validate === undefined ? undefined : validate.source);
          return (0, code_1._)`${wrapper}${_n2}${vCode}`;
        }
        return;
      }
      function usedState(name) {
        var _a;
        return (_a = usedValues[name.prefix]) === null || _a === undefined ? undefined : _a.get(name);
      }
      function setUsedState(name, state) {
        const { prefix } = name;
        const names = usedValues[prefix] = usedValues[prefix] || new Map;
        names.set(name, state);
      }
    }
  }
  module.exports = exports = standaloneCode;
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = standaloneCode;
});

// node_modules/@fastify/ajv-compiler/standalone.js
var require_standalone4 = __commonJS((exports, module) => {
  var ValidatorSelector = require_ajv_compiler();
  var standaloneCode = require_standalone3().default;
  function StandaloneValidator(options = { readMode: true }) {
    if (options.readMode === true && !options.restoreFunction) {
      throw new Error("You must provide a restoreFunction options when readMode ON");
    }
    if (options.readMode !== true && !options.storeFunction) {
      throw new Error("You must provide a storeFunction options when readMode OFF");
    }
    if (options.readMode === true) {
      return function wrapper() {
        return function(opts) {
          return options.restoreFunction(opts);
        };
      };
    }
    const factory = ValidatorSelector();
    return function wrapper(externalSchemas, ajvOptions = {}) {
      if (!ajvOptions.customOptions || !ajvOptions.customOptions.code) {
        ajvOptions.customOptions = Object.assign({}, ajvOptions.customOptions, { code: { source: true } });
      }
      const compiler = factory(externalSchemas, ajvOptions);
      return function(opts) {
        const validationFunc = compiler(opts);
        const schemaValidationCode = standaloneCode(compiler[ValidatorSelector.AjvReference].ajv, validationFunc);
        options.storeFunction(opts, schemaValidationCode);
        return validationFunc;
      };
    };
  }
  module.exports = StandaloneValidator;
});

// node_modules/@fastify/ajv-compiler/index.js
var require_ajv_compiler = __commonJS((exports, module) => {
  var AjvReference = Symbol.for("fastify.ajv-compiler.reference");
  var ValidatorCompiler = require_validator_compiler();
  var SerializerCompiler = require_serializer_compiler();
  function AjvCompiler(opts) {
    const validatorPool = new Map;
    const serializerPool = new Map;
    if (opts && opts.jtdSerializer === true) {
      return function buildSerializerFromPool(externalSchemas, serializerOpts) {
        const uniqueAjvKey = getPoolKey({}, serializerOpts);
        if (serializerPool.has(uniqueAjvKey)) {
          return serializerPool.get(uniqueAjvKey);
        }
        const compiler = new SerializerCompiler(externalSchemas, serializerOpts);
        const ret = compiler.buildSerializerFunction.bind(compiler);
        serializerPool.set(uniqueAjvKey, ret);
        return ret;
      };
    }
    return function buildCompilerFromPool(externalSchemas, options) {
      const uniqueAjvKey = getPoolKey(externalSchemas, options.customOptions);
      if (validatorPool.has(uniqueAjvKey)) {
        return validatorPool.get(uniqueAjvKey);
      }
      const compiler = new ValidatorCompiler(externalSchemas, options);
      const ret = compiler.buildValidatorFunction.bind(compiler);
      validatorPool.set(uniqueAjvKey, ret);
      if (options.customOptions.code !== undefined) {
        ret[AjvReference] = compiler;
      }
      return ret;
    };
  }
  function getPoolKey(externalSchemas, options) {
    const externals = JSON.stringify(externalSchemas);
    const ajvConfig = JSON.stringify(options);
    return `${externals}${ajvConfig}`;
  }
  module.exports = AjvCompiler;
  module.exports.default = AjvCompiler;
  module.exports.AjvCompiler = AjvCompiler;
  module.exports.AjvReference = AjvReference;
  module.exports.StandaloneValidator = require_standalone4();
});

// node_modules/fastify/lib/schema-controller.js
var require_schema_controller = __commonJS((exports, module) => {
  var { buildSchemas } = require_schemas();
  var SerializerSelector = require_fast_json_stringify_compiler();
  var ValidatorSelector = require_ajv_compiler();
  function buildSchemaController(parentSchemaCtrl, opts) {
    if (parentSchemaCtrl) {
      return new SchemaController(parentSchemaCtrl, opts);
    }
    const compilersFactory = Object.assign({
      buildValidator: null,
      buildSerializer: null
    }, opts?.compilersFactory);
    if (!compilersFactory.buildValidator) {
      compilersFactory.buildValidator = ValidatorSelector();
    }
    if (!compilersFactory.buildSerializer) {
      compilersFactory.buildSerializer = SerializerSelector();
    }
    const option = {
      bucket: opts && opts.bucket || buildSchemas,
      compilersFactory,
      isCustomValidatorCompiler: typeof opts?.compilersFactory?.buildValidator === "function",
      isCustomSerializerCompiler: typeof opts?.compilersFactory?.buildValidator === "function"
    };
    return new SchemaController(undefined, option);
  }

  class SchemaController {
    constructor(parent, options) {
      this.opts = options || parent?.opts;
      this.addedSchemas = false;
      this.compilersFactory = this.opts.compilersFactory;
      if (parent) {
        this.schemaBucket = this.opts.bucket(parent.getSchemas());
        this.validatorCompiler = parent.getValidatorCompiler();
        this.serializerCompiler = parent.getSerializerCompiler();
        this.isCustomValidatorCompiler = parent.isCustomValidatorCompiler;
        this.isCustomSerializerCompiler = parent.isCustomSerializerCompiler;
        this.parent = parent;
      } else {
        this.schemaBucket = this.opts.bucket();
        this.isCustomValidatorCompiler = this.opts.isCustomValidatorCompiler || false;
        this.isCustomSerializerCompiler = this.opts.isCustomSerializerCompiler || false;
      }
    }
    add(schema) {
      this.addedSchemas = true;
      return this.schemaBucket.add(schema);
    }
    getSchema(schemaId) {
      return this.schemaBucket.getSchema(schemaId);
    }
    getSchemas() {
      return this.schemaBucket.getSchemas();
    }
    setValidatorCompiler(validatorCompiler) {
      this.compilersFactory = Object.assign({}, this.compilersFactory, { buildValidator: () => validatorCompiler });
      this.validatorCompiler = validatorCompiler;
      this.isCustomValidatorCompiler = true;
    }
    setSerializerCompiler(serializerCompiler) {
      this.compilersFactory = Object.assign({}, this.compilersFactory, { buildSerializer: () => serializerCompiler });
      this.serializerCompiler = serializerCompiler;
      this.isCustomSerializerCompiler = true;
    }
    getValidatorCompiler() {
      return this.validatorCompiler || this.parent && this.parent.getValidatorCompiler();
    }
    getSerializerCompiler() {
      return this.serializerCompiler || this.parent && this.parent.getSerializerCompiler();
    }
    getSerializerBuilder() {
      return this.compilersFactory.buildSerializer || this.parent && this.parent.getSerializerBuilder();
    }
    getValidatorBuilder() {
      return this.compilersFactory.buildValidator || this.parent && this.parent.getValidatorBuilder();
    }
    setupValidator(serverOptions) {
      const isReady = this.validatorCompiler !== undefined && !this.addedSchemas;
      if (isReady) {
        return;
      }
      this.validatorCompiler = this.getValidatorBuilder()(this.schemaBucket.getSchemas(), serverOptions.ajv);
    }
    setupSerializer(serverOptions) {
      const isReady = this.serializerCompiler !== undefined && !this.addedSchemas;
      if (isReady) {
        return;
      }
      this.serializerCompiler = this.getSerializerBuilder()(this.schemaBucket.getSchemas(), serverOptions.serializerOpts);
    }
  }
  SchemaController.buildSchemaController = buildSchemaController;
  module.exports = SchemaController;
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug2();
  exports = module.exports = {};
  var re2 = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t = exports.t = {};
  var R2 = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value) => {
    for (const [token, max] of safeRegexReplacements) {
      value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
  };
  var createToken = (name, value, isGlobal) => {
    const safe = makeSafeRegex(value);
    const index = R2++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re2[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a3, b5) => {
    const anum = numeric.test(a3);
    const bnum = numeric.test(b5);
    if (anum && bnum) {
      a3 = +a3;
      b5 = +b5;
    }
    return a3 === b5 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a3 < b5 ? -1 : 1;
  };
  var rcompareIdentifiers = (a3, b5) => compareIdentifiers(b5, a3);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug2();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re2, t } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m3 = version.trim().match(options.loose ? re2[t.LOOSE] : re2[t.FULL]);
      if (!m3) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m3[1];
      this.minor = +m3[2];
      this.patch = +m3[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m3[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m3[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m3[5] ? m3[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a3 = this.prerelease[i];
        const b5 = other.prerelease[i];
        debug("prerelease compare", i, a3, b5);
        if (a3 === undefined && b5 === undefined) {
          return 0;
        } else if (b5 === undefined) {
          return 1;
        } else if (a3 === undefined) {
          return -1;
        } else if (a3 === b5) {
          continue;
        } else {
          return compareIdentifiers(a3, b5);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a3 = this.build[i];
        const b5 = other.build[i];
        debug("build compare", i, a3, b5);
        if (a3 === undefined && b5 === undefined) {
          return 0;
        } else if (b5 === undefined) {
          return 1;
        } else if (a3 === undefined) {
          return -1;
        } else if (a3 === b5) {
          continue;
        } else {
          return compareIdentifiers(a3, b5);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re2[t.PRERELEASELOOSE] : re2[t.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er2) {
      if (!throwErrors) {
        return null;
      }
      throw er2;
    }
  };
  module.exports = parse;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse = require_parse2();
  var valid = (version, options) => {
    const v2 = parse(version, options);
    return v2 ? v2.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse = require_parse2();
  var clean = (version, options) => {
    const s2 = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  };
  module.exports = clean;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er2) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse = require_parse2();
  var diff = (version1, version2) => {
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a3, loose) => new SemVer(a3, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a3, loose) => new SemVer(a3, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a3, loose) => new SemVer(a3, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse = require_parse2();
  var prerelease = (version, options) => {
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a3, b5, loose) => new SemVer(a3, loose).compare(new SemVer(b5, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a3, b5, loose) => compare(b5, a3, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a3, b5) => compare(a3, b5, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a3, b5, loose) => {
    const versionA = new SemVer(a3, loose);
    const versionB = new SemVer(b5, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a3, b5) => compareBuild(a3, b5, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a3, b5) => compareBuild(b5, a3, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt3 = (a3, b5, loose) => compare(a3, b5, loose) > 0;
  module.exports = gt3;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt2 = (a3, b5, loose) => compare(a3, b5, loose) < 0;
  module.exports = lt2;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a3, b5, loose) => compare(a3, b5, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a3, b5, loose) => compare(a3, b5, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a3, b5, loose) => compare(a3, b5, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a3, b5, loose) => compare(a3, b5, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt3 = require_gt();
  var gte = require_gte();
  var lt2 = require_lt();
  var lte = require_lte();
  var cmp = (a3, op, b5, loose) => {
    switch (op) {
      case "===":
        if (typeof a3 === "object") {
          a3 = a3.version;
        }
        if (typeof b5 === "object") {
          b5 = b5.version;
        }
        return a3 === b5;
      case "!==":
        if (typeof a3 === "object") {
          a3 = a3.version;
        }
        if (typeof b5 === "object") {
          b5 = b5.version;
        }
        return a3 !== b5;
      case "":
      case "=":
      case "==":
        return eq(a3, b5, loose);
      case "!=":
        return neq(a3, b5, loose);
      case ">":
        return gt3(a3, b5, loose);
      case ">=":
        return gte(a3, b5, loose);
      case "<":
        return lt2(a3, b5, loose);
      case "<=":
        return lte(a3, b5, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse = require_parse2();
  var { safeRe: re2, t } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re2[t.COERCEFULL] : re2[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re2[t.COERCERTLFULL] : re2[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value = this.map.get(key);
      if (value === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value);
        return value;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value) {
      const deleted = this.delete(key);
      if (!deleted && value !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i = 0;i < this.set.length; i++) {
          if (i > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i];
          for (let k3 = 0;k3 < comps.length; k3++) {
            if (k3 > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k3].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr3 = loose ? re2[t.HYPHENRANGELOOSE] : re2[t.HYPHENRANGE];
      range = range.replace(hr3, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re2[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re2[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re2[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re2[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er2) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug2();
  var SemVer = require_semver();
  var {
    safeRe: re2,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c2) => c2.value === "<0.0.0-0";
  var isAny = (c2) => c2.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r = options.loose ? re2[t.TILDELOOSE] : re2[t.TILDE];
    return comp.replace(r, (_3, M3, m3, p3, pr2) => {
      debug("tilde", comp, _3, M3, m3, p3, pr2);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m3)) {
        ret = `>=${M3}.0.0 <${+M3 + 1}.0.0-0`;
      } else if (isX(p3)) {
        ret = `>=${M3}.${m3}.0 <${M3}.${+m3 + 1}.0-0`;
      } else if (pr2) {
        debug("replaceTilde pr", pr2);
        ret = `>=${M3}.${m3}.${p3}-${pr2} <${M3}.${+m3 + 1}.0-0`;
      } else {
        ret = `>=${M3}.${m3}.${p3} <${M3}.${+m3 + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r = options.loose ? re2[t.CARETLOOSE] : re2[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_3, M3, m3, p3, pr2) => {
      debug("caret", comp, _3, M3, m3, p3, pr2);
      let ret;
      if (isX(M3)) {
        ret = "";
      } else if (isX(m3)) {
        ret = `>=${M3}.0.0${z} <${+M3 + 1}.0.0-0`;
      } else if (isX(p3)) {
        if (M3 === "0") {
          ret = `>=${M3}.${m3}.0${z} <${M3}.${+m3 + 1}.0-0`;
        } else {
          ret = `>=${M3}.${m3}.0${z} <${+M3 + 1}.0.0-0`;
        }
      } else if (pr2) {
        debug("replaceCaret pr", pr2);
        if (M3 === "0") {
          if (m3 === "0") {
            ret = `>=${M3}.${m3}.${p3}-${pr2} <${M3}.${m3}.${+p3 + 1}-0`;
          } else {
            ret = `>=${M3}.${m3}.${p3}-${pr2} <${M3}.${+m3 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m3}.${p3}-${pr2} <${+M3 + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M3 === "0") {
          if (m3 === "0") {
            ret = `>=${M3}.${m3}.${p3}${z} <${M3}.${m3}.${+p3 + 1}-0`;
          } else {
            ret = `>=${M3}.${m3}.${p3}${z} <${M3}.${+m3 + 1}.0-0`;
          }
        } else {
          ret = `>=${M3}.${m3}.${p3} <${+M3 + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r = options.loose ? re2[t.XRANGELOOSE] : re2[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M3, m3, p3, pr2) => {
      debug("xRange", comp, ret, gtlt, M3, m3, p3, pr2);
      const xM = isX(M3);
      const xm = xM || isX(m3);
      const xp = xm || isX(p3);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr2 = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m3 = 0;
        }
        p3 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M3 = +M3 + 1;
            m3 = 0;
            p3 = 0;
          } else {
            m3 = +m3 + 1;
            p3 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M3 = +M3 + 1;
          } else {
            m3 = +m3 + 1;
          }
        }
        if (gtlt === "<") {
          pr2 = "-0";
        }
        ret = `${gtlt + M3}.${m3}.${p3}${pr2}`;
      } else if (xm) {
        ret = `>=${M3}.0.0${pr2} <${+M3 + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M3}.${m3}.0${pr2} <${M3}.${+m3 + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re2[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re2[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to2, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to2 = "";
    } else if (isX(tm)) {
      to2 = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to2 = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to2 = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to2 = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to2 = `<=${to2}`;
    }
    return `${from} ${to2}`.trim();
  };
  var testSet = (set, version, options) => {
    for (let i = 0;i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set.length; i++) {
        debug(set[i].semver);
        if (set[i].semver === Comparator.ANY) {
          continue;
        }
        if (set[i].semver.prerelease.length > 0) {
          const allowed = set[i].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r = this.options.loose ? re2[t.COMPARATORLOOSE] : re2[t.COMPARATOR];
      const m3 = comp.match(r);
      if (!m3) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m3[1] !== undefined ? m3[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m3[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m3[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er2) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re2, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug2();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er2) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er2) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!max || maxSV.compare(v2) === -1) {
          max = v2;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er2) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!min || minSV.compare(v2) === 1) {
          min = v2;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt3 = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt3(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt3(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er2) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt3 = require_gt();
  var lt2 = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt3;
        ltefn = lte;
        ltfn = lt2;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt2;
        ltefn = gte;
        ltfn = gt3;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set = [];
    let first = null;
    let prev = null;
    const v2 = versions.sort((a3, b5) => compare(a3, b5, options));
    for (const version of v2) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v2[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v2[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt3, lt2;
    for (const c2 of sub) {
      if (c2.operator === ">" || c2.operator === ">=") {
        gt3 = higherGT(gt3, c2, options);
      } else if (c2.operator === "<" || c2.operator === "<=") {
        lt2 = lowerLT(lt2, c2, options);
      } else {
        eqSet.add(c2.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt3 && lt2) {
      gtltComp = compare(gt3.semver, lt2.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt3.operator !== ">=" || lt2.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt3 && !satisfies(eq, String(gt3), options)) {
        return null;
      }
      if (lt2 && !satisfies(eq, String(lt2), options)) {
        return null;
      }
      for (const c2 of dom) {
        if (!satisfies(eq, String(c2), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
    let needDomGTPre = gt3 && !options.includePrerelease && gt3.semver.prerelease.length ? gt3.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c2 of dom) {
      hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
      hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
      if (gt3) {
        if (needDomGTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c2.operator === ">" || c2.operator === ">=") {
          higher = higherGT(gt3, c2, options);
          if (higher === c2 && higher !== gt3) {
            return false;
          }
        } else if (gt3.operator === ">=" && !satisfies(gt3.semver, String(c2), options)) {
          return false;
        }
      }
      if (lt2) {
        if (needDomLTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c2.operator === "<" || c2.operator === "<=") {
          lower = lowerLT(lt2, c2, options);
          if (lower === c2 && lower !== lt2) {
            return false;
          }
        } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c2), options)) {
          return false;
        }
      }
      if (!c2.operator && (lt2 || gt3) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt3 && hasDomLT && !lt2 && gtltComp !== 0) {
      return false;
    }
    if (lt2 && hasDomGT && !gt3 && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a3, b5, options) => {
    if (!a3) {
      return b5;
    }
    const comp = compare(a3.semver, b5.semver, options);
    return comp > 0 ? a3 : comp < 0 ? b5 : b5.operator === ">" && a3.operator === ">=" ? b5 : a3;
  };
  var lowerLT = (a3, b5, options) => {
    if (!a3) {
      return b5;
    }
    const comp = compare(a3.semver, b5.semver, options);
    return comp < 0 ? a3 : comp > 0 ? b5 : b5.operator === "<" && a3.operator === "<=" ? b5 : a3;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse = require_parse2();
  var valid = require_valid();
  var clean = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt3 = require_gt();
  var lt2 = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt: gt3,
    lt: lt2,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node:assert
var require_assert = __commonJS(() => {
  var di3 = Object.create;
  var Re = Object.defineProperty;
  var hi = Object.getOwnPropertyDescriptor;
  var bi3 = Object.getOwnPropertyNames;
  var mi3 = Object.getPrototypeOf;
  var vi3 = Object.prototype.hasOwnProperty;
  var Si3 = (e, r) => () => (e && (r = e(e = 0)), r);
  var y3 = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports);
  var Ai2 = (e, r) => {
    for (var t in r)
      Re(e, t, { get: r[t], enumerable: true });
  };
  var Te = (e, r, t, n) => {
    if (r && typeof r == "object" || typeof r == "function")
      for (let o2 of bi3(r))
        !vi3.call(e, o2) && o2 !== t && Re(e, o2, { get: () => r[o2], enumerable: !(n = hi(r, o2)) || n.enumerable });
    return e;
  };
  var D = (e, r, t) => (Te(e, r, "default"), t && Te(t, r, "default"));
  var bt4 = (e, r, t) => (t = e != null ? di3(mi3(e)) : {}, Te(r || !e || !e.__esModule ? Re(t, "default", { value: e, enumerable: true }) : t, e));
  var ue4 = (e) => Te(Re({}, "__esModule", { value: true }), e);
  var hr3 = y3((Lu, mt3) => {
    mt3.exports = function() {
      if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
        return false;
      if (typeof Symbol.iterator == "symbol")
        return true;
      var r = {}, t = Symbol("test"), n = Object(t);
      if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(n) !== "[object Symbol]")
        return false;
      var o2 = 42;
      r[t] = o2;
      for (t in r)
        return false;
      if (typeof Object.keys == "function" && Object.keys(r).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(r).length !== 0)
        return false;
      var i = Object.getOwnPropertySymbols(r);
      if (i.length !== 1 || i[0] !== t || !Object.prototype.propertyIsEnumerable.call(r, t))
        return false;
      if (typeof Object.getOwnPropertyDescriptor == "function") {
        var a3 = Object.getOwnPropertyDescriptor(r, t);
        if (a3.value !== o2 || a3.enumerable !== true)
          return false;
      }
      return true;
    };
  });
  var ce3 = y3((Vu, vt) => {
    var Oi = hr3();
    vt.exports = function() {
      return Oi() && !!Symbol.toStringTag;
    };
  });
  var Ot = y3((Wu, At4) => {
    var St = typeof Symbol < "u" && Symbol, Ei2 = hr3();
    At4.exports = function() {
      return typeof St != "function" || typeof Symbol != "function" || typeof St("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : Ei2();
    };
  });
  var wt = y3((zu, Et2) => {
    var wi2 = "Function.prototype.bind called on incompatible ", br3 = Array.prototype.slice, ji2 = Object.prototype.toString, Pi2 = "[object Function]";
    Et2.exports = function(r) {
      var t = this;
      if (typeof t != "function" || ji2.call(t) !== Pi2)
        throw new TypeError(wi2 + t);
      for (var n = br3.call(arguments, 1), o2, i = function() {
        if (this instanceof o2) {
          var s2 = t.apply(this, n.concat(br3.call(arguments)));
          return Object(s2) === s2 ? s2 : this;
        } else
          return t.apply(r, n.concat(br3.call(arguments)));
      }, a3 = Math.max(0, t.length - n.length), f2 = [], u2 = 0;u2 < a3; u2++)
        f2.push("$" + u2);
      if (o2 = Function("binder", "return function (" + f2.join(",") + "){ return binder.apply(this,arguments); }")(i), t.prototype) {
        var c2 = function() {};
        c2.prototype = t.prototype, o2.prototype = new c2, c2.prototype = null;
      }
      return o2;
    };
  });
  var Ne = y3((Cu, jt2) => {
    var qi = wt();
    jt2.exports = Function.prototype.bind || qi;
  });
  var qt2 = y3((Hu, Pt) => {
    var Ii2 = Ne();
    Pt.exports = Ii2.call(Function.call, Object.prototype.hasOwnProperty);
  });
  var le = y3((Ju, Ft2) => {
    var h3, Z = SyntaxError, Nt2 = Function, X2 = TypeError, mr2 = function(e) {
      try {
        return Nt2('"use strict"; return (' + e + ").constructor;")();
      } catch {}
    }, G = Object.getOwnPropertyDescriptor;
    if (G)
      try {
        G({}, "");
      } catch {
        G = null;
      }
    var vr3 = function() {
      throw new X2;
    }, Ti2 = G ? function() {
      try {
        return arguments.callee, vr3;
      } catch {
        try {
          return G(arguments, "callee").get;
        } catch {
          return vr3;
        }
      }
    }() : vr3, J2 = Ot()(), x3 = Object.getPrototypeOf || function(e) {
      return e.__proto__;
    }, Y2 = {}, Ri2 = typeof Uint8Array > "u" ? h3 : x3(Uint8Array), L3 = { "%AggregateError%": typeof AggregateError > "u" ? h3 : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? h3 : ArrayBuffer, "%ArrayIteratorPrototype%": J2 ? x3([][Symbol.iterator]()) : h3, "%AsyncFromSyncIteratorPrototype%": h3, "%AsyncFunction%": Y2, "%AsyncGenerator%": Y2, "%AsyncGeneratorFunction%": Y2, "%AsyncIteratorPrototype%": Y2, "%Atomics%": typeof Atomics > "u" ? h3 : Atomics, "%BigInt%": typeof BigInt > "u" ? h3 : BigInt, "%BigInt64Array%": typeof BigInt64Array > "u" ? h3 : BigInt64Array, "%BigUint64Array%": typeof BigUint64Array > "u" ? h3 : BigUint64Array, "%Boolean%": Boolean, "%DataView%": typeof DataView > "u" ? h3 : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array > "u" ? h3 : Float32Array, "%Float64Array%": typeof Float64Array > "u" ? h3 : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? h3 : FinalizationRegistry, "%Function%": Nt2, "%GeneratorFunction%": Y2, "%Int8Array%": typeof Int8Array > "u" ? h3 : Int8Array, "%Int16Array%": typeof Int16Array > "u" ? h3 : Int16Array, "%Int32Array%": typeof Int32Array > "u" ? h3 : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": J2 ? x3(x3([][Symbol.iterator]())) : h3, "%JSON%": typeof JSON == "object" ? JSON : h3, "%Map%": typeof Map > "u" ? h3 : Map, "%MapIteratorPrototype%": typeof Map > "u" || !J2 ? h3 : x3(new Map()[Symbol.iterator]()), "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? h3 : Promise, "%Proxy%": typeof Proxy > "u" ? h3 : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect > "u" ? h3 : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set > "u" ? h3 : Set, "%SetIteratorPrototype%": typeof Set > "u" || !J2 ? h3 : x3(new Set()[Symbol.iterator]()), "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? h3 : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": J2 ? x3(""[Symbol.iterator]()) : h3, "%Symbol%": J2 ? Symbol : h3, "%SyntaxError%": Z, "%ThrowTypeError%": Ti2, "%TypedArray%": Ri2, "%TypeError%": X2, "%Uint8Array%": typeof Uint8Array > "u" ? h3 : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? h3 : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array > "u" ? h3 : Uint16Array, "%Uint32Array%": typeof Uint32Array > "u" ? h3 : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap > "u" ? h3 : WeakMap, "%WeakRef%": typeof WeakRef > "u" ? h3 : WeakRef, "%WeakSet%": typeof WeakSet > "u" ? h3 : WeakSet };
    try {
      null.error;
    } catch (e) {
      It = x3(x3(e)), L3["%Error.prototype%"] = It;
    }
    var It, Ni2 = function e(r) {
      var t;
      if (r === "%AsyncFunction%")
        t = mr2("async function () {}");
      else if (r === "%GeneratorFunction%")
        t = mr2("function* () {}");
      else if (r === "%AsyncGeneratorFunction%")
        t = mr2("async function* () {}");
      else if (r === "%AsyncGenerator%") {
        var n = e("%AsyncGeneratorFunction%");
        n && (t = n.prototype);
      } else if (r === "%AsyncIteratorPrototype%") {
        var o2 = e("%AsyncGenerator%");
        o2 && (t = x3(o2.prototype));
      }
      return L3[r] = t, t;
    }, Tt3 = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, se2 = Ne(), Fe = qt2(), Fi = se2.call(Function.call, Array.prototype.concat), xi3 = se2.call(Function.apply, Array.prototype.splice), Rt = se2.call(Function.call, String.prototype.replace), xe = se2.call(Function.call, String.prototype.slice), Di2 = se2.call(Function.call, RegExp.prototype.exec), Bi = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Ui = /\\(\\)?/g, Mi = function(r) {
      var t = xe(r, 0, 1), n = xe(r, -1);
      if (t === "%" && n !== "%")
        throw new Z("invalid intrinsic syntax, expected closing `%`");
      if (n === "%" && t !== "%")
        throw new Z("invalid intrinsic syntax, expected opening `%`");
      var o2 = [];
      return Rt(r, Bi, function(i, a3, f2, u2) {
        o2[o2.length] = f2 ? Rt(u2, Ui, "$1") : a3 || i;
      }), o2;
    }, _i3 = function(r, t) {
      var n = r, o2;
      if (Fe(Tt3, n) && (o2 = Tt3[n], n = "%" + o2[0] + "%"), Fe(L3, n)) {
        var i = L3[n];
        if (i === Y2 && (i = Ni2(n)), typeof i > "u" && !t)
          throw new X2("intrinsic " + r + " exists, but is not available. Please file an issue!");
        return { alias: o2, name: n, value: i };
      }
      throw new Z("intrinsic " + r + " does not exist!");
    };
    Ft2.exports = function(r, t) {
      if (typeof r != "string" || r.length === 0)
        throw new X2("intrinsic name must be a non-empty string");
      if (arguments.length > 1 && typeof t != "boolean")
        throw new X2('"allowMissing" argument must be a boolean');
      if (Di2(/^%?[^%]*%?$/, r) === null)
        throw new Z("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      var n = Mi(r), o2 = n.length > 0 ? n[0] : "", i = _i3("%" + o2 + "%", t), a3 = i.name, f2 = i.value, u2 = false, c2 = i.alias;
      c2 && (o2 = c2[0], xi3(n, Fi([0, 1], c2)));
      for (var s2 = 1, l3 = true;s2 < n.length; s2 += 1) {
        var p3 = n[s2], m3 = xe(p3, 0, 1), S = xe(p3, -1);
        if ((m3 === '"' || m3 === "'" || m3 === "`" || S === '"' || S === "'" || S === "`") && m3 !== S)
          throw new Z("property names with quotes must have matching quotes");
        if ((p3 === "constructor" || !l3) && (u2 = true), o2 += "." + p3, a3 = "%" + o2 + "%", Fe(L3, a3))
          f2 = L3[a3];
        else if (f2 != null) {
          if (!(p3 in f2)) {
            if (!t)
              throw new X2("base intrinsic for " + r + " exists, but the property is not available.");
            return;
          }
          if (G && s2 + 1 >= n.length) {
            var q = G(f2, p3);
            l3 = !!q, l3 && "get" in q && !("originalValue" in q.get) ? f2 = q.get : f2 = f2[p3];
          } else
            l3 = Fe(f2, p3), f2 = f2[p3];
          l3 && !u2 && (L3[a3] = f2);
        }
      }
      return f2;
    };
  });
  var Be = y3((Yu, De) => {
    var Sr = Ne(), Q3 = le(), Bt = Q3("%Function.prototype.apply%"), Ut2 = Q3("%Function.prototype.call%"), Mt = Q3("%Reflect.apply%", true) || Sr.call(Ut2, Bt), xt3 = Q3("%Object.getOwnPropertyDescriptor%", true), V4 = Q3("%Object.defineProperty%", true), $i = Q3("%Math.max%");
    if (V4)
      try {
        V4({}, "a", { value: 1 });
      } catch {
        V4 = null;
      }
    De.exports = function(r) {
      var t = Mt(Sr, Ut2, arguments);
      if (xt3 && V4) {
        var n = xt3(t, "length");
        n.configurable && V4(t, "length", { value: 1 + $i(0, r.length - (arguments.length - 1)) });
      }
      return t;
    };
    var Dt2 = function() {
      return Mt(Sr, Bt, arguments);
    };
    V4 ? V4(De.exports, "apply", { value: Dt2 }) : De.exports.apply = Dt2;
  });
  var Ue = y3((Xu, kt) => {
    var _t3 = le(), $t = Be(), ki = $t(_t3("String.prototype.indexOf"));
    kt.exports = function(r, t) {
      var n = _t3(r, !!t);
      return typeof n == "function" && ki(r, ".prototype.") > -1 ? $t(n) : n;
    };
  });
  var Vt2 = y3((Zu, Lt2) => {
    var Gi3 = ce3()(), Li2 = Ue(), Ar2 = Li2("Object.prototype.toString"), Me = function(r) {
      return Gi3 && r && typeof r == "object" && Symbol.toStringTag in r ? false : Ar2(r) === "[object Arguments]";
    }, Gt = function(r) {
      return Me(r) ? true : r !== null && typeof r == "object" && typeof r.length == "number" && r.length >= 0 && Ar2(r) !== "[object Array]" && Ar2(r.callee) === "[object Function]";
    }, Vi3 = function() {
      return Me(arguments);
    }();
    Me.isLegacyArguments = Gt;
    Lt2.exports = Vi3 ? Me : Gt;
  });
  var Ct = y3((Qu, zt) => {
    var Wi2 = Object.prototype.toString, zi = Function.prototype.toString, Ci = /^\s*(?:function)?\*/, Wt2 = ce3()(), Or = Object.getPrototypeOf, Hi2 = function() {
      if (!Wt2)
        return false;
      try {
        return Function("return function*() {}")();
      } catch {}
    }, Er4;
    zt.exports = function(r) {
      if (typeof r != "function")
        return false;
      if (Ci.test(zi.call(r)))
        return true;
      if (!Wt2) {
        var t = Wi2.call(r);
        return t === "[object GeneratorFunction]";
      }
      if (!Or)
        return false;
      if (typeof Er4 > "u") {
        var n = Hi2();
        Er4 = n ? Or(n) : false;
      }
      return Or(r) === Er4;
    };
  });
  var Xt2 = y3((Ku, Yt) => {
    var Jt = Function.prototype.toString, K3 = typeof Reflect == "object" && Reflect !== null && Reflect.apply, jr, _e3;
    if (typeof K3 == "function" && typeof Object.defineProperty == "function")
      try {
        jr = Object.defineProperty({}, "length", { get: function() {
          throw _e3;
        } }), _e3 = {}, K3(function() {
          throw 42;
        }, null, jr);
      } catch (e) {
        e !== _e3 && (K3 = null);
      }
    else
      K3 = null;
    var Ji2 = /^\s*class\b/, Pr = function(r) {
      try {
        var t = Jt.call(r);
        return Ji2.test(t);
      } catch {
        return false;
      }
    }, wr = function(r) {
      try {
        return Pr(r) ? false : (Jt.call(r), true);
      } catch {
        return false;
      }
    }, $e2 = Object.prototype.toString, Yi2 = "[object Object]", Xi2 = "[object Function]", Zi = "[object GeneratorFunction]", Qi2 = "[object HTMLAllCollection]", Ki2 = "[object HTML document.all class]", ea = "[object HTMLCollection]", ra = typeof Symbol == "function" && !!Symbol.toStringTag, ta = !(0 in [,]), qr3 = function() {
      return false;
    };
    typeof document == "object" && (Ht2 = document.all, $e2.call(Ht2) === $e2.call(document.all) && (qr3 = function(r) {
      if ((ta || !r) && (typeof r > "u" || typeof r == "object"))
        try {
          var t = $e2.call(r);
          return (t === Qi2 || t === Ki2 || t === ea || t === Yi2) && r("") == null;
        } catch {}
      return false;
    }));
    var Ht2;
    Yt.exports = K3 ? function(r) {
      if (qr3(r))
        return true;
      if (!r || typeof r != "function" && typeof r != "object")
        return false;
      try {
        K3(r, null, jr);
      } catch (t) {
        if (t !== _e3)
          return false;
      }
      return !Pr(r) && wr(r);
    } : function(r) {
      if (qr3(r))
        return true;
      if (!r || typeof r != "function" && typeof r != "object")
        return false;
      if (ra)
        return wr(r);
      if (Pr(r))
        return false;
      var t = $e2.call(r);
      return t !== Xi2 && t !== Zi && !/^\[object HTML/.test(t) ? false : wr(r);
    };
  });
  var Ir2 = y3((ec, Qt2) => {
    var na = Xt2(), oa = Object.prototype.toString, Zt = Object.prototype.hasOwnProperty, ia = function(r, t, n) {
      for (var o2 = 0, i = r.length;o2 < i; o2++)
        Zt.call(r, o2) && (n == null ? t(r[o2], o2, r) : t.call(n, r[o2], o2, r));
    }, aa = function(r, t, n) {
      for (var o2 = 0, i = r.length;o2 < i; o2++)
        n == null ? t(r.charAt(o2), o2, r) : t.call(n, r.charAt(o2), o2, r);
    }, fa = function(r, t, n) {
      for (var o2 in r)
        Zt.call(r, o2) && (n == null ? t(r[o2], o2, r) : t.call(n, r[o2], o2, r));
    }, ua = function(r, t, n) {
      if (!na(t))
        throw new TypeError("iterator must be a function");
      var o2;
      arguments.length >= 3 && (o2 = n), oa.call(r) === "[object Array]" ? ia(r, t, o2) : typeof r == "string" ? aa(r, t, o2) : fa(r, t, o2);
    };
    Qt2.exports = ua;
  });
  var Rr3 = y3((rc, Kt3) => {
    var Tr = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], ca = typeof globalThis > "u" ? global : globalThis;
    Kt3.exports = function() {
      for (var r = [], t = 0;t < Tr.length; t++)
        typeof ca[Tr[t]] == "function" && (r[r.length] = Tr[t]);
      return r;
    };
  });
  var Nr = y3((tc, en) => {
    var sa = le(), ke3 = sa("%Object.getOwnPropertyDescriptor%", true);
    if (ke3)
      try {
        ke3([], "length");
      } catch {
        ke3 = null;
      }
    en.exports = ke3;
  });
  var Dr2 = y3((nc, an2) => {
    var rn2 = Ir2(), la = Rr3(), xr2 = Ue(), pa = xr2("Object.prototype.toString"), tn2 = ce3()(), Ge = Nr(), ya = typeof globalThis > "u" ? global : globalThis, nn = la(), ga = xr2("Array.prototype.indexOf", true) || function(r, t) {
      for (var n = 0;n < r.length; n += 1)
        if (r[n] === t)
          return n;
      return -1;
    }, da = xr2("String.prototype.slice"), on = {}, Fr2 = Object.getPrototypeOf;
    tn2 && Ge && Fr2 && rn2(nn, function(e) {
      var r = new ya[e];
      if (Symbol.toStringTag in r) {
        var t = Fr2(r), n = Ge(t, Symbol.toStringTag);
        if (!n) {
          var o2 = Fr2(t);
          n = Ge(o2, Symbol.toStringTag);
        }
        on[e] = n.get;
      }
    });
    var ha = function(r) {
      var t = false;
      return rn2(on, function(n, o2) {
        if (!t)
          try {
            t = n.call(r) === o2;
          } catch {}
      }), t;
    };
    an2.exports = function(r) {
      if (!r || typeof r != "object")
        return false;
      if (!tn2 || !(Symbol.toStringTag in r)) {
        var t = da(pa(r), 8, -1);
        return ga(nn, t) > -1;
      }
      return Ge ? ha(r) : false;
    };
  });
  var yn = y3((oc, pn2) => {
    var un = Ir2(), ba = Rr3(), cn2 = Ue(), Br2 = Nr(), ma = cn2("Object.prototype.toString"), sn = ce3()(), fn = typeof globalThis > "u" ? global : globalThis, va = ba(), Sa = cn2("String.prototype.slice"), ln = {}, Ur2 = Object.getPrototypeOf;
    sn && Br2 && Ur2 && un(va, function(e) {
      if (typeof fn[e] == "function") {
        var r = new fn[e];
        if (Symbol.toStringTag in r) {
          var t = Ur2(r), n = Br2(t, Symbol.toStringTag);
          if (!n) {
            var o2 = Ur2(t);
            n = Br2(o2, Symbol.toStringTag);
          }
          ln[e] = n.get;
        }
      }
    });
    var Aa = function(r) {
      var t = false;
      return un(ln, function(n, o2) {
        if (!t)
          try {
            var i = n.call(r);
            i === o2 && (t = i);
          } catch {}
      }), t;
    }, Oa = Dr2();
    pn2.exports = function(r) {
      return Oa(r) ? !sn || !(Symbol.toStringTag in r) ? Sa(ma(r), 8, -1) : Aa(r) : false;
    };
  });
  var qn = y3((g3) => {
    var Ea = Vt2(), wa = Ct(), T = yn(), gn = Dr2();
    function ee(e) {
      return e.call.bind(e);
    }
    var dn = typeof BigInt < "u", hn = typeof Symbol < "u", E5 = ee(Object.prototype.toString), ja = ee(Number.prototype.valueOf), Pa = ee(String.prototype.valueOf), qa = ee(Boolean.prototype.valueOf);
    dn && (bn = ee(BigInt.prototype.valueOf));
    var bn;
    hn && (mn = ee(Symbol.prototype.valueOf));
    var mn;
    function ye(e, r) {
      if (typeof e != "object")
        return false;
      try {
        return r(e), true;
      } catch {
        return false;
      }
    }
    g3.isArgumentsObject = Ea;
    g3.isGeneratorFunction = wa;
    g3.isTypedArray = gn;
    function Ia(e) {
      return typeof Promise < "u" && e instanceof Promise || e !== null && typeof e == "object" && typeof e.then == "function" && typeof e.catch == "function";
    }
    g3.isPromise = Ia;
    function Ta(e) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(e) : gn(e) || Sn2(e);
    }
    g3.isArrayBufferView = Ta;
    function Ra(e) {
      return T(e) === "Uint8Array";
    }
    g3.isUint8Array = Ra;
    function Na(e) {
      return T(e) === "Uint8ClampedArray";
    }
    g3.isUint8ClampedArray = Na;
    function Fa(e) {
      return T(e) === "Uint16Array";
    }
    g3.isUint16Array = Fa;
    function xa(e) {
      return T(e) === "Uint32Array";
    }
    g3.isUint32Array = xa;
    function Da(e) {
      return T(e) === "Int8Array";
    }
    g3.isInt8Array = Da;
    function Ba(e) {
      return T(e) === "Int16Array";
    }
    g3.isInt16Array = Ba;
    function Ua(e) {
      return T(e) === "Int32Array";
    }
    g3.isInt32Array = Ua;
    function Ma(e) {
      return T(e) === "Float32Array";
    }
    g3.isFloat32Array = Ma;
    function _a(e) {
      return T(e) === "Float64Array";
    }
    g3.isFloat64Array = _a;
    function $a(e) {
      return T(e) === "BigInt64Array";
    }
    g3.isBigInt64Array = $a;
    function ka(e) {
      return T(e) === "BigUint64Array";
    }
    g3.isBigUint64Array = ka;
    function Le(e) {
      return E5(e) === "[object Map]";
    }
    Le.working = typeof Map < "u" && Le(new Map);
    function Ga(e) {
      return typeof Map > "u" ? false : Le.working ? Le(e) : e instanceof Map;
    }
    g3.isMap = Ga;
    function Ve(e) {
      return E5(e) === "[object Set]";
    }
    Ve.working = typeof Set < "u" && Ve(new Set);
    function La(e) {
      return typeof Set > "u" ? false : Ve.working ? Ve(e) : e instanceof Set;
    }
    g3.isSet = La;
    function We2(e) {
      return E5(e) === "[object WeakMap]";
    }
    We2.working = typeof WeakMap < "u" && We2(new WeakMap);
    function Va(e) {
      return typeof WeakMap > "u" ? false : We2.working ? We2(e) : e instanceof WeakMap;
    }
    g3.isWeakMap = Va;
    function _r3(e) {
      return E5(e) === "[object WeakSet]";
    }
    _r3.working = typeof WeakSet < "u" && _r3(new WeakSet);
    function Wa(e) {
      return _r3(e);
    }
    g3.isWeakSet = Wa;
    function ze(e) {
      return E5(e) === "[object ArrayBuffer]";
    }
    ze.working = typeof ArrayBuffer < "u" && ze(new ArrayBuffer);
    function vn(e) {
      return typeof ArrayBuffer > "u" ? false : ze.working ? ze(e) : e instanceof ArrayBuffer;
    }
    g3.isArrayBuffer = vn;
    function Ce(e) {
      return E5(e) === "[object DataView]";
    }
    Ce.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Ce(new DataView(new ArrayBuffer(1), 0, 1));
    function Sn2(e) {
      return typeof DataView > "u" ? false : Ce.working ? Ce(e) : e instanceof DataView;
    }
    g3.isDataView = Sn2;
    var Mr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : undefined;
    function pe2(e) {
      return E5(e) === "[object SharedArrayBuffer]";
    }
    function An(e) {
      return typeof Mr > "u" ? false : (typeof pe2.working > "u" && (pe2.working = pe2(new Mr)), pe2.working ? pe2(e) : e instanceof Mr);
    }
    g3.isSharedArrayBuffer = An;
    function za(e) {
      return E5(e) === "[object AsyncFunction]";
    }
    g3.isAsyncFunction = za;
    function Ca(e) {
      return E5(e) === "[object Map Iterator]";
    }
    g3.isMapIterator = Ca;
    function Ha(e) {
      return E5(e) === "[object Set Iterator]";
    }
    g3.isSetIterator = Ha;
    function Ja(e) {
      return E5(e) === "[object Generator]";
    }
    g3.isGeneratorObject = Ja;
    function Ya(e) {
      return E5(e) === "[object WebAssembly.Module]";
    }
    g3.isWebAssemblyCompiledModule = Ya;
    function On2(e) {
      return ye(e, ja);
    }
    g3.isNumberObject = On2;
    function En(e) {
      return ye(e, Pa);
    }
    g3.isStringObject = En;
    function wn(e) {
      return ye(e, qa);
    }
    g3.isBooleanObject = wn;
    function jn2(e) {
      return dn && ye(e, bn);
    }
    g3.isBigIntObject = jn2;
    function Pn(e) {
      return hn && ye(e, mn);
    }
    g3.isSymbolObject = Pn;
    function Xa(e) {
      return On2(e) || En(e) || wn(e) || jn2(e) || Pn(e);
    }
    g3.isBoxedPrimitive = Xa;
    function Za(e) {
      return typeof Uint8Array < "u" && (vn(e) || An(e));
    }
    g3.isAnyArrayBuffer = Za;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e) {
      Object.defineProperty(g3, e, { enumerable: false, value: function() {
        throw new Error(e + " is not supported in userland");
      } });
    });
  });
  var Tn = y3((ac, In) => {
    In.exports = function(r) {
      return r && typeof r == "object" && typeof r.copy == "function" && typeof r.fill == "function" && typeof r.readUInt8 == "function";
    };
  });
  var Rn = y3((fc, $r3) => {
    typeof Object.create == "function" ? $r3.exports = function(r, t) {
      t && (r.super_ = t, r.prototype = Object.create(t.prototype, { constructor: { value: r, enumerable: false, writable: true, configurable: true } }));
    } : $r3.exports = function(r, t) {
      if (t) {
        r.super_ = t;
        var n = function() {};
        n.prototype = t.prototype, r.prototype = new n, r.prototype.constructor = r;
      }
    };
  });
  var Un = y3((d3) => {
    var Nn2 = Object.getOwnPropertyDescriptors || function(r) {
      for (var t = Object.keys(r), n = {}, o2 = 0;o2 < t.length; o2++)
        n[t[o2]] = Object.getOwnPropertyDescriptor(r, t[o2]);
      return n;
    }, Qa = /%[sdj%]/g;
    d3.format = function(e) {
      if (!Ke2(e)) {
        for (var r = [], t = 0;t < arguments.length; t++)
          r.push(B2(arguments[t]));
        return r.join(" ");
      }
      for (var t = 1, n = arguments, o2 = n.length, i = String(e).replace(Qa, function(f2) {
        if (f2 === "%%")
          return "%";
        if (t >= o2)
          return f2;
        switch (f2) {
          case "%s":
            return String(n[t++]);
          case "%d":
            return Number(n[t++]);
          case "%j":
            try {
              return JSON.stringify(n[t++]);
            } catch {
              return "[Circular]";
            }
          default:
            return f2;
        }
      }), a3 = n[t];t < o2; a3 = n[++t])
        Qe2(a3) || !re2(a3) ? i += " " + a3 : i += " " + B2(a3);
      return i;
    };
    d3.deprecate = function(e, r) {
      if (typeof process < "u" && process.noDeprecation === true)
        return e;
      if (typeof process > "u")
        return function() {
          return d3.deprecate(e, r).apply(this, arguments);
        };
      var t = false;
      function n() {
        if (!t) {
          if (process.throwDeprecation)
            throw new Error(r);
          process.traceDeprecation ? console.trace(r) : console.error(r), t = true;
        }
        return e.apply(this, arguments);
      }
      return n;
    };
    var He3 = {}, Fn2 = /^$/;
    process.env.NODE_DEBUG && (Je = process.env.NODE_DEBUG, Je = Je.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), Fn2 = new RegExp("^" + Je + "$", "i"));
    var Je;
    d3.debuglog = function(e) {
      if (e = e.toUpperCase(), !He3[e])
        if (Fn2.test(e)) {
          var r = process.pid;
          He3[e] = function() {
            var t = d3.format.apply(d3, arguments);
            console.error("%s %d: %s", e, r, t);
          };
        } else
          He3[e] = function() {};
      return He3[e];
    };
    function B2(e, r) {
      var t = { seen: [], stylize: ef2 };
      return arguments.length >= 3 && (t.depth = arguments[2]), arguments.length >= 4 && (t.colors = arguments[3]), Vr(r) ? t.showHidden = r : r && d3._extend(t, r), z(t.showHidden) && (t.showHidden = false), z(t.depth) && (t.depth = 2), z(t.colors) && (t.colors = false), z(t.customInspect) && (t.customInspect = true), t.colors && (t.stylize = Ka), Xe(t, e, t.depth);
    }
    d3.inspect = B2;
    B2.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] };
    B2.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" };
    function Ka(e, r) {
      var t = B2.styles[r];
      return t ? "\x1B[" + B2.colors[t][0] + "m" + e + "\x1B[" + B2.colors[t][1] + "m" : e;
    }
    function ef2(e, r) {
      return e;
    }
    function rf(e) {
      var r = {};
      return e.forEach(function(t, n) {
        r[t] = true;
      }), r;
    }
    function Xe(e, r, t) {
      if (e.customInspect && r && Ye(r.inspect) && r.inspect !== d3.inspect && !(r.constructor && r.constructor.prototype === r)) {
        var n = r.inspect(t, e);
        return Ke2(n) || (n = Xe(e, n, t)), n;
      }
      var o2 = tf2(e, r);
      if (o2)
        return o2;
      var i = Object.keys(r), a3 = rf(i);
      if (e.showHidden && (i = Object.getOwnPropertyNames(r)), de(r) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
        return kr(r);
      if (i.length === 0) {
        if (Ye(r)) {
          var f2 = r.name ? ": " + r.name : "";
          return e.stylize("[Function" + f2 + "]", "special");
        }
        if (ge(r))
          return e.stylize(RegExp.prototype.toString.call(r), "regexp");
        if (Ze2(r))
          return e.stylize(Date.prototype.toString.call(r), "date");
        if (de(r))
          return kr(r);
      }
      var u2 = "", c2 = false, s2 = ["{", "}"];
      if (xn(r) && (c2 = true, s2 = ["[", "]"]), Ye(r)) {
        var l3 = r.name ? ": " + r.name : "";
        u2 = " [Function" + l3 + "]";
      }
      if (ge(r) && (u2 = " " + RegExp.prototype.toString.call(r)), Ze2(r) && (u2 = " " + Date.prototype.toUTCString.call(r)), de(r) && (u2 = " " + kr(r)), i.length === 0 && (!c2 || r.length == 0))
        return s2[0] + u2 + s2[1];
      if (t < 0)
        return ge(r) ? e.stylize(RegExp.prototype.toString.call(r), "regexp") : e.stylize("[Object]", "special");
      e.seen.push(r);
      var p3;
      return c2 ? p3 = nf(e, r, t, a3, i) : p3 = i.map(function(m3) {
        return Lr(e, r, t, a3, m3, c2);
      }), e.seen.pop(), of(p3, u2, s2);
    }
    function tf2(e, r) {
      if (z(r))
        return e.stylize("undefined", "undefined");
      if (Ke2(r)) {
        var t = "'" + JSON.stringify(r).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return e.stylize(t, "string");
      }
      if (Dn2(r))
        return e.stylize("" + r, "number");
      if (Vr(r))
        return e.stylize("" + r, "boolean");
      if (Qe2(r))
        return e.stylize("null", "null");
    }
    function kr(e) {
      return "[" + Error.prototype.toString.call(e) + "]";
    }
    function nf(e, r, t, n, o2) {
      for (var i = [], a3 = 0, f2 = r.length;a3 < f2; ++a3)
        Bn2(r, String(a3)) ? i.push(Lr(e, r, t, n, String(a3), true)) : i.push("");
      return o2.forEach(function(u2) {
        u2.match(/^\d+$/) || i.push(Lr(e, r, t, n, u2, true));
      }), i;
    }
    function Lr(e, r, t, n, o2, i) {
      var a3, f2, u2;
      if (u2 = Object.getOwnPropertyDescriptor(r, o2) || { value: r[o2] }, u2.get ? u2.set ? f2 = e.stylize("[Getter/Setter]", "special") : f2 = e.stylize("[Getter]", "special") : u2.set && (f2 = e.stylize("[Setter]", "special")), Bn2(n, o2) || (a3 = "[" + o2 + "]"), f2 || (e.seen.indexOf(u2.value) < 0 ? (Qe2(t) ? f2 = Xe(e, u2.value, null) : f2 = Xe(e, u2.value, t - 1), f2.indexOf(`
`) > -1 && (i ? f2 = f2.split(`
`).map(function(c2) {
        return "  " + c2;
      }).join(`
`).slice(2) : f2 = `
` + f2.split(`
`).map(function(c2) {
        return "   " + c2;
      }).join(`
`))) : f2 = e.stylize("[Circular]", "special")), z(a3)) {
        if (i && o2.match(/^\d+$/))
          return f2;
        a3 = JSON.stringify("" + o2), a3.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (a3 = a3.slice(1, -1), a3 = e.stylize(a3, "name")) : (a3 = a3.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), a3 = e.stylize(a3, "string"));
      }
      return a3 + ": " + f2;
    }
    function of(e, r, t) {
      var n = 0, o2 = e.reduce(function(i, a3) {
        return n++, a3.indexOf(`
`) >= 0 && n++, i + a3.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return o2 > 60 ? t[0] + (r === "" ? "" : r + `
 `) + " " + e.join(`,
  `) + " " + t[1] : t[0] + r + " " + e.join(", ") + " " + t[1];
    }
    d3.types = qn();
    function xn(e) {
      return Array.isArray(e);
    }
    d3.isArray = xn;
    function Vr(e) {
      return typeof e == "boolean";
    }
    d3.isBoolean = Vr;
    function Qe2(e) {
      return e === null;
    }
    d3.isNull = Qe2;
    function af(e) {
      return e == null;
    }
    d3.isNullOrUndefined = af;
    function Dn2(e) {
      return typeof e == "number";
    }
    d3.isNumber = Dn2;
    function Ke2(e) {
      return typeof e == "string";
    }
    d3.isString = Ke2;
    function ff(e) {
      return typeof e == "symbol";
    }
    d3.isSymbol = ff;
    function z(e) {
      return e === undefined;
    }
    d3.isUndefined = z;
    function ge(e) {
      return re2(e) && Wr(e) === "[object RegExp]";
    }
    d3.isRegExp = ge;
    d3.types.isRegExp = ge;
    function re2(e) {
      return typeof e == "object" && e !== null;
    }
    d3.isObject = re2;
    function Ze2(e) {
      return re2(e) && Wr(e) === "[object Date]";
    }
    d3.isDate = Ze2;
    d3.types.isDate = Ze2;
    function de(e) {
      return re2(e) && (Wr(e) === "[object Error]" || e instanceof Error);
    }
    d3.isError = de;
    d3.types.isNativeError = de;
    function Ye(e) {
      return typeof e == "function";
    }
    d3.isFunction = Ye;
    function uf(e) {
      return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || typeof e > "u";
    }
    d3.isPrimitive = uf;
    d3.isBuffer = Tn();
    function Wr(e) {
      return Object.prototype.toString.call(e);
    }
    function Gr2(e) {
      return e < 10 ? "0" + e.toString(10) : e.toString(10);
    }
    var cf = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    function sf() {
      var e = new Date, r = [Gr2(e.getHours()), Gr2(e.getMinutes()), Gr2(e.getSeconds())].join(":");
      return [e.getDate(), cf[e.getMonth()], r].join(" ");
    }
    d3.log = function() {
      console.log("%s - %s", sf(), d3.format.apply(d3, arguments));
    };
    d3.inherits = Rn();
    d3._extend = function(e, r) {
      if (!r || !re2(r))
        return e;
      for (var t = Object.keys(r), n = t.length;n--; )
        e[t[n]] = r[t[n]];
      return e;
    };
    function Bn2(e, r) {
      return Object.prototype.hasOwnProperty.call(e, r);
    }
    var W = typeof Symbol < "u" ? Symbol("util.promisify.custom") : undefined;
    d3.promisify = function(r) {
      if (typeof r != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (W && r[W]) {
        var t = r[W];
        if (typeof t != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, W, { value: t, enumerable: false, writable: false, configurable: true }), t;
      }
      function t() {
        for (var n, o2, i = new Promise(function(u2, c2) {
          n = u2, o2 = c2;
        }), a3 = [], f2 = 0;f2 < arguments.length; f2++)
          a3.push(arguments[f2]);
        a3.push(function(u2, c2) {
          u2 ? o2(u2) : n(c2);
        });
        try {
          r.apply(this, a3);
        } catch (u2) {
          o2(u2);
        }
        return i;
      }
      return Object.setPrototypeOf(t, Object.getPrototypeOf(r)), W && Object.defineProperty(t, W, { value: t, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t, Nn2(r));
    };
    d3.promisify.custom = W;
    function lf(e, r) {
      if (!e) {
        var t = new Error("Promise was rejected with a falsy value");
        t.reason = e, e = t;
      }
      return r(e);
    }
    function pf(e) {
      if (typeof e != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function r() {
        for (var t = [], n = 0;n < arguments.length; n++)
          t.push(arguments[n]);
        var o2 = t.pop();
        if (typeof o2 != "function")
          throw new TypeError("The last argument must be of type Function");
        var i = this, a3 = function() {
          return o2.apply(i, arguments);
        };
        e.apply(this, t).then(function(f2) {
          process.nextTick(a3.bind(null, null, f2));
        }, function(f2) {
          process.nextTick(lf.bind(null, f2, a3));
        });
      }
      return Object.setPrototypeOf(r, Object.getPrototypeOf(e)), Object.defineProperties(r, Nn2(e)), r;
    }
    d3.callbackify = pf;
  });
  var w2 = {};
  Ai2(w2, { TextDecoder: () => _n2, TextEncoder: () => Mn, default: () => yf });
  var Mn;
  var _n2;
  var yf;
  var te2 = Si3(() => {
    D(w2, bt4(Un()));
    Mn = globalThis.TextEncoder, _n2 = globalThis.TextDecoder, yf = { TextEncoder: Mn, TextDecoder: _n2 };
  });
  var Jr2 = y3((sc, Gn) => {
    function ne(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ne = function(t) {
        return typeof t;
      } : ne = function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      }, ne(e);
    }
    function gf(e, r) {
      if (!(e instanceof r))
        throw new TypeError("Cannot call a class as a function");
    }
    function df(e, r) {
      return r && (ne(r) === "object" || typeof r == "function") ? r : hf(e);
    }
    function hf(e) {
      if (e === undefined)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function Cr3(e) {
      return Cr3 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
      }, Cr3(e);
    }
    function bf(e, r) {
      if (typeof r != "function" && r !== null)
        throw new TypeError("Super expression must either be null or a function");
      e.prototype = Object.create(r && r.prototype, { constructor: { value: e, writable: true, configurable: true } }), r && Hr(e, r);
    }
    function Hr(e, r) {
      return Hr = Object.setPrototypeOf || function(n, o2) {
        return n.__proto__ = o2, n;
      }, Hr(e, r);
    }
    var kn = {}, oe3, zr;
    function he(e, r, t) {
      t || (t = Error);
      function n(i, a3, f2) {
        return typeof r == "string" ? r : r(i, a3, f2);
      }
      var o2 = function(i) {
        bf(a3, i);
        function a3(f2, u2, c2) {
          var s2;
          return gf(this, a3), s2 = df(this, Cr3(a3).call(this, n(f2, u2, c2))), s2.code = e, s2;
        }
        return a3;
      }(t);
      kn[e] = o2;
    }
    function $n(e, r) {
      if (Array.isArray(e)) {
        var t = e.length;
        return e = e.map(function(n) {
          return String(n);
        }), t > 2 ? "one of ".concat(r, " ").concat(e.slice(0, t - 1).join(", "), ", or ") + e[t - 1] : t === 2 ? "one of ".concat(r, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(r, " ").concat(e[0]);
      } else
        return "of ".concat(r, " ").concat(String(e));
    }
    function mf(e, r, t) {
      return e.substr(!t || t < 0 ? 0 : +t, r.length) === r;
    }
    function vf(e, r, t) {
      return (t === undefined || t > e.length) && (t = e.length), e.substring(t - r.length, t) === r;
    }
    function Sf(e, r, t) {
      return typeof t != "number" && (t = 0), t + r.length > e.length ? false : e.indexOf(r, t) !== -1;
    }
    he("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
    he("ERR_INVALID_ARG_TYPE", function(e, r, t) {
      oe3 === undefined && (oe3 = er2()), oe3(typeof e == "string", "'name' must be a string");
      var n;
      typeof r == "string" && mf(r, "not ") ? (n = "must not be", r = r.replace(/^not /, "")) : n = "must be";
      var o2;
      if (vf(e, " argument"))
        o2 = "The ".concat(e, " ").concat(n, " ").concat($n(r, "type"));
      else {
        var i = Sf(e, ".") ? "property" : "argument";
        o2 = 'The "'.concat(e, '" ').concat(i, " ").concat(n, " ").concat($n(r, "type"));
      }
      return o2 += ". Received type ".concat(ne(t)), o2;
    }, TypeError);
    he("ERR_INVALID_ARG_VALUE", function(e, r) {
      var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "is invalid";
      zr === undefined && (zr = (te2(), ue4(w2)));
      var n = zr.inspect(r);
      return n.length > 128 && (n = "".concat(n.slice(0, 128), "...")), "The argument '".concat(e, "' ").concat(t, ". Received ").concat(n);
    }, TypeError, RangeError);
    he("ERR_INVALID_RETURN_VALUE", function(e, r, t) {
      var n;
      return t && t.constructor && t.constructor.name ? n = "instance of ".concat(t.constructor.name) : n = "type ".concat(ne(t)), "Expected ".concat(e, ' to be returned from the "').concat(r, '"') + " function but got ".concat(n, ".");
    }, TypeError);
    he("ERR_MISSING_ARGS", function() {
      for (var e = arguments.length, r = new Array(e), t = 0;t < e; t++)
        r[t] = arguments[t];
      oe3 === undefined && (oe3 = er2()), oe3(r.length > 0, "At least one arg needs to be specified");
      var n = "The ", o2 = r.length;
      switch (r = r.map(function(i) {
        return '"'.concat(i, '"');
      }), o2) {
        case 1:
          n += "".concat(r[0], " argument");
          break;
        case 2:
          n += "".concat(r[0], " and ").concat(r[1], " arguments");
          break;
        default:
          n += r.slice(0, o2 - 1).join(", "), n += ", and ".concat(r[o2 - 1], " arguments");
          break;
      }
      return "".concat(n, " must be specified");
    }, TypeError);
    Gn.exports.codes = kn;
  });
  var Cn = y3((lc, zn2) => {
    function Af(e) {
      for (var r = 1;r < arguments.length; r++) {
        var t = arguments[r] != null ? arguments[r] : {}, n = Object.keys(t);
        typeof Object.getOwnPropertySymbols == "function" && (n = n.concat(Object.getOwnPropertySymbols(t).filter(function(o2) {
          return Object.getOwnPropertyDescriptor(t, o2).enumerable;
        }))), n.forEach(function(o2) {
          Of(e, o2, t[o2]);
        });
      }
      return e;
    }
    function Of(e, r, t) {
      return r in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function Ef(e, r) {
      if (!(e instanceof r))
        throw new TypeError("Cannot call a class as a function");
    }
    function Ln2(e, r) {
      for (var t = 0;t < r.length; t++) {
        var n = r[t];
        n.enumerable = n.enumerable || false, n.configurable = true, "value" in n && (n.writable = true), Object.defineProperty(e, n.key, n);
      }
    }
    function wf(e, r, t) {
      return r && Ln2(e.prototype, r), t && Ln2(e, t), e;
    }
    function ie(e, r) {
      return r && (j3(r) === "object" || typeof r == "function") ? r : Yr(e);
    }
    function Yr(e) {
      if (e === undefined)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function jf(e, r) {
      if (typeof r != "function" && r !== null)
        throw new TypeError("Super expression must either be null or a function");
      e.prototype = Object.create(r && r.prototype, { constructor: { value: e, writable: true, configurable: true } }), r && Se3(e, r);
    }
    function Xr(e) {
      var r = typeof Map == "function" ? new Map : undefined;
      return Xr = function(n) {
        if (n === null || !qf(n))
          return n;
        if (typeof n != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof r < "u") {
          if (r.has(n))
            return r.get(n);
          r.set(n, o2);
        }
        function o2() {
          return rr(n, arguments, U2(this).constructor);
        }
        return o2.prototype = Object.create(n.prototype, { constructor: { value: o2, enumerable: false, writable: true, configurable: true } }), Se3(o2, n);
      }, Xr(e);
    }
    function Pf() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
        return false;
      if (typeof Proxy == "function")
        return true;
      try {
        return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), true;
      } catch {
        return false;
      }
    }
    function rr(e, r, t) {
      return Pf() ? rr = Reflect.construct : rr = function(o2, i, a3) {
        var f2 = [null];
        f2.push.apply(f2, i);
        var u2 = Function.bind.apply(o2, f2), c2 = new u2;
        return a3 && Se3(c2, a3.prototype), c2;
      }, rr.apply(null, arguments);
    }
    function qf(e) {
      return Function.toString.call(e).indexOf("[native code]") !== -1;
    }
    function Se3(e, r) {
      return Se3 = Object.setPrototypeOf || function(n, o2) {
        return n.__proto__ = o2, n;
      }, Se3(e, r);
    }
    function U2(e) {
      return U2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
        return t.__proto__ || Object.getPrototypeOf(t);
      }, U2(e);
    }
    function j3(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? j3 = function(t) {
        return typeof t;
      } : j3 = function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      }, j3(e);
    }
    var If = (te2(), ue4(w2)), Zr2 = If.inspect, Tf = Jr2(), Rf = Tf.codes.ERR_INVALID_ARG_TYPE;
    function Vn(e, r, t) {
      return (t === undefined || t > e.length) && (t = e.length), e.substring(t - r.length, t) === r;
    }
    function Nf(e, r) {
      if (r = Math.floor(r), e.length == 0 || r == 0)
        return "";
      var t = e.length * r;
      for (r = Math.floor(Math.log(r) / Math.log(2));r; )
        e += e, r--;
      return e += e.substring(0, t - e.length), e;
    }
    var R2 = "", be = "", me = "", v2 = "", C3 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" }, Ff = 10;
    function Wn(e) {
      var r = Object.keys(e), t = Object.create(Object.getPrototypeOf(e));
      return r.forEach(function(n) {
        t[n] = e[n];
      }), Object.defineProperty(t, "message", { value: e.message }), t;
    }
    function ve(e) {
      return Zr2(e, { compact: false, customInspect: false, depth: 1000, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
    }
    function xf(e, r, t) {
      var n = "", o2 = "", i = 0, a3 = "", f2 = false, u2 = ve(e), c2 = u2.split(`
`), s2 = ve(r).split(`
`), l3 = 0, p3 = "";
      if (t === "strictEqual" && j3(e) === "object" && j3(r) === "object" && e !== null && r !== null && (t = "strictEqualObject"), c2.length === 1 && s2.length === 1 && c2[0] !== s2[0]) {
        var m3 = c2[0].length + s2[0].length;
        if (m3 <= Ff) {
          if ((j3(e) !== "object" || e === null) && (j3(r) !== "object" || r === null) && (e !== 0 || r !== 0))
            return "".concat(C3[t], `

`) + "".concat(c2[0], " !== ").concat(s2[0], `
`);
        } else if (t !== "strictEqualObject") {
          var S = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
          if (m3 < S) {
            for (;c2[0][l3] === s2[0][l3]; )
              l3++;
            l3 > 2 && (p3 = `
  `.concat(Nf(" ", l3), "^"), l3 = 0);
          }
        }
      }
      for (var q = c2[c2.length - 1], gt3 = s2[s2.length - 1];q === gt3 && (l3++ < 2 ? a3 = `
  `.concat(q).concat(a3) : n = q, c2.pop(), s2.pop(), !(c2.length === 0 || s2.length === 0)); )
        q = c2[c2.length - 1], gt3 = s2[s2.length - 1];
      var gr3 = Math.max(c2.length, s2.length);
      if (gr3 === 0) {
        var ae2 = u2.split(`
`);
        if (ae2.length > 30)
          for (ae2[26] = "".concat(R2, "...").concat(v2);ae2.length > 27; )
            ae2.pop();
        return "".concat(C3.notIdentical, `

`).concat(ae2.join(`
`), `
`);
      }
      l3 > 3 && (a3 = `
`.concat(R2, "...").concat(v2).concat(a3), f2 = true), n !== "" && (a3 = `
  `.concat(n).concat(a3), n = "");
      var I3 = 0, dt3 = C3[t] + `
`.concat(be, "+ actual").concat(v2, " ").concat(me, "- expected").concat(v2), ht = " ".concat(R2, "...").concat(v2, " Lines skipped");
      for (l3 = 0;l3 < gr3; l3++) {
        var F2 = l3 - i;
        if (c2.length < l3 + 1)
          F2 > 1 && l3 > 2 && (F2 > 4 ? (o2 += `
`.concat(R2, "...").concat(v2), f2 = true) : F2 > 3 && (o2 += `
  `.concat(s2[l3 - 2]), I3++), o2 += `
  `.concat(s2[l3 - 1]), I3++), i = l3, n += `
`.concat(me, "-").concat(v2, " ").concat(s2[l3]), I3++;
        else if (s2.length < l3 + 1)
          F2 > 1 && l3 > 2 && (F2 > 4 ? (o2 += `
`.concat(R2, "...").concat(v2), f2 = true) : F2 > 3 && (o2 += `
  `.concat(c2[l3 - 2]), I3++), o2 += `
  `.concat(c2[l3 - 1]), I3++), i = l3, o2 += `
`.concat(be, "+").concat(v2, " ").concat(c2[l3]), I3++;
        else {
          var fe3 = s2[l3], k3 = c2[l3], dr4 = k3 !== fe3 && (!Vn(k3, ",") || k3.slice(0, -1) !== fe3);
          dr4 && Vn(fe3, ",") && fe3.slice(0, -1) === k3 && (dr4 = false, k3 += ","), dr4 ? (F2 > 1 && l3 > 2 && (F2 > 4 ? (o2 += `
`.concat(R2, "...").concat(v2), f2 = true) : F2 > 3 && (o2 += `
  `.concat(c2[l3 - 2]), I3++), o2 += `
  `.concat(c2[l3 - 1]), I3++), i = l3, o2 += `
`.concat(be, "+").concat(v2, " ").concat(k3), n += `
`.concat(me, "-").concat(v2, " ").concat(fe3), I3 += 2) : (o2 += n, n = "", (F2 === 1 || l3 === 0) && (o2 += `
  `.concat(k3), I3++));
        }
        if (I3 > 20 && l3 < gr3 - 2)
          return "".concat(dt3).concat(ht, `
`).concat(o2, `
`).concat(R2, "...").concat(v2).concat(n, `
`) + "".concat(R2, "...").concat(v2);
      }
      return "".concat(dt3).concat(f2 ? ht : "", `
`).concat(o2).concat(n).concat(a3).concat(p3);
    }
    var Df = function(e) {
      jf(r, e);
      function r(t) {
        var n;
        if (Ef(this, r), j3(t) !== "object" || t === null)
          throw new Rf("options", "Object", t);
        var { message: o2, operator: i, stackStartFn: a3, actual: f2, expected: u2 } = t, c2 = Error.stackTraceLimit;
        if (Error.stackTraceLimit = 0, o2 != null)
          n = ie(this, U2(r).call(this, String(o2)));
        else if (process.stderr && process.stderr.isTTY && (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1 ? (R2 = "\x1B[34m", be = "\x1B[32m", v2 = "\x1B[39m", me = "\x1B[31m") : (R2 = "", be = "", v2 = "", me = "")), j3(f2) === "object" && f2 !== null && j3(u2) === "object" && u2 !== null && "stack" in f2 && f2 instanceof Error && "stack" in u2 && u2 instanceof Error && (f2 = Wn(f2), u2 = Wn(u2)), i === "deepStrictEqual" || i === "strictEqual")
          n = ie(this, U2(r).call(this, xf(f2, u2, i)));
        else if (i === "notDeepStrictEqual" || i === "notStrictEqual") {
          var s2 = C3[i], l3 = ve(f2).split(`
`);
          if (i === "notStrictEqual" && j3(f2) === "object" && f2 !== null && (s2 = C3.notStrictEqualObject), l3.length > 30)
            for (l3[26] = "".concat(R2, "...").concat(v2);l3.length > 27; )
              l3.pop();
          l3.length === 1 ? n = ie(this, U2(r).call(this, "".concat(s2, " ").concat(l3[0]))) : n = ie(this, U2(r).call(this, "".concat(s2, `

`).concat(l3.join(`
`), `
`)));
        } else {
          var p3 = ve(f2), m3 = "", S = C3[i];
          i === "notDeepEqual" || i === "notEqual" ? (p3 = "".concat(C3[i], `

`).concat(p3), p3.length > 1024 && (p3 = "".concat(p3.slice(0, 1021), "..."))) : (m3 = "".concat(ve(u2)), p3.length > 512 && (p3 = "".concat(p3.slice(0, 509), "...")), m3.length > 512 && (m3 = "".concat(m3.slice(0, 509), "...")), i === "deepEqual" || i === "equal" ? p3 = "".concat(S, `

`).concat(p3, `

should equal

`) : m3 = " ".concat(i, " ").concat(m3)), n = ie(this, U2(r).call(this, "".concat(p3).concat(m3)));
        }
        return Error.stackTraceLimit = c2, n.generatedMessage = !o2, Object.defineProperty(Yr(n), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), n.code = "ERR_ASSERTION", n.actual = f2, n.expected = u2, n.operator = i, Error.captureStackTrace && Error.captureStackTrace(Yr(n), a3), n.stack, n.name = "AssertionError", ie(n);
      }
      return wf(r, [{ key: "toString", value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      } }, { key: Zr2.custom, value: function(n, o2) {
        return Zr2(this, Af({}, o2, { customInspect: false, depth: 0 }));
      } }]), r;
    }(Xr(Error));
    zn2.exports = Df;
  });
  var Yn = y3((pc, Jn) => {
    function Hn(e, r) {
      if (e == null)
        throw new TypeError("Cannot convert first argument to object");
      for (var t = Object(e), n = 1;n < arguments.length; n++) {
        var o2 = arguments[n];
        if (o2 != null)
          for (var i = Object.keys(Object(o2)), a3 = 0, f2 = i.length;a3 < f2; a3++) {
            var u2 = i[a3], c2 = Object.getOwnPropertyDescriptor(o2, u2);
            c2 !== undefined && c2.enumerable && (t[u2] = o2[u2]);
          }
      }
      return t;
    }
    function Bf() {
      Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: Hn });
    }
    Jn.exports = { assign: Hn, polyfill: Bf };
  });
  var Qr2 = y3((yc, Zn) => {
    var Xn = Object.prototype.toString;
    Zn.exports = function(r) {
      var t = Xn.call(r), n = t === "[object Arguments]";
      return n || (n = t !== "[object Array]" && r !== null && typeof r == "object" && typeof r.length == "number" && r.length >= 0 && Xn.call(r.callee) === "[object Function]"), n;
    };
  });
  var ao = y3((gc, io) => {
    var oo;
    Object.keys || (Ae2 = Object.prototype.hasOwnProperty, Kr3 = Object.prototype.toString, Qn = Qr2(), et3 = Object.prototype.propertyIsEnumerable, Kn = !et3.call({ toString: null }, "toString"), eo2 = et3.call(function() {}, "prototype"), Oe = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], tr = function(e) {
      var r = e.constructor;
      return r && r.prototype === e;
    }, ro2 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, to2 = function() {
      if (typeof window > "u")
        return false;
      for (var e in window)
        try {
          if (!ro2["$" + e] && Ae2.call(window, e) && window[e] !== null && typeof window[e] == "object")
            try {
              tr(window[e]);
            } catch {
              return true;
            }
        } catch {
          return true;
        }
      return false;
    }(), no = function(e) {
      if (typeof window > "u" || !to2)
        return tr(e);
      try {
        return tr(e);
      } catch {
        return false;
      }
    }, oo = function(r) {
      var t = r !== null && typeof r == "object", n = Kr3.call(r) === "[object Function]", o2 = Qn(r), i = t && Kr3.call(r) === "[object String]", a3 = [];
      if (!t && !n && !o2)
        throw new TypeError("Object.keys called on a non-object");
      var f2 = eo2 && n;
      if (i && r.length > 0 && !Ae2.call(r, 0))
        for (var u2 = 0;u2 < r.length; ++u2)
          a3.push(String(u2));
      if (o2 && r.length > 0)
        for (var c2 = 0;c2 < r.length; ++c2)
          a3.push(String(c2));
      else
        for (var s2 in r)
          !(f2 && s2 === "prototype") && Ae2.call(r, s2) && a3.push(String(s2));
      if (Kn)
        for (var l3 = no(r), p3 = 0;p3 < Oe.length; ++p3)
          !(l3 && Oe[p3] === "constructor") && Ae2.call(r, Oe[p3]) && a3.push(Oe[p3]);
      return a3;
    });
    var Ae2, Kr3, Qn, et3, Kn, eo2, Oe, tr, ro2, to2, no;
    io.exports = oo;
  });
  var so2 = y3((dc, co) => {
    var Uf = Array.prototype.slice, Mf = Qr2(), fo = Object.keys, nr = fo ? function(r) {
      return fo(r);
    } : ao(), uo = Object.keys;
    nr.shim = function() {
      if (Object.keys) {
        var r = function() {
          var t = Object.keys(arguments);
          return t && t.length === arguments.length;
        }(1, 2);
        r || (Object.keys = function(n) {
          return Mf(n) ? uo(Uf.call(n)) : uo(n);
        });
      } else
        Object.keys = nr;
      return Object.keys || nr;
    };
    co.exports = nr;
  });
  var po = y3((hc, lo) => {
    var _f = le(), rt3 = _f("%Object.defineProperty%", true), tt3 = function() {
      if (rt3)
        try {
          return rt3({}, "a", { value: 1 }), true;
        } catch {
          return false;
        }
      return false;
    };
    tt3.hasArrayLengthDefineBug = function() {
      if (!tt3())
        return null;
      try {
        return rt3([], "length", { value: 1 }).length !== 1;
      } catch {
        return true;
      }
    };
    lo.exports = tt3;
  });
  var Ee = y3((bc, bo) => {
    var $f = so2(), kf = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", Gf = Object.prototype.toString, Lf = Array.prototype.concat, yo = Object.defineProperty, Vf = function(e) {
      return typeof e == "function" && Gf.call(e) === "[object Function]";
    }, Wf = po()(), go = yo && Wf, zf = function(e, r, t, n) {
      if (r in e) {
        if (n === true) {
          if (e[r] === t)
            return;
        } else if (!Vf(n) || !n())
          return;
      }
      go ? yo(e, r, { configurable: true, enumerable: false, value: t, writable: true }) : e[r] = t;
    }, ho = function(e, r) {
      var t = arguments.length > 2 ? arguments[2] : {}, n = $f(r);
      kf && (n = Lf.call(n, Object.getOwnPropertySymbols(r)));
      for (var o2 = 0;o2 < n.length; o2 += 1)
        zf(e, n[o2], r[n[o2]], t[n[o2]]);
    };
    ho.supportsDescriptors = !!go;
    bo.exports = ho;
  });
  var nt3 = y3((mc, vo) => {
    var mo = function(e) {
      return e !== e;
    };
    vo.exports = function(r, t) {
      return r === 0 && t === 0 ? 1 / r === 1 / t : !!(r === t || mo(r) && mo(t));
    };
  });
  var ot = y3((vc, So) => {
    var Cf2 = nt3();
    So.exports = function() {
      return typeof Object.is == "function" ? Object.is : Cf2;
    };
  });
  var Oo = y3((Sc, Ao) => {
    var Hf = ot(), Jf = Ee();
    Ao.exports = function() {
      var r = Hf();
      return Jf(Object, { is: r }, { is: function() {
        return Object.is !== r;
      } }), r;
    };
  });
  var it2 = y3((Ac, jo) => {
    var Yf = Ee(), Xf = Be(), Zf = nt3(), Eo = ot(), Qf = Oo(), wo = Xf(Eo(), Object);
    Yf(wo, { getPolyfill: Eo, implementation: Zf, shim: Qf });
    jo.exports = wo;
  });
  var at = y3((Oc, Po) => {
    Po.exports = function(r) {
      return r !== r;
    };
  });
  var ft = y3((Ec, qo) => {
    var Kf = at();
    qo.exports = function() {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : Kf;
    };
  });
  var To = y3((wc, Io) => {
    var eu = Ee(), ru = ft();
    Io.exports = function() {
      var r = ru();
      return eu(Number, { isNaN: r }, { isNaN: function() {
        return Number.isNaN !== r;
      } }), r;
    };
  });
  var xo = y3((jc, Fo) => {
    var tu = Be(), nu = Ee(), ou2 = at(), Ro = ft(), iu2 = To(), No = tu(Ro(), Number);
    nu(No, { getPolyfill: Ro, implementation: ou2, shim: iu2 });
    Fo.exports = No;
  });
  var Qo = y3((Pc, Zo) => {
    function Do(e, r) {
      return uu2(e) || fu2(e, r) || au2();
    }
    function au2() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
    function fu2(e, r) {
      var t = [], n = true, o2 = false, i = undefined;
      try {
        for (var a3 = e[Symbol.iterator](), f2;!(n = (f2 = a3.next()).done) && (t.push(f2.value), !(r && t.length === r)); n = true)
          ;
      } catch (u2) {
        o2 = true, i = u2;
      } finally {
        try {
          !n && a3.return != null && a3.return();
        } finally {
          if (o2)
            throw i;
        }
      }
      return t;
    }
    function uu2(e) {
      if (Array.isArray(e))
        return e;
    }
    function O2(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? O2 = function(t) {
        return typeof t;
      } : O2 = function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      }, O2(e);
    }
    var cu2 = /a/g.flags !== undefined, sr = function(r) {
      var t = [];
      return r.forEach(function(n) {
        return t.push(n);
      }), t;
    }, Bo = function(r) {
      var t = [];
      return r.forEach(function(n, o2) {
        return t.push([o2, n]);
      }), t;
    }, Co = Object.is ? Object.is : it2(), ur2 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
      return [];
    }, ut2 = Number.isNaN ? Number.isNaN : xo();
    function st2(e) {
      return e.call.bind(e);
    }
    var je = st2(Object.prototype.hasOwnProperty), cr2 = st2(Object.prototype.propertyIsEnumerable), Uo = st2(Object.prototype.toString), A3 = (te2(), ue4(w2)).types, su2 = A3.isAnyArrayBuffer, lu2 = A3.isArrayBufferView, Mo2 = A3.isDate, or = A3.isMap, _o = A3.isRegExp, ir3 = A3.isSet, pu = A3.isNativeError, yu = A3.isBoxedPrimitive, $o = A3.isNumberObject, ko = A3.isStringObject, Go = A3.isBooleanObject, Lo = A3.isBigIntObject, gu = A3.isSymbolObject, du = A3.isFloat32Array, hu2 = A3.isFloat64Array;
    function bu(e) {
      if (e.length === 0 || e.length > 10)
        return true;
      for (var r = 0;r < e.length; r++) {
        var t = e.charCodeAt(r);
        if (t < 48 || t > 57)
          return true;
      }
      return e.length === 10 && e >= Math.pow(2, 32);
    }
    function ar2(e) {
      return Object.keys(e).filter(bu).concat(ur2(e).filter(Object.prototype.propertyIsEnumerable.bind(e)));
    }
    function Ho(e, r) {
      if (e === r)
        return 0;
      for (var t = e.length, n = r.length, o2 = 0, i = Math.min(t, n);o2 < i; ++o2)
        if (e[o2] !== r[o2]) {
          t = e[o2], n = r[o2];
          break;
        }
      return t < n ? -1 : n < t ? 1 : 0;
    }
    var fr = undefined, mu = true, vu = false, ct2 = 0, lt2 = 1, Jo2 = 2, Yo = 3;
    function Su(e, r) {
      return cu2 ? e.source === r.source && e.flags === r.flags : RegExp.prototype.toString.call(e) === RegExp.prototype.toString.call(r);
    }
    function Au(e, r) {
      if (e.byteLength !== r.byteLength)
        return false;
      for (var t = 0;t < e.byteLength; t++)
        if (e[t] !== r[t])
          return false;
      return true;
    }
    function Ou(e, r) {
      return e.byteLength !== r.byteLength ? false : Ho(new Uint8Array(e.buffer, e.byteOffset, e.byteLength), new Uint8Array(r.buffer, r.byteOffset, r.byteLength)) === 0;
    }
    function Eu(e, r) {
      return e.byteLength === r.byteLength && Ho(new Uint8Array(e), new Uint8Array(r)) === 0;
    }
    function wu(e, r) {
      return $o(e) ? $o(r) && Co(Number.prototype.valueOf.call(e), Number.prototype.valueOf.call(r)) : ko(e) ? ko(r) && String.prototype.valueOf.call(e) === String.prototype.valueOf.call(r) : Go(e) ? Go(r) && Boolean.prototype.valueOf.call(e) === Boolean.prototype.valueOf.call(r) : Lo(e) ? Lo(r) && BigInt.prototype.valueOf.call(e) === BigInt.prototype.valueOf.call(r) : gu(r) && Symbol.prototype.valueOf.call(e) === Symbol.prototype.valueOf.call(r);
    }
    function P2(e, r, t, n) {
      if (e === r)
        return e !== 0 ? true : t ? Co(e, r) : true;
      if (t) {
        if (O2(e) !== "object")
          return typeof e == "number" && ut2(e) && ut2(r);
        if (O2(r) !== "object" || e === null || r === null || Object.getPrototypeOf(e) !== Object.getPrototypeOf(r))
          return false;
      } else {
        if (e === null || O2(e) !== "object")
          return r === null || O2(r) !== "object" ? e == r : false;
        if (r === null || O2(r) !== "object")
          return false;
      }
      var o2 = Uo(e), i = Uo(r);
      if (o2 !== i)
        return false;
      if (Array.isArray(e)) {
        if (e.length !== r.length)
          return false;
        var a3 = ar2(e, fr), f2 = ar2(r, fr);
        return a3.length !== f2.length ? false : we(e, r, t, n, lt2, a3);
      }
      if (o2 === "[object Object]" && (!or(e) && or(r) || !ir3(e) && ir3(r)))
        return false;
      if (Mo2(e)) {
        if (!Mo2(r) || Date.prototype.getTime.call(e) !== Date.prototype.getTime.call(r))
          return false;
      } else if (_o(e)) {
        if (!_o(r) || !Su(e, r))
          return false;
      } else if (pu(e) || e instanceof Error) {
        if (e.message !== r.message || e.name !== r.name)
          return false;
      } else if (lu2(e)) {
        if (!t && (du(e) || hu2(e))) {
          if (!Au(e, r))
            return false;
        } else if (!Ou(e, r))
          return false;
        var u2 = ar2(e, fr), c2 = ar2(r, fr);
        return u2.length !== c2.length ? false : we(e, r, t, n, ct2, u2);
      } else {
        if (ir3(e))
          return !ir3(r) || e.size !== r.size ? false : we(e, r, t, n, Jo2);
        if (or(e))
          return !or(r) || e.size !== r.size ? false : we(e, r, t, n, Yo);
        if (su2(e)) {
          if (!Eu(e, r))
            return false;
        } else if (yu(e) && !wu(e, r))
          return false;
      }
      return we(e, r, t, n, ct2);
    }
    function Vo(e, r) {
      return r.filter(function(t) {
        return cr2(e, t);
      });
    }
    function we(e, r, t, n, o2, i) {
      if (arguments.length === 5) {
        i = Object.keys(e);
        var a3 = Object.keys(r);
        if (i.length !== a3.length)
          return false;
      }
      for (var f2 = 0;f2 < i.length; f2++)
        if (!je(r, i[f2]))
          return false;
      if (t && arguments.length === 5) {
        var u2 = ur2(e);
        if (u2.length !== 0) {
          var c2 = 0;
          for (f2 = 0;f2 < u2.length; f2++) {
            var s2 = u2[f2];
            if (cr2(e, s2)) {
              if (!cr2(r, s2))
                return false;
              i.push(s2), c2++;
            } else if (cr2(r, s2))
              return false;
          }
          var l3 = ur2(r);
          if (u2.length !== l3.length && Vo(r, l3).length !== c2)
            return false;
        } else {
          var p3 = ur2(r);
          if (p3.length !== 0 && Vo(r, p3).length !== 0)
            return false;
        }
      }
      if (i.length === 0 && (o2 === ct2 || o2 === lt2 && e.length === 0 || e.size === 0))
        return true;
      if (n === undefined)
        n = { val1: new Map, val2: new Map, position: 0 };
      else {
        var m3 = n.val1.get(e);
        if (m3 !== undefined) {
          var S = n.val2.get(r);
          if (S !== undefined)
            return m3 === S;
        }
        n.position++;
      }
      n.val1.set(e, n.position), n.val2.set(r, n.position);
      var q = Tu(e, r, t, i, n, o2);
      return n.val1.delete(e), n.val2.delete(r), q;
    }
    function Wo(e, r, t, n) {
      for (var o2 = sr(e), i = 0;i < o2.length; i++) {
        var a3 = o2[i];
        if (P2(r, a3, t, n))
          return e.delete(a3), true;
      }
      return false;
    }
    function Xo(e) {
      switch (O2(e)) {
        case "undefined":
          return null;
        case "object":
          return;
        case "symbol":
          return false;
        case "string":
          e = +e;
        case "number":
          if (ut2(e))
            return false;
      }
      return true;
    }
    function ju(e, r, t) {
      var n = Xo(t);
      return n ?? (r.has(n) && !e.has(n));
    }
    function Pu(e, r, t, n, o2) {
      var i = Xo(t);
      if (i != null)
        return i;
      var a3 = r.get(i);
      return a3 === undefined && !r.has(i) || !P2(n, a3, false, o2) ? false : !e.has(i) && P2(n, a3, false, o2);
    }
    function qu(e, r, t, n) {
      for (var o2 = null, i = sr(e), a3 = 0;a3 < i.length; a3++) {
        var f2 = i[a3];
        if (O2(f2) === "object" && f2 !== null)
          o2 === null && (o2 = new Set), o2.add(f2);
        else if (!r.has(f2)) {
          if (t || !ju(e, r, f2))
            return false;
          o2 === null && (o2 = new Set), o2.add(f2);
        }
      }
      if (o2 !== null) {
        for (var u2 = sr(r), c2 = 0;c2 < u2.length; c2++) {
          var s2 = u2[c2];
          if (O2(s2) === "object" && s2 !== null) {
            if (!Wo(o2, s2, t, n))
              return false;
          } else if (!t && !e.has(s2) && !Wo(o2, s2, t, n))
            return false;
        }
        return o2.size === 0;
      }
      return true;
    }
    function zo(e, r, t, n, o2, i) {
      for (var a3 = sr(e), f2 = 0;f2 < a3.length; f2++) {
        var u2 = a3[f2];
        if (P2(t, u2, o2, i) && P2(n, r.get(u2), o2, i))
          return e.delete(u2), true;
      }
      return false;
    }
    function Iu(e, r, t, n) {
      for (var o2 = null, i = Bo(e), a3 = 0;a3 < i.length; a3++) {
        var f2 = Do(i[a3], 2), u2 = f2[0], c2 = f2[1];
        if (O2(u2) === "object" && u2 !== null)
          o2 === null && (o2 = new Set), o2.add(u2);
        else {
          var s2 = r.get(u2);
          if (s2 === undefined && !r.has(u2) || !P2(c2, s2, t, n)) {
            if (t || !Pu(e, r, u2, c2, n))
              return false;
            o2 === null && (o2 = new Set), o2.add(u2);
          }
        }
      }
      if (o2 !== null) {
        for (var l3 = Bo(r), p3 = 0;p3 < l3.length; p3++) {
          var m3 = Do(l3[p3], 2), u2 = m3[0], S = m3[1];
          if (O2(u2) === "object" && u2 !== null) {
            if (!zo(o2, e, u2, S, t, n))
              return false;
          } else if (!t && (!e.has(u2) || !P2(e.get(u2), S, false, n)) && !zo(o2, e, u2, S, false, n))
            return false;
        }
        return o2.size === 0;
      }
      return true;
    }
    function Tu(e, r, t, n, o2, i) {
      var a3 = 0;
      if (i === Jo2) {
        if (!qu(e, r, t, o2))
          return false;
      } else if (i === Yo) {
        if (!Iu(e, r, t, o2))
          return false;
      } else if (i === lt2)
        for (;a3 < e.length; a3++)
          if (je(e, a3)) {
            if (!je(r, a3) || !P2(e[a3], r[a3], t, o2))
              return false;
          } else {
            if (je(r, a3))
              return false;
            for (var f2 = Object.keys(e);a3 < f2.length; a3++) {
              var u2 = f2[a3];
              if (!je(r, u2) || !P2(e[u2], r[u2], t, o2))
                return false;
            }
            return f2.length === Object.keys(r).length;
          }
      for (a3 = 0;a3 < n.length; a3++) {
        var c2 = n[a3];
        if (!P2(e[c2], r[c2], t, o2))
          return false;
      }
      return true;
    }
    function Ru(e, r) {
      return P2(e, r, vu);
    }
    function Nu(e, r) {
      return P2(e, r, mu);
    }
    Zo.exports = { isDeepEqual: Ru, isDeepStrictEqual: Nu };
  });
  var er2 = y3((qc, gi3) => {
    function M3(e) {
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? M3 = function(t) {
        return typeof t;
      } : M3 = function(t) {
        return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
      }, M3(e);
    }
    function Fu(e, r) {
      if (!(e instanceof r))
        throw new TypeError("Cannot call a class as a function");
    }
    var xu = Jr2(), qe2 = xu.codes, Ko = qe2.ERR_AMBIGUOUS_ARGUMENT, Pe2 = qe2.ERR_INVALID_ARG_TYPE, Du = qe2.ERR_INVALID_ARG_VALUE, Bu = qe2.ERR_INVALID_RETURN_VALUE, $ = qe2.ERR_MISSING_ARGS, H2 = Cn(), Uu = (te2(), ue4(w2)), Mu = Uu.inspect, ni = (te2(), ue4(w2)).types, _u = ni.isPromise, pt2 = ni.isRegExp, $u = Object.assign ? Object.assign : Yn().assign, oi = Object.is ? Object.is : it2(), _3, lr;
    function Ie() {
      var e = Qo();
      _3 = e.isDeepEqual, lr = e.isDeepStrictEqual;
    }
    var ei = false, b5 = gi3.exports = yt2, pr2 = {};
    function N4(e) {
      throw e.message instanceof Error ? e.message : new H2(e);
    }
    function ii(e, r, t, n, o2) {
      var i = arguments.length, a3;
      if (i === 0)
        a3 = "Failed";
      else if (i === 1)
        t = e, e = undefined;
      else {
        if (ei === false) {
          ei = true;
          var f2 = process.emitWarning ? process.emitWarning : console.warn.bind(console);
          f2("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
        }
        i === 2 && (n = "!=");
      }
      if (t instanceof Error)
        throw t;
      var u2 = { actual: e, expected: r, operator: n === undefined ? "fail" : n, stackStartFn: o2 || ii };
      t !== undefined && (u2.message = t);
      var c2 = new H2(u2);
      throw a3 && (c2.message = a3, c2.generatedMessage = true), c2;
    }
    b5.fail = ii;
    b5.AssertionError = H2;
    function ai(e, r, t, n) {
      if (!t) {
        var o2 = false;
        if (r === 0)
          o2 = true, n = "No value argument passed to `assert.ok()`";
        else if (n instanceof Error)
          throw n;
        var i = new H2({ actual: t, expected: true, message: n, operator: "==", stackStartFn: e });
        throw i.generatedMessage = o2, i;
      }
    }
    function yt2() {
      for (var e = arguments.length, r = new Array(e), t = 0;t < e; t++)
        r[t] = arguments[t];
      ai.apply(undefined, [yt2, r.length].concat(r));
    }
    b5.ok = yt2;
    b5.equal = function e(r, t, n) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      r != t && N4({ actual: r, expected: t, message: n, operator: "==", stackStartFn: e });
    };
    b5.notEqual = function e(r, t, n) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      r == t && N4({ actual: r, expected: t, message: n, operator: "!=", stackStartFn: e });
    };
    b5.deepEqual = function e(r, t, n) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      _3 === undefined && Ie(), _3(r, t) || N4({ actual: r, expected: t, message: n, operator: "deepEqual", stackStartFn: e });
    };
    b5.notDeepEqual = function e(r, t, n) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      _3 === undefined && Ie(), _3(r, t) && N4({ actual: r, expected: t, message: n, operator: "notDeepEqual", stackStartFn: e });
    };
    b5.deepStrictEqual = function e(r, t, n) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      _3 === undefined && Ie(), lr(r, t) || N4({ actual: r, expected: t, message: n, operator: "deepStrictEqual", stackStartFn: e });
    };
    b5.notDeepStrictEqual = fi2;
    function fi2(e, r, t) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      _3 === undefined && Ie(), lr(e, r) && N4({ actual: e, expected: r, message: t, operator: "notDeepStrictEqual", stackStartFn: fi2 });
    }
    b5.strictEqual = function e(r, t, n) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      oi(r, t) || N4({ actual: r, expected: t, message: n, operator: "strictEqual", stackStartFn: e });
    };
    b5.notStrictEqual = function e(r, t, n) {
      if (arguments.length < 2)
        throw new $("actual", "expected");
      oi(r, t) && N4({ actual: r, expected: t, message: n, operator: "notStrictEqual", stackStartFn: e });
    };
    var ri2 = function e(r, t, n) {
      var o2 = this;
      Fu(this, e), t.forEach(function(i) {
        i in r && (n !== undefined && typeof n[i] == "string" && pt2(r[i]) && r[i].test(n[i]) ? o2[i] = n[i] : o2[i] = r[i]);
      });
    };
    function ku(e, r, t, n, o2, i) {
      if (!(t in e) || !lr(e[t], r[t])) {
        if (!n) {
          var a3 = new ri2(e, o2), f2 = new ri2(r, o2, e), u2 = new H2({ actual: a3, expected: f2, operator: "deepStrictEqual", stackStartFn: i });
          throw u2.actual = e, u2.expected = r, u2.operator = i.name, u2;
        }
        N4({ actual: e, expected: r, message: n, operator: i.name, stackStartFn: i });
      }
    }
    function ui(e, r, t, n) {
      if (typeof r != "function") {
        if (pt2(r))
          return r.test(e);
        if (arguments.length === 2)
          throw new Pe2("expected", ["Function", "RegExp"], r);
        if (M3(e) !== "object" || e === null) {
          var o2 = new H2({ actual: e, expected: r, message: t, operator: "deepStrictEqual", stackStartFn: n });
          throw o2.operator = n.name, o2;
        }
        var i = Object.keys(r);
        if (r instanceof Error)
          i.push("name", "message");
        else if (i.length === 0)
          throw new Du("error", r, "may not be an empty object");
        return _3 === undefined && Ie(), i.forEach(function(a3) {
          typeof e[a3] == "string" && pt2(r[a3]) && r[a3].test(e[a3]) || ku(e, r, a3, t, i, n);
        }), true;
      }
      return r.prototype !== undefined && e instanceof r ? true : Error.isPrototypeOf(r) ? false : r.call({}, e) === true;
    }
    function ci2(e) {
      if (typeof e != "function")
        throw new Pe2("fn", "Function", e);
      try {
        e();
      } catch (r) {
        return r;
      }
      return pr2;
    }
    function ti2(e) {
      return _u(e) || e !== null && M3(e) === "object" && typeof e.then == "function" && typeof e.catch == "function";
    }
    function si2(e) {
      return Promise.resolve().then(function() {
        var r;
        if (typeof e == "function") {
          if (r = e(), !ti2(r))
            throw new Bu("instance of Promise", "promiseFn", r);
        } else if (ti2(e))
          r = e;
        else
          throw new Pe2("promiseFn", ["Function", "Promise"], e);
        return Promise.resolve().then(function() {
          return r;
        }).then(function() {
          return pr2;
        }).catch(function(t) {
          return t;
        });
      });
    }
    function li2(e, r, t, n) {
      if (typeof t == "string") {
        if (arguments.length === 4)
          throw new Pe2("error", ["Object", "Error", "Function", "RegExp"], t);
        if (M3(r) === "object" && r !== null) {
          if (r.message === t)
            throw new Ko("error/message", 'The error message "'.concat(r.message, '" is identical to the message.'));
        } else if (r === t)
          throw new Ko("error/message", 'The error "'.concat(r, '" is identical to the message.'));
        n = t, t = undefined;
      } else if (t != null && M3(t) !== "object" && typeof t != "function")
        throw new Pe2("error", ["Object", "Error", "Function", "RegExp"], t);
      if (r === pr2) {
        var o2 = "";
        t && t.name && (o2 += " (".concat(t.name, ")")), o2 += n ? ": ".concat(n) : ".";
        var i = e.name === "rejects" ? "rejection" : "exception";
        N4({ actual: undefined, expected: t, operator: e.name, message: "Missing expected ".concat(i).concat(o2), stackStartFn: e });
      }
      if (t && !ui(r, t, n, e))
        throw r;
    }
    function pi3(e, r, t, n) {
      if (r !== pr2) {
        if (typeof t == "string" && (n = t, t = undefined), !t || ui(r, t)) {
          var o2 = n ? ": ".concat(n) : ".", i = e.name === "doesNotReject" ? "rejection" : "exception";
          N4({ actual: r, expected: t, operator: e.name, message: "Got unwanted ".concat(i).concat(o2, `
`) + 'Actual message: "'.concat(r && r.message, '"'), stackStartFn: e });
        }
        throw r;
      }
    }
    b5.throws = function e(r) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o2 = 1;o2 < t; o2++)
        n[o2 - 1] = arguments[o2];
      li2.apply(undefined, [e, ci2(r)].concat(n));
    };
    b5.rejects = function e(r) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o2 = 1;o2 < t; o2++)
        n[o2 - 1] = arguments[o2];
      return si2(r).then(function(i) {
        return li2.apply(undefined, [e, i].concat(n));
      });
    };
    b5.doesNotThrow = function e(r) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o2 = 1;o2 < t; o2++)
        n[o2 - 1] = arguments[o2];
      pi3.apply(undefined, [e, ci2(r)].concat(n));
    };
    b5.doesNotReject = function e(r) {
      for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o2 = 1;o2 < t; o2++)
        n[o2 - 1] = arguments[o2];
      return si2(r).then(function(i) {
        return pi3.apply(undefined, [e, i].concat(n));
      });
    };
    b5.ifError = function e(r) {
      if (r != null) {
        var t = "ifError got unwanted exception: ";
        M3(r) === "object" && typeof r.message == "string" ? r.message.length === 0 && r.constructor ? t += r.constructor.name : t += r.message : t += Mu(r);
        var n = new H2({ actual: r, expected: null, operator: "ifError", message: t, stackStartFn: e }), o2 = r.stack;
        if (typeof o2 == "string") {
          var i = o2.split(`
`);
          i.shift();
          for (var a3 = n.stack.split(`
`), f2 = 0;f2 < i.length; f2++) {
            var u2 = a3.indexOf(i[f2]);
            if (u2 !== -1) {
              a3 = a3.slice(0, u2);
              break;
            }
          }
          n.stack = "".concat(a3.join(`
`), `
`).concat(i.join(`
`));
        }
        throw n;
      }
    };
    function yi2() {
      for (var e = arguments.length, r = new Array(e), t = 0;t < e; t++)
        r[t] = arguments[t];
      ai.apply(undefined, [yi2, r.length].concat(r));
    }
    b5.strict = $u(yi2, b5, { equal: b5.strictEqual, deepEqual: b5.deepStrictEqual, notEqual: b5.notStrictEqual, notDeepEqual: b5.notDeepStrictEqual });
    b5.strict.strict = b5.strict;
  });
  var yr2 = {};
  D(yr2, bt4(er2()));
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
});

// node_modules/fastify/lib/pluginUtils.js
var require_pluginUtils = __commonJS((exports, module) => {
  var semver = require_semver2();
  var assert = require_assert();
  var kRegisteredPlugins = Symbol.for("registered-plugin");
  var {
    kTestInternals
  } = require_symbols2();
  var { exist, existReply, existRequest } = require_decorate();
  var {
    FST_ERR_PLUGIN_VERSION_MISMATCH,
    FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE,
    FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER
  } = require_errors2();
  var rcRegex = /-(?:rc|pre|alpha).+$/u;
  function getMeta(fn) {
    return fn[Symbol.for("plugin-meta")];
  }
  function getPluginName(func) {
    const display = getDisplayName(func);
    if (display) {
      return display;
    }
    const cache = __require.cache;
    if (cache) {
      const keys = Object.keys(cache);
      for (let i = 0;i < keys.length; i++) {
        const key = keys[i];
        if (cache[key].exports === func) {
          return key;
        }
      }
    }
    if (func.name) {
      return func.name;
    }
    return null;
  }
  function getFuncPreview(func) {
    return func.toString().split(`
`, 2).map((s2) => s2.trim()).join(" -- ");
  }
  function getDisplayName(fn) {
    return fn[Symbol.for("fastify.display-name")];
  }
  function shouldSkipOverride(fn) {
    return !!fn[Symbol.for("skip-override")];
  }
  function checkDependencies(fn) {
    const meta = getMeta(fn);
    if (!meta)
      return;
    const dependencies = meta.dependencies;
    if (!dependencies)
      return;
    assert(Array.isArray(dependencies), "The dependencies should be an array of strings");
    dependencies.forEach((dependency) => {
      assert(this[kRegisteredPlugins].indexOf(dependency) > -1, `The dependency '${dependency}' of plugin '${meta.name}' is not registered`);
    });
  }
  function checkDecorators(fn) {
    const meta = getMeta(fn);
    if (!meta)
      return;
    const { decorators, name } = meta;
    if (!decorators)
      return;
    if (decorators.fastify)
      _checkDecorators(this, "Fastify", decorators.fastify, name);
    if (decorators.reply)
      _checkDecorators(this, "Reply", decorators.reply, name);
    if (decorators.request)
      _checkDecorators(this, "Request", decorators.request, name);
  }
  var checks = {
    Fastify: exist,
    Request: existRequest,
    Reply: existReply
  };
  function _checkDecorators(that, instance, decorators, name) {
    assert(Array.isArray(decorators), "The decorators should be an array of strings");
    decorators.forEach((decorator) => {
      const withPluginName = typeof name === "string" ? ` required by '${name}'` : "";
      if (!checks[instance].call(that, decorator)) {
        throw new FST_ERR_PLUGIN_NOT_PRESENT_IN_INSTANCE(decorator, withPluginName, instance);
      }
    });
  }
  function checkVersion(fn) {
    const meta = getMeta(fn);
    if (meta?.fastify == null)
      return;
    const requiredVersion = meta.fastify;
    const fastifyRc = rcRegex.test(this.version);
    if (fastifyRc === true && semver.gt(this.version, semver.coerce(requiredVersion)) === true) {
      return;
    }
    if (requiredVersion && semver.satisfies(this.version, requiredVersion, { includePrerelease: fastifyRc }) === false) {
      throw new FST_ERR_PLUGIN_VERSION_MISMATCH(meta.name, requiredVersion, this.version);
    }
  }
  function registerPluginName(fn) {
    const meta = getMeta(fn);
    if (!meta)
      return;
    const name = meta.name;
    if (!name)
      return;
    this[kRegisteredPlugins].push(name);
    return name;
  }
  function checkPluginHealthiness(fn, pluginName) {
    if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
      throw new FST_ERR_PLUGIN_INVALID_ASYNC_HANDLER(pluginName);
    }
  }
  function registerPlugin(fn) {
    const pluginName = registerPluginName.call(this, fn) || getPluginName(fn);
    checkPluginHealthiness.call(this, fn, pluginName);
    checkVersion.call(this, fn);
    checkDecorators.call(this, fn);
    checkDependencies.call(this, fn);
    return shouldSkipOverride(fn);
  }
  module.exports = {
    getPluginName,
    getFuncPreview,
    kRegisteredPlugins,
    getDisplayName,
    registerPlugin
  };
  module.exports[kTestInternals] = {
    shouldSkipOverride,
    getMeta,
    checkDecorators,
    checkDependencies
  };
});

// node_modules/fastify/lib/reqIdGenFactory.js
var require_reqIdGenFactory = __commonJS((exports, module) => {
  function reqIdGenFactory(requestIdHeader, optGenReqId) {
    const genReqId = optGenReqId || buildDefaultGenReqId();
    if (requestIdHeader) {
      return buildOptionalHeaderReqId(requestIdHeader, genReqId);
    }
    return genReqId;
  }
  function getGenReqId(contextServer, req) {
    return contextServer.genReqId(req);
  }
  function buildDefaultGenReqId() {
    const maxInt = 2147483647;
    let nextReqId = 0;
    return function defaultGenReqId() {
      nextReqId = nextReqId + 1 & maxInt;
      return `req-${nextReqId.toString(36)}`;
    };
  }
  function buildOptionalHeaderReqId(requestIdHeader, genReqId) {
    return function(req) {
      return req.headers[requestIdHeader] || genReqId(req);
    };
  }
  module.exports = {
    getGenReqId,
    reqIdGenFactory
  };
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function hexCodeToInt(c2, shift) {
    var i = HEX[c2];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse3 = __commonJS((exports, module) => {
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {};
  Empty.prototype = Object.create(null);
  function parse(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c2 = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c2 = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c2 === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c2 === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c2 === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c2 === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  }
  module.exports = parse;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var hexTable = Array.from({ length: 256 }, (_3, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function encodeString(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c2 = str.charCodeAt(i);
        while (c2 < 128) {
          if (noEscape[c2] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c2];
          }
          if (++i === len)
            break outer;
          c2 = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c2 < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c2 >> 6] + hexTable[128 | c2 & 63];
          continue;
        }
        if (c2 < 55296 || c2 >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c2 >> 12] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c22 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c2 = 65536 + ((c2 & 1023) << 10 | c22);
        out += hexTable[240 | c2 >> 18] + hexTable[128 | c2 >> 12 & 63] + hexTable[128 | c2 >> 6 & 63] + hexTable[128 | c2 & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  }
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var { encodeString } = require_querystring();
  function getAsPrimitive(value) {
    const type = typeof value;
    if (type === "string") {
      return encodeString(value);
    } else if (type === "bigint") {
      return value.toString();
    } else if (type === "boolean") {
      return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  }
  function stringify(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j3 = 0;j3 < valueLength; j3++) {
          if (j3) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j3]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  }
  module.exports = stringify;
});

// node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var parse = require_parse3();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse;
  module.exports.stringify = stringify;
});

// node_modules/ret/dist/types/tokens.js
var require_tokens = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/ret/dist/types/types.js
var require_types5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = undefined;
  var types;
  (function(types2) {
    types2[types2["ROOT"] = 0] = "ROOT";
    types2[types2["GROUP"] = 1] = "GROUP";
    types2[types2["POSITION"] = 2] = "POSITION";
    types2[types2["SET"] = 3] = "SET";
    types2[types2["RANGE"] = 4] = "RANGE";
    types2[types2["REPETITION"] = 5] = "REPETITION";
    types2[types2["REFERENCE"] = 6] = "REFERENCE";
    types2[types2["CHAR"] = 7] = "CHAR";
  })(types = exports.types || (exports.types = {}));
});

// node_modules/ret/dist/types/set-lookup.js
var require_set_lookup = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/ret/dist/types/index.js
var require_types6 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m3[k3];
    } });
  } : function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    o2[k22] = m3[k3];
  });
  var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
    for (var p3 in m3)
      if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
        __createBinding(exports2, m3, p3);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_tokens(), exports);
  __exportStar(require_types5(), exports);
  __exportStar(require_set_lookup(), exports);
});

// node_modules/ret/dist/sets.js
var require_sets = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.anyChar = exports.notWhitespace = exports.whitespace = exports.notInts = exports.ints = exports.notWords = exports.words = undefined;
  var types_1 = require_types6();
  var INTS = () => [{ type: types_1.types.RANGE, from: 48, to: 57 }];
  var WORDS = () => [
    { type: types_1.types.CHAR, value: 95 },
    { type: types_1.types.RANGE, from: 97, to: 122 },
    { type: types_1.types.RANGE, from: 65, to: 90 },
    { type: types_1.types.RANGE, from: 48, to: 57 }
  ];
  var WHITESPACE = () => [
    { type: types_1.types.CHAR, value: 9 },
    { type: types_1.types.CHAR, value: 10 },
    { type: types_1.types.CHAR, value: 11 },
    { type: types_1.types.CHAR, value: 12 },
    { type: types_1.types.CHAR, value: 13 },
    { type: types_1.types.CHAR, value: 32 },
    { type: types_1.types.CHAR, value: 160 },
    { type: types_1.types.CHAR, value: 5760 },
    { type: types_1.types.RANGE, from: 8192, to: 8202 },
    { type: types_1.types.CHAR, value: 8232 },
    { type: types_1.types.CHAR, value: 8233 },
    { type: types_1.types.CHAR, value: 8239 },
    { type: types_1.types.CHAR, value: 8287 },
    { type: types_1.types.CHAR, value: 12288 },
    { type: types_1.types.CHAR, value: 65279 }
  ];
  var NOTANYCHAR = () => [
    { type: types_1.types.CHAR, value: 10 },
    { type: types_1.types.CHAR, value: 13 },
    { type: types_1.types.CHAR, value: 8232 },
    { type: types_1.types.CHAR, value: 8233 }
  ];
  exports.words = () => ({ type: types_1.types.SET, set: WORDS(), not: false });
  exports.notWords = () => ({ type: types_1.types.SET, set: WORDS(), not: true });
  exports.ints = () => ({ type: types_1.types.SET, set: INTS(), not: false });
  exports.notInts = () => ({ type: types_1.types.SET, set: INTS(), not: true });
  exports.whitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: false });
  exports.notWhitespace = () => ({ type: types_1.types.SET, set: WHITESPACE(), not: true });
  exports.anyChar = () => ({ type: types_1.types.SET, set: NOTANYCHAR(), not: true });
});

// node_modules/ret/dist/util.js
var require_util4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m3[k3];
    } });
  } : function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    o2[k22] = m3[k3];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k3 in mod)
        if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
          __createBinding(result, mod, k3);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tokenizeClass = exports.strToChars = undefined;
  var types_1 = require_types6();
  var sets = __importStar(require_sets());
  var CTRL = "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^ ?";
  exports.strToChars = (str) => {
    const charsRegex = /(\[\\b\])|(\\)?\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|c([@A-Z[\\\]^?])|([0tnvfr]))/g;
    return str.replace(charsRegex, (s2, b5, lbs, a16, b16, dctrl, eslsh) => {
      if (lbs) {
        return s2;
      }
      let code = b5 ? 8 : a16 ? parseInt(a16, 16) : b16 ? parseInt(b16, 16) : dctrl ? CTRL.indexOf(dctrl) : {
        0: 0,
        t: 9,
        n: 10,
        v: 11,
        f: 12,
        r: 13
      }[eslsh];
      let c2 = String.fromCharCode(code);
      return /[[\]{}^$.|?*+()]/.test(c2) ? `\\${c2}` : c2;
    });
  };
  exports.tokenizeClass = (str, regexpStr) => {
    var _a, _b, _c, _d, _e3, _f, _g;
    let tokens = [], rs, c2;
    const regexp = /\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\)(.)|([^\]\\]))-(((?:\\)])|(((?:\\)?([^\]])))))|(\])|(?:\\)?([^])/g;
    while ((rs = regexp.exec(str)) !== null) {
      const p3 = (_g = (_f = (_e3 = (_d = (_c = (_b = (_a = rs[1] && sets.words()) !== null && _a !== undefined ? _a : rs[2] && sets.ints()) !== null && _b !== undefined ? _b : rs[3] && sets.whitespace()) !== null && _c !== undefined ? _c : rs[4] && sets.notWords()) !== null && _d !== undefined ? _d : rs[5] && sets.notInts()) !== null && _e3 !== undefined ? _e3 : rs[6] && sets.notWhitespace()) !== null && _f !== undefined ? _f : rs[7] && {
        type: types_1.types.RANGE,
        from: (rs[8] || rs[9]).charCodeAt(0),
        to: (c2 = rs[10]).charCodeAt(c2.length - 1)
      }) !== null && _g !== undefined ? _g : (c2 = rs[16]) && { type: types_1.types.CHAR, value: c2.charCodeAt(0) };
      if (p3) {
        tokens.push(p3);
      } else {
        return [tokens, regexp.lastIndex];
      }
    }
    throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated character class`);
  };
});

// node_modules/ret/dist/tokenizer.js
var require_tokenizer = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m3[k3];
    } });
  } : function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    o2[k22] = m3[k3];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k3 in mod)
        if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
          __createBinding(result, mod, k3);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tokenizer = undefined;
  var util = __importStar(require_util4());
  var types_1 = require_types6();
  var sets = __importStar(require_sets());
  var captureGroupFirstChar = /^[a-zA-Z_$]$/i;
  var captureGroupChars = /^[a-zA-Z0-9_$]$/i;
  var digit = /\d/;
  exports.tokenizer = (regexpStr) => {
    let i = 0, c2;
    let start = { type: types_1.types.ROOT, stack: [] };
    let lastGroup = start;
    let last = start.stack;
    let groupStack = [];
    let referenceQueue = [];
    let groupCount = 0;
    const repeatErr = (col) => {
      throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Nothing to repeat at column ${col - 1}`);
    };
    let str = util.strToChars(regexpStr);
    while (i < str.length) {
      switch (c2 = str[i++]) {
        case "\\":
          if (i === str.length) {
            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: \\ at end of pattern`);
          }
          switch (c2 = str[i++]) {
            case "b":
              last.push({ type: types_1.types.POSITION, value: "b" });
              break;
            case "B":
              last.push({ type: types_1.types.POSITION, value: "B" });
              break;
            case "w":
              last.push(sets.words());
              break;
            case "W":
              last.push(sets.notWords());
              break;
            case "d":
              last.push(sets.ints());
              break;
            case "D":
              last.push(sets.notInts());
              break;
            case "s":
              last.push(sets.whitespace());
              break;
            case "S":
              last.push(sets.notWhitespace());
              break;
            default:
              if (digit.test(c2)) {
                let digits = c2;
                while (i < str.length && digit.test(str[i])) {
                  digits += str[i++];
                }
                let value = parseInt(digits, 10);
                const reference = { type: types_1.types.REFERENCE, value };
                last.push(reference);
                referenceQueue.push({ reference, stack: last, index: last.length - 1 });
              } else {
                last.push({ type: types_1.types.CHAR, value: c2.charCodeAt(0) });
              }
          }
          break;
        case "^":
          last.push({ type: types_1.types.POSITION, value: "^" });
          break;
        case "$":
          last.push({ type: types_1.types.POSITION, value: "$" });
          break;
        case "[": {
          let not;
          if (str[i] === "^") {
            not = true;
            i++;
          } else {
            not = false;
          }
          let classTokens = util.tokenizeClass(str.slice(i), regexpStr);
          i += classTokens[1];
          last.push({
            type: types_1.types.SET,
            set: classTokens[0],
            not
          });
          break;
        }
        case ".":
          last.push(sets.anyChar());
          break;
        case "(": {
          let group = {
            type: types_1.types.GROUP,
            stack: [],
            remember: true
          };
          if (str[i] === "?") {
            c2 = str[i + 1];
            i += 2;
            if (c2 === "=") {
              group.followedBy = true;
              group.remember = false;
            } else if (c2 === "!") {
              group.notFollowedBy = true;
              group.remember = false;
            } else if (c2 === "<") {
              let name = "";
              if (captureGroupFirstChar.test(str[i])) {
                name += str[i];
                i++;
              } else {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}'` + ` after '<' at column ${i + 1}`);
              }
              while (i < str.length && captureGroupChars.test(str[i])) {
                name += str[i];
                i++;
              }
              if (!name) {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid capture group name, character '${str[i]}'` + ` after '<' at column ${i + 1}`);
              }
              if (str[i] !== ">") {
                throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unclosed capture group name, expected '>', found` + ` '${str[i]}' at column ${i + 1}`);
              }
              group.name = name;
              i++;
            } else if (c2 === ":") {
              group.remember = false;
            } else {
              throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Invalid group, character '${c2}'` + ` after '?' at column ${i - 1}`);
            }
          } else {
            groupCount += 1;
          }
          last.push(group);
          groupStack.push(lastGroup);
          lastGroup = group;
          last = group.stack;
          break;
        }
        case ")":
          if (groupStack.length === 0) {
            throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unmatched ) at column ${i - 1}`);
          }
          lastGroup = groupStack.pop();
          last = lastGroup.options ? lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;
          break;
        case "|": {
          if (!lastGroup.options) {
            lastGroup.options = [lastGroup.stack];
            delete lastGroup.stack;
          }
          let stack = [];
          lastGroup.options.push(stack);
          last = stack;
          break;
        }
        case "{": {
          let rs = /^(\d+)(,(\d+)?)?\}/.exec(str.slice(i)), min, max;
          if (rs !== null) {
            if (last.length === 0) {
              repeatErr(i);
            }
            min = parseInt(rs[1], 10);
            max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;
            i += rs[0].length;
            last.push({
              type: types_1.types.REPETITION,
              min,
              max,
              value: last.pop()
            });
          } else {
            last.push({
              type: types_1.types.CHAR,
              value: 123
            });
          }
          break;
        }
        case "?":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types_1.types.REPETITION,
            min: 0,
            max: 1,
            value: last.pop()
          });
          break;
        case "+":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types_1.types.REPETITION,
            min: 1,
            max: Infinity,
            value: last.pop()
          });
          break;
        case "*":
          if (last.length === 0) {
            repeatErr(i);
          }
          last.push({
            type: types_1.types.REPETITION,
            min: 0,
            max: Infinity,
            value: last.pop()
          });
          break;
        default:
          last.push({
            type: types_1.types.CHAR,
            value: c2.charCodeAt(0)
          });
      }
    }
    if (groupStack.length !== 0) {
      throw new SyntaxError(`Invalid regular expression: /${regexpStr}/: Unterminated group`);
    }
    updateReferences(referenceQueue, groupCount);
    return start;
  };
  function updateReferences(referenceQueue, groupCount) {
    for (const elem of referenceQueue.reverse()) {
      if (groupCount < elem.reference.value) {
        elem.reference.type = types_1.types.CHAR;
        const valueString = elem.reference.value.toString();
        elem.reference.value = parseInt(valueString, 8);
        if (!/^[0-7]+$/.test(valueString)) {
          let i = 0;
          while (valueString[i] !== "8" && valueString[i] !== "9") {
            i += 1;
          }
          if (i === 0) {
            elem.reference.value = valueString.charCodeAt(0);
            i += 1;
          } else {
            elem.reference.value = parseInt(valueString.slice(0, i), 8);
          }
          if (valueString.length > i) {
            const tail = elem.stack.splice(elem.index + 1);
            for (const char of valueString.slice(i)) {
              elem.stack.push({
                type: types_1.types.CHAR,
                value: char.charCodeAt(0)
              });
            }
            elem.stack.push(...tail);
          }
        }
      }
    }
  }
});

// node_modules/ret/dist/sets-lookup.js
var require_sets_lookup = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m3[k3];
    } });
  } : function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    o2[k22] = m3[k3];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k3 in mod)
        if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
          __createBinding(result, mod, k3);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NOTANYCHAR = exports.WHITESPACE = exports.WORDS = exports.INTS = undefined;
  var Sets = __importStar(require_sets());
  var types_1 = require_types6();
  function setToLookup(tokens) {
    let lookup = {};
    let len = 0;
    for (const token of tokens) {
      if (token.type === types_1.types.CHAR) {
        lookup[token.value] = true;
      }
      if (token.type === types_1.types.RANGE) {
        lookup[`${token.from}-${token.to}`] = true;
      }
      len += 1;
    }
    return {
      lookup: () => Object.assign({}, lookup),
      len
    };
  }
  exports.INTS = setToLookup(Sets.ints().set);
  exports.WORDS = setToLookup(Sets.words().set);
  exports.WHITESPACE = setToLookup(Sets.whitespace().set);
  exports.NOTANYCHAR = setToLookup(Sets.anyChar().set);
});

// node_modules/ret/dist/write-set-tokens.js
var require_write_set_tokens = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m3[k3];
    } });
  } : function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    o2[k22] = m3[k3];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
    Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
  } : function(o2, v2) {
    o2["default"] = v2;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k3 in mod)
        if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
          __createBinding(result, mod, k3);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.writeSetTokens = exports.setChar = undefined;
  var types_1 = require_types6();
  var sets = __importStar(require_sets_lookup());
  function setChar(charCode) {
    return charCode === 94 ? "\\^" : charCode === 92 ? "\\\\" : charCode === 93 ? "\\]" : charCode === 45 ? "\\-" : String.fromCharCode(charCode);
  }
  exports.setChar = setChar;
  function isSameSet(set, { lookup, len }) {
    if (len !== set.length) {
      return false;
    }
    const map = lookup();
    for (const elem of set) {
      if (elem.type === types_1.types.SET) {
        return false;
      }
      const key = elem.type === types_1.types.CHAR ? elem.value : `${elem.from}-${elem.to}`;
      if (map[key]) {
        map[key] = false;
      } else {
        return false;
      }
    }
    return true;
  }
  function writeSetTokens(set, isNested = false) {
    if (isSameSet(set.set, sets.INTS)) {
      return set.not ? "\\D" : "\\d";
    }
    if (isSameSet(set.set, sets.WORDS)) {
      return set.not ? "\\W" : "\\w";
    }
    if (set.not && isSameSet(set.set, sets.NOTANYCHAR)) {
      return ".";
    }
    if (isSameSet(set.set, sets.WHITESPACE)) {
      return set.not ? "\\S" : "\\s";
    }
    let tokenString = "";
    for (let i = 0;i < set.set.length; i++) {
      const subset = set.set[i];
      tokenString += writeSetToken(subset);
    }
    const contents = `${set.not ? "^" : ""}${tokenString}`;
    return isNested ? contents : `[${contents}]`;
  }
  exports.writeSetTokens = writeSetTokens;
  function writeSetToken(set) {
    if (set.type === types_1.types.CHAR) {
      return setChar(set.value);
    } else if (set.type === types_1.types.RANGE) {
      return `${setChar(set.from)}-${setChar(set.to)}`;
    }
    return writeSetTokens(set, true);
  }
});

// node_modules/ret/dist/reconstruct.js
var require_reconstruct = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.reconstruct = undefined;
  var types_1 = require_types6();
  var write_set_tokens_1 = require_write_set_tokens();
  var reduceStack = (stack) => stack.map(exports.reconstruct).join("");
  var createAlternate = (token) => {
    if ("options" in token) {
      return token.options.map(reduceStack).join("|");
    } else if ("stack" in token) {
      return reduceStack(token.stack);
    } else {
      throw new Error(`options or stack must be Root or Group token`);
    }
  };
  exports.reconstruct = (token) => {
    switch (token.type) {
      case types_1.types.ROOT:
        return createAlternate(token);
      case types_1.types.CHAR: {
        const c2 = String.fromCharCode(token.value);
        return (/[[\\{}$^.|?*+()]/.test(c2) ? "\\" : "") + c2;
      }
      case types_1.types.POSITION:
        if (token.value === "^" || token.value === "$") {
          return token.value;
        } else {
          return `\\${token.value}`;
        }
      case types_1.types.REFERENCE:
        return `\\${token.value}`;
      case types_1.types.SET:
        return write_set_tokens_1.writeSetTokens(token);
      case types_1.types.GROUP: {
        const prefix = token.name ? `?<${token.name}>` : token.remember ? "" : token.followedBy ? "?=" : token.notFollowedBy ? "?!" : "?:";
        return `(${prefix}${createAlternate(token)})`;
      }
      case types_1.types.REPETITION: {
        const { min, max } = token;
        let endWith;
        if (min === 0 && max === 1) {
          endWith = "?";
        } else if (min === 1 && max === Infinity) {
          endWith = "+";
        } else if (min === 0 && max === Infinity) {
          endWith = "*";
        } else if (max === Infinity) {
          endWith = `{${min},}`;
        } else if (min === max) {
          endWith = `{${min}}`;
        } else {
          endWith = `{${min},${max}}`;
        }
        return `${exports.reconstruct(token.value)}${endWith}`;
      }
      case types_1.types.RANGE:
        return `${write_set_tokens_1.setChar(token.from)}-${write_set_tokens_1.setChar(token.to)}`;
      default:
        throw new Error(`Invalid token type ${token}`);
    }
  };
});

// node_modules/ret/dist/index.js
var require_dist3 = __commonJS((exports, module) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    Object.defineProperty(o2, k22, { enumerable: true, get: function() {
      return m3[k3];
    } });
  } : function(o2, m3, k3, k22) {
    if (k22 === undefined)
      k22 = k3;
    o2[k22] = m3[k3];
  });
  var __exportStar = exports && exports.__exportStar || function(m3, exports2) {
    for (var p3 in m3)
      if (p3 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p3))
        __createBinding(exports2, m3, p3);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.types = undefined;
  var types_1 = require_types6();
  Object.defineProperty(exports, "types", { enumerable: true, get: function() {
    return types_1.types;
  } });
  __exportStar(require_tokenizer(), exports);
  __exportStar(require_reconstruct(), exports);
  var tokenizer_1 = require_tokenizer();
  var reconstruct_1 = require_reconstruct();
  __exportStar(require_types6(), exports);
  exports.default = tokenizer_1.tokenizer;
  module.exports = tokenizer_1.tokenizer;
  module.exports.types = types_1.types;
  module.exports.reconstruct = reconstruct_1.reconstruct;
});

// node_modules/safe-regex2/index.js
var require_safe_regex2 = __commonJS((exports, module) => {
  var parse = require_dist3();
  var types = parse.types;
  function safeRegex(re2, opts) {
    if (!opts)
      opts = {};
    const replimit = opts.limit === undefined ? 25 : opts.limit;
    if (isRegExp(re2))
      re2 = re2.source;
    else if (typeof re2 !== "string")
      re2 = String(re2);
    try {
      re2 = parse(re2);
    } catch {
      return false;
    }
    let reps = 0;
    return function walk(node, starHeight) {
      let i;
      let ok;
      let len;
      if (node.type === types.REPETITION) {
        starHeight++;
        reps++;
        if (starHeight > 1)
          return false;
        if (reps > replimit)
          return false;
      }
      if (node.options) {
        for (i = 0, len = node.options.length;i < len; i++) {
          ok = walk({ stack: node.options[i] }, starHeight);
          if (!ok)
            return false;
        }
      }
      const stack = node.stack || node.value?.stack;
      if (!stack)
        return true;
      for (i = 0;i < stack.length; i++) {
        ok = walk(stack[i], starHeight);
        if (!ok)
          return false;
      }
      return true;
    }(re2, 0);
  }
  function isRegExp(x3) {
    return {}.toString.call(x3) === "[object RegExp]";
  }
  module.exports = safeRegex;
  module.exports.default = safeRegex;
  module.exports.safeRegex = safeRegex;
});

// node_modules/find-my-way/lib/strategies/http-method.js
var require_http_method = __commonJS((exports, module) => {
  module.exports = {
    name: "__fmw_internal_strategy_merged_tree_http_method__",
    storage: function() {
      const handlers = new Map;
      return {
        get: (type) => {
          return handlers.get(type) || null;
        },
        set: (type, store) => {
          handlers.set(type, store);
        }
      };
    },
    deriveConstraint: (req) => req.method,
    mustMatchWhenDerived: true
  };
});

// node_modules/find-my-way/lib/pretty-print.js
var require_pretty_print = __commonJS((exports, module) => {
  var deepEqual = require_fast_deep_equal();
  var httpMethodStrategy = require_http_method();
  var treeDataSymbol = Symbol("treeData");
  function printObjectTree(obj, parentPrefix = "") {
    let tree = "";
    const keys = Object.keys(obj);
    for (let i = 0;i < keys.length; i++) {
      const key = keys[i];
      const value = obj[key];
      const isLast = i === keys.length - 1;
      const nodePrefix = isLast ? "└── " : "├── ";
      const childPrefix = isLast ? "    " : "│   ";
      const nodeData = value[treeDataSymbol] || "";
      const prefixedNodeData = nodeData.replaceAll(`
`, `
` + parentPrefix + childPrefix);
      tree += parentPrefix + nodePrefix + key + prefixedNodeData + `
`;
      tree += printObjectTree(value, parentPrefix + childPrefix);
    }
    return tree;
  }
  function parseFunctionName(fn) {
    let fName = fn.name || "";
    fName = fName.replace("bound", "").trim();
    fName = (fName || "anonymous") + "()";
    return fName;
  }
  function parseMeta(meta) {
    if (Array.isArray(meta))
      return meta.map((m3) => parseMeta(m3));
    if (typeof meta === "symbol")
      return meta.toString();
    if (typeof meta === "function")
      return parseFunctionName(meta);
    return meta;
  }
  function getRouteMetaData(route, options) {
    if (!options.includeMeta)
      return {};
    const metaDataObject = options.buildPrettyMeta(route);
    const filteredMetaData = {};
    let includeMetaKeys = options.includeMeta;
    if (!Array.isArray(includeMetaKeys)) {
      includeMetaKeys = Reflect.ownKeys(metaDataObject);
    }
    for (const metaKey of includeMetaKeys) {
      if (!Object.prototype.hasOwnProperty.call(metaDataObject, metaKey))
        continue;
      const serializedKey = metaKey.toString();
      const metaValue = metaDataObject[metaKey];
      if (metaValue !== undefined && metaValue !== null) {
        const serializedValue = JSON.stringify(parseMeta(metaValue));
        filteredMetaData[serializedKey] = serializedValue;
      }
    }
    return filteredMetaData;
  }
  function serializeMetaData(metaData) {
    let serializedMetaData = "";
    for (const [key, value] of Object.entries(metaData)) {
      serializedMetaData += `
• (${key}) ${value}`;
    }
    return serializedMetaData;
  }
  function normalizeRoute(route) {
    const constraints = { ...route.opts.constraints };
    const method = constraints[httpMethodStrategy.name];
    delete constraints[httpMethodStrategy.name];
    return { ...route, method, opts: { constraints } };
  }
  function serializeRoute(route) {
    let serializedRoute = ` (${route.method})`;
    const constraints = route.opts.constraints || {};
    if (Object.keys(constraints).length !== 0) {
      serializedRoute += " " + JSON.stringify(constraints);
    }
    serializedRoute += serializeMetaData(route.metaData);
    return serializedRoute;
  }
  function mergeSimilarRoutes(routes) {
    return routes.reduce((mergedRoutes, route) => {
      for (const nodeRoute of mergedRoutes) {
        if (deepEqual(route.opts.constraints, nodeRoute.opts.constraints) && deepEqual(route.metaData, nodeRoute.metaData)) {
          nodeRoute.method += ", " + route.method;
          return mergedRoutes;
        }
      }
      mergedRoutes.push(route);
      return mergedRoutes;
    }, []);
  }
  function serializeNode(node, prefix, options) {
    let routes = node.routes;
    if (options.method === undefined) {
      routes = routes.map(normalizeRoute);
    }
    routes = routes.map((route) => {
      route.metaData = getRouteMetaData(route, options);
      return route;
    });
    if (options.method === undefined) {
      routes = mergeSimilarRoutes(routes);
    }
    return routes.map(serializeRoute).join(`
${prefix}`);
  }
  function buildObjectTree(node, tree, prefix, options) {
    if (node.isLeafNode || options.commonPrefix !== false) {
      prefix = prefix || "(empty root node)";
      tree = tree[prefix] = {};
      if (node.isLeafNode) {
        tree[treeDataSymbol] = serializeNode(node, prefix, options);
      }
      prefix = "";
    }
    if (node.staticChildren) {
      for (const child of Object.values(node.staticChildren)) {
        buildObjectTree(child, tree, prefix + child.prefix, options);
      }
    }
    if (node.parametricChildren) {
      for (const child of Object.values(node.parametricChildren)) {
        const childPrefix = Array.from(child.nodePaths).join("|");
        buildObjectTree(child, tree, prefix + childPrefix, options);
      }
    }
    if (node.wildcardChild) {
      buildObjectTree(node.wildcardChild, tree, "*", options);
    }
  }
  function prettyPrintTree(root, options) {
    const objectTree = {};
    buildObjectTree(root, objectTree, root.prefix, options);
    return printObjectTree(objectTree);
  }
  module.exports = { prettyPrintTree };
});

// node_modules/find-my-way/lib/null-object.js
var require_null_object = __commonJS((exports, module) => {
  var NullObject = function() {};
  NullObject.prototype = Object.create(null);
  module.exports = {
    NullObject
  };
});

// node_modules/find-my-way/lib/handler-storage.js
var require_handler_storage = __commonJS((exports, module) => {
  var { NullObject } = require_null_object();
  var httpMethodStrategy = require_http_method();

  class HandlerStorage {
    constructor() {
      this.unconstrainedHandler = null;
      this.constraints = [];
      this.handlers = [];
      this.constrainedHandlerStores = null;
    }
    getMatchingHandler(derivedConstraints) {
      if (derivedConstraints === undefined) {
        return this.unconstrainedHandler;
      }
      return this._getHandlerMatchingConstraints(derivedConstraints);
    }
    addHandler(constrainer, route) {
      const params = route.params;
      const constraints = route.opts.constraints || {};
      const handlerObject = {
        params,
        constraints,
        handler: route.handler,
        store: route.store || null,
        _createParamsObject: this._compileCreateParamsObject(params)
      };
      const constraintsNames = Object.keys(constraints);
      if (constraintsNames.length === 0) {
        this.unconstrainedHandler = handlerObject;
      }
      for (const constraint of constraintsNames) {
        if (!this.constraints.includes(constraint)) {
          if (constraint === "version") {
            this.constraints.unshift(constraint);
          } else {
            this.constraints.push(constraint);
          }
        }
      }
      const isMergedTree = constraintsNames.includes(httpMethodStrategy.name);
      if (!isMergedTree && this.handlers.length >= 31) {
        throw new Error("find-my-way supports a maximum of 31 route handlers per node when there are constraints, limit reached");
      }
      this.handlers.push(handlerObject);
      this.handlers.sort((a3, b5) => Object.keys(a3.constraints).length - Object.keys(b5.constraints).length);
      if (!isMergedTree) {
        this._compileGetHandlerMatchingConstraints(constrainer, constraints);
      }
    }
    _compileCreateParamsObject(params) {
      const fnBody = [];
      fnBody.push("const fn = function _createParamsObject (paramsArray) {");
      fnBody.push("const params = new NullObject()");
      for (let i = 0;i < params.length; i++) {
        fnBody.push(`params['${params[i]}'] = paramsArray[${i}]`);
      }
      fnBody.push("return params");
      fnBody.push("}");
      fnBody.push("return fn");
      return new Function("NullObject", fnBody.join(`
`))(NullObject);
    }
    _getHandlerMatchingConstraints() {
      return null;
    }
    _buildConstraintStore(store, constraint) {
      for (let i = 0;i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        const constraintValue = handler.constraints[constraint];
        if (constraintValue !== undefined) {
          let indexes = store.get(constraintValue) || 0;
          indexes |= 1 << i;
          store.set(constraintValue, indexes);
        }
      }
    }
    _constrainedIndexBitmask(constraint) {
      let mask = 0;
      for (let i = 0;i < this.handlers.length; i++) {
        const handler = this.handlers[i];
        const constraintValue = handler.constraints[constraint];
        if (constraintValue !== undefined) {
          mask |= 1 << i;
        }
      }
      return ~mask;
    }
    _compileGetHandlerMatchingConstraints(constrainer) {
      this.constrainedHandlerStores = {};
      for (const constraint of this.constraints) {
        const store = constrainer.newStoreForConstraint(constraint);
        this.constrainedHandlerStores[constraint] = store;
        this._buildConstraintStore(store, constraint);
      }
      const lines = [];
      lines.push(`
    let candidates = ${(1 << this.handlers.length) - 1}
    let mask, matches
    `);
      for (const constraint of this.constraints) {
        lines.push(`
      mask = ${this._constrainedIndexBitmask(constraint)}
      value = derivedConstraints.${constraint}
      `);
        const strategy = constrainer.strategies[constraint];
        const matchMask = strategy.mustMatchWhenDerived ? "matches" : "(matches | mask)";
        lines.push(`
      if (value === undefined) {
        candidates &= mask
      } else {
        matches = this.constrainedHandlerStores.${constraint}.get(value) || 0
        candidates &= ${matchMask}
      }
      if (candidates === 0) return null;
      `);
      }
      for (const constraint in constrainer.strategies) {
        const strategy = constrainer.strategies[constraint];
        if (strategy.mustMatchWhenDerived && !this.constraints.includes(constraint)) {
          lines.push(`if (derivedConstraints.${constraint} !== undefined) return null`);
        }
      }
      lines.push("return this.handlers[Math.floor(Math.log2(candidates))]");
      this._getHandlerMatchingConstraints = new Function("derivedConstraints", lines.join(`
`));
    }
  }
  module.exports = HandlerStorage;
});

// node_modules/find-my-way/lib/node.js
var require_node = __commonJS((exports, module) => {
  var HandlerStorage = require_handler_storage();
  var NODE_TYPES = {
    STATIC: 0,
    PARAMETRIC: 1,
    WILDCARD: 2
  };

  class Node {
    constructor() {
      this.isLeafNode = false;
      this.routes = null;
      this.handlerStorage = null;
    }
    addRoute(route, constrainer) {
      if (this.routes === null) {
        this.routes = [];
      }
      if (this.handlerStorage === null) {
        this.handlerStorage = new HandlerStorage;
      }
      this.isLeafNode = true;
      this.routes.push(route);
      this.handlerStorage.addHandler(constrainer, route);
    }
  }

  class ParentNode extends Node {
    constructor() {
      super();
      this.staticChildren = {};
    }
    findStaticMatchingChild(path, pathIndex) {
      const staticChild = this.staticChildren[path.charAt(pathIndex)];
      if (staticChild === undefined || !staticChild.matchPrefix(path, pathIndex)) {
        return null;
      }
      return staticChild;
    }
    getStaticChild(path, pathIndex = 0) {
      if (path.length === pathIndex) {
        return this;
      }
      const staticChild = this.findStaticMatchingChild(path, pathIndex);
      if (staticChild) {
        return staticChild.getStaticChild(path, pathIndex + staticChild.prefix.length);
      }
      return null;
    }
    createStaticChild(path) {
      if (path.length === 0) {
        return this;
      }
      let staticChild = this.staticChildren[path.charAt(0)];
      if (staticChild) {
        let i = 1;
        for (;i < staticChild.prefix.length; i++) {
          if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {
            staticChild = staticChild.split(this, i);
            break;
          }
        }
        return staticChild.createStaticChild(path.slice(i));
      }
      const label = path.charAt(0);
      this.staticChildren[label] = new StaticNode(path);
      return this.staticChildren[label];
    }
  }

  class StaticNode extends ParentNode {
    constructor(prefix) {
      super();
      this.prefix = prefix;
      this.wildcardChild = null;
      this.parametricChildren = [];
      this.kind = NODE_TYPES.STATIC;
      this._compilePrefixMatch();
    }
    getParametricChild(regex) {
      const regexpSource = regex && regex.source;
      const parametricChild = this.parametricChildren.find((child) => {
        const childRegexSource = child.regex && child.regex.source;
        return childRegexSource === regexpSource;
      });
      if (parametricChild) {
        return parametricChild;
      }
      return null;
    }
    createParametricChild(regex, staticSuffix, nodePath) {
      let parametricChild = this.getParametricChild(regex);
      if (parametricChild) {
        parametricChild.nodePaths.add(nodePath);
        return parametricChild;
      }
      parametricChild = new ParametricNode(regex, staticSuffix, nodePath);
      this.parametricChildren.push(parametricChild);
      this.parametricChildren.sort((child1, child2) => {
        if (!child1.isRegex)
          return 1;
        if (!child2.isRegex)
          return -1;
        if (child1.staticSuffix === null)
          return 1;
        if (child2.staticSuffix === null)
          return -1;
        if (child2.staticSuffix.endsWith(child1.staticSuffix))
          return 1;
        if (child1.staticSuffix.endsWith(child2.staticSuffix))
          return -1;
        return 0;
      });
      return parametricChild;
    }
    getWildcardChild() {
      return this.wildcardChild;
    }
    createWildcardChild() {
      this.wildcardChild = this.getWildcardChild() || new WildcardNode;
      return this.wildcardChild;
    }
    split(parentNode, length) {
      const parentPrefix = this.prefix.slice(0, length);
      const childPrefix = this.prefix.slice(length);
      this.prefix = childPrefix;
      this._compilePrefixMatch();
      const staticNode = new StaticNode(parentPrefix);
      staticNode.staticChildren[childPrefix.charAt(0)] = this;
      parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode;
      return staticNode;
    }
    getNextNode(path, pathIndex, nodeStack, paramsCount) {
      let node = this.findStaticMatchingChild(path, pathIndex);
      let parametricBrotherNodeIndex = 0;
      if (node === null) {
        if (this.parametricChildren.length === 0) {
          return this.wildcardChild;
        }
        node = this.parametricChildren[0];
        parametricBrotherNodeIndex = 1;
      }
      if (this.wildcardChild !== null) {
        nodeStack.push({
          paramsCount,
          brotherPathIndex: pathIndex,
          brotherNode: this.wildcardChild
        });
      }
      for (let i = this.parametricChildren.length - 1;i >= parametricBrotherNodeIndex; i--) {
        nodeStack.push({
          paramsCount,
          brotherPathIndex: pathIndex,
          brotherNode: this.parametricChildren[i]
        });
      }
      return node;
    }
    _compilePrefixMatch() {
      if (this.prefix.length === 1) {
        this.matchPrefix = () => true;
        return;
      }
      const lines = [];
      for (let i = 1;i < this.prefix.length; i++) {
        const charCode = this.prefix.charCodeAt(i);
        lines.push(`path.charCodeAt(i + ${i}) === ${charCode}`);
      }
      this.matchPrefix = new Function("path", "i", `return ${lines.join(" && ")}`);
    }
  }

  class ParametricNode extends ParentNode {
    constructor(regex, staticSuffix, nodePath) {
      super();
      this.isRegex = !!regex;
      this.regex = regex || null;
      this.staticSuffix = staticSuffix || null;
      this.kind = NODE_TYPES.PARAMETRIC;
      this.nodePaths = new Set([nodePath]);
    }
    getNextNode(path, pathIndex) {
      return this.findStaticMatchingChild(path, pathIndex);
    }
  }

  class WildcardNode extends Node {
    constructor() {
      super();
      this.kind = NODE_TYPES.WILDCARD;
    }
    getNextNode() {
      return null;
    }
  }
  module.exports = { StaticNode, ParametricNode, WildcardNode, NODE_TYPES };
});

// node_modules/find-my-way/lib/strategies/accept-version.js
var require_accept_version = __commonJS((exports, module) => {
  var assert = require_assert();
  function SemVerStore() {
    if (!(this instanceof SemVerStore)) {
      return new SemVerStore;
    }
    this.store = new Map;
    this.maxMajor = 0;
    this.maxMinors = {};
    this.maxPatches = {};
  }
  SemVerStore.prototype.set = function(version, store) {
    if (typeof version !== "string") {
      throw new TypeError("Version should be a string");
    }
    let [major, minor, patch] = version.split(".", 3);
    if (isNaN(major)) {
      throw new TypeError("Major version must be a numeric value");
    }
    major = Number(major);
    minor = Number(minor) || 0;
    patch = Number(patch) || 0;
    if (major >= this.maxMajor) {
      this.maxMajor = major;
      this.store.set("x", store);
      this.store.set("*", store);
      this.store.set("x.x", store);
      this.store.set("x.x.x", store);
    }
    if (minor >= (this.maxMinors[major] || 0)) {
      this.maxMinors[major] = minor;
      this.store.set(`${major}.x`, store);
      this.store.set(`${major}.x.x`, store);
    }
    if (patch >= (this.maxPatches[`${major}.${minor}`] || 0)) {
      this.maxPatches[`${major}.${minor}`] = patch;
      this.store.set(`${major}.${minor}.x`, store);
    }
    this.store.set(`${major}.${minor}.${patch}`, store);
    return this;
  };
  SemVerStore.prototype.get = function(version) {
    return this.store.get(version);
  };
  module.exports = {
    name: "version",
    mustMatchWhenDerived: true,
    storage: SemVerStore,
    validate(value) {
      assert(typeof value === "string", "Version should be a string");
    }
  };
});

// node_modules/find-my-way/lib/strategies/accept-host.js
var require_accept_host = __commonJS((exports, module) => {
  var assert = require_assert();
  function HostStorage() {
    const hosts = new Map;
    const regexHosts = [];
    return {
      get: (host) => {
        const exact = hosts.get(host);
        if (exact) {
          return exact;
        }
        for (const regex of regexHosts) {
          if (regex.host.test(host)) {
            return regex.value;
          }
        }
      },
      set: (host, value) => {
        if (host instanceof RegExp) {
          regexHosts.push({ host, value });
        } else {
          hosts.set(host, value);
        }
      }
    };
  }
  module.exports = {
    name: "host",
    mustMatchWhenDerived: false,
    storage: HostStorage,
    validate(value) {
      assert(typeof value === "string" || Object.prototype.toString.call(value) === "[object RegExp]", "Host should be a string or a RegExp");
    }
  };
});

// node_modules/find-my-way/lib/constrainer.js
var require_constrainer = __commonJS((exports, module) => {
  var acceptVersionStrategy = require_accept_version();
  var acceptHostStrategy = require_accept_host();
  var assert = require_assert();

  class Constrainer {
    constructor(customStrategies) {
      this.strategies = {
        version: acceptVersionStrategy,
        host: acceptHostStrategy
      };
      this.strategiesInUse = new Set;
      this.asyncStrategiesInUse = new Set;
      if (customStrategies) {
        for (const strategy of Object.values(customStrategies)) {
          this.addConstraintStrategy(strategy);
        }
      }
    }
    isStrategyUsed(strategyName) {
      return this.strategiesInUse.has(strategyName) || this.asyncStrategiesInUse.has(strategyName);
    }
    hasConstraintStrategy(strategyName) {
      const customConstraintStrategy = this.strategies[strategyName];
      if (customConstraintStrategy !== undefined) {
        return customConstraintStrategy.isCustom || this.isStrategyUsed(strategyName);
      }
      return false;
    }
    addConstraintStrategy(strategy) {
      assert(typeof strategy.name === "string" && strategy.name !== "", "strategy.name is required.");
      assert(strategy.storage && typeof strategy.storage === "function", "strategy.storage function is required.");
      assert(strategy.deriveConstraint && typeof strategy.deriveConstraint === "function", "strategy.deriveConstraint function is required.");
      if (this.strategies[strategy.name] && this.strategies[strategy.name].isCustom) {
        throw new Error(`There already exists a custom constraint with the name ${strategy.name}.`);
      }
      if (this.isStrategyUsed(strategy.name)) {
        throw new Error(`There already exists a route with ${strategy.name} constraint.`);
      }
      strategy.isCustom = true;
      strategy.isAsync = strategy.deriveConstraint.length === 3;
      this.strategies[strategy.name] = strategy;
      if (strategy.mustMatchWhenDerived) {
        this.noteUsage({ [strategy.name]: strategy });
      }
    }
    deriveConstraints(req, ctx, done) {
      const constraints = this.deriveSyncConstraints(req, ctx);
      if (done === undefined) {
        return constraints;
      }
      this.deriveAsyncConstraints(constraints, req, ctx, done);
    }
    deriveSyncConstraints(req, ctx) {
      return;
    }
    noteUsage(constraints) {
      if (constraints) {
        const beforeSize = this.strategiesInUse.size;
        for (const key in constraints) {
          const strategy = this.strategies[key];
          if (strategy.isAsync) {
            this.asyncStrategiesInUse.add(key);
          } else {
            this.strategiesInUse.add(key);
          }
        }
        if (beforeSize !== this.strategiesInUse.size) {
          this._buildDeriveConstraints();
        }
      }
    }
    newStoreForConstraint(constraint) {
      if (!this.strategies[constraint]) {
        throw new Error(`No strategy registered for constraint key ${constraint}`);
      }
      return this.strategies[constraint].storage();
    }
    validateConstraints(constraints) {
      for (const key in constraints) {
        const value = constraints[key];
        if (typeof value === "undefined") {
          throw new Error("Can't pass an undefined constraint value, must pass null or no key at all");
        }
        const strategy = this.strategies[key];
        if (!strategy) {
          throw new Error(`No strategy registered for constraint key ${key}`);
        }
        if (strategy.validate) {
          strategy.validate(value);
        }
      }
    }
    deriveAsyncConstraints(constraints, req, ctx, done) {
      let asyncConstraintsCount = this.asyncStrategiesInUse.size;
      if (asyncConstraintsCount === 0) {
        done(null, constraints);
        return;
      }
      constraints = constraints || {};
      for (const key of this.asyncStrategiesInUse) {
        const strategy = this.strategies[key];
        strategy.deriveConstraint(req, ctx, (err, constraintValue) => {
          if (err !== null) {
            done(err);
            return;
          }
          constraints[key] = constraintValue;
          if (--asyncConstraintsCount === 0) {
            done(null, constraints);
          }
        });
      }
    }
    _buildDeriveConstraints() {
      if (this.strategiesInUse.size === 0)
        return;
      const lines = ["return {"];
      for (const key of this.strategiesInUse) {
        const strategy = this.strategies[key];
        if (!strategy.isCustom) {
          if (key === "version") {
            lines.push("   version: req.headers['accept-version'],");
          } else {
            lines.push("   host: req.headers.host || req.headers[':authority'],");
          }
        } else {
          lines.push(`  ${strategy.name}: this.strategies.${key}.deriveConstraint(req, ctx),`);
        }
      }
      lines.push("}");
      this.deriveSyncConstraints = new Function("req", "ctx", lines.join(`
`)).bind(this);
    }
  }
  module.exports = Constrainer;
});

// node_modules/find-my-way/lib/http-methods.js
var require_http_methods = __commonJS((exports, module) => {
  var httpMethods = [
    "ACL",
    "BIND",
    "CHECKOUT",
    "CONNECT",
    "COPY",
    "DELETE",
    "GET",
    "HEAD",
    "LINK",
    "LOCK",
    "M-SEARCH",
    "MERGE",
    "MKACTIVITY",
    "MKCALENDAR",
    "MKCOL",
    "MOVE",
    "NOTIFY",
    "OPTIONS",
    "PATCH",
    "POST",
    "PROPFIND",
    "PROPPATCH",
    "PURGE",
    "PUT",
    "QUERY",
    "REBIND",
    "REPORT",
    "SEARCH",
    "SOURCE",
    "SUBSCRIBE",
    "TRACE",
    "UNBIND",
    "UNLINK",
    "UNLOCK",
    "UNSUBSCRIBE"
  ];
  module.exports = httpMethods;
});

// node_modules/find-my-way/lib/url-sanitizer.js
var require_url_sanitizer = __commonJS((exports, module) => {
  function decodeComponentChar(highCharCode, lowCharCode) {
    if (highCharCode === 50) {
      if (lowCharCode === 53)
        return "%";
      if (lowCharCode === 51)
        return "#";
      if (lowCharCode === 52)
        return "$";
      if (lowCharCode === 54)
        return "&";
      if (lowCharCode === 66)
        return "+";
      if (lowCharCode === 98)
        return "+";
      if (lowCharCode === 67)
        return ",";
      if (lowCharCode === 99)
        return ",";
      if (lowCharCode === 70)
        return "/";
      if (lowCharCode === 102)
        return "/";
      return null;
    }
    if (highCharCode === 51) {
      if (lowCharCode === 65)
        return ":";
      if (lowCharCode === 97)
        return ":";
      if (lowCharCode === 66)
        return ";";
      if (lowCharCode === 98)
        return ";";
      if (lowCharCode === 68)
        return "=";
      if (lowCharCode === 100)
        return "=";
      if (lowCharCode === 70)
        return "?";
      if (lowCharCode === 102)
        return "?";
      return null;
    }
    if (highCharCode === 52 && lowCharCode === 48) {
      return "@";
    }
    return null;
  }
  function safeDecodeURI(path, useSemicolonDelimiter) {
    let shouldDecode = false;
    let shouldDecodeParam = false;
    let querystring = "";
    for (let i = 1;i < path.length; i++) {
      const charCode = path.charCodeAt(i);
      if (charCode === 37) {
        const highCharCode = path.charCodeAt(i + 1);
        const lowCharCode = path.charCodeAt(i + 2);
        if (decodeComponentChar(highCharCode, lowCharCode) === null) {
          shouldDecode = true;
        } else {
          shouldDecodeParam = true;
          if (highCharCode === 50 && lowCharCode === 53) {
            shouldDecode = true;
            path = path.slice(0, i + 1) + "25" + path.slice(i + 1);
            i += 2;
          }
          i += 2;
        }
      } else if (charCode === 63 || charCode === 35 || charCode === 59 && useSemicolonDelimiter) {
        querystring = path.slice(i + 1);
        path = path.slice(0, i);
        break;
      }
    }
    const decodedPath = shouldDecode ? decodeURI(path) : path;
    return { path: decodedPath, querystring, shouldDecodeParam };
  }
  function safeDecodeURIComponent(uriComponent) {
    const startIndex = uriComponent.indexOf("%");
    if (startIndex === -1)
      return uriComponent;
    let decoded = "";
    let lastIndex = startIndex;
    for (let i = startIndex;i < uriComponent.length; i++) {
      if (uriComponent.charCodeAt(i) === 37) {
        const highCharCode = uriComponent.charCodeAt(i + 1);
        const lowCharCode = uriComponent.charCodeAt(i + 2);
        const decodedChar = decodeComponentChar(highCharCode, lowCharCode);
        decoded += uriComponent.slice(lastIndex, i) + decodedChar;
        lastIndex = i + 3;
      }
    }
    return uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex);
  }
  module.exports = { safeDecodeURI, safeDecodeURIComponent };
});

// node_modules/find-my-way/index.js
var require_find_my_way = __commonJS((exports, module) => {
  var assert = require_assert();
  var querystring = require_lib();
  var isRegexSafe = require_safe_regex2();
  var deepEqual = require_fast_deep_equal();
  var { prettyPrintTree } = require_pretty_print();
  var { StaticNode, NODE_TYPES } = require_node();
  var Constrainer = require_constrainer();
  var httpMethods = require_http_methods();
  var httpMethodStrategy = require_http_method();
  var { safeDecodeURI, safeDecodeURIComponent } = require_url_sanitizer();
  var FULL_PATH_REGEXP = /^https?:\/\/.*?\//;
  var OPTIONAL_PARAM_REGEXP = /(\/:[^/()]*?)\?(\/?)/;
  var ESCAPE_REGEXP = /[.*+?^${}()|[\]\\]/g;
  var REMOVE_DUPLICATE_SLASHES_REGEXP = /\/\/+/g;
  if (!isRegexSafe(FULL_PATH_REGEXP)) {
    throw new Error("the FULL_PATH_REGEXP is not safe, update this module");
  }
  if (!isRegexSafe(OPTIONAL_PARAM_REGEXP)) {
    throw new Error("the OPTIONAL_PARAM_REGEXP is not safe, update this module");
  }
  if (!isRegexSafe(ESCAPE_REGEXP)) {
    throw new Error("the ESCAPE_REGEXP is not safe, update this module");
  }
  if (!isRegexSafe(REMOVE_DUPLICATE_SLASHES_REGEXP)) {
    throw new Error("the REMOVE_DUPLICATE_SLASHES_REGEXP is not safe, update this module");
  }
  function Router(opts) {
    if (!(this instanceof Router)) {
      return new Router(opts);
    }
    opts = opts || {};
    this._opts = opts;
    if (opts.defaultRoute) {
      assert(typeof opts.defaultRoute === "function", "The default route must be a function");
      this.defaultRoute = opts.defaultRoute;
    } else {
      this.defaultRoute = null;
    }
    if (opts.onBadUrl) {
      assert(typeof opts.onBadUrl === "function", "The bad url handler must be a function");
      this.onBadUrl = opts.onBadUrl;
    } else {
      this.onBadUrl = null;
    }
    if (opts.buildPrettyMeta) {
      assert(typeof opts.buildPrettyMeta === "function", "buildPrettyMeta must be a function");
      this.buildPrettyMeta = opts.buildPrettyMeta;
    } else {
      this.buildPrettyMeta = defaultBuildPrettyMeta;
    }
    if (opts.querystringParser) {
      assert(typeof opts.querystringParser === "function", "querystringParser must be a function");
      this.querystringParser = opts.querystringParser;
    } else {
      this.querystringParser = (query) => query.length === 0 ? {} : querystring.parse(query);
    }
    this.caseSensitive = opts.caseSensitive === undefined ? true : opts.caseSensitive;
    this.ignoreTrailingSlash = opts.ignoreTrailingSlash || false;
    this.ignoreDuplicateSlashes = opts.ignoreDuplicateSlashes || false;
    this.maxParamLength = opts.maxParamLength || 100;
    this.allowUnsafeRegex = opts.allowUnsafeRegex || false;
    this.constrainer = new Constrainer(opts.constraints);
    this.useSemicolonDelimiter = opts.useSemicolonDelimiter || false;
    this.routes = [];
    this.trees = {};
  }
  Router.prototype.on = function on(method, path, opts, handler, store) {
    if (typeof opts === "function") {
      if (handler !== undefined) {
        store = handler;
      }
      handler = opts;
      opts = {};
    }
    assert(typeof path === "string", "Path should be a string");
    assert(path.length > 0, "The path could not be empty");
    assert(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
    assert(typeof handler === "function", "Handler should be a function");
    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch) {
      assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2") || "/";
      this.on(method, pathFull, opts, handler, store);
      this.on(method, pathOptional, opts, handler, store);
      return;
    }
    const route = path;
    if (this.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    if (this.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const methods = Array.isArray(method) ? method : [method];
    for (const method2 of methods) {
      assert(typeof method2 === "string", "Method should be a string");
      assert(httpMethods.includes(method2), `Method '${method2}' is not an http method.`);
      this._on(method2, path, opts, handler, store, route);
    }
  };
  Router.prototype._on = function _on(method, path, opts, handler, store) {
    let constraints = {};
    if (opts.constraints !== undefined) {
      assert(typeof opts.constraints === "object" && opts.constraints !== null, "Constraints should be an object");
      if (Object.keys(opts.constraints).length !== 0) {
        constraints = opts.constraints;
      }
    }
    this.constrainer.validateConstraints(constraints);
    this.constrainer.noteUsage(constraints);
    if (this.trees[method] === undefined) {
      this.trees[method] = new StaticNode("/");
    }
    let pattern = path;
    if (pattern === "*" && this.trees[method].prefix.length !== 0) {
      const currentRoot = this.trees[method];
      this.trees[method] = new StaticNode("");
      this.trees[method].staticChildren["/"] = currentRoot;
    }
    let currentNode = this.trees[method];
    let parentNodePathIndex = currentNode.prefix.length;
    const params = [];
    for (let i = 0;i <= pattern.length; i++) {
      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern.slice(parentNodePathIndex, i);
        if (!this.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.replaceAll("::", ":");
        staticNodePath = staticNodePath.replaceAll("%", "%25");
        currentNode = currentNode.createStaticChild(staticNodePath);
      }
      if (isParametricNode) {
        let isRegexNode = false;
        let isParamSafe = true;
        let backtrack = "";
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j3 = lastParamStartIndex;; j3++) {
          const charCode = pattern.charCodeAt(j3);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j3 === pattern.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            const paramName = pattern.slice(lastParamStartIndex, j3);
            params.push(paramName);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern, j3);
              const regexString = pattern.slice(j3, endOfRegexIndex + 1);
              if (!this.allowUnsafeRegex) {
                assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
              }
              regexps.push(trimRegExpStartAndEnd(regexString));
              j3 = endOfRegexIndex + 1;
              isParamSafe = true;
            } else {
              regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
              isParamSafe = false;
            }
            const staticPartStartIndex = j3;
            for (;j3 < pattern.length; j3++) {
              const charCode2 = pattern.charCodeAt(j3);
              if (charCode2 === 47)
                break;
              if (charCode2 === 58) {
                const nextCharCode = pattern.charCodeAt(j3 + 1);
                if (nextCharCode === 58)
                  j3++;
                else
                  break;
              }
            }
            let staticPart = pattern.slice(staticPartStartIndex, j3);
            if (staticPart) {
              staticPart = staticPart.replaceAll("::", ":");
              staticPart = staticPart.replaceAll("%", "%25");
              regexps.push(backtrack = escapeRegExp(staticPart));
            }
            lastParamStartIndex = j3 + 1;
            if (isEndOfNode || pattern.charCodeAt(j3) === 47 || j3 === pattern.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern.slice(i, j3);
              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j3);
              i += nodePattern.length;
              const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
              currentNode = currentNode.createParametricChild(regex, staticPart || null, nodePath);
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        params.push("*");
        currentNode = currentNode.createWildcardChild();
        parentNodePathIndex = i + 1;
        if (i !== pattern.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.caseSensitive) {
      pattern = pattern.toLowerCase();
    }
    if (pattern === "*") {
      pattern = "/*";
    }
    for (const existRoute of this.routes) {
      const routeConstraints = existRoute.opts.constraints || {};
      if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
        throw new Error(`Method '${method}' already declared for route '${pattern}' with constraints '${JSON.stringify(constraints)}'`);
      }
    }
    const route = { method, path, pattern, params, opts, handler, store };
    this.routes.push(route);
    currentNode.addRoute(route, this.constrainer);
  };
  Router.prototype.hasRoute = function hasRoute(method, path, constraints) {
    const route = this.findRoute(method, path, constraints);
    return route !== null;
  };
  Router.prototype.findRoute = function findNode(method, path, constraints = {}) {
    if (this.trees[method] === undefined) {
      return null;
    }
    let pattern = path;
    let currentNode = this.trees[method];
    let parentNodePathIndex = currentNode.prefix.length;
    const params = [];
    for (let i = 0;i <= pattern.length; i++) {
      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {
        i++;
        continue;
      }
      const isParametricNode = pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58;
      const isWildcardNode = pattern.charCodeAt(i) === 42;
      if (isParametricNode || isWildcardNode || i === pattern.length && i !== parentNodePathIndex) {
        let staticNodePath = pattern.slice(parentNodePathIndex, i);
        if (!this.caseSensitive) {
          staticNodePath = staticNodePath.toLowerCase();
        }
        staticNodePath = staticNodePath.replaceAll("::", ":");
        staticNodePath = staticNodePath.replaceAll("%", "%25");
        currentNode = currentNode.getStaticChild(staticNodePath);
        if (currentNode === null) {
          return null;
        }
      }
      if (isParametricNode) {
        let isRegexNode = false;
        let isParamSafe = true;
        let backtrack = "";
        const regexps = [];
        let lastParamStartIndex = i + 1;
        for (let j3 = lastParamStartIndex;; j3++) {
          const charCode = pattern.charCodeAt(j3);
          const isRegexParam = charCode === 40;
          const isStaticPart = charCode === 45 || charCode === 46;
          const isEndOfNode = charCode === 47 || j3 === pattern.length;
          if (isRegexParam || isStaticPart || isEndOfNode) {
            const paramName = pattern.slice(lastParamStartIndex, j3);
            params.push(paramName);
            isRegexNode = isRegexNode || isRegexParam || isStaticPart;
            if (isRegexParam) {
              const endOfRegexIndex = getClosingParenthensePosition(pattern, j3);
              const regexString = pattern.slice(j3, endOfRegexIndex + 1);
              if (!this.allowUnsafeRegex) {
                assert(isRegexSafe(new RegExp(regexString)), `The regex '${regexString}' is not safe!`);
              }
              regexps.push(trimRegExpStartAndEnd(regexString));
              j3 = endOfRegexIndex + 1;
              isParamSafe = false;
            } else {
              regexps.push(isParamSafe ? "(.*?)" : `(${backtrack}|(?:(?!${backtrack}).)*)`);
              isParamSafe = false;
            }
            const staticPartStartIndex = j3;
            for (;j3 < pattern.length; j3++) {
              const charCode2 = pattern.charCodeAt(j3);
              if (charCode2 === 47)
                break;
              if (charCode2 === 58) {
                const nextCharCode = pattern.charCodeAt(j3 + 1);
                if (nextCharCode === 58)
                  j3++;
                else
                  break;
              }
            }
            let staticPart = pattern.slice(staticPartStartIndex, j3);
            if (staticPart) {
              staticPart = staticPart.replaceAll("::", ":");
              staticPart = staticPart.replaceAll("%", "%25");
              regexps.push(backtrack = escapeRegExp(staticPart));
            }
            lastParamStartIndex = j3 + 1;
            if (isEndOfNode || pattern.charCodeAt(j3) === 47 || j3 === pattern.length) {
              const nodePattern = isRegexNode ? "()" + staticPart : staticPart;
              const nodePath = pattern.slice(i, j3);
              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j3);
              i += nodePattern.length;
              const regex = isRegexNode ? new RegExp("^" + regexps.join("") + "$") : null;
              currentNode = currentNode.getParametricChild(regex, staticPart || null, nodePath);
              if (currentNode === null) {
                return null;
              }
              parentNodePathIndex = i + 1;
              break;
            }
          }
        }
      } else if (isWildcardNode) {
        params.push("*");
        currentNode = currentNode.getWildcardChild();
        parentNodePathIndex = i + 1;
        if (i !== pattern.length - 1) {
          throw new Error("Wildcard must be the last character in the route");
        }
      }
    }
    if (!this.caseSensitive) {
      pattern = pattern.toLowerCase();
    }
    for (const existRoute of this.routes) {
      const routeConstraints = existRoute.opts.constraints || {};
      if (existRoute.method === method && existRoute.pattern === pattern && deepEqual(routeConstraints, constraints)) {
        return {
          handler: existRoute.handler,
          store: existRoute.store,
          params: existRoute.params
        };
      }
    }
    return null;
  };
  Router.prototype.hasConstraintStrategy = function(strategyName) {
    return this.constrainer.hasConstraintStrategy(strategyName);
  };
  Router.prototype.addConstraintStrategy = function(constraints) {
    this.constrainer.addConstraintStrategy(constraints);
    this._rebuild(this.routes);
  };
  Router.prototype.reset = function reset() {
    this.trees = {};
    this.routes = [];
  };
  Router.prototype.off = function off(method, path, constraints) {
    assert(typeof path === "string", "Path should be a string");
    assert(path.length > 0, "The path could not be empty");
    assert(path[0] === "/" || path[0] === "*", "The first character of a path should be `/` or `*`");
    assert(typeof constraints === "undefined" || typeof constraints === "object" && !Array.isArray(constraints) && constraints !== null, "Constraints should be an object or undefined.");
    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP);
    if (optionalParamMatch) {
      assert(path.length === optionalParamMatch.index + optionalParamMatch[0].length, "Optional Parameter needs to be the last parameter of the path");
      const pathFull = path.replace(OPTIONAL_PARAM_REGEXP, "$1$2");
      const pathOptional = path.replace(OPTIONAL_PARAM_REGEXP, "$2");
      this.off(method, pathFull, constraints);
      this.off(method, pathOptional, constraints);
      return;
    }
    if (this.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    if (this.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const methods = Array.isArray(method) ? method : [method];
    for (const method2 of methods) {
      this._off(method2, path, constraints);
    }
  };
  Router.prototype._off = function _off(method, path, constraints) {
    assert(typeof method === "string", "Method should be a string");
    assert(httpMethods.includes(method), `Method '${method}' is not an http method.`);
    function matcherWithoutConstraints(route) {
      return method !== route.method || path !== route.path;
    }
    function matcherWithConstraints(route) {
      return matcherWithoutConstraints(route) || !deepEqual(constraints, route.opts.constraints || {});
    }
    const predicate = constraints ? matcherWithConstraints : matcherWithoutConstraints;
    const newRoutes = this.routes.filter(predicate);
    this._rebuild(newRoutes);
  };
  Router.prototype.lookup = function lookup(req, res, ctx, done) {
    if (typeof ctx === "function") {
      done = ctx;
      ctx = undefined;
    }
    if (done === undefined) {
      const constraints = this.constrainer.deriveConstraints(req, ctx);
      const handle = this.find(req.method, req.url, constraints);
      return this.callHandler(handle, req, res, ctx);
    }
    this.constrainer.deriveConstraints(req, ctx, (err, constraints) => {
      if (err !== null) {
        done(err);
        return;
      }
      try {
        const handle = this.find(req.method, req.url, constraints);
        const result = this.callHandler(handle, req, res, ctx);
        done(null, result);
      } catch (err2) {
        done(err2);
      }
    });
  };
  Router.prototype.callHandler = function callHandler(handle, req, res, ctx) {
    if (handle === null)
      return this._defaultRoute(req, res, ctx);
    return ctx === undefined ? handle.handler(req, res, handle.params, handle.store, handle.searchParams) : handle.handler.call(ctx, req, res, handle.params, handle.store, handle.searchParams);
  };
  Router.prototype.find = function find(method, path, derivedConstraints) {
    let currentNode = this.trees[method];
    if (currentNode === undefined)
      return null;
    if (path.charCodeAt(0) !== 47) {
      path = path.replace(FULL_PATH_REGEXP, "/");
    }
    if (this.ignoreDuplicateSlashes) {
      path = removeDuplicateSlashes(path);
    }
    let sanitizedUrl;
    let querystring2;
    let shouldDecodeParam;
    try {
      sanitizedUrl = safeDecodeURI(path, this.useSemicolonDelimiter);
      path = sanitizedUrl.path;
      querystring2 = sanitizedUrl.querystring;
      shouldDecodeParam = sanitizedUrl.shouldDecodeParam;
    } catch (error) {
      return this._onBadUrl(path);
    }
    if (this.ignoreTrailingSlash) {
      path = trimLastSlash(path);
    }
    const originPath = path;
    if (this.caseSensitive === false) {
      path = path.toLowerCase();
    }
    const maxParamLength = this.maxParamLength;
    let pathIndex = currentNode.prefix.length;
    const params = [];
    const pathLen = path.length;
    const brothersNodesStack = [];
    while (true) {
      if (pathIndex === pathLen && currentNode.isLeafNode) {
        const handle = currentNode.handlerStorage.getMatchingHandler(derivedConstraints);
        if (handle !== null) {
          return {
            handler: handle.handler,
            store: handle.store,
            params: handle._createParamsObject(params),
            searchParams: this.querystringParser(querystring2)
          };
        }
      }
      let node = currentNode.getNextNode(path, pathIndex, brothersNodesStack, params.length);
      if (node === null) {
        if (brothersNodesStack.length === 0) {
          return null;
        }
        const brotherNodeState = brothersNodesStack.pop();
        pathIndex = brotherNodeState.brotherPathIndex;
        params.splice(brotherNodeState.paramsCount);
        node = brotherNodeState.brotherNode;
      }
      currentNode = node;
      if (currentNode.kind === NODE_TYPES.STATIC) {
        pathIndex += currentNode.prefix.length;
        continue;
      }
      if (currentNode.kind === NODE_TYPES.WILDCARD) {
        let param2 = originPath.slice(pathIndex);
        if (shouldDecodeParam) {
          param2 = safeDecodeURIComponent(param2);
        }
        params.push(param2);
        pathIndex = pathLen;
        continue;
      }
      let paramEndIndex = originPath.indexOf("/", pathIndex);
      if (paramEndIndex === -1) {
        paramEndIndex = pathLen;
      }
      let param = originPath.slice(pathIndex, paramEndIndex);
      if (shouldDecodeParam) {
        param = safeDecodeURIComponent(param);
      }
      if (currentNode.isRegex) {
        const matchedParameters = currentNode.regex.exec(param);
        if (matchedParameters === null)
          continue;
        for (let i = 1;i < matchedParameters.length; i++) {
          const matchedParam = matchedParameters[i];
          if (matchedParam.length > maxParamLength) {
            return null;
          }
          params.push(matchedParam);
        }
      } else {
        if (param.length > maxParamLength) {
          return null;
        }
        params.push(param);
      }
      pathIndex = paramEndIndex;
    }
  };
  Router.prototype._rebuild = function(routes) {
    this.reset();
    for (const route of routes) {
      const { method, path, opts, handler, store } = route;
      this._on(method, path, opts, handler, store);
    }
  };
  Router.prototype._defaultRoute = function(req, res, ctx) {
    if (this.defaultRoute !== null) {
      return ctx === undefined ? this.defaultRoute(req, res) : this.defaultRoute.call(ctx, req, res);
    } else {
      res.statusCode = 404;
      res.end();
    }
  };
  Router.prototype._onBadUrl = function(path) {
    if (this.onBadUrl === null) {
      return null;
    }
    const onBadUrl = this.onBadUrl;
    return {
      handler: (req, res, ctx) => onBadUrl(path, req, res),
      params: {},
      store: null
    };
  };
  Router.prototype.prettyPrint = function(options = {}) {
    const method = options.method;
    options.buildPrettyMeta = this.buildPrettyMeta.bind(this);
    let tree = null;
    if (method === undefined) {
      const { version, host, ...constraints } = this.constrainer.strategies;
      constraints[httpMethodStrategy.name] = httpMethodStrategy;
      const mergedRouter = new Router({ ...this._opts, constraints });
      const mergedRoutes = this.routes.map((route) => {
        const constraints2 = {
          ...route.opts.constraints,
          [httpMethodStrategy.name]: route.method
        };
        return { ...route, method: "MERGED", opts: { constraints: constraints2 } };
      });
      mergedRouter._rebuild(mergedRoutes);
      tree = mergedRouter.trees.MERGED;
    } else {
      tree = this.trees[method];
    }
    if (tree == null)
      return "(empty tree)";
    return prettyPrintTree(tree, options);
  };
  for (const i in httpMethods) {
    if (!httpMethods.hasOwnProperty(i))
      continue;
    const m3 = httpMethods[i];
    const methodName = m3.toLowerCase();
    Router.prototype[methodName] = function(path, handler, store) {
      return this.on(m3, path, handler, store);
    };
  }
  Router.prototype.all = function(path, handler, store) {
    this.on(httpMethods, path, handler, store);
  };
  module.exports = Router;
  function escapeRegExp(string) {
    return string.replace(ESCAPE_REGEXP, "\\$&");
  }
  function removeDuplicateSlashes(path) {
    return path.indexOf("//") !== -1 ? path.replace(REMOVE_DUPLICATE_SLASHES_REGEXP, "/") : path;
  }
  function trimLastSlash(path) {
    if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {
      return path.slice(0, -1);
    }
    return path;
  }
  function trimRegExpStartAndEnd(regexString) {
    if (regexString.charCodeAt(1) === 94) {
      regexString = regexString.slice(0, 1) + regexString.slice(2);
    }
    if (regexString.charCodeAt(regexString.length - 2) === 36) {
      regexString = regexString.slice(0, regexString.length - 2) + regexString.slice(regexString.length - 1);
    }
    return regexString;
  }
  function getClosingParenthensePosition(path, idx) {
    let parentheses = 1;
    while (idx < path.length) {
      idx++;
      if (path.charCodeAt(idx) === 92) {
        idx++;
        continue;
      }
      if (path.charCodeAt(idx) === 41) {
        parentheses--;
      } else if (path.charCodeAt(idx) === 40) {
        parentheses++;
      }
      if (!parentheses)
        return idx;
    }
    throw new TypeError('Invalid regexp expression in "' + path + '"');
  }
  function defaultBuildPrettyMeta(route) {
    if (!route)
      return {};
    if (!route.store)
      return {};
    return Object.assign({}, route.store);
  }
});

// node_modules/fastify/lib/headRoute.js
var require_headRoute = __commonJS((exports, module) => {
  function headRouteOnSendHandler(req, reply, payload, done) {
    if (payload === undefined) {
      reply.header("content-length", "0");
      done(null, null);
      return;
    }
    if (typeof payload.resume === "function") {
      payload.on("error", (err) => {
        reply.log.error({ err }, "Error on Stream found for HEAD route");
      });
      payload.resume();
      done(null, null);
      return;
    }
    const size = "" + Buffer.byteLength(payload);
    reply.header("content-length", size);
    done(null, null);
  }
  function parseHeadOnSendHandlers(onSendHandlers) {
    if (onSendHandlers == null)
      return headRouteOnSendHandler;
    return Array.isArray(onSendHandlers) ? [...onSendHandlers, headRouteOnSendHandler] : [onSendHandlers, headRouteOnSendHandler];
  }
  module.exports = {
    parseHeadOnSendHandlers
  };
});

// node_modules/fastify/lib/route.js
var require_route = __commonJS((exports, module) => {
  var FindMyWay = require_find_my_way();
  var Context = require_context();
  var handleRequest = require_handleRequest();
  var { onRequestAbortHookRunner, lifecycleHooks, preParsingHookRunner, onTimeoutHookRunner, onRequestHookRunner } = require_hooks();
  var { normalizeSchema } = require_schemas();
  var { parseHeadOnSendHandlers } = require_headRoute();
  var {
    compileSchemasForValidation,
    compileSchemasForSerialization
  } = require_validation();
  var {
    FST_ERR_SCH_VALIDATION_BUILD,
    FST_ERR_SCH_SERIALIZATION_BUILD,
    FST_ERR_DUPLICATED_ROUTE,
    FST_ERR_INVALID_URL,
    FST_ERR_HOOK_INVALID_HANDLER,
    FST_ERR_ROUTE_OPTIONS_NOT_OBJ,
    FST_ERR_ROUTE_DUPLICATED_HANDLER,
    FST_ERR_ROUTE_HANDLER_NOT_FN,
    FST_ERR_ROUTE_MISSING_HANDLER,
    FST_ERR_ROUTE_METHOD_NOT_SUPPORTED,
    FST_ERR_ROUTE_METHOD_INVALID,
    FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED,
    FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT,
    FST_ERR_HOOK_INVALID_ASYNC_HANDLER
  } = require_errors2();
  var { FSTDEP022 } = require_warnings();
  var {
    kRoutePrefix,
    kSupportedHTTPMethods,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kOptions,
    kReplySerializerDefault,
    kReplyIsError,
    kRequestPayloadStream,
    kDisableRequestLogging,
    kSchemaErrorFormatter,
    kErrorHandler,
    kHasBeenDecorated,
    kRequestAcceptVersion,
    kRouteByFastify,
    kRouteContext
  } = require_symbols2();
  var { buildErrorHandler } = require_error_handler();
  var { createChildLogger } = require_logger_factory();
  var { getGenReqId } = require_reqIdGenFactory();
  var routerKeys = [
    "allowUnsafeRegex",
    "buildPrettyMeta",
    "caseSensitive",
    "constraints",
    "defaultRoute",
    "ignoreDuplicateSlashes",
    "ignoreTrailingSlash",
    "maxParamLength",
    "onBadUrl",
    "querystringParser",
    "useSemicolonDelimiter"
  ];
  function buildRouting(options) {
    const router = FindMyWay(options.config);
    let avvio;
    let fourOhFour;
    let logger;
    let hasLogger;
    let setupResponseListeners;
    let throwIfAlreadyStarted;
    let disableRequestLogging;
    let ignoreTrailingSlash;
    let ignoreDuplicateSlashes;
    let return503OnClosing;
    let globalExposeHeadRoutes;
    let keepAliveConnections;
    let closing = false;
    return {
      setup(options2, fastifyArgs) {
        avvio = fastifyArgs.avvio;
        fourOhFour = fastifyArgs.fourOhFour;
        logger = fastifyArgs.logger;
        hasLogger = fastifyArgs.hasLogger;
        setupResponseListeners = fastifyArgs.setupResponseListeners;
        throwIfAlreadyStarted = fastifyArgs.throwIfAlreadyStarted;
        globalExposeHeadRoutes = options2.exposeHeadRoutes;
        disableRequestLogging = options2.disableRequestLogging;
        ignoreTrailingSlash = options2.routerOptions.ignoreTrailingSlash;
        ignoreDuplicateSlashes = options2.routerOptions.ignoreDuplicateSlashes;
        return503OnClosing = Object.hasOwn(options2, "return503OnClosing") ? options2.return503OnClosing : true;
        keepAliveConnections = fastifyArgs.keepAliveConnections;
      },
      routing: router.lookup.bind(router),
      route,
      hasRoute,
      prepareRoute,
      routeHandler,
      closeRoutes: () => {
        closing = true;
      },
      printRoutes: router.prettyPrint.bind(router),
      addConstraintStrategy,
      hasConstraintStrategy,
      isAsyncConstraint,
      findRoute
    };
    function addConstraintStrategy(strategy) {
      throwIfAlreadyStarted("Cannot add constraint strategy!");
      return router.addConstraintStrategy(strategy);
    }
    function hasConstraintStrategy(strategyName) {
      return router.hasConstraintStrategy(strategyName);
    }
    function isAsyncConstraint() {
      return router.constrainer.asyncStrategiesInUse.size > 0;
    }
    function prepareRoute({ method, url, options: options2, handler, isFastify }) {
      if (typeof url !== "string") {
        throw new FST_ERR_INVALID_URL(typeof url);
      }
      if (!handler && typeof options2 === "function") {
        handler = options2;
        options2 = {};
      } else if (handler && typeof handler === "function") {
        if (Object.prototype.toString.call(options2) !== "[object Object]") {
          throw new FST_ERR_ROUTE_OPTIONS_NOT_OBJ(method, url);
        } else if (options2.handler) {
          if (typeof options2.handler === "function") {
            throw new FST_ERR_ROUTE_DUPLICATED_HANDLER(method, url);
          } else {
            throw new FST_ERR_ROUTE_HANDLER_NOT_FN(method, url);
          }
        }
      }
      options2 = Object.assign({}, options2, {
        method,
        url,
        path: url,
        handler: handler || options2 && options2.handler
      });
      return route.call(this, { options: options2, isFastify });
    }
    function hasRoute({ options: options2 }) {
      const normalizedMethod = options2.method?.toUpperCase() ?? "";
      return router.hasRoute(normalizedMethod, options2.url || "", options2.constraints);
    }
    function findRoute(options2) {
      const route2 = router.find(options2.method, options2.url || "", options2.constraints);
      if (route2) {
        return {
          handler: route2.handler,
          params: route2.params,
          searchParams: route2.searchParams
        };
      } else {
        return null;
      }
    }
    function route({ options: options2, isFastify }) {
      throwIfAlreadyStarted("Cannot add route!");
      const opts = { ...options2 };
      const path = opts.url || opts.path || "";
      if (!opts.handler) {
        throw new FST_ERR_ROUTE_MISSING_HANDLER(opts.method, path);
      }
      if (opts.errorHandler !== undefined && typeof opts.errorHandler !== "function") {
        throw new FST_ERR_ROUTE_HANDLER_NOT_FN(opts.method, path);
      }
      validateBodyLimitOption(opts.bodyLimit);
      const shouldExposeHead = opts.exposeHeadRoute ?? globalExposeHeadRoutes;
      let isGetRoute = false;
      let isHeadRoute = false;
      if (Array.isArray(opts.method)) {
        for (let i = 0;i < opts.method.length; ++i) {
          opts.method[i] = normalizeAndValidateMethod.call(this, opts.method[i]);
          validateSchemaBodyOption.call(this, opts.method[i], path, opts.schema);
          isGetRoute = opts.method.includes("GET");
          isHeadRoute = opts.method.includes("HEAD");
        }
      } else {
        opts.method = normalizeAndValidateMethod.call(this, opts.method);
        validateSchemaBodyOption.call(this, opts.method, path, opts.schema);
        isGetRoute = opts.method === "GET";
        isHeadRoute = opts.method === "HEAD";
      }
      const headOpts = shouldExposeHead && isGetRoute ? { ...options2 } : null;
      const prefix = this[kRoutePrefix];
      if (path === "/" && prefix.length > 0 && opts.method !== "HEAD") {
        switch (opts.prefixTrailingSlash) {
          case "slash":
            addNewRoute.call(this, { path, isFastify });
            break;
          case "no-slash":
            addNewRoute.call(this, { path: "", isFastify });
            break;
          case "both":
          default:
            addNewRoute.call(this, { path: "", isFastify });
            if (ignoreTrailingSlash !== true && (ignoreDuplicateSlashes !== true || !prefix.endsWith("/"))) {
              addNewRoute.call(this, { path, prefixing: true, isFastify });
            }
        }
      } else if (path[0] === "/" && prefix.endsWith("/")) {
        addNewRoute.call(this, { path: path.slice(1), isFastify });
      } else {
        addNewRoute.call(this, { path, isFastify });
      }
      return this;
      function addNewRoute({ path: path2, prefixing = false, isFastify: isFastify2 = false }) {
        const url = prefix + path2;
        opts.url = url;
        opts.path = url;
        opts.routePath = path2;
        opts.prefix = prefix;
        opts.logLevel = opts.logLevel || this[kLogLevel];
        if (this[kLogSerializers] || opts.logSerializers) {
          opts.logSerializers = Object.assign(Object.create(this[kLogSerializers]), opts.logSerializers);
        }
        if (opts.attachValidation == null) {
          opts.attachValidation = false;
        }
        if (prefixing === false) {
          for (const hook of this[kHooks].onRoute) {
            hook.call(this, opts);
          }
        }
        for (const hook of lifecycleHooks) {
          if (opts && hook in opts) {
            if (Array.isArray(opts[hook])) {
              for (const func of opts[hook]) {
                if (typeof func !== "function") {
                  throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(func));
                }
                if (hook === "onSend" || hook === "preSerialization" || hook === "onError" || hook === "preParsing") {
                  if (func.constructor.name === "AsyncFunction" && func.length === 4) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
                  }
                } else if (hook === "onRequestAbort") {
                  if (func.constructor.name === "AsyncFunction" && func.length !== 1) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
                  }
                } else {
                  if (func.constructor.name === "AsyncFunction" && func.length === 3) {
                    throw new FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
                  }
                }
              }
            } else if (opts[hook] !== undefined && typeof opts[hook] !== "function") {
              throw new FST_ERR_HOOK_INVALID_HANDLER(hook, Object.prototype.toString.call(opts[hook]));
            }
          }
        }
        const constraints = opts.constraints || {};
        const config = {
          ...opts.config,
          url,
          method: opts.method
        };
        const context = new Context({
          schema: opts.schema,
          handler: opts.handler.bind(this),
          config,
          errorHandler: opts.errorHandler,
          childLoggerFactory: opts.childLoggerFactory,
          bodyLimit: opts.bodyLimit,
          logLevel: opts.logLevel,
          logSerializers: opts.logSerializers,
          attachValidation: opts.attachValidation,
          schemaErrorFormatter: opts.schemaErrorFormatter,
          replySerializer: this[kReplySerializerDefault],
          validatorCompiler: opts.validatorCompiler,
          serializerCompiler: opts.serializerCompiler,
          exposeHeadRoute: shouldExposeHead,
          prefixTrailingSlash: opts.prefixTrailingSlash || "both",
          server: this,
          isFastify: isFastify2
        });
        const headHandler = router.findRoute("HEAD", opts.url, constraints);
        const hasHEADHandler = headHandler !== null;
        try {
          router.on(opts.method, opts.url, { constraints }, routeHandler, context);
        } catch (error) {
          if (!context[kRouteByFastify]) {
            const isDuplicatedRoute = error.message.includes(`Method '${opts.method}' already declared for route`);
            if (isDuplicatedRoute) {
              throw new FST_ERR_DUPLICATED_ROUTE(opts.method, opts.url);
            }
            throw error;
          }
        }
        this.after((notHandledErr, done) => {
          context.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
          context._parserOptions.limit = opts.bodyLimit || null;
          context.logLevel = opts.logLevel;
          context.logSerializers = opts.logSerializers;
          context.attachValidation = opts.attachValidation;
          context[kReplySerializerDefault] = this[kReplySerializerDefault];
          context.schemaErrorFormatter = opts.schemaErrorFormatter || this[kSchemaErrorFormatter] || context.schemaErrorFormatter;
          avvio.once("preReady", () => {
            for (const hook of lifecycleHooks) {
              const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h3) => h3.bind(this));
              context[hook] = toSet.length ? toSet : null;
            }
            while (!context.Request[kHasBeenDecorated] && context.Request.parent) {
              context.Request = context.Request.parent;
            }
            while (!context.Reply[kHasBeenDecorated] && context.Reply.parent) {
              context.Reply = context.Reply.parent;
            }
            fourOhFour.setContext(this, context);
            if (opts.schema) {
              context.schema = normalizeSchema(context.schema, this.initialConfig);
              const schemaController = this[kSchemaController];
              if (!opts.validatorCompiler && (opts.schema.body || opts.schema.headers || opts.schema.querystring || opts.schema.params)) {
                schemaController.setupValidator(this[kOptions]);
              }
              try {
                const isCustom = typeof opts?.validatorCompiler === "function" || schemaController.isCustomValidatorCompiler;
                compileSchemasForValidation(context, opts.validatorCompiler || schemaController.validatorCompiler, isCustom);
              } catch (error) {
                throw new FST_ERR_SCH_VALIDATION_BUILD(opts.method, url, error.message);
              }
              if (opts.schema.response && !opts.serializerCompiler) {
                schemaController.setupSerializer(this[kOptions]);
              }
              try {
                compileSchemasForSerialization(context, opts.serializerCompiler || schemaController.serializerCompiler);
              } catch (error) {
                throw new FST_ERR_SCH_SERIALIZATION_BUILD(opts.method, url, error.message);
              }
            }
          });
          done(notHandledErr);
        });
        if (shouldExposeHead && isGetRoute && !isHeadRoute && !hasHEADHandler) {
          const onSendHandlers = parseHeadOnSendHandlers(headOpts.onSend);
          prepareRoute.call(this, { method: "HEAD", url: path2, options: { ...headOpts, onSend: onSendHandlers }, isFastify: true });
        }
      }
    }
    function routeHandler(req, res, params, context, query) {
      const id = getGenReqId(context.server, req);
      const loggerOpts = {
        level: context.logLevel
      };
      if (context.logSerializers) {
        loggerOpts.serializers = context.logSerializers;
      }
      const childLogger = createChildLogger(context, logger, req, id, loggerOpts);
      childLogger[kDisableRequestLogging] = disableRequestLogging;
      if (closing === true) {
        if (req.httpVersionMajor !== 2) {
          res.setHeader("Connection", "close");
        }
        if (return503OnClosing) {
          const headers = {
            "Content-Type": "application/json",
            "Content-Length": "80"
          };
          res.writeHead(503, headers);
          res.end('{"error":"Service Unavailable","message":"Service Unavailable","statusCode":503}');
          childLogger.info({ res: { statusCode: 503 } }, "request aborted - refusing to accept new requests as server is closing");
          return;
        }
      }
      const connHeader = String.prototype.toLowerCase.call(req.headers.connection || "");
      if (connHeader === "keep-alive") {
        if (keepAliveConnections.has(req.socket) === false) {
          keepAliveConnections.add(req.socket);
          req.socket.on("close", removeTrackedSocket.bind({ keepAliveConnections, socket: req.socket }));
        }
      }
      if (req.headers[kRequestAcceptVersion] !== undefined) {
        req.headers["accept-version"] = req.headers[kRequestAcceptVersion];
        req.headers[kRequestAcceptVersion] = undefined;
      }
      const request = new context.Request(id, params, req, query, childLogger, context);
      const reply = new context.Reply(res, request, childLogger);
      if (disableRequestLogging === false) {
        childLogger.info({ req: request }, "incoming request");
      }
      if (hasLogger === true || context.onResponse !== null) {
        setupResponseListeners(reply);
      }
      if (context.onRequest !== null) {
        onRequestHookRunner(context.onRequest, request, reply, runPreParsing);
      } else {
        runPreParsing(null, request, reply);
      }
      if (context.onRequestAbort !== null) {
        req.on("close", () => {
          if (req.aborted) {
            onRequestAbortHookRunner(context.onRequestAbort, request, handleOnRequestAbortHooksErrors.bind(null, reply));
          }
        });
      }
      if (context.onTimeout !== null) {
        if (!request.raw.socket._meta) {
          request.raw.socket.on("timeout", handleTimeout);
        }
        request.raw.socket._meta = { context, request, reply };
      }
    }
  }
  function handleOnRequestAbortHooksErrors(reply, err) {
    if (err) {
      reply.log.error({ err }, "onRequestAborted hook failed");
    }
  }
  function handleTimeout() {
    const { context, request, reply } = this._meta;
    onTimeoutHookRunner(context.onTimeout, request, reply, noop);
  }
  function normalizeAndValidateMethod(method) {
    if (typeof method !== "string") {
      throw new FST_ERR_ROUTE_METHOD_INVALID;
    }
    method = method.toUpperCase();
    if (!this[kSupportedHTTPMethods].bodyless.has(method) && !this[kSupportedHTTPMethods].bodywith.has(method)) {
      throw new FST_ERR_ROUTE_METHOD_NOT_SUPPORTED(method);
    }
    return method;
  }
  function validateSchemaBodyOption(method, path, schema) {
    if (this[kSupportedHTTPMethods].bodyless.has(method) && schema?.body) {
      throw new FST_ERR_ROUTE_BODY_VALIDATION_SCHEMA_NOT_SUPPORTED(method, path);
    }
  }
  function validateBodyLimitOption(bodyLimit) {
    if (bodyLimit === undefined)
      return;
    if (!Number.isInteger(bodyLimit) || bodyLimit <= 0) {
      throw new FST_ERR_ROUTE_BODY_LIMIT_OPTION_NOT_INT(bodyLimit);
    }
  }
  function runPreParsing(err, request, reply) {
    if (reply.sent === true)
      return;
    if (err != null) {
      reply[kReplyIsError] = true;
      reply.send(err);
      return;
    }
    request[kRequestPayloadStream] = request.raw;
    if (request[kRouteContext].preParsing !== null) {
      preParsingHookRunner(request[kRouteContext].preParsing, request, reply, handleRequest.bind(request.server));
    } else {
      handleRequest.call(request.server, null, request, reply);
    }
  }
  function buildRouterOptions(options, defaultOptions) {
    const routerOptions = options.routerOptions || Object.create(null);
    const usedDeprecatedOptions = routerKeys.filter((key) => Object.hasOwn(options, key));
    if (usedDeprecatedOptions.length > 0) {
      FSTDEP022(usedDeprecatedOptions.join(", "));
    }
    for (const key of routerKeys) {
      if (!Object.hasOwn(routerOptions, key)) {
        routerOptions[key] = options[key] ?? defaultOptions[key];
      }
    }
    return routerOptions;
  }
  function removeTrackedSocket() {
    this.keepAliveConnections.delete(this.socket);
  }
  function noop() {}
  module.exports = { buildRouting, validateBodyLimitOption, buildRouterOptions };
});

// node_modules/fastify/lib/fourOhFour.js
var require_fourOhFour = __commonJS((exports, module) => {
  var FindMyWay = require_find_my_way();
  var Reply = require_reply();
  var Request = require_request();
  var Context = require_context();
  var {
    kRoutePrefix,
    kCanSetNotFoundHandler,
    kFourOhFourLevelInstance,
    kFourOhFourContext,
    kHooks,
    kErrorHandler
  } = require_symbols2();
  var { lifecycleHooks } = require_hooks();
  var { buildErrorHandler } = require_error_handler();
  var {
    FST_ERR_NOT_FOUND
  } = require_errors2();
  var { createChildLogger } = require_logger_factory();
  var { getGenReqId } = require_reqIdGenFactory();
  function fourOhFour(options) {
    const { logger, disableRequestLogging } = options;
    const router = FindMyWay({ onBadUrl: createOnBadUrl(), defaultRoute: fourOhFourFallBack });
    let _onBadUrlHandler = null;
    return { router, setNotFoundHandler, setContext, arrange404 };
    function arrange404(instance) {
      instance[kFourOhFourLevelInstance] = instance;
      instance[kCanSetNotFoundHandler] = true;
      router.onBadUrl = router.onBadUrl.bind(instance);
      router.defaultRoute = router.defaultRoute.bind(instance);
    }
    function basic404(request, reply) {
      const { url, method } = request.raw;
      const message = `Route ${method}:${url} not found`;
      if (!disableRequestLogging) {
        request.log.info(message);
      }
      reply.code(404).send({
        message,
        error: "Not Found",
        statusCode: 404
      });
    }
    function createOnBadUrl() {
      return function onBadUrl(path, req, res) {
        const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
        const id = getGenReqId(fourOhFourContext.server, req);
        const childLogger = createChildLogger(fourOhFourContext, logger, req, id);
        const request = new Request(id, null, req, null, childLogger, fourOhFourContext);
        const reply = new Reply(res, request, childLogger);
        _onBadUrlHandler(request, reply);
      };
    }
    function setContext(instance, context) {
      const _404Context = Object.assign({}, instance[kFourOhFourContext]);
      _404Context.onSend = context.onSend;
      context[kFourOhFourContext] = _404Context;
    }
    function setNotFoundHandler(opts, handler, avvio, routeHandler) {
      if (this[kCanSetNotFoundHandler] === undefined) {
        this[kCanSetNotFoundHandler] = true;
      }
      if (this[kFourOhFourContext] === undefined) {
        this[kFourOhFourContext] = null;
      }
      const _fastify = this;
      const prefix = this[kRoutePrefix] || "/";
      if (this[kCanSetNotFoundHandler] === false) {
        throw new Error(`Not found handler already set for Fastify instance with prefix: '${prefix}'`);
      }
      if (typeof opts === "object") {
        if (opts.preHandler) {
          if (Array.isArray(opts.preHandler)) {
            opts.preHandler = opts.preHandler.map((hook) => hook.bind(_fastify));
          } else {
            opts.preHandler = opts.preHandler.bind(_fastify);
          }
        }
        if (opts.preValidation) {
          if (Array.isArray(opts.preValidation)) {
            opts.preValidation = opts.preValidation.map((hook) => hook.bind(_fastify));
          } else {
            opts.preValidation = opts.preValidation.bind(_fastify);
          }
        }
      }
      if (typeof opts === "function") {
        handler = opts;
        opts = undefined;
      }
      opts = opts || {};
      if (handler) {
        this[kFourOhFourLevelInstance][kCanSetNotFoundHandler] = false;
        handler = handler.bind(this);
        _onBadUrlHandler = handler;
      } else {
        handler = basic404;
        _onBadUrlHandler = basic404;
      }
      this.after((notHandledErr, done) => {
        _setNotFoundHandler.call(this, prefix, opts, handler, avvio, routeHandler);
        done(notHandledErr);
      });
    }
    function _setNotFoundHandler(prefix, opts, handler, avvio, routeHandler) {
      const context = new Context({
        schema: opts.schema,
        handler,
        config: opts.config || {},
        server: this
      });
      avvio.once("preReady", () => {
        const context2 = this[kFourOhFourContext];
        for (const hook of lifecycleHooks) {
          const toSet = this[kHooks][hook].concat(opts[hook] || []).map((h3) => h3.bind(this));
          context2[hook] = toSet.length ? toSet : null;
        }
        context2.errorHandler = opts.errorHandler ? buildErrorHandler(this[kErrorHandler], opts.errorHandler) : this[kErrorHandler];
      });
      if (this[kFourOhFourContext] !== null && prefix === "/") {
        Object.assign(this[kFourOhFourContext], context);
        return;
      }
      this[kFourOhFourLevelInstance][kFourOhFourContext] = context;
      router.all(prefix + (prefix.endsWith("/") ? "*" : "/*"), routeHandler, context);
      router.all(prefix, routeHandler, context);
    }
    function fourOhFourFallBack(req, res) {
      const fourOhFourContext = this[kFourOhFourLevelInstance][kFourOhFourContext];
      const id = getGenReqId(fourOhFourContext.server, req);
      const childLogger = createChildLogger(fourOhFourContext, logger, req, id);
      childLogger.info({ req }, "incoming request");
      const request = new Request(id, null, req, null, childLogger, fourOhFourContext);
      const reply = new Reply(res, request, childLogger);
      request.log.warn("the default handler for 404 did not catch this, this is likely a fastify bug, please report it");
      request.log.warn(router.prettyPrint());
      reply.code(404).send(new FST_ERR_NOT_FOUND);
    }
  }
  module.exports = fourOhFour;
});

// node_modules/fastify/lib/configValidator.js
var require_configValidator = __commonJS((exports, module) => {
  module.exports = validate10;
  module.exports.default = validate10;
  var schema11 = { type: "object", additionalProperties: false, properties: { connectionTimeout: { type: "integer", default: 0 }, keepAliveTimeout: { type: "integer", default: 72000 }, forceCloseConnections: { oneOf: [{ type: "string", pattern: "idle" }, { type: "boolean" }] }, maxRequestsPerSocket: { type: "integer", default: 0, nullable: true }, requestTimeout: { type: "integer", default: 0 }, bodyLimit: { type: "integer", default: 1048576 }, caseSensitive: { type: "boolean", default: true }, allowUnsafeRegex: { type: "boolean", default: false }, http2: { type: "boolean" }, https: { if: { not: { oneOf: [{ type: "boolean" }, { type: "null" }, { type: "object", additionalProperties: false, required: ["allowHTTP1"], properties: { allowHTTP1: { type: "boolean" } } }] } }, then: { setDefaultValue: true } }, ignoreTrailingSlash: { type: "boolean", default: false }, ignoreDuplicateSlashes: { type: "boolean", default: false }, disableRequestLogging: { type: "boolean", default: false }, maxParamLength: { type: "integer", default: 100 }, onProtoPoisoning: { type: "string", default: "error" }, onConstructorPoisoning: { type: "string", default: "error" }, pluginTimeout: { type: "integer", default: 1e4 }, requestIdHeader: { anyOf: [{ type: "boolean" }, { type: "string" }], default: false }, requestIdLogLabel: { type: "string", default: "reqId" }, http2SessionTimeout: { type: "integer", default: 72000 }, exposeHeadRoutes: { type: "boolean", default: true }, useSemicolonDelimiter: { type: "boolean", default: false }, routerOptions: { type: "object", additionalProperties: false, properties: { ignoreTrailingSlash: { type: "boolean", default: false }, ignoreDuplicateSlashes: { type: "boolean", default: false }, maxParamLength: { type: "integer", default: 100 }, allowUnsafeRegex: { type: "boolean", default: false }, useSemicolonDelimiter: { type: "boolean", default: false } } }, constraints: { type: "object", additionalProperties: { type: "object", required: ["name", "storage", "validate", "deriveConstraint"], additionalProperties: true, properties: { name: { type: "string" }, storage: {}, validate: {}, deriveConstraint: {} } } } } };
  var func2 = Object.prototype.hasOwnProperty;
  var pattern0 = new RegExp("idle", "u");
  function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    if (errors === 0) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.connectionTimeout === undefined) {
          data.connectionTimeout = 0;
        }
        if (data.keepAliveTimeout === undefined) {
          data.keepAliveTimeout = 72000;
        }
        if (data.maxRequestsPerSocket === undefined) {
          data.maxRequestsPerSocket = 0;
        }
        if (data.requestTimeout === undefined) {
          data.requestTimeout = 0;
        }
        if (data.bodyLimit === undefined) {
          data.bodyLimit = 1048576;
        }
        if (data.caseSensitive === undefined) {
          data.caseSensitive = true;
        }
        if (data.allowUnsafeRegex === undefined) {
          data.allowUnsafeRegex = false;
        }
        if (data.ignoreTrailingSlash === undefined) {
          data.ignoreTrailingSlash = false;
        }
        if (data.ignoreDuplicateSlashes === undefined) {
          data.ignoreDuplicateSlashes = false;
        }
        if (data.disableRequestLogging === undefined) {
          data.disableRequestLogging = false;
        }
        if (data.maxParamLength === undefined) {
          data.maxParamLength = 100;
        }
        if (data.onProtoPoisoning === undefined) {
          data.onProtoPoisoning = "error";
        }
        if (data.onConstructorPoisoning === undefined) {
          data.onConstructorPoisoning = "error";
        }
        if (data.pluginTimeout === undefined) {
          data.pluginTimeout = 1e4;
        }
        if (data.requestIdHeader === undefined) {
          data.requestIdHeader = false;
        }
        if (data.requestIdLogLabel === undefined) {
          data.requestIdLogLabel = "reqId";
        }
        if (data.http2SessionTimeout === undefined) {
          data.http2SessionTimeout = 72000;
        }
        if (data.exposeHeadRoutes === undefined) {
          data.exposeHeadRoutes = true;
        }
        if (data.useSemicolonDelimiter === undefined) {
          data.useSemicolonDelimiter = false;
        }
        const _errs1 = errors;
        for (const key0 in data) {
          if (!func2.call(schema11.properties, key0)) {
            delete data[key0];
          }
        }
        if (_errs1 === errors) {
          let data0 = data.connectionTimeout;
          const _errs2 = errors;
          if (!(typeof data0 == "number" && (!(data0 % 1) && !isNaN(data0)) && isFinite(data0))) {
            let dataType0 = typeof data0;
            let coerced0 = undefined;
            if (!(coerced0 !== undefined)) {
              if (dataType0 === "boolean" || data0 === null || dataType0 === "string" && data0 && data0 == +data0 && !(data0 % 1)) {
                coerced0 = +data0;
              } else {
                validate10.errors = [{ instancePath: instancePath + "/connectionTimeout", schemaPath: "#/properties/connectionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                return false;
              }
            }
            if (coerced0 !== undefined) {
              data0 = coerced0;
              if (data !== undefined) {
                data["connectionTimeout"] = coerced0;
              }
            }
          }
          var valid0 = _errs2 === errors;
          if (valid0) {
            let data1 = data.keepAliveTimeout;
            const _errs4 = errors;
            if (!(typeof data1 == "number" && (!(data1 % 1) && !isNaN(data1)) && isFinite(data1))) {
              let dataType1 = typeof data1;
              let coerced1 = undefined;
              if (!(coerced1 !== undefined)) {
                if (dataType1 === "boolean" || data1 === null || dataType1 === "string" && data1 && data1 == +data1 && !(data1 % 1)) {
                  coerced1 = +data1;
                } else {
                  validate10.errors = [{ instancePath: instancePath + "/keepAliveTimeout", schemaPath: "#/properties/keepAliveTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                  return false;
                }
              }
              if (coerced1 !== undefined) {
                data1 = coerced1;
                if (data !== undefined) {
                  data["keepAliveTimeout"] = coerced1;
                }
              }
            }
            var valid0 = _errs4 === errors;
            if (valid0) {
              if (data.forceCloseConnections !== undefined) {
                let data2 = data.forceCloseConnections;
                const _errs6 = errors;
                const _errs7 = errors;
                let valid1 = false;
                let passing0 = null;
                const _errs8 = errors;
                if (typeof data2 !== "string") {
                  let dataType2 = typeof data2;
                  let coerced2 = undefined;
                  if (!(coerced2 !== undefined)) {
                    if (dataType2 == "number" || dataType2 == "boolean") {
                      coerced2 = "" + data2;
                    } else if (data2 === null) {
                      coerced2 = "";
                    } else {
                      const err0 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                      if (vErrors === null) {
                        vErrors = [err0];
                      } else {
                        vErrors.push(err0);
                      }
                      errors++;
                    }
                  }
                  if (coerced2 !== undefined) {
                    data2 = coerced2;
                    if (data !== undefined) {
                      data["forceCloseConnections"] = coerced2;
                    }
                  }
                }
                if (errors === _errs8) {
                  if (typeof data2 === "string") {
                    if (!pattern0.test(data2)) {
                      const err1 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/0/pattern", keyword: "pattern", params: { pattern: "idle" }, message: 'must match pattern "' + "idle" + '"' };
                      if (vErrors === null) {
                        vErrors = [err1];
                      } else {
                        vErrors.push(err1);
                      }
                      errors++;
                    }
                  }
                }
                var _valid0 = _errs8 === errors;
                if (_valid0) {
                  valid1 = true;
                  passing0 = 0;
                }
                const _errs10 = errors;
                if (typeof data2 !== "boolean") {
                  let coerced3 = undefined;
                  if (!(coerced3 !== undefined)) {
                    if (data2 === "false" || data2 === 0 || data2 === null) {
                      coerced3 = false;
                    } else if (data2 === "true" || data2 === 1) {
                      coerced3 = true;
                    } else {
                      const err2 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf/1/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                      if (vErrors === null) {
                        vErrors = [err2];
                      } else {
                        vErrors.push(err2);
                      }
                      errors++;
                    }
                  }
                  if (coerced3 !== undefined) {
                    data2 = coerced3;
                    if (data !== undefined) {
                      data["forceCloseConnections"] = coerced3;
                    }
                  }
                }
                var _valid0 = _errs10 === errors;
                if (_valid0 && valid1) {
                  valid1 = false;
                  passing0 = [passing0, 1];
                } else {
                  if (_valid0) {
                    valid1 = true;
                    passing0 = 1;
                  }
                }
                if (!valid1) {
                  const err3 = { instancePath: instancePath + "/forceCloseConnections", schemaPath: "#/properties/forceCloseConnections/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
                  if (vErrors === null) {
                    vErrors = [err3];
                  } else {
                    vErrors.push(err3);
                  }
                  errors++;
                  validate10.errors = vErrors;
                  return false;
                } else {
                  errors = _errs7;
                  if (vErrors !== null) {
                    if (_errs7) {
                      vErrors.length = _errs7;
                    } else {
                      vErrors = null;
                    }
                  }
                }
                var valid0 = _errs6 === errors;
              } else {
                var valid0 = true;
              }
              if (valid0) {
                let data3 = data.maxRequestsPerSocket;
                const _errs12 = errors;
                if (!(typeof data3 == "number" && (!(data3 % 1) && !isNaN(data3)) && isFinite(data3)) && data3 !== null) {
                  let dataType4 = typeof data3;
                  let coerced4 = undefined;
                  if (!(coerced4 !== undefined)) {
                    if (dataType4 === "boolean" || data3 === null || dataType4 === "string" && data3 && data3 == +data3 && !(data3 % 1)) {
                      coerced4 = +data3;
                    } else if (data3 === "" || data3 === 0 || data3 === false) {
                      coerced4 = null;
                    } else {
                      validate10.errors = [{ instancePath: instancePath + "/maxRequestsPerSocket", schemaPath: "#/properties/maxRequestsPerSocket/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                      return false;
                    }
                  }
                  if (coerced4 !== undefined) {
                    data3 = coerced4;
                    if (data !== undefined) {
                      data["maxRequestsPerSocket"] = coerced4;
                    }
                  }
                }
                var valid0 = _errs12 === errors;
                if (valid0) {
                  let data4 = data.requestTimeout;
                  const _errs15 = errors;
                  if (!(typeof data4 == "number" && (!(data4 % 1) && !isNaN(data4)) && isFinite(data4))) {
                    let dataType5 = typeof data4;
                    let coerced5 = undefined;
                    if (!(coerced5 !== undefined)) {
                      if (dataType5 === "boolean" || data4 === null || dataType5 === "string" && data4 && data4 == +data4 && !(data4 % 1)) {
                        coerced5 = +data4;
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/requestTimeout", schemaPath: "#/properties/requestTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                        return false;
                      }
                    }
                    if (coerced5 !== undefined) {
                      data4 = coerced5;
                      if (data !== undefined) {
                        data["requestTimeout"] = coerced5;
                      }
                    }
                  }
                  var valid0 = _errs15 === errors;
                  if (valid0) {
                    let data5 = data.bodyLimit;
                    const _errs17 = errors;
                    if (!(typeof data5 == "number" && (!(data5 % 1) && !isNaN(data5)) && isFinite(data5))) {
                      let dataType6 = typeof data5;
                      let coerced6 = undefined;
                      if (!(coerced6 !== undefined)) {
                        if (dataType6 === "boolean" || data5 === null || dataType6 === "string" && data5 && data5 == +data5 && !(data5 % 1)) {
                          coerced6 = +data5;
                        } else {
                          validate10.errors = [{ instancePath: instancePath + "/bodyLimit", schemaPath: "#/properties/bodyLimit/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                          return false;
                        }
                      }
                      if (coerced6 !== undefined) {
                        data5 = coerced6;
                        if (data !== undefined) {
                          data["bodyLimit"] = coerced6;
                        }
                      }
                    }
                    var valid0 = _errs17 === errors;
                    if (valid0) {
                      let data6 = data.caseSensitive;
                      const _errs19 = errors;
                      if (typeof data6 !== "boolean") {
                        let coerced7 = undefined;
                        if (!(coerced7 !== undefined)) {
                          if (data6 === "false" || data6 === 0 || data6 === null) {
                            coerced7 = false;
                          } else if (data6 === "true" || data6 === 1) {
                            coerced7 = true;
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/caseSensitive", schemaPath: "#/properties/caseSensitive/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                            return false;
                          }
                        }
                        if (coerced7 !== undefined) {
                          data6 = coerced7;
                          if (data !== undefined) {
                            data["caseSensitive"] = coerced7;
                          }
                        }
                      }
                      var valid0 = _errs19 === errors;
                      if (valid0) {
                        let data7 = data.allowUnsafeRegex;
                        const _errs21 = errors;
                        if (typeof data7 !== "boolean") {
                          let coerced8 = undefined;
                          if (!(coerced8 !== undefined)) {
                            if (data7 === "false" || data7 === 0 || data7 === null) {
                              coerced8 = false;
                            } else if (data7 === "true" || data7 === 1) {
                              coerced8 = true;
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/allowUnsafeRegex", schemaPath: "#/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                              return false;
                            }
                          }
                          if (coerced8 !== undefined) {
                            data7 = coerced8;
                            if (data !== undefined) {
                              data["allowUnsafeRegex"] = coerced8;
                            }
                          }
                        }
                        var valid0 = _errs21 === errors;
                        if (valid0) {
                          if (data.http2 !== undefined) {
                            let data8 = data.http2;
                            const _errs23 = errors;
                            if (typeof data8 !== "boolean") {
                              let coerced9 = undefined;
                              if (!(coerced9 !== undefined)) {
                                if (data8 === "false" || data8 === 0 || data8 === null) {
                                  coerced9 = false;
                                } else if (data8 === "true" || data8 === 1) {
                                  coerced9 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/http2", schemaPath: "#/properties/http2/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced9 !== undefined) {
                                data8 = coerced9;
                                if (data !== undefined) {
                                  data["http2"] = coerced9;
                                }
                              }
                            }
                            var valid0 = _errs23 === errors;
                          } else {
                            var valid0 = true;
                          }
                          if (valid0) {
                            if (data.https !== undefined) {
                              let data9 = data.https;
                              const _errs25 = errors;
                              const _errs26 = errors;
                              let valid2 = true;
                              const _errs27 = errors;
                              const _errs28 = errors;
                              const _errs29 = errors;
                              const _errs30 = errors;
                              let valid4 = false;
                              let passing1 = null;
                              const _errs31 = errors;
                              if (typeof data9 !== "boolean") {
                                let coerced10 = undefined;
                                if (!(coerced10 !== undefined)) {
                                  if (data9 === "false" || data9 === 0 || data9 === null) {
                                    coerced10 = false;
                                  } else if (data9 === "true" || data9 === 1) {
                                    coerced10 = true;
                                  } else {
                                    const err4 = {};
                                    if (vErrors === null) {
                                      vErrors = [err4];
                                    } else {
                                      vErrors.push(err4);
                                    }
                                    errors++;
                                  }
                                }
                                if (coerced10 !== undefined) {
                                  data9 = coerced10;
                                  if (data !== undefined) {
                                    data["https"] = coerced10;
                                  }
                                }
                              }
                              var _valid2 = _errs31 === errors;
                              if (_valid2) {
                                valid4 = true;
                                passing1 = 0;
                              }
                              const _errs33 = errors;
                              if (data9 !== null) {
                                let coerced11 = undefined;
                                if (!(coerced11 !== undefined)) {
                                  if (data9 === "" || data9 === 0 || data9 === false) {
                                    coerced11 = null;
                                  } else {
                                    const err5 = {};
                                    if (vErrors === null) {
                                      vErrors = [err5];
                                    } else {
                                      vErrors.push(err5);
                                    }
                                    errors++;
                                  }
                                }
                                if (coerced11 !== undefined) {
                                  data9 = coerced11;
                                  if (data !== undefined) {
                                    data["https"] = coerced11;
                                  }
                                }
                              }
                              var _valid2 = _errs33 === errors;
                              if (_valid2 && valid4) {
                                valid4 = false;
                                passing1 = [passing1, 1];
                              } else {
                                if (_valid2) {
                                  valid4 = true;
                                  passing1 = 1;
                                }
                                const _errs35 = errors;
                                if (errors === _errs35) {
                                  if (data9 && typeof data9 == "object" && !Array.isArray(data9)) {
                                    let missing0;
                                    if (data9.allowHTTP1 === undefined && (missing0 = "allowHTTP1")) {
                                      const err6 = {};
                                      if (vErrors === null) {
                                        vErrors = [err6];
                                      } else {
                                        vErrors.push(err6);
                                      }
                                      errors++;
                                    } else {
                                      const _errs37 = errors;
                                      for (const key1 in data9) {
                                        if (!(key1 === "allowHTTP1")) {
                                          delete data9[key1];
                                        }
                                      }
                                      if (_errs37 === errors) {
                                        if (data9.allowHTTP1 !== undefined) {
                                          let data10 = data9.allowHTTP1;
                                          if (typeof data10 !== "boolean") {
                                            let coerced12 = undefined;
                                            if (!(coerced12 !== undefined)) {
                                              if (data10 === "false" || data10 === 0 || data10 === null) {
                                                coerced12 = false;
                                              } else if (data10 === "true" || data10 === 1) {
                                                coerced12 = true;
                                              } else {
                                                const err7 = {};
                                                if (vErrors === null) {
                                                  vErrors = [err7];
                                                } else {
                                                  vErrors.push(err7);
                                                }
                                                errors++;
                                              }
                                            }
                                            if (coerced12 !== undefined) {
                                              data10 = coerced12;
                                              if (data9 !== undefined) {
                                                data9["allowHTTP1"] = coerced12;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  } else {
                                    const err8 = {};
                                    if (vErrors === null) {
                                      vErrors = [err8];
                                    } else {
                                      vErrors.push(err8);
                                    }
                                    errors++;
                                  }
                                }
                                var _valid2 = _errs35 === errors;
                                if (_valid2 && valid4) {
                                  valid4 = false;
                                  passing1 = [passing1, 2];
                                } else {
                                  if (_valid2) {
                                    valid4 = true;
                                    passing1 = 2;
                                  }
                                }
                              }
                              if (!valid4) {
                                const err9 = {};
                                if (vErrors === null) {
                                  vErrors = [err9];
                                } else {
                                  vErrors.push(err9);
                                }
                                errors++;
                              } else {
                                errors = _errs30;
                                if (vErrors !== null) {
                                  if (_errs30) {
                                    vErrors.length = _errs30;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              }
                              var valid3 = _errs29 === errors;
                              if (valid3) {
                                const err10 = {};
                                if (vErrors === null) {
                                  vErrors = [err10];
                                } else {
                                  vErrors.push(err10);
                                }
                                errors++;
                              } else {
                                errors = _errs28;
                                if (vErrors !== null) {
                                  if (_errs28) {
                                    vErrors.length = _errs28;
                                  } else {
                                    vErrors = null;
                                  }
                                }
                              }
                              var _valid1 = _errs27 === errors;
                              errors = _errs26;
                              if (vErrors !== null) {
                                if (_errs26) {
                                  vErrors.length = _errs26;
                                } else {
                                  vErrors = null;
                                }
                              }
                              if (_valid1) {
                                const _errs40 = errors;
                                data["https"] = true;
                                var _valid1 = _errs40 === errors;
                                valid2 = _valid1;
                              }
                              if (!valid2) {
                                const err11 = { instancePath: instancePath + "/https", schemaPath: "#/properties/https/if", keyword: "if", params: { failingKeyword: "then" }, message: 'must match "then" schema' };
                                if (vErrors === null) {
                                  vErrors = [err11];
                                } else {
                                  vErrors.push(err11);
                                }
                                errors++;
                                validate10.errors = vErrors;
                                return false;
                              }
                              var valid0 = _errs25 === errors;
                            } else {
                              var valid0 = true;
                            }
                            if (valid0) {
                              let data11 = data.ignoreTrailingSlash;
                              const _errs41 = errors;
                              if (typeof data11 !== "boolean") {
                                let coerced13 = undefined;
                                if (!(coerced13 !== undefined)) {
                                  if (data11 === "false" || data11 === 0 || data11 === null) {
                                    coerced13 = false;
                                  } else if (data11 === "true" || data11 === 1) {
                                    coerced13 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/ignoreTrailingSlash", schemaPath: "#/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced13 !== undefined) {
                                  data11 = coerced13;
                                  if (data !== undefined) {
                                    data["ignoreTrailingSlash"] = coerced13;
                                  }
                                }
                              }
                              var valid0 = _errs41 === errors;
                              if (valid0) {
                                let data12 = data.ignoreDuplicateSlashes;
                                const _errs43 = errors;
                                if (typeof data12 !== "boolean") {
                                  let coerced14 = undefined;
                                  if (!(coerced14 !== undefined)) {
                                    if (data12 === "false" || data12 === 0 || data12 === null) {
                                      coerced14 = false;
                                    } else if (data12 === "true" || data12 === 1) {
                                      coerced14 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/ignoreDuplicateSlashes", schemaPath: "#/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced14 !== undefined) {
                                    data12 = coerced14;
                                    if (data !== undefined) {
                                      data["ignoreDuplicateSlashes"] = coerced14;
                                    }
                                  }
                                }
                                var valid0 = _errs43 === errors;
                                if (valid0) {
                                  let data13 = data.disableRequestLogging;
                                  const _errs45 = errors;
                                  if (typeof data13 !== "boolean") {
                                    let coerced15 = undefined;
                                    if (!(coerced15 !== undefined)) {
                                      if (data13 === "false" || data13 === 0 || data13 === null) {
                                        coerced15 = false;
                                      } else if (data13 === "true" || data13 === 1) {
                                        coerced15 = true;
                                      } else {
                                        validate10.errors = [{ instancePath: instancePath + "/disableRequestLogging", schemaPath: "#/properties/disableRequestLogging/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                        return false;
                                      }
                                    }
                                    if (coerced15 !== undefined) {
                                      data13 = coerced15;
                                      if (data !== undefined) {
                                        data["disableRequestLogging"] = coerced15;
                                      }
                                    }
                                  }
                                  var valid0 = _errs45 === errors;
                                  if (valid0) {
                                    let data14 = data.maxParamLength;
                                    const _errs47 = errors;
                                    if (!(typeof data14 == "number" && (!(data14 % 1) && !isNaN(data14)) && isFinite(data14))) {
                                      let dataType16 = typeof data14;
                                      let coerced16 = undefined;
                                      if (!(coerced16 !== undefined)) {
                                        if (dataType16 === "boolean" || data14 === null || dataType16 === "string" && data14 && data14 == +data14 && !(data14 % 1)) {
                                          coerced16 = +data14;
                                        } else {
                                          validate10.errors = [{ instancePath: instancePath + "/maxParamLength", schemaPath: "#/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                          return false;
                                        }
                                      }
                                      if (coerced16 !== undefined) {
                                        data14 = coerced16;
                                        if (data !== undefined) {
                                          data["maxParamLength"] = coerced16;
                                        }
                                      }
                                    }
                                    var valid0 = _errs47 === errors;
                                    if (valid0) {
                                      let data15 = data.onProtoPoisoning;
                                      const _errs49 = errors;
                                      if (typeof data15 !== "string") {
                                        let dataType17 = typeof data15;
                                        let coerced17 = undefined;
                                        if (!(coerced17 !== undefined)) {
                                          if (dataType17 == "number" || dataType17 == "boolean") {
                                            coerced17 = "" + data15;
                                          } else if (data15 === null) {
                                            coerced17 = "";
                                          } else {
                                            validate10.errors = [{ instancePath: instancePath + "/onProtoPoisoning", schemaPath: "#/properties/onProtoPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                            return false;
                                          }
                                        }
                                        if (coerced17 !== undefined) {
                                          data15 = coerced17;
                                          if (data !== undefined) {
                                            data["onProtoPoisoning"] = coerced17;
                                          }
                                        }
                                      }
                                      var valid0 = _errs49 === errors;
                                      if (valid0) {
                                        let data16 = data.onConstructorPoisoning;
                                        const _errs51 = errors;
                                        if (typeof data16 !== "string") {
                                          let dataType18 = typeof data16;
                                          let coerced18 = undefined;
                                          if (!(coerced18 !== undefined)) {
                                            if (dataType18 == "number" || dataType18 == "boolean") {
                                              coerced18 = "" + data16;
                                            } else if (data16 === null) {
                                              coerced18 = "";
                                            } else {
                                              validate10.errors = [{ instancePath: instancePath + "/onConstructorPoisoning", schemaPath: "#/properties/onConstructorPoisoning/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                              return false;
                                            }
                                          }
                                          if (coerced18 !== undefined) {
                                            data16 = coerced18;
                                            if (data !== undefined) {
                                              data["onConstructorPoisoning"] = coerced18;
                                            }
                                          }
                                        }
                                        var valid0 = _errs51 === errors;
                                        if (valid0) {
                                          let data17 = data.pluginTimeout;
                                          const _errs53 = errors;
                                          if (!(typeof data17 == "number" && (!(data17 % 1) && !isNaN(data17)) && isFinite(data17))) {
                                            let dataType19 = typeof data17;
                                            let coerced19 = undefined;
                                            if (!(coerced19 !== undefined)) {
                                              if (dataType19 === "boolean" || data17 === null || dataType19 === "string" && data17 && data17 == +data17 && !(data17 % 1)) {
                                                coerced19 = +data17;
                                              } else {
                                                validate10.errors = [{ instancePath: instancePath + "/pluginTimeout", schemaPath: "#/properties/pluginTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                return false;
                                              }
                                            }
                                            if (coerced19 !== undefined) {
                                              data17 = coerced19;
                                              if (data !== undefined) {
                                                data["pluginTimeout"] = coerced19;
                                              }
                                            }
                                          }
                                          var valid0 = _errs53 === errors;
                                          if (valid0) {
                                            let data18 = data.requestIdHeader;
                                            const _errs55 = errors;
                                            const _errs56 = errors;
                                            let valid6 = false;
                                            const _errs57 = errors;
                                            if (typeof data18 !== "boolean") {
                                              let coerced20 = undefined;
                                              if (!(coerced20 !== undefined)) {
                                                if (data18 === "false" || data18 === 0 || data18 === null) {
                                                  coerced20 = false;
                                                } else if (data18 === "true" || data18 === 1) {
                                                  coerced20 = true;
                                                } else {
                                                  const err12 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/0/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" };
                                                  if (vErrors === null) {
                                                    vErrors = [err12];
                                                  } else {
                                                    vErrors.push(err12);
                                                  }
                                                  errors++;
                                                }
                                              }
                                              if (coerced20 !== undefined) {
                                                data18 = coerced20;
                                                if (data !== undefined) {
                                                  data["requestIdHeader"] = coerced20;
                                                }
                                              }
                                            }
                                            var _valid3 = _errs57 === errors;
                                            valid6 = valid6 || _valid3;
                                            if (!valid6) {
                                              const _errs59 = errors;
                                              if (typeof data18 !== "string") {
                                                let dataType21 = typeof data18;
                                                let coerced21 = undefined;
                                                if (!(coerced21 !== undefined)) {
                                                  if (dataType21 == "number" || dataType21 == "boolean") {
                                                    coerced21 = "" + data18;
                                                  } else if (data18 === null) {
                                                    coerced21 = "";
                                                  } else {
                                                    const err13 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                                                    if (vErrors === null) {
                                                      vErrors = [err13];
                                                    } else {
                                                      vErrors.push(err13);
                                                    }
                                                    errors++;
                                                  }
                                                }
                                                if (coerced21 !== undefined) {
                                                  data18 = coerced21;
                                                  if (data !== undefined) {
                                                    data["requestIdHeader"] = coerced21;
                                                  }
                                                }
                                              }
                                              var _valid3 = _errs59 === errors;
                                              valid6 = valid6 || _valid3;
                                            }
                                            if (!valid6) {
                                              const err14 = { instancePath: instancePath + "/requestIdHeader", schemaPath: "#/properties/requestIdHeader/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                                              if (vErrors === null) {
                                                vErrors = [err14];
                                              } else {
                                                vErrors.push(err14);
                                              }
                                              errors++;
                                              validate10.errors = vErrors;
                                              return false;
                                            } else {
                                              errors = _errs56;
                                              if (vErrors !== null) {
                                                if (_errs56) {
                                                  vErrors.length = _errs56;
                                                } else {
                                                  vErrors = null;
                                                }
                                              }
                                            }
                                            var valid0 = _errs55 === errors;
                                            if (valid0) {
                                              let data19 = data.requestIdLogLabel;
                                              const _errs61 = errors;
                                              if (typeof data19 !== "string") {
                                                let dataType22 = typeof data19;
                                                let coerced22 = undefined;
                                                if (!(coerced22 !== undefined)) {
                                                  if (dataType22 == "number" || dataType22 == "boolean") {
                                                    coerced22 = "" + data19;
                                                  } else if (data19 === null) {
                                                    coerced22 = "";
                                                  } else {
                                                    validate10.errors = [{ instancePath: instancePath + "/requestIdLogLabel", schemaPath: "#/properties/requestIdLogLabel/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                    return false;
                                                  }
                                                }
                                                if (coerced22 !== undefined) {
                                                  data19 = coerced22;
                                                  if (data !== undefined) {
                                                    data["requestIdLogLabel"] = coerced22;
                                                  }
                                                }
                                              }
                                              var valid0 = _errs61 === errors;
                                              if (valid0) {
                                                let data20 = data.http2SessionTimeout;
                                                const _errs63 = errors;
                                                if (!(typeof data20 == "number" && (!(data20 % 1) && !isNaN(data20)) && isFinite(data20))) {
                                                  let dataType23 = typeof data20;
                                                  let coerced23 = undefined;
                                                  if (!(coerced23 !== undefined)) {
                                                    if (dataType23 === "boolean" || data20 === null || dataType23 === "string" && data20 && data20 == +data20 && !(data20 % 1)) {
                                                      coerced23 = +data20;
                                                    } else {
                                                      validate10.errors = [{ instancePath: instancePath + "/http2SessionTimeout", schemaPath: "#/properties/http2SessionTimeout/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                      return false;
                                                    }
                                                  }
                                                  if (coerced23 !== undefined) {
                                                    data20 = coerced23;
                                                    if (data !== undefined) {
                                                      data["http2SessionTimeout"] = coerced23;
                                                    }
                                                  }
                                                }
                                                var valid0 = _errs63 === errors;
                                                if (valid0) {
                                                  let data21 = data.exposeHeadRoutes;
                                                  const _errs65 = errors;
                                                  if (typeof data21 !== "boolean") {
                                                    let coerced24 = undefined;
                                                    if (!(coerced24 !== undefined)) {
                                                      if (data21 === "false" || data21 === 0 || data21 === null) {
                                                        coerced24 = false;
                                                      } else if (data21 === "true" || data21 === 1) {
                                                        coerced24 = true;
                                                      } else {
                                                        validate10.errors = [{ instancePath: instancePath + "/exposeHeadRoutes", schemaPath: "#/properties/exposeHeadRoutes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                        return false;
                                                      }
                                                    }
                                                    if (coerced24 !== undefined) {
                                                      data21 = coerced24;
                                                      if (data !== undefined) {
                                                        data["exposeHeadRoutes"] = coerced24;
                                                      }
                                                    }
                                                  }
                                                  var valid0 = _errs65 === errors;
                                                  if (valid0) {
                                                    let data22 = data.useSemicolonDelimiter;
                                                    const _errs67 = errors;
                                                    if (typeof data22 !== "boolean") {
                                                      let coerced25 = undefined;
                                                      if (!(coerced25 !== undefined)) {
                                                        if (data22 === "false" || data22 === 0 || data22 === null) {
                                                          coerced25 = false;
                                                        } else if (data22 === "true" || data22 === 1) {
                                                          coerced25 = true;
                                                        } else {
                                                          validate10.errors = [{ instancePath: instancePath + "/useSemicolonDelimiter", schemaPath: "#/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                          return false;
                                                        }
                                                      }
                                                      if (coerced25 !== undefined) {
                                                        data22 = coerced25;
                                                        if (data !== undefined) {
                                                          data["useSemicolonDelimiter"] = coerced25;
                                                        }
                                                      }
                                                    }
                                                    var valid0 = _errs67 === errors;
                                                    if (valid0) {
                                                      if (data.routerOptions !== undefined) {
                                                        let data23 = data.routerOptions;
                                                        const _errs69 = errors;
                                                        if (errors === _errs69) {
                                                          if (data23 && typeof data23 == "object" && !Array.isArray(data23)) {
                                                            if (data23.ignoreTrailingSlash === undefined) {
                                                              data23.ignoreTrailingSlash = false;
                                                            }
                                                            if (data23.ignoreDuplicateSlashes === undefined) {
                                                              data23.ignoreDuplicateSlashes = false;
                                                            }
                                                            if (data23.maxParamLength === undefined) {
                                                              data23.maxParamLength = 100;
                                                            }
                                                            if (data23.allowUnsafeRegex === undefined) {
                                                              data23.allowUnsafeRegex = false;
                                                            }
                                                            if (data23.useSemicolonDelimiter === undefined) {
                                                              data23.useSemicolonDelimiter = false;
                                                            }
                                                            const _errs71 = errors;
                                                            for (const key2 in data23) {
                                                              if (!(key2 === "ignoreTrailingSlash" || key2 === "ignoreDuplicateSlashes" || key2 === "maxParamLength" || key2 === "allowUnsafeRegex" || key2 === "useSemicolonDelimiter")) {
                                                                delete data23[key2];
                                                              }
                                                            }
                                                            if (_errs71 === errors) {
                                                              let data24 = data23.ignoreTrailingSlash;
                                                              const _errs72 = errors;
                                                              if (typeof data24 !== "boolean") {
                                                                let coerced26 = undefined;
                                                                if (!(coerced26 !== undefined)) {
                                                                  if (data24 === "false" || data24 === 0 || data24 === null) {
                                                                    coerced26 = false;
                                                                  } else if (data24 === "true" || data24 === 1) {
                                                                    coerced26 = true;
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/routerOptions/ignoreTrailingSlash", schemaPath: "#/properties/routerOptions/properties/ignoreTrailingSlash/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                if (coerced26 !== undefined) {
                                                                  data24 = coerced26;
                                                                  if (data23 !== undefined) {
                                                                    data23["ignoreTrailingSlash"] = coerced26;
                                                                  }
                                                                }
                                                              }
                                                              var valid7 = _errs72 === errors;
                                                              if (valid7) {
                                                                let data25 = data23.ignoreDuplicateSlashes;
                                                                const _errs74 = errors;
                                                                if (typeof data25 !== "boolean") {
                                                                  let coerced27 = undefined;
                                                                  if (!(coerced27 !== undefined)) {
                                                                    if (data25 === "false" || data25 === 0 || data25 === null) {
                                                                      coerced27 = false;
                                                                    } else if (data25 === "true" || data25 === 1) {
                                                                      coerced27 = true;
                                                                    } else {
                                                                      validate10.errors = [{ instancePath: instancePath + "/routerOptions/ignoreDuplicateSlashes", schemaPath: "#/properties/routerOptions/properties/ignoreDuplicateSlashes/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                      return false;
                                                                    }
                                                                  }
                                                                  if (coerced27 !== undefined) {
                                                                    data25 = coerced27;
                                                                    if (data23 !== undefined) {
                                                                      data23["ignoreDuplicateSlashes"] = coerced27;
                                                                    }
                                                                  }
                                                                }
                                                                var valid7 = _errs74 === errors;
                                                                if (valid7) {
                                                                  let data26 = data23.maxParamLength;
                                                                  const _errs76 = errors;
                                                                  if (!(typeof data26 == "number" && (!(data26 % 1) && !isNaN(data26)) && isFinite(data26))) {
                                                                    let dataType28 = typeof data26;
                                                                    let coerced28 = undefined;
                                                                    if (!(coerced28 !== undefined)) {
                                                                      if (dataType28 === "boolean" || data26 === null || dataType28 === "string" && data26 && data26 == +data26 && !(data26 % 1)) {
                                                                        coerced28 = +data26;
                                                                      } else {
                                                                        validate10.errors = [{ instancePath: instancePath + "/routerOptions/maxParamLength", schemaPath: "#/properties/routerOptions/properties/maxParamLength/type", keyword: "type", params: { type: "integer" }, message: "must be integer" }];
                                                                        return false;
                                                                      }
                                                                    }
                                                                    if (coerced28 !== undefined) {
                                                                      data26 = coerced28;
                                                                      if (data23 !== undefined) {
                                                                        data23["maxParamLength"] = coerced28;
                                                                      }
                                                                    }
                                                                  }
                                                                  var valid7 = _errs76 === errors;
                                                                  if (valid7) {
                                                                    let data27 = data23.allowUnsafeRegex;
                                                                    const _errs78 = errors;
                                                                    if (typeof data27 !== "boolean") {
                                                                      let coerced29 = undefined;
                                                                      if (!(coerced29 !== undefined)) {
                                                                        if (data27 === "false" || data27 === 0 || data27 === null) {
                                                                          coerced29 = false;
                                                                        } else if (data27 === "true" || data27 === 1) {
                                                                          coerced29 = true;
                                                                        } else {
                                                                          validate10.errors = [{ instancePath: instancePath + "/routerOptions/allowUnsafeRegex", schemaPath: "#/properties/routerOptions/properties/allowUnsafeRegex/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                          return false;
                                                                        }
                                                                      }
                                                                      if (coerced29 !== undefined) {
                                                                        data27 = coerced29;
                                                                        if (data23 !== undefined) {
                                                                          data23["allowUnsafeRegex"] = coerced29;
                                                                        }
                                                                      }
                                                                    }
                                                                    var valid7 = _errs78 === errors;
                                                                    if (valid7) {
                                                                      let data28 = data23.useSemicolonDelimiter;
                                                                      const _errs80 = errors;
                                                                      if (typeof data28 !== "boolean") {
                                                                        let coerced30 = undefined;
                                                                        if (!(coerced30 !== undefined)) {
                                                                          if (data28 === "false" || data28 === 0 || data28 === null) {
                                                                            coerced30 = false;
                                                                          } else if (data28 === "true" || data28 === 1) {
                                                                            coerced30 = true;
                                                                          } else {
                                                                            validate10.errors = [{ instancePath: instancePath + "/routerOptions/useSemicolonDelimiter", schemaPath: "#/properties/routerOptions/properties/useSemicolonDelimiter/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                                                            return false;
                                                                          }
                                                                        }
                                                                        if (coerced30 !== undefined) {
                                                                          data28 = coerced30;
                                                                          if (data23 !== undefined) {
                                                                            data23["useSemicolonDelimiter"] = coerced30;
                                                                          }
                                                                        }
                                                                      }
                                                                      var valid7 = _errs80 === errors;
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          } else {
                                                            validate10.errors = [{ instancePath: instancePath + "/routerOptions", schemaPath: "#/properties/routerOptions/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                            return false;
                                                          }
                                                        }
                                                        var valid0 = _errs69 === errors;
                                                      } else {
                                                        var valid0 = true;
                                                      }
                                                      if (valid0) {
                                                        if (data.constraints !== undefined) {
                                                          let data29 = data.constraints;
                                                          const _errs82 = errors;
                                                          if (errors === _errs82) {
                                                            if (data29 && typeof data29 == "object" && !Array.isArray(data29)) {
                                                              for (const key3 in data29) {
                                                                let data30 = data29[key3];
                                                                const _errs85 = errors;
                                                                if (errors === _errs85) {
                                                                  if (data30 && typeof data30 == "object" && !Array.isArray(data30)) {
                                                                    let missing1;
                                                                    if (data30.name === undefined && (missing1 = "name") || data30.storage === undefined && (missing1 = "storage") || data30.validate === undefined && (missing1 = "validate") || data30.deriveConstraint === undefined && (missing1 = "deriveConstraint")) {
                                                                      validate10.errors = [{ instancePath: instancePath + "/constraints/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" }];
                                                                      return false;
                                                                    } else {
                                                                      if (data30.name !== undefined) {
                                                                        let data31 = data30.name;
                                                                        if (typeof data31 !== "string") {
                                                                          let dataType31 = typeof data31;
                                                                          let coerced31 = undefined;
                                                                          if (!(coerced31 !== undefined)) {
                                                                            if (dataType31 == "number" || dataType31 == "boolean") {
                                                                              coerced31 = "" + data31;
                                                                            } else if (data31 === null) {
                                                                              coerced31 = "";
                                                                            } else {
                                                                              validate10.errors = [{ instancePath: instancePath + "/constraints/" + key3.replace(/~/g, "~0").replace(/\//g, "~1") + "/name", schemaPath: "#/properties/constraints/additionalProperties/properties/name/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                                                              return false;
                                                                            }
                                                                          }
                                                                          if (coerced31 !== undefined) {
                                                                            data31 = coerced31;
                                                                            if (data30 !== undefined) {
                                                                              data30["name"] = coerced31;
                                                                            }
                                                                          }
                                                                        }
                                                                      }
                                                                    }
                                                                  } else {
                                                                    validate10.errors = [{ instancePath: instancePath + "/constraints/" + key3.replace(/~/g, "~0").replace(/\//g, "~1"), schemaPath: "#/properties/constraints/additionalProperties/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                                    return false;
                                                                  }
                                                                }
                                                                var valid8 = _errs85 === errors;
                                                                if (!valid8) {
                                                                  break;
                                                                }
                                                              }
                                                            } else {
                                                              validate10.errors = [{ instancePath: instancePath + "/constraints", schemaPath: "#/properties/constraints/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                                                              return false;
                                                            }
                                                          }
                                                          var valid0 = _errs82 === errors;
                                                        } else {
                                                          var valid0 = true;
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
        return false;
      }
    }
    validate10.errors = vErrors;
    return errors === 0;
  }
  module.exports.defaultInitOptions = { connectionTimeout: 0, keepAliveTimeout: 72000, maxRequestsPerSocket: 0, requestTimeout: 0, bodyLimit: 1048576, caseSensitive: true, allowUnsafeRegex: false, disableRequestLogging: false, ignoreTrailingSlash: false, ignoreDuplicateSlashes: false, maxParamLength: 100, onProtoPoisoning: "error", onConstructorPoisoning: "error", pluginTimeout: 1e4, requestIdHeader: false, requestIdLogLabel: "reqId", http2SessionTimeout: 72000, exposeHeadRoutes: true, useSemicolonDelimiter: false, allowErrorHandlerOverride: true, routerOptions: { ignoreTrailingSlash: false, ignoreDuplicateSlashes: false, maxParamLength: 100, allowUnsafeRegex: false, useSemicolonDelimiter: false } };
});

// node_modules/fastify/lib/initialConfigValidation.js
var require_initialConfigValidation = __commonJS((exports, module) => {
  var validate = require_configValidator();
  var deepClone = require_rfdc()({ circles: true, proto: false });
  var { FST_ERR_INIT_OPTS_INVALID } = require_errors2();
  function validateInitialConfig(options) {
    const opts = deepClone(options);
    if (!validate(opts)) {
      const error = new FST_ERR_INIT_OPTS_INVALID(JSON.stringify(validate.errors.map((e) => e.message)));
      error.errors = validate.errors;
      throw error;
    }
    return deepFreezeObject(opts);
  }
  function deepFreezeObject(object) {
    const properties = Object.getOwnPropertyNames(object);
    for (const name of properties) {
      const value = object[name];
      if (ArrayBuffer.isView(value) && !(value instanceof DataView)) {
        continue;
      }
      object[name] = value && typeof value === "object" ? deepFreezeObject(value) : value;
    }
    return Object.freeze(object);
  }
  module.exports = validateInitialConfig;
  module.exports.defaultInitOptions = validate.defaultInitOptions;
  module.exports.utils = { deepFreezeObject };
});

// node_modules/fastify/lib/pluginOverride.js
var require_pluginOverride = __commonJS((exports, module) => {
  var {
    kAvvioBoot,
    kChildren,
    kRoutePrefix,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kContentTypeParser,
    kReply,
    kRequest,
    kFourOhFour,
    kPluginNameChain,
    kErrorHandlerAlreadySet
  } = require_symbols2();
  var Reply = require_reply();
  var Request = require_request();
  var SchemaController = require_schema_controller();
  var ContentTypeParser = require_contentTypeParser();
  var { buildHooks } = require_hooks();
  var pluginUtils = require_pluginUtils();
  module.exports = function override(old, fn, opts) {
    const shouldSkipOverride = pluginUtils.registerPlugin.call(old, fn);
    const fnName = pluginUtils.getPluginName(fn) || pluginUtils.getFuncPreview(fn);
    if (shouldSkipOverride) {
      old[kPluginNameChain].push(fnName);
      return old;
    }
    const instance = Object.create(old);
    old[kChildren].push(instance);
    instance.ready = old[kAvvioBoot].bind(instance);
    instance[kChildren] = [];
    instance[kReply] = Reply.buildReply(instance[kReply]);
    instance[kRequest] = Request.buildRequest(instance[kRequest]);
    instance[kContentTypeParser] = ContentTypeParser.helpers.buildContentTypeParser(instance[kContentTypeParser]);
    instance[kHooks] = buildHooks(instance[kHooks]);
    instance[kRoutePrefix] = buildRoutePrefix(instance[kRoutePrefix], opts.prefix);
    instance[kLogLevel] = opts.logLevel || instance[kLogLevel];
    instance[kSchemaController] = SchemaController.buildSchemaController(old[kSchemaController]);
    instance.getSchema = instance[kSchemaController].getSchema.bind(instance[kSchemaController]);
    instance.getSchemas = instance[kSchemaController].getSchemas.bind(instance[kSchemaController]);
    instance[pluginUtils.kRegisteredPlugins] = Object.create(instance[pluginUtils.kRegisteredPlugins]);
    instance[kPluginNameChain] = [fnName];
    instance[kErrorHandlerAlreadySet] = false;
    if (instance[kLogSerializers] || opts.logSerializers) {
      instance[kLogSerializers] = Object.assign(Object.create(instance[kLogSerializers]), opts.logSerializers);
    }
    if (opts.prefix) {
      instance[kFourOhFour].arrange404(instance);
    }
    for (const hook of instance[kHooks].onRegister)
      hook.call(old, instance, opts);
    return instance;
  };
  function buildRoutePrefix(instancePrefix, pluginPrefix) {
    if (!pluginPrefix) {
      return instancePrefix;
    }
    if (instancePrefix.endsWith("/") && pluginPrefix[0] === "/") {
      pluginPrefix = pluginPrefix.slice(1);
    } else if (pluginPrefix[0] !== "/") {
      pluginPrefix = "/" + pluginPrefix;
    }
    return instancePrefix + pluginPrefix;
  }
});

// node_modules/fastify/lib/noop-set.js
var require_noop_set = __commonJS((exports, module) => {
  module.exports = function noopSet() {
    return {
      [Symbol.iterator]: function* () {},
      add() {},
      delete() {},
      has() {
        return true;
      }
    };
  };
});

// node_modules/cookie/dist/index.js
var require_dist4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
  var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
  var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
  var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
  var __toString = Object.prototype.toString;
  var NullObject = /* @__PURE__ */ (() => {
    const C3 = function() {};
    C3.prototype = Object.create(null);
    return C3;
  })();
  function parse(str, options) {
    const obj = new NullObject;
    const len = str.length;
    if (len < 2)
      return obj;
    const dec = options?.decode || decode;
    let index = 0;
    do {
      const eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      const colonIdx = str.indexOf(";", index);
      const endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      const keyStartIdx = startIndex(str, index, eqIdx);
      const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
      const key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
        let valEndIdx = endIndex(str, endIdx, valStartIdx);
        const value = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      const code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      const code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    const enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name)) {
      throw new TypeError(`argument name is invalid: ${name}`);
    }
    const value = enc(val);
    if (!cookieValueRegExp.test(value)) {
      throw new TypeError(`argument val is invalid: ${val}`);
    }
    let str = name + "=" + value;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge)) {
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      }
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain)) {
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      }
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path)) {
        throw new TypeError(`option path is invalid: ${options.path}`);
      }
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf())) {
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      }
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly) {
      str += "; HttpOnly";
    }
    if (options.secure) {
      str += "; Secure";
    }
    if (options.partitioned) {
      str += "; Partitioned";
    }
    if (options.priority) {
      const priority = typeof options.priority === "string" ? options.priority.toLowerCase() : undefined;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    }
    if (options.sameSite) {
      const sameSite = typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite;
      switch (sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    }
    return str;
  }
  function decode(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});

// node_modules/light-my-request/node_modules/process-warning/index.js
var require_process_warning2 = __commonJS((exports, module) => {
  var { format } = (init_util(), __toCommonJS(exports_util));
  function createDeprecation(params) {
    return createWarning({ ...params, name: "DeprecationWarning" });
  }
  function createWarning({ name, code, message, unlimited = false } = {}) {
    if (!name)
      throw new Error("Warning name must not be empty");
    if (!code)
      throw new Error("Warning code must not be empty");
    if (!message)
      throw new Error("Warning message must not be empty");
    if (typeof unlimited !== "boolean")
      throw new Error("Warning opts.unlimited must be a boolean");
    code = code.toUpperCase();
    let warningContainer = {
      [name]: function(a3, b5, c2) {
        if (warning.emitted === true && warning.unlimited !== true) {
          return;
        }
        warning.emitted = true;
        process.emitWarning(warning.format(a3, b5, c2), warning.name, warning.code);
      }
    };
    if (unlimited) {
      warningContainer = {
        [name]: function(a3, b5, c2) {
          warning.emitted = true;
          process.emitWarning(warning.format(a3, b5, c2), warning.name, warning.code);
        }
      };
    }
    const warning = warningContainer[name];
    warning.emitted = false;
    warning.message = message;
    warning.unlimited = unlimited;
    warning.code = code;
    warning.format = function(a3, b5, c2) {
      let formatted;
      if (a3 && b5 && c2) {
        formatted = format(message, a3, b5, c2);
      } else if (a3 && b5) {
        formatted = format(message, a3, b5);
      } else if (a3) {
        formatted = format(message, a3);
      } else {
        formatted = message;
      }
      return formatted;
    };
    return warning;
  }
  var out = { createWarning, createDeprecation };
  module.exports = out;
  module.exports.default = out;
  module.exports.processWarning = out;
});

// node:url
var exports_url = {};
__export(exports_url, {
  resolveObject: () => at,
  resolve: () => rt3,
  parse: () => I3,
  format: () => et3,
  default: () => ot,
  Url: () => m3,
  URLSearchParams: () => X2,
  URL: () => J2
});
function F2(s2) {
  return typeof s2 == "string";
}
function K3(s2) {
  return typeof s2 == "object" && s2 !== null;
}
function w2(s2) {
  return s2 === null;
}
function Y2(s2) {
  return s2 == null;
}
function m3() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
function I3(s2, r, t) {
  if (s2 && K3(s2) && s2 instanceof m3)
    return s2;
  var a3 = new m3;
  return a3.parse(s2, r, t), a3;
}
function et3(s2) {
  return F2(s2) && (s2 = I3(s2)), s2 instanceof m3 ? s2.format() : m3.prototype.format.call(s2);
}
function rt3(s2, r) {
  return I3(s2, false, true).resolve(r);
}
function at(s2, r) {
  return s2 ? I3(s2, false, true).resolveObject(r) : r;
}
var J2, X2, S, k3, H2, Q3, E5, N4, M3, D, tt3 = 255, G, st2, ht, Z, j3, B2, ot;
var init_url = __esm(() => {
  ({ URL: J2, URLSearchParams: X2 } = globalThis);
  S = /^([a-z0-9.+-]+:)/i;
  k3 = /:[0-9]*$/;
  H2 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  Q3 = ["<", ">", '"', "`", " ", "\r", `
`, "\t"];
  E5 = ["{", "}", "|", "\\", "^", "`"].concat(Q3);
  N4 = ["'"].concat(E5);
  M3 = ["%", "/", "?", ";", "#"].concat(N4);
  D = ["/", "?", "#"];
  G = /^[+a-z0-9A-Z_-]{0,63}$/;
  st2 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  ht = { javascript: true, "javascript:": true };
  Z = { javascript: true, "javascript:": true };
  j3 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
  B2 = { parse(s2) {
    var r = decodeURIComponent;
    return (s2 + "").replace(/\+/g, " ").split("&").filter(Boolean).reduce(function(t, a3, o2) {
      var l3 = a3.split("="), f2 = r(l3[0] || ""), h3 = r(l3[1] || ""), g3 = t[f2];
      return t[f2] = g3 === undefined ? h3 : [].concat(g3, h3), t;
    }, {});
  }, stringify(s2) {
    var r = encodeURIComponent;
    return Object.keys(s2 || {}).reduce(function(t, a3) {
      return [].concat(s2[a3]).forEach(function(o2) {
        t.push(r(a3) + "=" + r(o2));
      }), t;
    }, []).join("&").replace(/\s/g, "+");
  } };
  m3.prototype.parse = function(s2, r, t) {
    if (!F2(s2))
      throw new TypeError("Parameter 'url' must be a string, not " + typeof s2);
    var a3 = s2.indexOf("?"), o2 = a3 !== -1 && a3 < s2.indexOf("#") ? "?" : "#", l3 = s2.split(o2), f2 = /\\/g;
    l3[0] = l3[0].replace(f2, "/"), s2 = l3.join(o2);
    var h3 = s2;
    if (h3 = h3.trim(), !t && s2.split("#").length === 1) {
      var g3 = H2.exec(h3);
      if (g3)
        return this.path = h3, this.href = h3, this.pathname = g3[1], g3[2] ? (this.search = g3[2], r ? this.query = B2.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : r && (this.search = "", this.query = {}), this;
    }
    var c2 = S.exec(h3);
    if (c2) {
      c2 = c2[0];
      var v2 = c2.toLowerCase();
      this.protocol = v2, h3 = h3.substr(c2.length);
    }
    if (t || c2 || h3.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var U2 = h3.substr(0, 2) === "//";
      U2 && !(c2 && Z[c2]) && (h3 = h3.substr(2), this.slashes = true);
    }
    if (!Z[c2] && (U2 || c2 && !j3[c2])) {
      for (var u2 = -1, n = 0;n < D.length; n++) {
        var b5 = h3.indexOf(D[n]);
        b5 !== -1 && (u2 === -1 || b5 < u2) && (u2 = b5);
      }
      var R2, p3;
      u2 === -1 ? p3 = h3.lastIndexOf("@") : p3 = h3.lastIndexOf("@", u2), p3 !== -1 && (R2 = h3.slice(0, p3), h3 = h3.slice(p3 + 1), this.auth = decodeURIComponent(R2)), u2 = -1;
      for (var n = 0;n < M3.length; n++) {
        var b5 = h3.indexOf(M3[n]);
        b5 !== -1 && (u2 === -1 || b5 < u2) && (u2 = b5);
      }
      u2 === -1 && (u2 = h3.length), this.host = h3.slice(0, u2), h3 = h3.slice(u2), this.parseHost(), this.hostname = this.hostname || "";
      var C3 = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!C3)
        for (var e = this.hostname.split(/\./), n = 0, i = e.length;n < i; n++) {
          var O2 = e[n];
          if (!!O2 && !O2.match(G)) {
            for (var y3 = "", d3 = 0, L3 = O2.length;d3 < L3; d3++)
              O2.charCodeAt(d3) > 127 ? y3 += "x" : y3 += O2[d3];
            if (!y3.match(G)) {
              var x3 = e.slice(0, n), q = e.slice(n + 1), A3 = O2.match(st2);
              A3 && (x3.push(A3[1]), q.unshift(A3[2])), q.length && (h3 = "/" + q.join(".") + h3), this.hostname = x3.join(".");
              break;
            }
          }
        }
      this.hostname.length > tt3 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), C3 || (this.hostname = new J2(`https://${this.hostname}`).hostname);
      var $ = this.port ? ":" + this.port : "", V4 = this.hostname || "";
      this.host = V4 + $, this.href += this.host, C3 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), h3[0] !== "/" && (h3 = "/" + h3));
    }
    if (!ht[v2])
      for (var n = 0, i = N4.length;n < i; n++) {
        var P2 = N4[n];
        if (h3.indexOf(P2) !== -1) {
          var z = encodeURIComponent(P2);
          z === P2 && (z = escape(P2)), h3 = h3.split(P2).join(z);
        }
      }
    var T = h3.indexOf("#");
    T !== -1 && (this.hash = h3.substr(T), h3 = h3.slice(0, T));
    var _3 = h3.indexOf("?");
    if (_3 !== -1 ? (this.search = h3.substr(_3), this.query = h3.substr(_3 + 1), r && (this.query = B2.parse(this.query)), h3 = h3.slice(0, _3)) : r && (this.search = "", this.query = {}), h3 && (this.pathname = h3), j3[v2] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      var $ = this.pathname || "", W = this.search || "";
      this.path = $ + W;
    }
    return this.href = this.format(), this;
  };
  m3.prototype.format = function() {
    var s2 = this.auth || "";
    s2 && (s2 = encodeURIComponent(s2), s2 = s2.replace(/%3A/i, ":"), s2 += "@");
    var r = this.protocol || "", t = this.pathname || "", a3 = this.hash || "", o2 = false, l3 = "";
    this.host ? o2 = s2 + this.host : this.hostname && (o2 = s2 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (o2 += ":" + this.port)), this.query && K3(this.query) && Object.keys(this.query).length && (l3 = B2.stringify(this.query));
    var f2 = this.search || l3 && "?" + l3 || "";
    return r && r.substr(-1) !== ":" && (r += ":"), this.slashes || (!r || j3[r]) && o2 !== false ? (o2 = "//" + (o2 || ""), t && t.charAt(0) !== "/" && (t = "/" + t)) : o2 || (o2 = ""), a3 && a3.charAt(0) !== "#" && (a3 = "#" + a3), f2 && f2.charAt(0) !== "?" && (f2 = "?" + f2), t = t.replace(/[?#]/g, function(h3) {
      return encodeURIComponent(h3);
    }), f2 = f2.replace("#", "%23"), r + o2 + t + f2 + a3;
  };
  m3.prototype.resolve = function(s2) {
    return this.resolveObject(I3(s2, false, true)).format();
  };
  m3.prototype.resolveObject = function(s2) {
    if (F2(s2)) {
      var r = new m3;
      r.parse(s2, false, true), s2 = r;
    }
    for (var t = new m3, a3 = Object.keys(this), o2 = 0;o2 < a3.length; o2++) {
      var l3 = a3[o2];
      t[l3] = this[l3];
    }
    if (t.hash = s2.hash, s2.href === "")
      return t.href = t.format(), t;
    if (s2.slashes && !s2.protocol) {
      for (var f2 = Object.keys(s2), h3 = 0;h3 < f2.length; h3++) {
        var g3 = f2[h3];
        g3 !== "protocol" && (t[g3] = s2[g3]);
      }
      return j3[t.protocol] && t.hostname && !t.pathname && (t.path = t.pathname = "/"), t.href = t.format(), t;
    }
    if (s2.protocol && s2.protocol !== t.protocol) {
      if (!j3[s2.protocol]) {
        for (var c2 = Object.keys(s2), v2 = 0;v2 < c2.length; v2++) {
          var U2 = c2[v2];
          t[U2] = s2[U2];
        }
        return t.href = t.format(), t;
      }
      if (t.protocol = s2.protocol, !s2.host && !Z[s2.protocol]) {
        for (var i = (s2.pathname || "").split("/");i.length && !(s2.host = i.shift()); )
          ;
        s2.host || (s2.host = ""), s2.hostname || (s2.hostname = ""), i[0] !== "" && i.unshift(""), i.length < 2 && i.unshift(""), t.pathname = i.join("/");
      } else
        t.pathname = s2.pathname;
      if (t.search = s2.search, t.query = s2.query, t.host = s2.host || "", t.auth = s2.auth, t.hostname = s2.hostname || s2.host, t.port = s2.port, t.pathname || t.search) {
        var u2 = t.pathname || "", n = t.search || "";
        t.path = u2 + n;
      }
      return t.slashes = t.slashes || s2.slashes, t.href = t.format(), t;
    }
    var b5 = t.pathname && t.pathname.charAt(0) === "/", R2 = s2.host || s2.pathname && s2.pathname.charAt(0) === "/", p3 = R2 || b5 || t.host && s2.pathname, C3 = p3, e = t.pathname && t.pathname.split("/") || [], i = s2.pathname && s2.pathname.split("/") || [], O2 = t.protocol && !j3[t.protocol];
    if (O2 && (t.hostname = "", t.port = null, t.host && (e[0] === "" ? e[0] = t.host : e.unshift(t.host)), t.host = "", s2.protocol && (s2.hostname = null, s2.port = null, s2.host && (i[0] === "" ? i[0] = s2.host : i.unshift(s2.host)), s2.host = null), p3 = p3 && (i[0] === "" || e[0] === "")), R2)
      t.host = s2.host || s2.host === "" ? s2.host : t.host, t.hostname = s2.hostname || s2.hostname === "" ? s2.hostname : t.hostname, t.search = s2.search, t.query = s2.query, e = i;
    else if (i.length)
      e || (e = []), e.pop(), e = e.concat(i), t.search = s2.search, t.query = s2.query;
    else if (!Y2(s2.search)) {
      if (O2) {
        t.hostname = t.host = e.shift();
        var y3 = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : false;
        y3 && (t.auth = y3.shift(), t.host = t.hostname = y3.shift());
      }
      return t.search = s2.search, t.query = s2.query, (!w2(t.pathname) || !w2(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.href = t.format(), t;
    }
    if (!e.length)
      return t.pathname = null, t.search ? t.path = "/" + t.search : t.path = null, t.href = t.format(), t;
    for (var d3 = e.slice(-1)[0], L3 = (t.host || s2.host || e.length > 1) && (d3 === "." || d3 === "..") || d3 === "", x3 = 0, q = e.length;q >= 0; q--)
      d3 = e[q], d3 === "." ? e.splice(q, 1) : d3 === ".." ? (e.splice(q, 1), x3++) : x3 && (e.splice(q, 1), x3--);
    if (!p3 && !C3)
      for (;x3--; x3)
        e.unshift("..");
    p3 && e[0] !== "" && (!e[0] || e[0].charAt(0) !== "/") && e.unshift(""), L3 && e.join("/").substr(-1) !== "/" && e.push("");
    var A3 = e[0] === "" || e[0] && e[0].charAt(0) === "/";
    if (O2) {
      t.hostname = t.host = A3 ? "" : e.length ? e.shift() : "";
      var y3 = t.host && t.host.indexOf("@") > 0 ? t.host.split("@") : false;
      y3 && (t.auth = y3.shift(), t.host = t.hostname = y3.shift());
    }
    return p3 = p3 || t.host && e.length, p3 && !A3 && e.unshift(""), e.length ? t.pathname = e.join("/") : (t.pathname = null, t.path = null), (!w2(t.pathname) || !w2(t.search)) && (t.path = (t.pathname ? t.pathname : "") + (t.search ? t.search : "")), t.auth = s2.auth || t.auth, t.slashes = t.slashes || s2.slashes, t.href = t.format(), t;
  };
  m3.prototype.parseHost = function() {
    var s2 = this.host, r = k3.exec(s2);
    r && (r = r[0], r !== ":" && (this.port = r.substr(1)), s2 = s2.substr(0, s2.length - r.length)), s2 && (this.hostname = s2);
  };
  ot = { parse: I3, resolve: rt3, resolveObject: at, format: et3, Url: m3, URL: J2, URLSearchParams: X2 };
});

// node_modules/light-my-request/lib/parse-url.js
var require_parse_url = __commonJS((exports, module) => {
  var { URL: URL2 } = (init_url(), __toCommonJS(exports_url));
  var BASE_URL = "http://localhost";
  module.exports = function parseURL(url, query) {
    if ((typeof url === "string" || Object.prototype.toString.call(url) === "[object String]") && url.startsWith("//")) {
      url = BASE_URL + url;
    }
    const result = typeof url === "object" ? Object.assign(new URL2(BASE_URL), url) : new URL2(url, BASE_URL);
    if (typeof query === "string") {
      query = new URLSearchParams(query);
      for (const key of query.keys()) {
        result.searchParams.delete(key);
        for (const value of query.getAll(key)) {
          result.searchParams.append(key, value);
        }
      }
    } else {
      const merged = Object.assign({}, url.query, query);
      for (const key in merged) {
        const value = merged[key];
        if (Array.isArray(value)) {
          result.searchParams.delete(key);
          for (const param of value) {
            result.searchParams.append(key, param);
          }
        } else {
          result.searchParams.set(key, value);
        }
      }
    }
    return result;
  };
});

// node:crypto
var exports_crypto = {};
__export(exports_crypto, {
  webcrypto: () => cw,
  timingSafeEqual: () => x0,
  scryptSync: () => Id,
  scrypt: () => Td,
  randomUUID: () => lw,
  getRandomValues: () => uw,
  getCurves: () => dw,
  default: () => Wq,
  DEFAULT_ENCODING: () => Ga
});
function dw() {
  return Hq;
}
var pw, Xa, vw, bw, mw, gw, R0 = (t, e) => () => (t && (e = t(t = 0)), e), T = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), Ja = (t, e) => {
  for (var r in e)
    Xa(t, r, { get: e[r], enumerable: true });
}, Ya = (t, e, r, o2) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let f2 of bw(e))
      !gw.call(t, f2) && f2 !== r && Xa(t, f2, { get: () => e[f2], enumerable: !(o2 = vw(e, f2)) || o2.enumerable });
  return t;
}, ot2 = (t, e, r) => (Ya(t, e, "default"), r && Ya(r, e, "default")), rn2 = (t, e, r) => (r = t != null ? pw(mw(t)) : {}, Ya(e || !t || !t.__esModule ? Xa(r, "default", { value: t, enumerable: true }) : r, t)), ur2 = (t) => Ya(Xa({}, "__esModule", { value: true }), t), Nd, Dd, Ut2, Te, on, Ie, ki, W0, $f, pc, Z0, sn, V0, G0, J0, hn, co, Jf, po, Qf, vo, Pc, Oc, th, ph, Qc, np, ap, bh, Ao, Bo, pn2, _p, Ep, gh, qp, yh, Op, ko, Tt3, Gr2, No, Jt, pa, Rh, pr2, Y_, Oi, Fi, Ui, k1, yn, Vo, Go, Z1, Xo, Fh, ba, Jh, Dv, Qr2, fu2, ou2, os, eb, cu2, lb, bu, vf, S7, db, yi2, bf, wb, mu, wu, Mu, Eb, _u, xu, Eu, Au, Ub, Iu, Tu, ar2, vs, ku, Yb, Qb, em, im, nm, yf, om, um, dm, pm, bm, Pu, Ou, Fu, ws, Aa, Em, Wu, ju, Ba, Dm, Fm, Es, Hm, Vm, ji2, Yu, Ym, Xm, As, tl, ol, rg, ag, hg, hl2, pg, dl2, kn, cl2, bl, Ln2, Ds, Lg, Dg, yl2, Il, Yg, t2, i2, Ws2, Ks2, s2, ri2, Nl, or, Oa, b22, y22, _22, Pl, Cr3, Tf, Cl, N22, Fl, F22, Wl, Z2, V22, Q22, ty, e0, ny, t0, uy, dy, vy, yy, xy, Ey, Iy, o0, td, h0, u0, Kf, d0, c0, nd, Hy, od, hd, Jy, dd, r3, n3, o3, cd, d3, p3, v3, m32, Ha, bd, _3, A3, k32, N32, P3, _d, xd, w0, Ed, j32, Y3, X3, ow, qd, Xt2, zq, Ga = "buffer", uw = (t) => crypto.getRandomValues(t), lw = () => crypto.randomUUID(), Hq, x0, Id, Td, cw, Wq;
var init_crypto = __esm(() => {
  pw = Object.create;
  Xa = Object.defineProperty;
  vw = Object.getOwnPropertyDescriptor;
  bw = Object.getOwnPropertyNames;
  mw = Object.getPrototypeOf;
  gw = Object.prototype.hasOwnProperty;
  Nd = T((Qa) => {
    Qa.byteLength = ww;
    Qa.toByteArray = _w;
    Qa.fromByteArray = Ew;
    var jr = [], lr = [], yw = typeof Uint8Array < "u" ? Uint8Array : Array, B0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (nn = 0, kd = B0.length;nn < kd; ++nn)
      jr[nn] = B0[nn], lr[B0.charCodeAt(nn)] = nn;
    var nn, kd;
    lr[45] = 62;
    lr[95] = 63;
    function Ld(t) {
      var e = t.length;
      if (e % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var r = t.indexOf("=");
      r === -1 && (r = e);
      var o2 = r === e ? 0 : 4 - r % 4;
      return [r, o2];
    }
    function ww(t) {
      var e = Ld(t), r = e[0], o2 = e[1];
      return (r + o2) * 3 / 4 - o2;
    }
    function Mw(t, e, r) {
      return (e + r) * 3 / 4 - r;
    }
    function _w(t) {
      var e, r = Ld(t), o2 = r[0], f2 = r[1], p3 = new yw(Mw(t, o2, f2)), m4 = 0, y3 = f2 > 0 ? o2 - 4 : o2, M4;
      for (M4 = 0;M4 < y3; M4 += 4)
        e = lr[t.charCodeAt(M4)] << 18 | lr[t.charCodeAt(M4 + 1)] << 12 | lr[t.charCodeAt(M4 + 2)] << 6 | lr[t.charCodeAt(M4 + 3)], p3[m4++] = e >> 16 & 255, p3[m4++] = e >> 8 & 255, p3[m4++] = e & 255;
      return f2 === 2 && (e = lr[t.charCodeAt(M4)] << 2 | lr[t.charCodeAt(M4 + 1)] >> 4, p3[m4++] = e & 255), f2 === 1 && (e = lr[t.charCodeAt(M4)] << 10 | lr[t.charCodeAt(M4 + 1)] << 4 | lr[t.charCodeAt(M4 + 2)] >> 2, p3[m4++] = e >> 8 & 255, p3[m4++] = e & 255), p3;
    }
    function xw(t) {
      return jr[t >> 18 & 63] + jr[t >> 12 & 63] + jr[t >> 6 & 63] + jr[t & 63];
    }
    function Sw(t, e, r) {
      for (var o2, f2 = [], p3 = e;p3 < r; p3 += 3)
        o2 = (t[p3] << 16 & 16711680) + (t[p3 + 1] << 8 & 65280) + (t[p3 + 2] & 255), f2.push(xw(o2));
      return f2.join("");
    }
    function Ew(t) {
      for (var e, r = t.length, o2 = r % 3, f2 = [], p3 = 16383, m4 = 0, y3 = r - o2;m4 < y3; m4 += p3)
        f2.push(Sw(t, m4, m4 + p3 > y3 ? y3 : m4 + p3));
      return o2 === 1 ? (e = t[r - 1], f2.push(jr[e >> 2] + jr[e << 4 & 63] + "==")) : o2 === 2 && (e = (t[r - 2] << 8) + t[r - 1], f2.push(jr[e >> 10] + jr[e >> 4 & 63] + jr[e << 2 & 63] + "=")), f2.join("");
    }
  });
  Dd = T((q0) => {
    q0.read = function(t, e, r, o2, f2) {
      var p3, m4, y3 = f2 * 8 - o2 - 1, M4 = (1 << y3) - 1, x3 = M4 >> 1, S2 = -7, E6 = r ? f2 - 1 : 0, B3 = r ? -1 : 1, q = t[e + E6];
      for (E6 += B3, p3 = q & (1 << -S2) - 1, q >>= -S2, S2 += y3;S2 > 0; p3 = p3 * 256 + t[e + E6], E6 += B3, S2 -= 8)
        ;
      for (m4 = p3 & (1 << -S2) - 1, p3 >>= -S2, S2 += o2;S2 > 0; m4 = m4 * 256 + t[e + E6], E6 += B3, S2 -= 8)
        ;
      if (p3 === 0)
        p3 = 1 - x3;
      else {
        if (p3 === M4)
          return m4 ? NaN : (q ? -1 : 1) * (1 / 0);
        m4 = m4 + Math.pow(2, o2), p3 = p3 - x3;
      }
      return (q ? -1 : 1) * m4 * Math.pow(2, p3 - o2);
    };
    q0.write = function(t, e, r, o2, f2, p3) {
      var m4, y3, M4, x3 = p3 * 8 - f2 - 1, S2 = (1 << x3) - 1, E6 = S2 >> 1, B3 = f2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, q = o2 ? 0 : p3 - 1, L3 = o2 ? 1 : -1, ge = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (y3 = isNaN(e) ? 1 : 0, m4 = S2) : (m4 = Math.floor(Math.log(e) / Math.LN2), e * (M4 = Math.pow(2, -m4)) < 1 && (m4--, M4 *= 2), m4 + E6 >= 1 ? e += B3 / M4 : e += B3 * Math.pow(2, 1 - E6), e * M4 >= 2 && (m4++, M4 /= 2), m4 + E6 >= S2 ? (y3 = 0, m4 = S2) : m4 + E6 >= 1 ? (y3 = (e * M4 - 1) * Math.pow(2, f2), m4 = m4 + E6) : (y3 = e * Math.pow(2, E6 - 1) * Math.pow(2, f2), m4 = 0));f2 >= 8; t[r + q] = y3 & 255, q += L3, y3 /= 256, f2 -= 8)
        ;
      for (m4 = m4 << f2 | y3, x3 += f2;x3 > 0; t[r + q] = m4 & 255, q += L3, m4 /= 256, x3 -= 8)
        ;
      t[r + q - L3] |= ge * 128;
    };
  });
  Ut2 = T((Xn) => {
    var I0 = Nd(), Gn = Dd(), Pd = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Xn.Buffer = me;
    Xn.SlowBuffer = Tw;
    Xn.INSPECT_MAX_BYTES = 50;
    var eo2 = 2147483647;
    Xn.kMaxLength = eo2;
    me.TYPED_ARRAY_SUPPORT = Aw();
    !me.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Aw() {
      try {
        let t = new Uint8Array(1), e = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(me.prototype, "parent", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(me.prototype, "offset", { enumerable: true, get: function() {
      if (!!me.isBuffer(this))
        return this.byteOffset;
    } });
    function li2(t) {
      if (t > eo2)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      let e = new Uint8Array(t);
      return Object.setPrototypeOf(e, me.prototype), e;
    }
    function me(t, e, r) {
      if (typeof t == "number") {
        if (typeof e == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return N0(t);
      }
      return Ud(t, e, r);
    }
    me.poolSize = 8192;
    function Ud(t, e, r) {
      if (typeof t == "string")
        return Bw(t, e);
      if (ArrayBuffer.isView(t))
        return qw(t);
      if (t == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      if (Zr2(t, ArrayBuffer) || t && Zr2(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Zr2(t, SharedArrayBuffer) || t && Zr2(t.buffer, SharedArrayBuffer)))
        return k0(t, e, r);
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let o2 = t.valueOf && t.valueOf();
      if (o2 != null && o2 !== t)
        return me.from(o2, e, r);
      let f2 = Iw(t);
      if (f2)
        return f2;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
        return me.from(t[Symbol.toPrimitive]("string"), e, r);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    }
    me.from = function(t, e, r) {
      return Ud(t, e, r);
    };
    Object.setPrototypeOf(me.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(me, Uint8Array);
    function zd(t) {
      if (typeof t != "number")
        throw new TypeError('"size" argument must be of type number');
      if (t < 0)
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
    }
    function Rw(t, e, r) {
      return zd(t), t <= 0 ? li2(t) : e !== undefined ? typeof r == "string" ? li2(t).fill(e, r) : li2(t).fill(e) : li2(t);
    }
    me.alloc = function(t, e, r) {
      return Rw(t, e, r);
    };
    function N0(t) {
      return zd(t), li2(t < 0 ? 0 : D0(t) | 0);
    }
    me.allocUnsafe = function(t) {
      return N0(t);
    };
    me.allocUnsafeSlow = function(t) {
      return N0(t);
    };
    function Bw(t, e) {
      if ((typeof e != "string" || e === "") && (e = "utf8"), !me.isEncoding(e))
        throw new TypeError("Unknown encoding: " + e);
      let r = Hd(t, e) | 0, o2 = li2(r), f2 = o2.write(t, e);
      return f2 !== r && (o2 = o2.slice(0, f2)), o2;
    }
    function T0(t) {
      let e = t.length < 0 ? 0 : D0(t.length) | 0, r = li2(e);
      for (let o2 = 0;o2 < e; o2 += 1)
        r[o2] = t[o2] & 255;
      return r;
    }
    function qw(t) {
      if (Zr2(t, Uint8Array)) {
        let e = new Uint8Array(t);
        return k0(e.buffer, e.byteOffset, e.byteLength);
      }
      return T0(t);
    }
    function k0(t, e, r) {
      if (e < 0 || t.byteLength < e)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (t.byteLength < e + (r || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let o2;
      return e === undefined && r === undefined ? o2 = new Uint8Array(t) : r === undefined ? o2 = new Uint8Array(t, e) : o2 = new Uint8Array(t, e, r), Object.setPrototypeOf(o2, me.prototype), o2;
    }
    function Iw(t) {
      if (me.isBuffer(t)) {
        let e = D0(t.length) | 0, r = li2(e);
        return r.length === 0 || t.copy(r, 0, 0, e), r;
      }
      if (t.length !== undefined)
        return typeof t.length != "number" || C0(t.length) ? li2(0) : T0(t);
      if (t.type === "Buffer" && Array.isArray(t.data))
        return T0(t.data);
    }
    function D0(t) {
      if (t >= eo2)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + eo2.toString(16) + " bytes");
      return t | 0;
    }
    function Tw(t) {
      return +t != t && (t = 0), me.alloc(+t);
    }
    me.isBuffer = function(e) {
      return e != null && e._isBuffer === true && e !== me.prototype;
    };
    me.compare = function(e, r) {
      if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), Zr2(r, Uint8Array) && (r = me.from(r, r.offset, r.byteLength)), !me.isBuffer(e) || !me.isBuffer(r))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e === r)
        return 0;
      let o2 = e.length, f2 = r.length;
      for (let p3 = 0, m4 = Math.min(o2, f2);p3 < m4; ++p3)
        if (e[p3] !== r[p3]) {
          o2 = e[p3], f2 = r[p3];
          break;
        }
      return o2 < f2 ? -1 : f2 < o2 ? 1 : 0;
    };
    me.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    me.concat = function(e, r) {
      if (!Array.isArray(e))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (e.length === 0)
        return me.alloc(0);
      let o2;
      if (r === undefined)
        for (r = 0, o2 = 0;o2 < e.length; ++o2)
          r += e[o2].length;
      let f2 = me.allocUnsafe(r), p3 = 0;
      for (o2 = 0;o2 < e.length; ++o2) {
        let m4 = e[o2];
        if (Zr2(m4, Uint8Array))
          p3 + m4.length > f2.length ? (me.isBuffer(m4) || (m4 = me.from(m4)), m4.copy(f2, p3)) : Uint8Array.prototype.set.call(f2, m4, p3);
        else if (me.isBuffer(m4))
          m4.copy(f2, p3);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        p3 += m4.length;
      }
      return f2;
    };
    function Hd(t, e) {
      if (me.isBuffer(t))
        return t.length;
      if (ArrayBuffer.isView(t) || Zr2(t, ArrayBuffer))
        return t.byteLength;
      if (typeof t != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
      let r = t.length, o2 = arguments.length > 2 && arguments[2] === true;
      if (!o2 && r === 0)
        return 0;
      let f2 = false;
      for (;; )
        switch (e) {
          case "ascii":
          case "latin1":
          case "binary":
            return r;
          case "utf8":
          case "utf-8":
            return L0(t).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return r * 2;
          case "hex":
            return r >>> 1;
          case "base64":
            return Xd(t).length;
          default:
            if (f2)
              return o2 ? -1 : L0(t).length;
            e = ("" + e).toLowerCase(), f2 = true;
        }
    }
    me.byteLength = Hd;
    function kw(t, e, r) {
      let o2 = false;
      if ((e === undefined || e < 0) && (e = 0), e > this.length || ((r === undefined || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
        return "";
      for (t || (t = "utf8");; )
        switch (t) {
          case "hex":
            return Hw(this, e, r);
          case "utf8":
          case "utf-8":
            return Kd(this, e, r);
          case "ascii":
            return Uw(this, e, r);
          case "latin1":
          case "binary":
            return zw(this, e, r);
          case "base64":
            return Ow(this, e, r);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Ww(this, e, r);
          default:
            if (o2)
              throw new TypeError("Unknown encoding: " + t);
            t = (t + "").toLowerCase(), o2 = true;
        }
    }
    me.prototype._isBuffer = true;
    function fn(t, e, r) {
      let o2 = t[e];
      t[e] = t[r], t[r] = o2;
    }
    me.prototype.swap16 = function() {
      let e = this.length;
      if (e % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let r = 0;r < e; r += 2)
        fn(this, r, r + 1);
      return this;
    };
    me.prototype.swap32 = function() {
      let e = this.length;
      if (e % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let r = 0;r < e; r += 4)
        fn(this, r, r + 3), fn(this, r + 1, r + 2);
      return this;
    };
    me.prototype.swap64 = function() {
      let e = this.length;
      if (e % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let r = 0;r < e; r += 8)
        fn(this, r, r + 7), fn(this, r + 1, r + 6), fn(this, r + 2, r + 5), fn(this, r + 3, r + 4);
      return this;
    };
    me.prototype.toString = function() {
      let e = this.length;
      return e === 0 ? "" : arguments.length === 0 ? Kd(this, 0, e) : kw.apply(this, arguments);
    };
    me.prototype.toLocaleString = me.prototype.toString;
    me.prototype.equals = function(e) {
      if (!me.isBuffer(e))
        throw new TypeError("Argument must be a Buffer");
      return this === e ? true : me.compare(this, e) === 0;
    };
    me.prototype.inspect = function() {
      let e = "", r = Xn.INSPECT_MAX_BYTES;
      return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
    };
    Pd && (me.prototype[Pd] = me.prototype.inspect);
    me.prototype.compare = function(e, r, o2, f2, p3) {
      if (Zr2(e, Uint8Array) && (e = me.from(e, e.offset, e.byteLength)), !me.isBuffer(e))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
      if (r === undefined && (r = 0), o2 === undefined && (o2 = e ? e.length : 0), f2 === undefined && (f2 = 0), p3 === undefined && (p3 = this.length), r < 0 || o2 > e.length || f2 < 0 || p3 > this.length)
        throw new RangeError("out of range index");
      if (f2 >= p3 && r >= o2)
        return 0;
      if (f2 >= p3)
        return -1;
      if (r >= o2)
        return 1;
      if (r >>>= 0, o2 >>>= 0, f2 >>>= 0, p3 >>>= 0, this === e)
        return 0;
      let m4 = p3 - f2, y3 = o2 - r, M4 = Math.min(m4, y3), x3 = this.slice(f2, p3), S2 = e.slice(r, o2);
      for (let E6 = 0;E6 < M4; ++E6)
        if (x3[E6] !== S2[E6]) {
          m4 = x3[E6], y3 = S2[E6];
          break;
        }
      return m4 < y3 ? -1 : y3 < m4 ? 1 : 0;
    };
    function Wd(t, e, r, o2, f2) {
      if (t.length === 0)
        return -1;
      if (typeof r == "string" ? (o2 = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, C0(r) && (r = f2 ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
        if (f2)
          return -1;
        r = t.length - 1;
      } else if (r < 0)
        if (f2)
          r = 0;
        else
          return -1;
      if (typeof e == "string" && (e = me.from(e, o2)), me.isBuffer(e))
        return e.length === 0 ? -1 : Cd(t, e, r, o2, f2);
      if (typeof e == "number")
        return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? f2 ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Cd(t, [e], r, o2, f2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Cd(t, e, r, o2, f2) {
      let p3 = 1, m4 = t.length, y3 = e.length;
      if (o2 !== undefined && (o2 = String(o2).toLowerCase(), o2 === "ucs2" || o2 === "ucs-2" || o2 === "utf16le" || o2 === "utf-16le")) {
        if (t.length < 2 || e.length < 2)
          return -1;
        p3 = 2, m4 /= 2, y3 /= 2, r /= 2;
      }
      function M4(S2, E6) {
        return p3 === 1 ? S2[E6] : S2.readUInt16BE(E6 * p3);
      }
      let x3;
      if (f2) {
        let S2 = -1;
        for (x3 = r;x3 < m4; x3++)
          if (M4(t, x3) === M4(e, S2 === -1 ? 0 : x3 - S2)) {
            if (S2 === -1 && (S2 = x3), x3 - S2 + 1 === y3)
              return S2 * p3;
          } else
            S2 !== -1 && (x3 -= x3 - S2), S2 = -1;
      } else
        for (r + y3 > m4 && (r = m4 - y3), x3 = r;x3 >= 0; x3--) {
          let S2 = true;
          for (let E6 = 0;E6 < y3; E6++)
            if (M4(t, x3 + E6) !== M4(e, E6)) {
              S2 = false;
              break;
            }
          if (S2)
            return x3;
        }
      return -1;
    }
    me.prototype.includes = function(e, r, o2) {
      return this.indexOf(e, r, o2) !== -1;
    };
    me.prototype.indexOf = function(e, r, o2) {
      return Wd(this, e, r, o2, true);
    };
    me.prototype.lastIndexOf = function(e, r, o2) {
      return Wd(this, e, r, o2, false);
    };
    function Lw(t, e, r, o2) {
      r = Number(r) || 0;
      let f2 = t.length - r;
      o2 ? (o2 = Number(o2), o2 > f2 && (o2 = f2)) : o2 = f2;
      let p3 = e.length;
      o2 > p3 / 2 && (o2 = p3 / 2);
      let m4;
      for (m4 = 0;m4 < o2; ++m4) {
        let y3 = parseInt(e.substr(m4 * 2, 2), 16);
        if (C0(y3))
          return m4;
        t[r + m4] = y3;
      }
      return m4;
    }
    function Nw(t, e, r, o2) {
      return to2(L0(e, t.length - r), t, r, o2);
    }
    function Dw(t, e, r, o2) {
      return to2(Vw(e), t, r, o2);
    }
    function Pw(t, e, r, o2) {
      return to2(Xd(e), t, r, o2);
    }
    function Cw(t, e, r, o2) {
      return to2($w(e, t.length - r), t, r, o2);
    }
    me.prototype.write = function(e, r, o2, f2) {
      if (r === undefined)
        f2 = "utf8", o2 = this.length, r = 0;
      else if (o2 === undefined && typeof r == "string")
        f2 = r, o2 = this.length, r = 0;
      else if (isFinite(r))
        r = r >>> 0, isFinite(o2) ? (o2 = o2 >>> 0, f2 === undefined && (f2 = "utf8")) : (f2 = o2, o2 = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let p3 = this.length - r;
      if ((o2 === undefined || o2 > p3) && (o2 = p3), e.length > 0 && (o2 < 0 || r < 0) || r > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      f2 || (f2 = "utf8");
      let m4 = false;
      for (;; )
        switch (f2) {
          case "hex":
            return Lw(this, e, r, o2);
          case "utf8":
          case "utf-8":
            return Nw(this, e, r, o2);
          case "ascii":
          case "latin1":
          case "binary":
            return Dw(this, e, r, o2);
          case "base64":
            return Pw(this, e, r, o2);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Cw(this, e, r, o2);
          default:
            if (m4)
              throw new TypeError("Unknown encoding: " + f2);
            f2 = ("" + f2).toLowerCase(), m4 = true;
        }
    };
    me.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Ow(t, e, r) {
      return e === 0 && r === t.length ? I0.fromByteArray(t) : I0.fromByteArray(t.slice(e, r));
    }
    function Kd(t, e, r) {
      r = Math.min(t.length, r);
      let o2 = [], f2 = e;
      for (;f2 < r; ) {
        let p3 = t[f2], m4 = null, y3 = p3 > 239 ? 4 : p3 > 223 ? 3 : p3 > 191 ? 2 : 1;
        if (f2 + y3 <= r) {
          let M4, x3, S2, E6;
          switch (y3) {
            case 1:
              p3 < 128 && (m4 = p3);
              break;
            case 2:
              M4 = t[f2 + 1], (M4 & 192) === 128 && (E6 = (p3 & 31) << 6 | M4 & 63, E6 > 127 && (m4 = E6));
              break;
            case 3:
              M4 = t[f2 + 1], x3 = t[f2 + 2], (M4 & 192) === 128 && (x3 & 192) === 128 && (E6 = (p3 & 15) << 12 | (M4 & 63) << 6 | x3 & 63, E6 > 2047 && (E6 < 55296 || E6 > 57343) && (m4 = E6));
              break;
            case 4:
              M4 = t[f2 + 1], x3 = t[f2 + 2], S2 = t[f2 + 3], (M4 & 192) === 128 && (x3 & 192) === 128 && (S2 & 192) === 128 && (E6 = (p3 & 15) << 18 | (M4 & 63) << 12 | (x3 & 63) << 6 | S2 & 63, E6 > 65535 && E6 < 1114112 && (m4 = E6));
          }
        }
        m4 === null ? (m4 = 65533, y3 = 1) : m4 > 65535 && (m4 -= 65536, o2.push(m4 >>> 10 & 1023 | 55296), m4 = 56320 | m4 & 1023), o2.push(m4), f2 += y3;
      }
      return Fw(o2);
    }
    var Od = 4096;
    function Fw(t) {
      let e = t.length;
      if (e <= Od)
        return String.fromCharCode.apply(String, t);
      let r = "", o2 = 0;
      for (;o2 < e; )
        r += String.fromCharCode.apply(String, t.slice(o2, o2 += Od));
      return r;
    }
    function Uw(t, e, r) {
      let o2 = "";
      r = Math.min(t.length, r);
      for (let f2 = e;f2 < r; ++f2)
        o2 += String.fromCharCode(t[f2] & 127);
      return o2;
    }
    function zw(t, e, r) {
      let o2 = "";
      r = Math.min(t.length, r);
      for (let f2 = e;f2 < r; ++f2)
        o2 += String.fromCharCode(t[f2]);
      return o2;
    }
    function Hw(t, e, r) {
      let o2 = t.length;
      (!e || e < 0) && (e = 0), (!r || r < 0 || r > o2) && (r = o2);
      let f2 = "";
      for (let p3 = e;p3 < r; ++p3)
        f2 += Gw[t[p3]];
      return f2;
    }
    function Ww(t, e, r) {
      let o2 = t.slice(e, r), f2 = "";
      for (let p3 = 0;p3 < o2.length - 1; p3 += 2)
        f2 += String.fromCharCode(o2[p3] + o2[p3 + 1] * 256);
      return f2;
    }
    me.prototype.slice = function(e, r) {
      let o2 = this.length;
      e = ~~e, r = r === undefined ? o2 : ~~r, e < 0 ? (e += o2, e < 0 && (e = 0)) : e > o2 && (e = o2), r < 0 ? (r += o2, r < 0 && (r = 0)) : r > o2 && (r = o2), r < e && (r = e);
      let f2 = this.subarray(e, r);
      return Object.setPrototypeOf(f2, me.prototype), f2;
    };
    function Dt2(t, e, r) {
      if (t % 1 !== 0 || t < 0)
        throw new RangeError("offset is not uint");
      if (t + e > r)
        throw new RangeError("Trying to access beyond buffer length");
    }
    me.prototype.readUintLE = me.prototype.readUIntLE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f2 = this[e], p3 = 1, m4 = 0;
      for (;++m4 < r && (p3 *= 256); )
        f2 += this[e + m4] * p3;
      return f2;
    };
    me.prototype.readUintBE = me.prototype.readUIntBE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f2 = this[e + --r], p3 = 1;
      for (;r > 0 && (p3 *= 256); )
        f2 += this[e + --r] * p3;
      return f2;
    };
    me.prototype.readUint8 = me.prototype.readUInt8 = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 1, this.length), this[e];
    };
    me.prototype.readUint16LE = me.prototype.readUInt16LE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 2, this.length), this[e] | this[e + 1] << 8;
    };
    me.prototype.readUint16BE = me.prototype.readUInt16BE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 2, this.length), this[e] << 8 | this[e + 1];
    };
    me.prototype.readUint32LE = me.prototype.readUInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
    };
    me.prototype.readUint32BE = me.prototype.readUInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
    };
    me.prototype.readBigUInt64LE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f2 = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, p3 = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + o2 * 2 ** 24;
      return BigInt(f2) + (BigInt(p3) << BigInt(32));
    });
    me.prototype.readBigUInt64BE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f2 = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], p3 = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o2;
      return (BigInt(f2) << BigInt(32)) + BigInt(p3);
    });
    me.prototype.readIntLE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f2 = this[e], p3 = 1, m4 = 0;
      for (;++m4 < r && (p3 *= 256); )
        f2 += this[e + m4] * p3;
      return p3 *= 128, f2 >= p3 && (f2 -= Math.pow(2, 8 * r)), f2;
    };
    me.prototype.readIntBE = function(e, r, o2) {
      e = e >>> 0, r = r >>> 0, o2 || Dt2(e, r, this.length);
      let f2 = r, p3 = 1, m4 = this[e + --f2];
      for (;f2 > 0 && (p3 *= 256); )
        m4 += this[e + --f2] * p3;
      return p3 *= 128, m4 >= p3 && (m4 -= Math.pow(2, 8 * r)), m4;
    };
    me.prototype.readInt8 = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
    };
    me.prototype.readInt16LE = function(e, r) {
      e = e >>> 0, r || Dt2(e, 2, this.length);
      let o2 = this[e] | this[e + 1] << 8;
      return o2 & 32768 ? o2 | 4294901760 : o2;
    };
    me.prototype.readInt16BE = function(e, r) {
      e = e >>> 0, r || Dt2(e, 2, this.length);
      let o2 = this[e + 1] | this[e] << 8;
      return o2 & 32768 ? o2 | 4294901760 : o2;
    };
    me.prototype.readInt32LE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
    };
    me.prototype.readInt32BE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
    };
    me.prototype.readBigInt64LE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f2 = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (o2 << 24);
      return (BigInt(f2) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
    });
    me.prototype.readBigInt64BE = Ti2(function(e) {
      e = e >>> 0, Yn(e, "offset");
      let r = this[e], o2 = this[e + 7];
      (r === undefined || o2 === undefined) && Vf(e, this.length - 8);
      let f2 = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
      return (BigInt(f2) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + o2);
    });
    me.prototype.readFloatLE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), Gn.read(this, e, true, 23, 4);
    };
    me.prototype.readFloatBE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 4, this.length), Gn.read(this, e, false, 23, 4);
    };
    me.prototype.readDoubleLE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 8, this.length), Gn.read(this, e, true, 52, 8);
    };
    me.prototype.readDoubleBE = function(e, r) {
      return e = e >>> 0, r || Dt2(e, 8, this.length), Gn.read(this, e, false, 52, 8);
    };
    function er2(t, e, r, o2, f2, p3) {
      if (!me.isBuffer(t))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (e > f2 || e < p3)
        throw new RangeError('"value" argument is out of bounds');
      if (r + o2 > t.length)
        throw new RangeError("Index out of range");
    }
    me.prototype.writeUintLE = me.prototype.writeUIntLE = function(e, r, o2, f2) {
      if (e = +e, r = r >>> 0, o2 = o2 >>> 0, !f2) {
        let y3 = Math.pow(2, 8 * o2) - 1;
        er2(this, e, r, o2, y3, 0);
      }
      let p3 = 1, m4 = 0;
      for (this[r] = e & 255;++m4 < o2 && (p3 *= 256); )
        this[r + m4] = e / p3 & 255;
      return r + o2;
    };
    me.prototype.writeUintBE = me.prototype.writeUIntBE = function(e, r, o2, f2) {
      if (e = +e, r = r >>> 0, o2 = o2 >>> 0, !f2) {
        let y3 = Math.pow(2, 8 * o2) - 1;
        er2(this, e, r, o2, y3, 0);
      }
      let p3 = o2 - 1, m4 = 1;
      for (this[r + p3] = e & 255;--p3 >= 0 && (m4 *= 256); )
        this[r + p3] = e / m4 & 255;
      return r + o2;
    };
    me.prototype.writeUint8 = me.prototype.writeUInt8 = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
    };
    me.prototype.writeUint16LE = me.prototype.writeUInt16LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeUint16BE = me.prototype.writeUInt16BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeUint32LE = me.prototype.writeUInt32LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
    };
    me.prototype.writeUint32BE = me.prototype.writeUInt32BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    function jd(t, e, r, o2, f2) {
      Yd(e, o2, f2, t, r, 7);
      let p3 = Number(e & BigInt(4294967295));
      t[r++] = p3, p3 = p3 >> 8, t[r++] = p3, p3 = p3 >> 8, t[r++] = p3, p3 = p3 >> 8, t[r++] = p3;
      let m4 = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r++] = m4, m4 = m4 >> 8, t[r++] = m4, m4 = m4 >> 8, t[r++] = m4, m4 = m4 >> 8, t[r++] = m4, r;
    }
    function Zd(t, e, r, o2, f2) {
      Yd(e, o2, f2, t, r, 7);
      let p3 = Number(e & BigInt(4294967295));
      t[r + 7] = p3, p3 = p3 >> 8, t[r + 6] = p3, p3 = p3 >> 8, t[r + 5] = p3, p3 = p3 >> 8, t[r + 4] = p3;
      let m4 = Number(e >> BigInt(32) & BigInt(4294967295));
      return t[r + 3] = m4, m4 = m4 >> 8, t[r + 2] = m4, m4 = m4 >> 8, t[r + 1] = m4, m4 = m4 >> 8, t[r] = m4, r + 8;
    }
    me.prototype.writeBigUInt64LE = Ti2(function(e, r = 0) {
      return jd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeBigUInt64BE = Ti2(function(e, r = 0) {
      return Zd(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    me.prototype.writeIntLE = function(e, r, o2, f2) {
      if (e = +e, r = r >>> 0, !f2) {
        let M4 = Math.pow(2, 8 * o2 - 1);
        er2(this, e, r, o2, M4 - 1, -M4);
      }
      let p3 = 0, m4 = 1, y3 = 0;
      for (this[r] = e & 255;++p3 < o2 && (m4 *= 256); )
        e < 0 && y3 === 0 && this[r + p3 - 1] !== 0 && (y3 = 1), this[r + p3] = (e / m4 >> 0) - y3 & 255;
      return r + o2;
    };
    me.prototype.writeIntBE = function(e, r, o2, f2) {
      if (e = +e, r = r >>> 0, !f2) {
        let M4 = Math.pow(2, 8 * o2 - 1);
        er2(this, e, r, o2, M4 - 1, -M4);
      }
      let p3 = o2 - 1, m4 = 1, y3 = 0;
      for (this[r + p3] = e & 255;--p3 >= 0 && (m4 *= 256); )
        e < 0 && y3 === 0 && this[r + p3 + 1] !== 0 && (y3 = 1), this[r + p3] = (e / m4 >> 0) - y3 & 255;
      return r + o2;
    };
    me.prototype.writeInt8 = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
    };
    me.prototype.writeInt16LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
    };
    me.prototype.writeInt16BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
    };
    me.prototype.writeInt32LE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
    };
    me.prototype.writeInt32BE = function(e, r, o2) {
      return e = +e, r = r >>> 0, o2 || er2(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
    };
    me.prototype.writeBigInt64LE = Ti2(function(e, r = 0) {
      return jd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    me.prototype.writeBigInt64BE = Ti2(function(e, r = 0) {
      return Zd(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Vd(t, e, r, o2, f2, p3) {
      if (r + o2 > t.length)
        throw new RangeError("Index out of range");
      if (r < 0)
        throw new RangeError("Index out of range");
    }
    function $d(t, e, r, o2, f2) {
      return e = +e, r = r >>> 0, f2 || Vd(t, e, r, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), Gn.write(t, e, r, o2, 23, 4), r + 4;
    }
    me.prototype.writeFloatLE = function(e, r, o2) {
      return $d(this, e, r, true, o2);
    };
    me.prototype.writeFloatBE = function(e, r, o2) {
      return $d(this, e, r, false, o2);
    };
    function Gd(t, e, r, o2, f2) {
      return e = +e, r = r >>> 0, f2 || Vd(t, e, r, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), Gn.write(t, e, r, o2, 52, 8), r + 8;
    }
    me.prototype.writeDoubleLE = function(e, r, o2) {
      return Gd(this, e, r, true, o2);
    };
    me.prototype.writeDoubleBE = function(e, r, o2) {
      return Gd(this, e, r, false, o2);
    };
    me.prototype.copy = function(e, r, o2, f2) {
      if (!me.isBuffer(e))
        throw new TypeError("argument should be a Buffer");
      if (o2 || (o2 = 0), !f2 && f2 !== 0 && (f2 = this.length), r >= e.length && (r = e.length), r || (r = 0), f2 > 0 && f2 < o2 && (f2 = o2), f2 === o2 || e.length === 0 || this.length === 0)
        return 0;
      if (r < 0)
        throw new RangeError("targetStart out of bounds");
      if (o2 < 0 || o2 >= this.length)
        throw new RangeError("Index out of range");
      if (f2 < 0)
        throw new RangeError("sourceEnd out of bounds");
      f2 > this.length && (f2 = this.length), e.length - r < f2 - o2 && (f2 = e.length - r + o2);
      let p3 = f2 - o2;
      return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, o2, f2) : Uint8Array.prototype.set.call(e, this.subarray(o2, f2), r), p3;
    };
    me.prototype.fill = function(e, r, o2, f2) {
      if (typeof e == "string") {
        if (typeof r == "string" ? (f2 = r, r = 0, o2 = this.length) : typeof o2 == "string" && (f2 = o2, o2 = this.length), f2 !== undefined && typeof f2 != "string")
          throw new TypeError("encoding must be a string");
        if (typeof f2 == "string" && !me.isEncoding(f2))
          throw new TypeError("Unknown encoding: " + f2);
        if (e.length === 1) {
          let m4 = e.charCodeAt(0);
          (f2 === "utf8" && m4 < 128 || f2 === "latin1") && (e = m4);
        }
      } else
        typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
      if (r < 0 || this.length < r || this.length < o2)
        throw new RangeError("Out of range index");
      if (o2 <= r)
        return this;
      r = r >>> 0, o2 = o2 === undefined ? this.length : o2 >>> 0, e || (e = 0);
      let p3;
      if (typeof e == "number")
        for (p3 = r;p3 < o2; ++p3)
          this[p3] = e;
      else {
        let m4 = me.isBuffer(e) ? e : me.from(e, f2), y3 = m4.length;
        if (y3 === 0)
          throw new TypeError('The value "' + e + '" is invalid for argument "value"');
        for (p3 = 0;p3 < o2 - r; ++p3)
          this[p3 + r] = m4[p3 % y3];
      }
      return this;
    };
    var $n = {};
    function P0(t, e, r) {
      $n[t] = class extends r {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
        }
        get code() {
          return t;
        }
        set code(f2) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: f2, writable: true });
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      };
    }
    P0("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
      return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    P0("ERR_INVALID_ARG_TYPE", function(t, e) {
      return `The "${t}" argument must be of type number. Received type ${typeof e}`;
    }, TypeError);
    P0("ERR_OUT_OF_RANGE", function(t, e, r) {
      let o2 = `The value of "${t}" is out of range.`, f2 = r;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? f2 = Fd(String(r)) : typeof r == "bigint" && (f2 = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (f2 = Fd(f2)), f2 += "n"), o2 += ` It must be ${e}. Received ${f2}`, o2;
    }, RangeError);
    function Fd(t) {
      let e = "", r = t.length, o2 = t[0] === "-" ? 1 : 0;
      for (;r >= o2 + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function Kw(t, e, r) {
      Yn(e, "offset"), (t[e] === undefined || t[e + r] === undefined) && Vf(e, t.length - (r + 1));
    }
    function Yd(t, e, r, o2, f2, p3) {
      if (t > r || t < e) {
        let m4 = typeof e == "bigint" ? "n" : "", y3;
        throw p3 > 3 ? e === 0 || e === BigInt(0) ? y3 = `>= 0${m4} and < 2${m4} ** ${(p3 + 1) * 8}${m4}` : y3 = `>= -(2${m4} ** ${(p3 + 1) * 8 - 1}${m4}) and < 2 ** ${(p3 + 1) * 8 - 1}${m4}` : y3 = `>= ${e}${m4} and <= ${r}${m4}`, new $n.ERR_OUT_OF_RANGE("value", y3, t);
      }
      Kw(o2, f2, p3);
    }
    function Yn(t, e) {
      if (typeof t != "number")
        throw new $n.ERR_INVALID_ARG_TYPE(e, "number", t);
    }
    function Vf(t, e, r) {
      throw Math.floor(t) !== t ? (Yn(t, r), new $n.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new $n.ERR_BUFFER_OUT_OF_BOUNDS : new $n.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
    }
    var jw = /[^+/0-9A-Za-z-_]/g;
    function Zw(t) {
      if (t = t.split("=")[0], t = t.trim().replace(jw, ""), t.length < 2)
        return "";
      for (;t.length % 4 !== 0; )
        t = t + "=";
      return t;
    }
    function L0(t, e) {
      e = e || 1 / 0;
      let r, o2 = t.length, f2 = null, p3 = [];
      for (let m4 = 0;m4 < o2; ++m4) {
        if (r = t.charCodeAt(m4), r > 55295 && r < 57344) {
          if (!f2) {
            if (r > 56319) {
              (e -= 3) > -1 && p3.push(239, 191, 189);
              continue;
            } else if (m4 + 1 === o2) {
              (e -= 3) > -1 && p3.push(239, 191, 189);
              continue;
            }
            f2 = r;
            continue;
          }
          if (r < 56320) {
            (e -= 3) > -1 && p3.push(239, 191, 189), f2 = r;
            continue;
          }
          r = (f2 - 55296 << 10 | r - 56320) + 65536;
        } else
          f2 && (e -= 3) > -1 && p3.push(239, 191, 189);
        if (f2 = null, r < 128) {
          if ((e -= 1) < 0)
            break;
          p3.push(r);
        } else if (r < 2048) {
          if ((e -= 2) < 0)
            break;
          p3.push(r >> 6 | 192, r & 63 | 128);
        } else if (r < 65536) {
          if ((e -= 3) < 0)
            break;
          p3.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
        } else if (r < 1114112) {
          if ((e -= 4) < 0)
            break;
          p3.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return p3;
    }
    function Vw(t) {
      let e = [];
      for (let r = 0;r < t.length; ++r)
        e.push(t.charCodeAt(r) & 255);
      return e;
    }
    function $w(t, e) {
      let r, o2, f2, p3 = [];
      for (let m4 = 0;m4 < t.length && !((e -= 2) < 0); ++m4)
        r = t.charCodeAt(m4), o2 = r >> 8, f2 = r % 256, p3.push(f2), p3.push(o2);
      return p3;
    }
    function Xd(t) {
      return I0.toByteArray(Zw(t));
    }
    function to2(t, e, r, o2) {
      let f2;
      for (f2 = 0;f2 < o2 && !(f2 + r >= e.length || f2 >= t.length); ++f2)
        e[f2 + r] = t[f2];
      return f2;
    }
    function Zr2(t, e) {
      return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
    }
    function C0(t) {
      return t !== t;
    }
    var Gw = function() {
      let t = "0123456789abcdef", e = new Array(256);
      for (let r = 0;r < 16; ++r) {
        let o2 = r * 16;
        for (let f2 = 0;f2 < 16; ++f2)
          e[o2 + f2] = t[r] + t[f2];
      }
      return e;
    }();
    function Ti2(t) {
      return typeof BigInt > "u" ? Yw : t;
    }
    function Yw() {
      throw new Error("BigInt not supported");
    }
  });
  Te = T((O0, Qd) => {
    var ro2 = Ut2(), Vr = ro2.Buffer;
    function Jd(t, e) {
      for (var r in t)
        e[r] = t[r];
    }
    Vr.from && Vr.alloc && Vr.allocUnsafe && Vr.allocUnsafeSlow ? Qd.exports = ro2 : (Jd(ro2, O0), O0.Buffer = an2);
    function an2(t, e, r) {
      return Vr(t, e, r);
    }
    an2.prototype = Object.create(Vr.prototype);
    Jd(Vr, an2);
    an2.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError("Argument must not be a number");
      return Vr(t, e, r);
    };
    an2.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      var o2 = Vr(t);
      return e !== undefined ? typeof r == "string" ? o2.fill(e, r) : o2.fill(e) : o2.fill(0), o2;
    };
    an2.allocUnsafe = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return Vr(t);
    };
    an2.allocUnsafeSlow = function(t) {
      if (typeof t != "number")
        throw new TypeError("Argument must be a number");
      return ro2.SlowBuffer(t);
    };
  });
  on = T((Gq, U0) => {
    var F0 = 65536, Xw = 4294967295;
    function Jw() {
      throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
    }
    var Qw = Te().Buffer, io = global.crypto || global.msCrypto;
    io && io.getRandomValues ? U0.exports = e6 : U0.exports = Jw;
    function e6(t, e) {
      if (t > Xw)
        throw new RangeError("requested too many random bytes");
      var r = Qw.allocUnsafe(t);
      if (t > 0)
        if (t > F0)
          for (var o2 = 0;o2 < t; o2 += F0)
            io.getRandomValues(r.slice(o2, o2 + F0));
        else
          io.getRandomValues(r);
      return typeof e == "function" ? process.nextTick(function() {
        e(null, r);
      }) : r;
    }
  });
  Ie = T((Yq, z0) => {
    typeof Object.create == "function" ? z0.exports = function(e, r) {
      r && (e.super_ = r, e.prototype = Object.create(r.prototype, { constructor: { value: e, enumerable: false, writable: true, configurable: true } }));
    } : z0.exports = function(e, r) {
      if (r) {
        e.super_ = r;
        var o2 = function() {};
        o2.prototype = r.prototype, e.prototype = new o2, e.prototype.constructor = e;
      }
    };
  });
  ki = T((Xq, H0) => {
    var Jn = typeof Reflect == "object" ? Reflect : null, ec = Jn && typeof Jn.apply == "function" ? Jn.apply : function(e, r, o2) {
      return Function.prototype.apply.call(e, r, o2);
    }, no;
    Jn && typeof Jn.ownKeys == "function" ? no = Jn.ownKeys : Object.getOwnPropertySymbols ? no = function(e) {
      return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
    } : no = function(e) {
      return Object.getOwnPropertyNames(e);
    };
    function t6(t) {
      console && console.warn && console.warn(t);
    }
    var rc = Number.isNaN || function(e) {
      return e !== e;
    };
    function Fe() {
      Fe.init.call(this);
    }
    H0.exports = Fe;
    H0.exports.once = f6;
    Fe.EventEmitter = Fe;
    Fe.prototype._events = undefined;
    Fe.prototype._eventsCount = 0;
    Fe.prototype._maxListeners = undefined;
    var tc = 10;
    function fo(t) {
      if (typeof t != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t);
    }
    Object.defineProperty(Fe, "defaultMaxListeners", { enumerable: true, get: function() {
      return tc;
    }, set: function(t) {
      if (typeof t != "number" || t < 0 || rc(t))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
      tc = t;
    } });
    Fe.init = function() {
      (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || undefined;
    };
    Fe.prototype.setMaxListeners = function(e) {
      if (typeof e != "number" || e < 0 || rc(e))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
      return this._maxListeners = e, this;
    };
    function ic(t) {
      return t._maxListeners === undefined ? Fe.defaultMaxListeners : t._maxListeners;
    }
    Fe.prototype.getMaxListeners = function() {
      return ic(this);
    };
    Fe.prototype.emit = function(e) {
      for (var r = [], o2 = 1;o2 < arguments.length; o2++)
        r.push(arguments[o2]);
      var f2 = e === "error", p3 = this._events;
      if (p3 !== undefined)
        f2 = f2 && p3.error === undefined;
      else if (!f2)
        return false;
      if (f2) {
        var m4;
        if (r.length > 0 && (m4 = r[0]), m4 instanceof Error)
          throw m4;
        var y3 = new Error("Unhandled error." + (m4 ? " (" + m4.message + ")" : ""));
        throw y3.context = m4, y3;
      }
      var M4 = p3[e];
      if (M4 === undefined)
        return false;
      if (typeof M4 == "function")
        ec(M4, this, r);
      else
        for (var x3 = M4.length, S2 = sc(M4, x3), o2 = 0;o2 < x3; ++o2)
          ec(S2[o2], this, r);
      return true;
    };
    function nc(t, e, r, o2) {
      var f2, p3, m4;
      if (fo(r), p3 = t._events, p3 === undefined ? (p3 = t._events = Object.create(null), t._eventsCount = 0) : (p3.newListener !== undefined && (t.emit("newListener", e, r.listener ? r.listener : r), p3 = t._events), m4 = p3[e]), m4 === undefined)
        m4 = p3[e] = r, ++t._eventsCount;
      else if (typeof m4 == "function" ? m4 = p3[e] = o2 ? [r, m4] : [m4, r] : o2 ? m4.unshift(r) : m4.push(r), f2 = ic(t), f2 > 0 && m4.length > f2 && !m4.warned) {
        m4.warned = true;
        var y3 = new Error("Possible EventEmitter memory leak detected. " + m4.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        y3.name = "MaxListenersExceededWarning", y3.emitter = t, y3.type = e, y3.count = m4.length, t6(y3);
      }
      return t;
    }
    Fe.prototype.addListener = function(e, r) {
      return nc(this, e, r, false);
    };
    Fe.prototype.on = Fe.prototype.addListener;
    Fe.prototype.prependListener = function(e, r) {
      return nc(this, e, r, true);
    };
    function r6() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function fc(t, e, r) {
      var o2 = { fired: false, wrapFn: undefined, target: t, type: e, listener: r }, f2 = r6.bind(o2);
      return f2.listener = r, o2.wrapFn = f2, f2;
    }
    Fe.prototype.once = function(e, r) {
      return fo(r), this.on(e, fc(this, e, r)), this;
    };
    Fe.prototype.prependOnceListener = function(e, r) {
      return fo(r), this.prependListener(e, fc(this, e, r)), this;
    };
    Fe.prototype.removeListener = function(e, r) {
      var o2, f2, p3, m4, y3;
      if (fo(r), f2 = this._events, f2 === undefined)
        return this;
      if (o2 = f2[e], o2 === undefined)
        return this;
      if (o2 === r || o2.listener === r)
        --this._eventsCount === 0 ? this._events = Object.create(null) : (delete f2[e], f2.removeListener && this.emit("removeListener", e, o2.listener || r));
      else if (typeof o2 != "function") {
        for (p3 = -1, m4 = o2.length - 1;m4 >= 0; m4--)
          if (o2[m4] === r || o2[m4].listener === r) {
            y3 = o2[m4].listener, p3 = m4;
            break;
          }
        if (p3 < 0)
          return this;
        p3 === 0 ? o2.shift() : i6(o2, p3), o2.length === 1 && (f2[e] = o2[0]), f2.removeListener !== undefined && this.emit("removeListener", e, y3 || r);
      }
      return this;
    };
    Fe.prototype.off = Fe.prototype.removeListener;
    Fe.prototype.removeAllListeners = function(e) {
      var r, o2, f2;
      if (o2 = this._events, o2 === undefined)
        return this;
      if (o2.removeListener === undefined)
        return arguments.length === 0 ? (this._events = Object.create(null), this._eventsCount = 0) : o2[e] !== undefined && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete o2[e]), this;
      if (arguments.length === 0) {
        var p3 = Object.keys(o2), m4;
        for (f2 = 0;f2 < p3.length; ++f2)
          m4 = p3[f2], m4 !== "removeListener" && this.removeAllListeners(m4);
        return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
      }
      if (r = o2[e], typeof r == "function")
        this.removeListener(e, r);
      else if (r !== undefined)
        for (f2 = r.length - 1;f2 >= 0; f2--)
          this.removeListener(e, r[f2]);
      return this;
    };
    function ac(t, e, r) {
      var o2 = t._events;
      if (o2 === undefined)
        return [];
      var f2 = o2[e];
      return f2 === undefined ? [] : typeof f2 == "function" ? r ? [f2.listener || f2] : [f2] : r ? n6(f2) : sc(f2, f2.length);
    }
    Fe.prototype.listeners = function(e) {
      return ac(this, e, true);
    };
    Fe.prototype.rawListeners = function(e) {
      return ac(this, e, false);
    };
    Fe.listenerCount = function(t, e) {
      return typeof t.listenerCount == "function" ? t.listenerCount(e) : oc.call(t, e);
    };
    Fe.prototype.listenerCount = oc;
    function oc(t) {
      var e = this._events;
      if (e !== undefined) {
        var r = e[t];
        if (typeof r == "function")
          return 1;
        if (r !== undefined)
          return r.length;
      }
      return 0;
    }
    Fe.prototype.eventNames = function() {
      return this._eventsCount > 0 ? no(this._events) : [];
    };
    function sc(t, e) {
      for (var r = new Array(e), o2 = 0;o2 < e; ++o2)
        r[o2] = t[o2];
      return r;
    }
    function i6(t, e) {
      for (;e + 1 < t.length; e++)
        t[e] = t[e + 1];
      t.pop();
    }
    function n6(t) {
      for (var e = new Array(t.length), r = 0;r < e.length; ++r)
        e[r] = t[r].listener || t[r];
      return e;
    }
    function f6(t, e) {
      return new Promise(function(r, o2) {
        function f2(m4) {
          t.removeListener(e, p3), o2(m4);
        }
        function p3() {
          typeof t.removeListener == "function" && t.removeListener("error", f2), r([].slice.call(arguments));
        }
        hc(t, e, p3, { once: true }), e !== "error" && a6(t, f2, { once: true });
      });
    }
    function a6(t, e, r) {
      typeof t.on == "function" && hc(t, "error", e, r);
    }
    function hc(t, e, r, o2) {
      if (typeof t.on == "function")
        o2.once ? t.once(e, r) : t.on(e, r);
      else if (typeof t.addEventListener == "function")
        t.addEventListener(e, function f(p3) {
          o2.once && t.removeEventListener(e, f), r(p3);
        });
      else
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
    }
  });
  W0 = T((Jq, uc) => {
    uc.exports = ki().EventEmitter;
  });
  $f = T(() => {});
  pc = T((tI, cc) => {
    function lc(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(t);
        e && (o2 = o2.filter(function(f2) {
          return Object.getOwnPropertyDescriptor(t, f2).enumerable;
        })), r.push.apply(r, o2);
      }
      return r;
    }
    function o6(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lc(Object(r), true).forEach(function(o2) {
          s6(t, o2, r[o2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lc(Object(r)).forEach(function(o2) {
          Object.defineProperty(t, o2, Object.getOwnPropertyDescriptor(r, o2));
        });
      }
      return t;
    }
    function s6(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function h6(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dc(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o2 = e[r];
        o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t, o2.key, o2);
      }
    }
    function u6(t, e, r) {
      return e && dc(t.prototype, e), r && dc(t, r), t;
    }
    var l6 = Ut2(), ao = l6.Buffer, d6 = $f(), K0 = d6.inspect, c6 = K0 && K0.custom || "inspect";
    function p6(t, e, r) {
      ao.prototype.copy.call(t, e, r);
    }
    cc.exports = function() {
      function t() {
        h6(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return u6(t, [{ key: "push", value: function(r) {
        var o2 = { data: r, next: null };
        this.length > 0 ? this.tail.next = o2 : this.head = o2, this.tail = o2, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o2 = { data: r, next: this.head };
        this.length === 0 && (this.tail = o2), this.head = o2, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o2 = this.head, f2 = "" + o2.data;o2 = o2.next; )
          f2 += r + o2.data;
        return f2;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return ao.alloc(0);
        for (var o2 = ao.allocUnsafe(r >>> 0), f2 = this.head, p3 = 0;f2; )
          p6(f2.data, o2, p3), p3 += f2.data.length, f2 = f2.next;
        return o2;
      } }, { key: "consume", value: function(r, o2) {
        var f2;
        return r < this.head.data.length ? (f2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f2 = this.shift() : f2 = o2 ? this._getString(r) : this._getBuffer(r), f2;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o2 = this.head, f2 = 1, p3 = o2.data;
        for (r -= p3.length;o2 = o2.next; ) {
          var m4 = o2.data, y3 = r > m4.length ? m4.length : r;
          if (y3 === m4.length ? p3 += m4 : p3 += m4.slice(0, r), r -= y3, r === 0) {
            y3 === m4.length ? (++f2, o2.next ? this.head = o2.next : this.head = this.tail = null) : (this.head = o2, o2.data = m4.slice(y3));
            break;
          }
          ++f2;
        }
        return this.length -= f2, p3;
      } }, { key: "_getBuffer", value: function(r) {
        var o2 = ao.allocUnsafe(r), f2 = this.head, p3 = 1;
        for (f2.data.copy(o2), r -= f2.data.length;f2 = f2.next; ) {
          var m4 = f2.data, y3 = r > m4.length ? m4.length : r;
          if (m4.copy(o2, o2.length - r, 0, y3), r -= y3, r === 0) {
            y3 === m4.length ? (++p3, f2.next ? this.head = f2.next : this.head = this.tail = null) : (this.head = f2, f2.data = m4.slice(y3));
            break;
          }
          ++p3;
        }
        return this.length -= p3, o2;
      } }, { key: c6, value: function(r, o2) {
        return K0(this, o6({}, o2, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  Z0 = T((rI, bc) => {
    function v6(t, e) {
      var r = this, o2 = this._readableState && this._readableState.destroyed, f2 = this._writableState && this._writableState.destroyed;
      return o2 || f2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(j0, this, t)) : process.nextTick(j0, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p3) {
        !e && p3 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(oo, r) : (r._writableState.errorEmitted = true, process.nextTick(vc, r, p3)) : process.nextTick(vc, r, p3) : e ? (process.nextTick(oo, r), e(p3)) : process.nextTick(oo, r);
      }), this);
    }
    function vc(t, e) {
      j0(t, e), oo(t);
    }
    function oo(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function b6() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function j0(t, e) {
      t.emit("error", e);
    }
    function m6(t, e) {
      var { _readableState: r, _writableState: o2 } = t;
      r && r.autoDestroy || o2 && o2.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bc.exports = { destroy: v6, undestroy: b6, errorOrDestroy: m6 };
  });
  sn = T((iI, yc) => {
    function g6(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gc = {};
    function dr4(t, e, r) {
      r || (r = Error);
      function o2(p3, m4, y3) {
        return typeof e == "string" ? e : e(p3, m4, y3);
      }
      var f2 = function(p3) {
        g6(m4, p3);
        function m4(y3, M4, x3) {
          return p3.call(this, o2(y3, M4, x3)) || this;
        }
        return m4;
      }(r);
      f2.prototype.name = r.name, f2.prototype.code = t, gc[t] = f2;
    }
    function mc(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o2) {
          return String(o2);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function y6(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function w6(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function M6(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    dr4("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    dr4("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o2;
      typeof e == "string" && y6(e, "not ") ? (o2 = "must not be", e = e.replace(/^not /, "")) : o2 = "must be";
      var f2;
      if (w6(t, " argument"))
        f2 = "The ".concat(t, " ").concat(o2, " ").concat(mc(e, "type"));
      else {
        var p3 = M6(t, ".") ? "property" : "argument";
        f2 = 'The "'.concat(t, '" ').concat(p3, " ").concat(o2, " ").concat(mc(e, "type"));
      }
      return f2 += ". Received type ".concat(typeof r), f2;
    }, TypeError);
    dr4("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    dr4("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    dr4("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    dr4("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    dr4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    dr4("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    dr4("ERR_STREAM_WRITE_AFTER_END", "write after end");
    dr4("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    dr4("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    dr4("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yc.exports.codes = gc;
  });
  V0 = T((nI, wc) => {
    var _6 = sn().codes.ERR_INVALID_OPT_VALUE;
    function x6(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function S6(t, e, r, o2) {
      var f2 = x6(e, o2, r);
      if (f2 != null) {
        if (!(isFinite(f2) && Math.floor(f2) === f2) || f2 < 0) {
          var p3 = o2 ? r : "highWaterMark";
          throw new _6(p3, f2);
        }
        return Math.floor(f2);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wc.exports = { getHighWaterMark: S6 };
  });
  G0 = T((fI, Mc) => {
    Mc.exports = E6;
    function E6(t, e) {
      if ($0("noDeprecation"))
        return t;
      var r = false;
      function o2() {
        if (!r) {
          if ($0("throwDeprecation"))
            throw new Error(e);
          $0("traceDeprecation") ? console.trace(e) : console.warn(e), r = true;
        }
        return t.apply(this, arguments);
      }
      return o2;
    }
    function $0(t) {
      try {
        if (!global.localStorage)
          return false;
      } catch {
        return false;
      }
      var e = global.localStorage[t];
      return e == null ? false : String(e).toLowerCase() === "true";
    }
  });
  J0 = T((aI, Rc) => {
    Rc.exports = ht2;
    function xc(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        J6(e, t);
      };
    }
    var Qn;
    ht2.WritableState = Yf;
    var A6 = { deprecate: G0() }, Sc = W0(), ho = Ut2().Buffer, R6 = global.Uint8Array || function() {};
    function B6(t) {
      return ho.from(t);
    }
    function q6(t) {
      return ho.isBuffer(t) || t instanceof R6;
    }
    var X0 = Z0(), I6 = V0(), T6 = I6.getHighWaterMark, Li2 = sn().codes, k6 = Li2.ERR_INVALID_ARG_TYPE, L6 = Li2.ERR_METHOD_NOT_IMPLEMENTED, N6 = Li2.ERR_MULTIPLE_CALLBACK, D6 = Li2.ERR_STREAM_CANNOT_PIPE, P6 = Li2.ERR_STREAM_DESTROYED, C6 = Li2.ERR_STREAM_NULL_VALUES, O6 = Li2.ERR_STREAM_WRITE_AFTER_END, F6 = Li2.ERR_UNKNOWN_ENCODING, ef2 = X0.errorOrDestroy;
    Ie()(ht2, Sc);
    function U6() {}
    function Yf(t, e, r) {
      Qn = Qn || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof Qn), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = T6(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o2 = t.decodeStrings === false;
      this.decodeStrings = !o2, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f2) {
        V6(e, f2);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new xc(this);
    }
    Yf.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(Yf.prototype, "buffer", { get: A6.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {}
    })();
    var so2;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (so2 = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht2, Symbol.hasInstance, { value: function(e) {
      return so2.call(this, e) ? true : this !== ht2 ? false : e && e._writableState instanceof Yf;
    } })) : so2 = function(e) {
      return e instanceof this;
    };
    function ht2(t) {
      Qn = Qn || hn();
      var e = this instanceof Qn;
      if (!e && !so2.call(ht2, this))
        return new ht2(t);
      this._writableState = new Yf(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), Sc.call(this);
    }
    ht2.prototype.pipe = function() {
      ef2(this, new D6);
    };
    function z6(t, e) {
      var r = new O6;
      ef2(t, r), process.nextTick(e, r);
    }
    function H6(t, e, r, o2) {
      var f2;
      return r === null ? f2 = new C6 : typeof r != "string" && !e.objectMode && (f2 = new k6("chunk", ["string", "Buffer"], r)), f2 ? (ef2(t, f2), process.nextTick(o2, f2), false) : true;
    }
    ht2.prototype.write = function(t, e, r) {
      var o2 = this._writableState, f2 = false, p3 = !o2.objectMode && q6(t);
      return p3 && !ho.isBuffer(t) && (t = B6(t)), typeof e == "function" && (r = e, e = null), p3 ? e = "buffer" : e || (e = o2.defaultEncoding), typeof r != "function" && (r = U6), o2.ending ? z6(this, r) : (p3 || H6(this, o2, t, r)) && (o2.pendingcb++, f2 = K6(this, o2, p3, t, e, r)), f2;
    };
    ht2.prototype.cork = function() {
      this._writableState.corked++;
    };
    ht2.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Ec(this, t));
    };
    ht2.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new F6(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ht2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function W6(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ho.from(e, r)), e;
    }
    Object.defineProperty(ht2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function K6(t, e, r, o2, f2, p3) {
      if (!r) {
        var m4 = W6(e, o2, f2);
        o2 !== m4 && (r = true, f2 = "buffer", o2 = m4);
      }
      var y3 = e.objectMode ? 1 : o2.length;
      e.length += y3;
      var M4 = e.length < e.highWaterMark;
      if (M4 || (e.needDrain = true), e.writing || e.corked) {
        var x3 = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o2, encoding: f2, isBuf: r, callback: p3, next: null }, x3 ? x3.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        Y0(t, e, false, y3, o2, f2, p3);
      return M4;
    }
    function Y0(t, e, r, o2, f2, p3, m4) {
      e.writelen = o2, e.writecb = m4, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new P6("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p3, e.onwrite), e.sync = false;
    }
    function j6(t, e, r, o2, f2) {
      --e.pendingcb, r ? (process.nextTick(f2, o2), process.nextTick(Gf, t, e), t._writableState.errorEmitted = true, ef2(t, o2)) : (f2(o2), t._writableState.errorEmitted = true, ef2(t, o2), Gf(t, e));
    }
    function Z6(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function V6(t, e) {
      var r = t._writableState, o2 = r.sync, f2 = r.writecb;
      if (typeof f2 != "function")
        throw new N6;
      if (Z6(r), e)
        j6(t, r, o2, e, f2);
      else {
        var p3 = Ac(r) || t.destroyed;
        !p3 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ec(t, r), o2 ? process.nextTick(_c, t, r, p3, f2) : _c(t, r, p3, f2);
      }
    }
    function _c(t, e, r, o2) {
      r || $6(t, e), e.pendingcb--, o2(), Gf(t, e);
    }
    function $6(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Ec(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o2 = e.bufferedRequestCount, f2 = new Array(o2), p3 = e.corkedRequestsFree;
        p3.entry = r;
        for (var m4 = 0, y3 = true;r; )
          f2[m4] = r, r.isBuf || (y3 = false), r = r.next, m4 += 1;
        f2.allBuffers = y3, Y0(t, e, true, e.length, f2, "", p3.finish), e.pendingcb++, e.lastBufferedRequest = null, p3.next ? (e.corkedRequestsFree = p3.next, p3.next = null) : e.corkedRequestsFree = new xc(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M4, encoding: x3, callback: S2 } = r, E6 = e.objectMode ? 1 : M4.length;
          if (Y0(t, e, false, E6, M4, x3, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ht2.prototype._write = function(t, e, r) {
      r(new L6("_write()"));
    };
    ht2.prototype._writev = null;
    ht2.prototype.end = function(t, e, r) {
      var o2 = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o2.corked && (o2.corked = 1, this.uncork()), o2.ending || X6(this, o2, r), this;
    };
    Object.defineProperty(ht2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Ac(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function G6(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && ef2(t, r), e.prefinished = true, t.emit("prefinish"), Gf(t, e);
      });
    }
    function Y6(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(G6, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Gf(t, e) {
      var r = Ac(e);
      if (r && (Y6(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o2 = t._readableState;
        (!o2 || o2.autoDestroy && o2.endEmitted) && t.destroy();
      }
      return r;
    }
    function X6(t, e, r) {
      e.ending = true, Gf(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function J6(t, e, r) {
      var o2 = t.entry;
      for (t.entry = null;o2; ) {
        var f2 = o2.callback;
        e.pendingcb--, f2(r), o2 = o2.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ht2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ht2.prototype.destroy = X0.destroy;
    ht2.prototype._undestroy = X0.undestroy;
    ht2.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  hn = T((oI, qc) => {
    var Q6 = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    qc.exports = $r3;
    var Bc = th(), eh = J0();
    Ie()($r3, Bc);
    for (Q0 = Q6(eh.prototype), uo = 0;uo < Q0.length; uo++)
      lo = Q0[uo], $r3.prototype[lo] || ($r3.prototype[lo] = eh.prototype[lo]);
    var Q0, lo, uo;
    function $r3(t) {
      if (!(this instanceof $r3))
        return new $r3(t);
      Bc.call(this, t), eh.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", eM)));
    }
    Object.defineProperty($r3.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty($r3.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty($r3.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function eM() {
      this._writableState.ended || process.nextTick(tM, this);
    }
    function tM(t) {
      t.end();
    }
    Object.defineProperty($r3.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  co = T((Tc) => {
    var ih = Te().Buffer, Ic = ih.isEncoding || function(t) {
      switch (t = "" + t, t && t.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function rM(t) {
      if (!t)
        return "utf8";
      for (var e;; )
        switch (t) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return t;
          default:
            if (e)
              return;
            t = ("" + t).toLowerCase(), e = true;
        }
    }
    function iM(t) {
      var e = rM(t);
      if (typeof e != "string" && (ih.isEncoding === Ic || !Ic(t)))
        throw new Error("Unknown encoding: " + t);
      return e || t;
    }
    Tc.StringDecoder = Xf;
    function Xf(t) {
      this.encoding = iM(t);
      var e;
      switch (this.encoding) {
        case "utf16le":
          this.text = hM, this.end = uM, e = 4;
          break;
        case "utf8":
          this.fillLast = aM, e = 4;
          break;
        case "base64":
          this.text = lM, this.end = dM, e = 3;
          break;
        default:
          this.write = cM, this.end = pM;
          return;
      }
      this.lastNeed = 0, this.lastTotal = 0, this.lastChar = ih.allocUnsafe(e);
    }
    Xf.prototype.write = function(t) {
      if (t.length === 0)
        return "";
      var e, r;
      if (this.lastNeed) {
        if (e = this.fillLast(t), e === undefined)
          return "";
        r = this.lastNeed, this.lastNeed = 0;
      } else
        r = 0;
      return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || "";
    };
    Xf.prototype.end = sM;
    Xf.prototype.text = oM;
    Xf.prototype.fillLast = function(t) {
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length;
    };
    function rh(t) {
      return t <= 127 ? 0 : t >> 5 === 6 ? 2 : t >> 4 === 14 ? 3 : t >> 3 === 30 ? 4 : t >> 6 === 2 ? -1 : -2;
    }
    function nM(t, e, r) {
      var o2 = e.length - 1;
      if (o2 < r)
        return 0;
      var f2 = rh(e[o2]);
      return f2 >= 0 ? (f2 > 0 && (t.lastNeed = f2 - 1), f2) : --o2 < r || f2 === -2 ? 0 : (f2 = rh(e[o2]), f2 >= 0 ? (f2 > 0 && (t.lastNeed = f2 - 2), f2) : --o2 < r || f2 === -2 ? 0 : (f2 = rh(e[o2]), f2 >= 0 ? (f2 > 0 && (f2 === 2 ? f2 = 0 : t.lastNeed = f2 - 3), f2) : 0));
    }
    function fM(t, e, r) {
      if ((e[0] & 192) !== 128)
        return t.lastNeed = 0, "�";
      if (t.lastNeed > 1 && e.length > 1) {
        if ((e[1] & 192) !== 128)
          return t.lastNeed = 1, "�";
        if (t.lastNeed > 2 && e.length > 2 && (e[2] & 192) !== 128)
          return t.lastNeed = 2, "�";
      }
    }
    function aM(t) {
      var e = this.lastTotal - this.lastNeed, r = fM(this, t, e);
      if (r !== undefined)
        return r;
      if (this.lastNeed <= t.length)
        return t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
      t.copy(this.lastChar, e, 0, t.length), this.lastNeed -= t.length;
    }
    function oM(t, e) {
      var r = nM(this, t, e);
      if (!this.lastNeed)
        return t.toString("utf8", e);
      this.lastTotal = r;
      var o2 = t.length - (r - this.lastNeed);
      return t.copy(this.lastChar, 0, o2), t.toString("utf8", e, o2);
    }
    function sM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + "�" : e;
    }
    function hM(t, e) {
      if ((t.length - e) % 2 === 0) {
        var r = t.toString("utf16le", e);
        if (r) {
          var o2 = r.charCodeAt(r.length - 1);
          if (o2 >= 55296 && o2 <= 56319)
            return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1);
        }
        return r;
      }
      return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1);
    }
    function uM(t) {
      var e = t && t.length ? this.write(t) : "";
      if (this.lastNeed) {
        var r = this.lastTotal - this.lastNeed;
        return e + this.lastChar.toString("utf16le", 0, r);
      }
      return e;
    }
    function lM(t, e) {
      var r = (t.length - e) % 3;
      return r === 0 ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r));
    }
    function dM(t) {
      var e = t && t.length ? this.write(t) : "";
      return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e;
    }
    function cM(t) {
      return t.toString(this.encoding);
    }
    function pM(t) {
      return t && t.length ? this.write(t) : "";
    }
  });
  Jf = {};
  Ja(Jf, { StringDecoder: () => po.StringDecoder, default: () => po.StringDecoder });
  Qf = R0(() => {
    po = rn2(co());
  });
  vo = T((hI, Nc) => {
    var kc = sn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function vM(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o2 = new Array(r), f2 = 0;f2 < r; f2++)
            o2[f2] = arguments[f2];
          t.apply(this, o2);
        }
      };
    }
    function bM() {}
    function mM(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Lc(t, e, r) {
      if (typeof e == "function")
        return Lc(t, null, e);
      e || (e = {}), r = vM(r || bM);
      var o2 = e.readable || e.readable !== false && t.readable, f2 = e.writable || e.writable !== false && t.writable, p3 = function() {
        t.writable || y3();
      }, m4 = t._writableState && t._writableState.finished, y3 = function() {
        f2 = false, m4 = true, o2 || r.call(t);
      }, M4 = t._readableState && t._readableState.endEmitted, x3 = function() {
        o2 = false, M4 = true, f2 || r.call(t);
      }, S2 = function(L3) {
        r.call(t, L3);
      }, E6 = function() {
        var L3;
        if (o2 && !M4)
          return (!t._readableState || !t._readableState.ended) && (L3 = new kc), r.call(t, L3);
        if (f2 && !m4)
          return (!t._writableState || !t._writableState.ended) && (L3 = new kc), r.call(t, L3);
      }, B3 = function() {
        t.req.on("finish", y3);
      };
      return mM(t) ? (t.on("complete", y3), t.on("abort", E6), t.req ? B3() : t.on("request", B3)) : f2 && !t._writableState && (t.on("end", p3), t.on("close", p3)), t.on("end", x3), t.on("finish", y3), e.error !== false && t.on("error", S2), t.on("close", E6), function() {
        t.removeListener("complete", y3), t.removeListener("abort", E6), t.removeListener("request", B3), t.req && t.req.removeListener("finish", y3), t.removeListener("end", p3), t.removeListener("close", p3), t.removeListener("finish", y3), t.removeListener("end", x3), t.removeListener("error", S2), t.removeListener("close", E6);
      };
    }
    Nc.exports = Lc;
  });
  Pc = T((uI, Dc) => {
    var bo;
    function Ni2(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var gM = vo(), Di2 = Symbol("lastResolve"), un = Symbol("lastReject"), ea = Symbol("error"), mo = Symbol("ended"), ln = Symbol("lastPromise"), nh = Symbol("handlePromise"), dn = Symbol("stream");
    function Pi2(t, e) {
      return { value: t, done: e };
    }
    function yM(t) {
      var e = t[Di2];
      if (e !== null) {
        var r = t[dn].read();
        r !== null && (t[ln] = null, t[Di2] = null, t[un] = null, e(Pi2(r, false)));
      }
    }
    function wM(t) {
      process.nextTick(yM, t);
    }
    function MM(t, e) {
      return function(r, o2) {
        t.then(function() {
          if (e[mo]) {
            r(Pi2(undefined, true));
            return;
          }
          e[nh](r, o2);
        }, o2);
      };
    }
    var _M = Object.getPrototypeOf(function() {}), xM = Object.setPrototypeOf((bo = { get stream() {
      return this[dn];
    }, next: function() {
      var e = this, r = this[ea];
      if (r !== null)
        return Promise.reject(r);
      if (this[mo])
        return Promise.resolve(Pi2(undefined, true));
      if (this[dn].destroyed)
        return new Promise(function(m4, y3) {
          process.nextTick(function() {
            e[ea] ? y3(e[ea]) : m4(Pi2(undefined, true));
          });
        });
      var o2 = this[ln], f2;
      if (o2)
        f2 = new Promise(MM(o2, this));
      else {
        var p3 = this[dn].read();
        if (p3 !== null)
          return Promise.resolve(Pi2(p3, false));
        f2 = new Promise(this[nh]);
      }
      return this[ln] = f2, f2;
    } }, Ni2(bo, Symbol.asyncIterator, function() {
      return this;
    }), Ni2(bo, "return", function() {
      var e = this;
      return new Promise(function(r, o2) {
        e[dn].destroy(null, function(f2) {
          if (f2) {
            o2(f2);
            return;
          }
          r(Pi2(undefined, true));
        });
      });
    }), bo), _M), SM = function(e) {
      var r, o2 = Object.create(xM, (r = {}, Ni2(r, dn, { value: e, writable: true }), Ni2(r, Di2, { value: null, writable: true }), Ni2(r, un, { value: null, writable: true }), Ni2(r, ea, { value: null, writable: true }), Ni2(r, mo, { value: e._readableState.endEmitted, writable: true }), Ni2(r, nh, { value: function(p3, m4) {
        var y3 = o2[dn].read();
        y3 ? (o2[ln] = null, o2[Di2] = null, o2[un] = null, p3(Pi2(y3, false))) : (o2[Di2] = p3, o2[un] = m4);
      }, writable: true }), r));
      return o2[ln] = null, gM(e, function(f2) {
        if (f2 && f2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p3 = o2[un];
          p3 !== null && (o2[ln] = null, o2[Di2] = null, o2[un] = null, p3(f2)), o2[ea] = f2;
          return;
        }
        var m4 = o2[Di2];
        m4 !== null && (o2[ln] = null, o2[Di2] = null, o2[un] = null, m4(Pi2(undefined, true))), o2[mo] = true;
      }), e.on("readable", wM.bind(null, o2)), o2;
    };
    Dc.exports = SM;
  });
  Oc = T((lI, Cc) => {
    Cc.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  th = T((cI, $c) => {
    $c.exports = Ce;
    var tf2;
    Ce.ReadableState = Hc;
    var dI = ki().EventEmitter, zc = function(e, r) {
      return e.listeners(r).length;
    }, ra = W0(), go = Ut2().Buffer, EM = global.Uint8Array || function() {};
    function AM(t) {
      return go.from(t);
    }
    function RM(t) {
      return go.isBuffer(t) || t instanceof EM;
    }
    var fh = $f(), Ne;
    fh && fh.debuglog ? Ne = fh.debuglog("stream") : Ne = function() {};
    var BM = pc(), dh = Z0(), qM = V0(), IM = qM.getHighWaterMark, yo = sn().codes, TM = yo.ERR_INVALID_ARG_TYPE, kM = yo.ERR_STREAM_PUSH_AFTER_EOF, LM = yo.ERR_METHOD_NOT_IMPLEMENTED, NM = yo.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, rf, ah, oh;
    Ie()(Ce, ra);
    var ta = dh.errorOrDestroy, sh = ["error", "close", "destroy", "pause", "resume"];
    function DM(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Hc(t, e, r) {
      tf2 = tf2 || hn(), t = t || {}, typeof r != "boolean" && (r = e instanceof tf2), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = IM(this, t, "readableHighWaterMark", r), this.buffer = new BM, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (rf || (rf = (Qf(), ur2(Jf)).StringDecoder), this.decoder = new rf(t.encoding), this.encoding = t.encoding);
    }
    function Ce(t) {
      if (tf2 = tf2 || hn(), !(this instanceof Ce))
        return new Ce(t);
      var e = this instanceof tf2;
      this._readableState = new Hc(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), ra.call(this);
    }
    Object.defineProperty(Ce.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Ce.prototype.destroy = dh.destroy;
    Ce.prototype._undestroy = dh.undestroy;
    Ce.prototype._destroy = function(t, e) {
      e(t);
    };
    Ce.prototype.push = function(t, e) {
      var r = this._readableState, o2;
      return r.objectMode ? o2 = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = go.from(t, e), e = ""), o2 = true), Wc(this, t, e, false, o2);
    };
    Ce.prototype.unshift = function(t) {
      return Wc(this, t, null, true, false);
    };
    function Wc(t, e, r, o2, f2) {
      Ne("readableAddChunk", e);
      var p3 = t._readableState;
      if (e === null)
        p3.reading = false, OM(t, p3);
      else {
        var m4;
        if (f2 || (m4 = PM(p3, e)), m4)
          ta(t, m4);
        else if (p3.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p3.objectMode && Object.getPrototypeOf(e) !== go.prototype && (e = AM(e)), o2)
            p3.endEmitted ? ta(t, new NM) : hh(t, p3, e, true);
          else if (p3.ended)
            ta(t, new kM);
          else {
            if (p3.destroyed)
              return false;
            p3.reading = false, p3.decoder && !r ? (e = p3.decoder.write(e), p3.objectMode || e.length !== 0 ? hh(t, p3, e, false) : lh(t, p3)) : hh(t, p3, e, false);
          }
        else
          o2 || (p3.reading = false, lh(t, p3));
      }
      return !p3.ended && (p3.length < p3.highWaterMark || p3.length === 0);
    }
    function hh(t, e, r, o2) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && wo(t)), lh(t, e);
    }
    function PM(t, e) {
      var r;
      return !RM(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new TM("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Ce.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Ce.prototype.setEncoding = function(t) {
      rf || (rf = (Qf(), ur2(Jf)).StringDecoder);
      var e = new rf(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o2 = "";r !== null; )
        o2 += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o2 !== "" && this._readableState.buffer.push(o2), this._readableState.length = o2.length, this;
    };
    var Fc = 1073741824;
    function CM(t) {
      return t >= Fc ? t = Fc : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Uc2(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = CM(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Ce.prototype.read = function(t) {
      Ne("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Ne("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? uh(this) : wo(this), null;
      if (t = Uc2(t, e), t === 0 && e.ended)
        return e.length === 0 && uh(this), null;
      var o2 = e.needReadable;
      Ne("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, Ne("length less than watermark", o2)), e.ended || e.reading ? (o2 = false, Ne("reading or ended", o2)) : o2 && (Ne("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Uc2(r, e)));
      var f2;
      return t > 0 ? f2 = Zc(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && uh(this)), f2 !== null && this.emit("data", f2), f2;
    };
    function OM(t, e) {
      if (Ne("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? wo(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, Kc(t)));
      }
    }
    function wo(t) {
      var e = t._readableState;
      Ne("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Ne("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(Kc, t));
    }
    function Kc(t) {
      var e = t._readableState;
      Ne("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ch(t);
    }
    function lh(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(FM, t, e));
    }
    function FM(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (Ne("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Ce.prototype._read = function(t) {
      ta(this, new LM("_read()"));
    };
    Ce.prototype.pipe = function(t, e) {
      var r = this, o2 = this._readableState;
      switch (o2.pipesCount) {
        case 0:
          o2.pipes = t;
          break;
        case 1:
          o2.pipes = [o2.pipes, t];
          break;
        default:
          o2.pipes.push(t);
          break;
      }
      o2.pipesCount += 1, Ne("pipe count=%d opts=%j", o2.pipesCount, e);
      var f2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p3 = f2 ? y3 : ge;
      o2.endEmitted ? process.nextTick(p3) : r.once("end", p3), t.on("unpipe", m4);
      function m4(_e3, N5) {
        Ne("onunpipe"), _e3 === r && N5 && N5.hasUnpiped === false && (N5.hasUnpiped = true, S2());
      }
      function y3() {
        Ne("onend"), t.end();
      }
      var M4 = UM(r);
      t.on("drain", M4);
      var x3 = false;
      function S2() {
        Ne("cleanup"), t.removeListener("close", q), t.removeListener("finish", L3), t.removeListener("drain", M4), t.removeListener("error", B3), t.removeListener("unpipe", m4), r.removeListener("end", y3), r.removeListener("end", ge), r.removeListener("data", E6), x3 = true, o2.awaitDrain && (!t._writableState || t._writableState.needDrain) && M4();
      }
      r.on("data", E6);
      function E6(_e3) {
        Ne("ondata");
        var N5 = t.write(_e3);
        Ne("dest.write", N5), N5 === false && ((o2.pipesCount === 1 && o2.pipes === t || o2.pipesCount > 1 && Vc(o2.pipes, t) !== -1) && !x3 && (Ne("false write response, pause", o2.awaitDrain), o2.awaitDrain++), r.pause());
      }
      function B3(_e3) {
        Ne("onerror", _e3), ge(), t.removeListener("error", B3), zc(t, "error") === 0 && ta(t, _e3);
      }
      DM(t, "error", B3);
      function q() {
        t.removeListener("finish", L3), ge();
      }
      t.once("close", q);
      function L3() {
        Ne("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L3);
      function ge() {
        Ne("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o2.flowing || (Ne("pipe resume"), r.resume()), t;
    };
    function UM(t) {
      return function() {
        var r = t._readableState;
        Ne("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && zc(t, "data") && (r.flowing = true, ch(t));
      };
    }
    Ce.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o2, pipesCount: f2 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p3 = 0;p3 < f2; p3++)
          o2[p3].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m4 = Vc(e.pipes, t);
      return m4 === -1 ? this : (e.pipes.splice(m4, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Ce.prototype.on = function(t, e) {
      var r = ra.prototype.on.call(this, t, e), o2 = this._readableState;
      return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, Ne("on readable", o2.length, o2.reading), o2.length ? wo(this) : o2.reading || process.nextTick(zM, this)), r;
    };
    Ce.prototype.addListener = Ce.prototype.on;
    Ce.prototype.removeListener = function(t, e) {
      var r = ra.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(jc, this), r;
    };
    Ce.prototype.removeAllListeners = function(t) {
      var e = ra.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(jc, this), e;
    };
    function jc(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function zM(t) {
      Ne("readable nexttick read 0"), t.read(0);
    }
    Ce.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (Ne("resume"), t.flowing = !t.readableListening, HM(this, t)), t.paused = false, this;
    };
    function HM(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(WM, t, e));
    }
    function WM(t, e) {
      Ne("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ch(t), e.flowing && !e.reading && t.read(0);
    }
    Ce.prototype.pause = function() {
      return Ne("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Ne("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ch(t) {
      var e = t._readableState;
      for (Ne("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Ce.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o2 = false;
      t.on("end", function() {
        if (Ne("wrapped end"), r.decoder && !r.ended) {
          var m4 = r.decoder.end();
          m4 && m4.length && e.push(m4);
        }
        e.push(null);
      }), t.on("data", function(m4) {
        if (Ne("wrapped data"), r.decoder && (m4 = r.decoder.write(m4)), !(r.objectMode && m4 == null) && !(!r.objectMode && (!m4 || !m4.length))) {
          var y3 = e.push(m4);
          y3 || (o2 = true, t.pause());
        }
      });
      for (var f2 in t)
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = function(y3) {
          return function() {
            return t[y3].apply(t, arguments);
          };
        }(f2));
      for (var p3 = 0;p3 < sh.length; p3++)
        t.on(sh[p3], this.emit.bind(this, sh[p3]));
      return this._read = function(m4) {
        Ne("wrapped _read", m4), o2 && (o2 = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Ce.prototype[Symbol.asyncIterator] = function() {
      return ah === undefined && (ah = Pc()), ah(this);
    });
    Object.defineProperty(Ce.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Ce.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Ce.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Ce._fromList = Zc;
    Object.defineProperty(Ce.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Zc(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function uh(t) {
      var e = t._readableState;
      Ne("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(KM, e, t));
    }
    function KM(t, e) {
      if (Ne("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Ce.from = function(t, e) {
      return oh === undefined && (oh = Oc()), oh(Ce, t, e);
    });
    function Vc(t, e) {
      for (var r = 0, o2 = t.length;r < o2; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  ph = T((pI, Yc) => {
    Yc.exports = di3;
    var Mo2 = sn().codes, jM = Mo2.ERR_METHOD_NOT_IMPLEMENTED, ZM = Mo2.ERR_MULTIPLE_CALLBACK, VM = Mo2.ERR_TRANSFORM_ALREADY_TRANSFORMING, $M = Mo2.ERR_TRANSFORM_WITH_LENGTH_0, _o = hn();
    Ie()(di3, _o);
    function GM(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o2 = r.writecb;
      if (o2 === null)
        return this.emit("error", new ZM);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o2(t);
      var f2 = this._readableState;
      f2.reading = false, (f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
    }
    function di3(t) {
      if (!(this instanceof di3))
        return new di3(t);
      _o.call(this, t), this._transformState = { afterTransform: GM.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", YM);
    }
    function YM() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Gc(t, e, r);
      }) : Gc(this, null, null);
    }
    di3.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, _o.prototype.push.call(this, t, e);
    };
    di3.prototype._transform = function(t, e, r) {
      r(new jM("_transform()"));
    };
    di3.prototype._write = function(t, e, r) {
      var o2 = this._transformState;
      if (o2.writecb = r, o2.writechunk = t, o2.writeencoding = e, !o2.transforming) {
        var f2 = this._readableState;
        (o2.needTransform || f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
      }
    };
    di3.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    di3.prototype._destroy = function(t, e) {
      _o.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Gc(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new $M;
      if (t._transformState.transforming)
        throw new VM;
      return t.push(null);
    }
  });
  Qc = T((vI, Jc) => {
    Jc.exports = ia;
    var Xc = ph();
    Ie()(ia, Xc);
    function ia(t) {
      if (!(this instanceof ia))
        return new ia(t);
      Xc.call(this, t);
    }
    ia.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  np = T((bI, ip) => {
    var vh;
    function XM(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var rp = sn().codes, JM = rp.ERR_MISSING_ARGS, QM = rp.ERR_STREAM_DESTROYED;
    function ep(t) {
      if (t)
        throw t;
    }
    function e4(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function t4(t, e, r, o2) {
      o2 = XM(o2);
      var f2 = false;
      t.on("close", function() {
        f2 = true;
      }), vh === undefined && (vh = vo()), vh(t, { readable: e, writable: r }, function(m4) {
        if (m4)
          return o2(m4);
        f2 = true, o2();
      });
      var p3 = false;
      return function(m4) {
        if (!f2 && !p3) {
          if (p3 = true, e4(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o2(m4 || new QM("pipe"));
        }
      };
    }
    function tp(t) {
      t();
    }
    function r4(t, e) {
      return t.pipe(e);
    }
    function i4(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? ep : t.pop();
    }
    function n4() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o2 = i4(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new JM("streams");
      var f2, p3 = e.map(function(m4, y3) {
        var M4 = y3 < e.length - 1, x3 = y3 > 0;
        return t4(m4, M4, x3, function(S2) {
          f2 || (f2 = S2), S2 && p3.forEach(tp), !M4 && (p3.forEach(tp), o2(f2));
        });
      });
      return e.reduce(r4);
    }
    ip.exports = n4;
  });
  ap = T((cr2, fp) => {
    cr2 = fp.exports = th();
    cr2.Stream = cr2;
    cr2.Readable = cr2;
    cr2.Writable = J0();
    cr2.Duplex = hn();
    cr2.Transform = ph();
    cr2.PassThrough = Qc();
    cr2.finished = vo();
    cr2.pipeline = np();
  });
  bh = T((mI, sp) => {
    var xo = Te().Buffer, op = ap().Transform, f4 = Ie();
    function a4(t, e) {
      if (!xo.isBuffer(t) && typeof t != "string")
        throw new TypeError(e + " must be a string or a buffer");
    }
    function Ci(t) {
      op.call(this), this._block = xo.allocUnsafe(t), this._blockSize = t, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
    }
    f4(Ci, op);
    Ci.prototype._transform = function(t, e, r) {
      var o2 = null;
      try {
        this.update(t, e);
      } catch (f2) {
        o2 = f2;
      }
      r(o2);
    };
    Ci.prototype._flush = function(t) {
      var e = null;
      try {
        this.push(this.digest());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Ci.prototype.update = function(t, e) {
      if (a4(t, "Data"), this._finalized)
        throw new Error("Digest already called");
      xo.isBuffer(t) || (t = xo.from(t, e));
      for (var r = this._block, o2 = 0;this._blockOffset + t.length - o2 >= this._blockSize; ) {
        for (var f2 = this._blockOffset;f2 < this._blockSize; )
          r[f2++] = t[o2++];
        this._update(), this._blockOffset = 0;
      }
      for (;o2 < t.length; )
        r[this._blockOffset++] = t[o2++];
      for (var p3 = 0, m4 = t.length * 8;m4 > 0; ++p3)
        this._length[p3] += m4, m4 = this._length[p3] / 4294967296 | 0, m4 > 0 && (this._length[p3] -= 4294967296 * m4);
      return this;
    };
    Ci.prototype._update = function() {
      throw new Error("_update is not implemented");
    };
    Ci.prototype.digest = function(t) {
      if (this._finalized)
        throw new Error("Digest already called");
      this._finalized = true;
      var e = this._digest();
      t !== undefined && (e = e.toString(t)), this._block.fill(0), this._blockOffset = 0;
      for (var r = 0;r < 4; ++r)
        this._length[r] = 0;
      return e;
    };
    Ci.prototype._digest = function() {
      throw new Error("_digest is not implemented");
    };
    sp.exports = Ci;
  });
  Ao = T((gI, up) => {
    var o4 = Ie(), hp = bh(), s4 = Te().Buffer, h4 = new Array(16);
    function So() {
      hp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
    }
    o4(So, hp);
    So.prototype._update = function() {
      for (var t = h4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      var r = this._a, o2 = this._b, f2 = this._c, p3 = this._d;
      r = jt2(r, o2, f2, p3, t[0], 3614090360, 7), p3 = jt2(p3, r, o2, f2, t[1], 3905402710, 12), f2 = jt2(f2, p3, r, o2, t[2], 606105819, 17), o2 = jt2(o2, f2, p3, r, t[3], 3250441966, 22), r = jt2(r, o2, f2, p3, t[4], 4118548399, 7), p3 = jt2(p3, r, o2, f2, t[5], 1200080426, 12), f2 = jt2(f2, p3, r, o2, t[6], 2821735955, 17), o2 = jt2(o2, f2, p3, r, t[7], 4249261313, 22), r = jt2(r, o2, f2, p3, t[8], 1770035416, 7), p3 = jt2(p3, r, o2, f2, t[9], 2336552879, 12), f2 = jt2(f2, p3, r, o2, t[10], 4294925233, 17), o2 = jt2(o2, f2, p3, r, t[11], 2304563134, 22), r = jt2(r, o2, f2, p3, t[12], 1804603682, 7), p3 = jt2(p3, r, o2, f2, t[13], 4254626195, 12), f2 = jt2(f2, p3, r, o2, t[14], 2792965006, 17), o2 = jt2(o2, f2, p3, r, t[15], 1236535329, 22), r = Zt(r, o2, f2, p3, t[1], 4129170786, 5), p3 = Zt(p3, r, o2, f2, t[6], 3225465664, 9), f2 = Zt(f2, p3, r, o2, t[11], 643717713, 14), o2 = Zt(o2, f2, p3, r, t[0], 3921069994, 20), r = Zt(r, o2, f2, p3, t[5], 3593408605, 5), p3 = Zt(p3, r, o2, f2, t[10], 38016083, 9), f2 = Zt(f2, p3, r, o2, t[15], 3634488961, 14), o2 = Zt(o2, f2, p3, r, t[4], 3889429448, 20), r = Zt(r, o2, f2, p3, t[9], 568446438, 5), p3 = Zt(p3, r, o2, f2, t[14], 3275163606, 9), f2 = Zt(f2, p3, r, o2, t[3], 4107603335, 14), o2 = Zt(o2, f2, p3, r, t[8], 1163531501, 20), r = Zt(r, o2, f2, p3, t[13], 2850285829, 5), p3 = Zt(p3, r, o2, f2, t[2], 4243563512, 9), f2 = Zt(f2, p3, r, o2, t[7], 1735328473, 14), o2 = Zt(o2, f2, p3, r, t[12], 2368359562, 20), r = Vt2(r, o2, f2, p3, t[5], 4294588738, 4), p3 = Vt2(p3, r, o2, f2, t[8], 2272392833, 11), f2 = Vt2(f2, p3, r, o2, t[11], 1839030562, 16), o2 = Vt2(o2, f2, p3, r, t[14], 4259657740, 23), r = Vt2(r, o2, f2, p3, t[1], 2763975236, 4), p3 = Vt2(p3, r, o2, f2, t[4], 1272893353, 11), f2 = Vt2(f2, p3, r, o2, t[7], 4139469664, 16), o2 = Vt2(o2, f2, p3, r, t[10], 3200236656, 23), r = Vt2(r, o2, f2, p3, t[13], 681279174, 4), p3 = Vt2(p3, r, o2, f2, t[0], 3936430074, 11), f2 = Vt2(f2, p3, r, o2, t[3], 3572445317, 16), o2 = Vt2(o2, f2, p3, r, t[6], 76029189, 23), r = Vt2(r, o2, f2, p3, t[9], 3654602809, 4), p3 = Vt2(p3, r, o2, f2, t[12], 3873151461, 11), f2 = Vt2(f2, p3, r, o2, t[15], 530742520, 16), o2 = Vt2(o2, f2, p3, r, t[2], 3299628645, 23), r = $t(r, o2, f2, p3, t[0], 4096336452, 6), p3 = $t(p3, r, o2, f2, t[7], 1126891415, 10), f2 = $t(f2, p3, r, o2, t[14], 2878612391, 15), o2 = $t(o2, f2, p3, r, t[5], 4237533241, 21), r = $t(r, o2, f2, p3, t[12], 1700485571, 6), p3 = $t(p3, r, o2, f2, t[3], 2399980690, 10), f2 = $t(f2, p3, r, o2, t[10], 4293915773, 15), o2 = $t(o2, f2, p3, r, t[1], 2240044497, 21), r = $t(r, o2, f2, p3, t[8], 1873313359, 6), p3 = $t(p3, r, o2, f2, t[15], 4264355552, 10), f2 = $t(f2, p3, r, o2, t[6], 2734768916, 15), o2 = $t(o2, f2, p3, r, t[13], 1309151649, 21), r = $t(r, o2, f2, p3, t[4], 4149444226, 6), p3 = $t(p3, r, o2, f2, t[11], 3174756917, 10), f2 = $t(f2, p3, r, o2, t[2], 718787259, 15), o2 = $t(o2, f2, p3, r, t[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + o2 | 0, this._c = this._c + f2 | 0, this._d = this._d + p3 | 0;
    };
    So.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = s4.allocUnsafe(16);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t;
    };
    function Eo(t, e) {
      return t << e | t >>> 32 - e;
    }
    function jt2(t, e, r, o2, f2, p3, m4) {
      return Eo(t + (e & r | ~e & o2) + f2 + p3 | 0, m4) + e | 0;
    }
    function Zt(t, e, r, o2, f2, p3, m4) {
      return Eo(t + (e & o2 | r & ~o2) + f2 + p3 | 0, m4) + e | 0;
    }
    function Vt2(t, e, r, o2, f2, p3, m4) {
      return Eo(t + (e ^ r ^ o2) + f2 + p3 | 0, m4) + e | 0;
    }
    function $t(t, e, r, o2, f2, p3, m4) {
      return Eo(t + (r ^ (e | ~o2)) + f2 + p3 | 0, m4) + e | 0;
    }
    up.exports = So;
  });
  Bo = T((yI, mp) => {
    var mh = Ut2().Buffer, u4 = Ie(), bp = bh(), l4 = new Array(16), na = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], fa = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], aa = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], oa = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11], sa = [0, 1518500249, 1859775393, 2400959708, 2840853838], ha = [1352829926, 1548603684, 1836072691, 2053994217, 0];
    function Ro() {
      bp.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
    }
    u4(Ro, bp);
    Ro.prototype._update = function() {
      for (var t = l4, e = 0;e < 16; ++e)
        t[e] = this._block.readInt32LE(e * 4);
      for (var r = this._a | 0, o2 = this._b | 0, f2 = this._c | 0, p3 = this._d | 0, m4 = this._e | 0, y3 = this._a | 0, M4 = this._b | 0, x3 = this._c | 0, S2 = this._d | 0, E6 = this._e | 0, B3 = 0;B3 < 80; B3 += 1) {
        var q, L3;
        B3 < 16 ? (q = lp(r, o2, f2, p3, m4, t[na[B3]], sa[0], aa[B3]), L3 = vp(y3, M4, x3, S2, E6, t[fa[B3]], ha[0], oa[B3])) : B3 < 32 ? (q = dp(r, o2, f2, p3, m4, t[na[B3]], sa[1], aa[B3]), L3 = pp(y3, M4, x3, S2, E6, t[fa[B3]], ha[1], oa[B3])) : B3 < 48 ? (q = cp(r, o2, f2, p3, m4, t[na[B3]], sa[2], aa[B3]), L3 = cp(y3, M4, x3, S2, E6, t[fa[B3]], ha[2], oa[B3])) : B3 < 64 ? (q = pp(r, o2, f2, p3, m4, t[na[B3]], sa[3], aa[B3]), L3 = dp(y3, M4, x3, S2, E6, t[fa[B3]], ha[3], oa[B3])) : (q = vp(r, o2, f2, p3, m4, t[na[B3]], sa[4], aa[B3]), L3 = lp(y3, M4, x3, S2, E6, t[fa[B3]], ha[4], oa[B3])), r = m4, m4 = p3, p3 = cn2(f2, 10), f2 = o2, o2 = q, y3 = E6, E6 = S2, S2 = cn2(x3, 10), x3 = M4, M4 = L3;
      }
      var ge = this._b + f2 + S2 | 0;
      this._b = this._c + p3 + E6 | 0, this._c = this._d + m4 + y3 | 0, this._d = this._e + r + M4 | 0, this._e = this._a + o2 + x3 | 0, this._a = ge;
    };
    Ro.prototype._digest = function() {
      this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
      var t = mh.alloc ? mh.alloc(20) : new mh(20);
      return t.writeInt32LE(this._a, 0), t.writeInt32LE(this._b, 4), t.writeInt32LE(this._c, 8), t.writeInt32LE(this._d, 12), t.writeInt32LE(this._e, 16), t;
    };
    function cn2(t, e) {
      return t << e | t >>> 32 - e;
    }
    function lp(t, e, r, o2, f2, p3, m4, y3) {
      return cn2(t + (e ^ r ^ o2) + p3 + m4 | 0, y3) + f2 | 0;
    }
    function dp(t, e, r, o2, f2, p3, m4, y3) {
      return cn2(t + (e & r | ~e & o2) + p3 + m4 | 0, y3) + f2 | 0;
    }
    function cp(t, e, r, o2, f2, p3, m4, y3) {
      return cn2(t + ((e | ~r) ^ o2) + p3 + m4 | 0, y3) + f2 | 0;
    }
    function pp(t, e, r, o2, f2, p3, m4, y3) {
      return cn2(t + (e & o2 | r & ~o2) + p3 + m4 | 0, y3) + f2 | 0;
    }
    function vp(t, e, r, o2, f2, p3, m4, y3) {
      return cn2(t + (e ^ (r | ~o2)) + p3 + m4 | 0, y3) + f2 | 0;
    }
    mp.exports = Ro;
  });
  pn2 = T((wI, yp) => {
    var gp = Te().Buffer;
    function qo(t, e) {
      this._block = gp.alloc(t), this._finalSize = e, this._blockSize = t, this._len = 0;
    }
    qo.prototype.update = function(t, e) {
      typeof t == "string" && (e = e || "utf8", t = gp.from(t, e));
      for (var r = this._block, o2 = this._blockSize, f2 = t.length, p3 = this._len, m4 = 0;m4 < f2; ) {
        for (var y3 = p3 % o2, M4 = Math.min(f2 - m4, o2 - y3), x3 = 0;x3 < M4; x3++)
          r[y3 + x3] = t[m4 + x3];
        p3 += M4, m4 += M4, p3 % o2 === 0 && this._update(r);
      }
      return this._len += f2, this;
    };
    qo.prototype.digest = function(t) {
      var e = this._len % this._blockSize;
      this._block[e] = 128, this._block.fill(0, e + 1), e >= this._finalSize && (this._update(this._block), this._block.fill(0));
      var r = this._len * 8;
      if (r <= 4294967295)
        this._block.writeUInt32BE(r, this._blockSize - 4);
      else {
        var o2 = (r & 4294967295) >>> 0, f2 = (r - o2) / 4294967296;
        this._block.writeUInt32BE(f2, this._blockSize - 8), this._block.writeUInt32BE(o2, this._blockSize - 4);
      }
      this._update(this._block);
      var p3 = this._hash();
      return t ? p3.toString(t) : p3;
    };
    qo.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    yp.exports = qo;
  });
  _p = T((MI, Mp) => {
    var d4 = Ie(), wp = pn2(), c4 = Te().Buffer, p4 = [1518500249, 1859775393, -1894007588, -899497514], v4 = new Array(80);
    function ua() {
      this.init(), this._w = v4, wp.call(this, 64, 56);
    }
    d4(ua, wp);
    ua.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function b42(t) {
      return t << 5 | t >>> 27;
    }
    function m4(t) {
      return t << 30 | t >>> 2;
    }
    function g4(t, e, r, o2) {
      return t === 0 ? e & r | ~e & o2 : t === 2 ? e & r | e & o2 | r & o2 : e ^ r ^ o2;
    }
    ua.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f2 = this._c | 0, p3 = this._d | 0, m5 = this._e | 0, y3 = 0;y3 < 16; ++y3)
        e[y3] = t.readInt32BE(y3 * 4);
      for (;y3 < 80; ++y3)
        e[y3] = e[y3 - 3] ^ e[y3 - 8] ^ e[y3 - 14] ^ e[y3 - 16];
      for (var M4 = 0;M4 < 80; ++M4) {
        var x3 = ~~(M4 / 20), S2 = b42(r) + g4(x3, o2, f2, p3) + m5 + e[M4] + p4[x3] | 0;
        m5 = p3, p3 = f2, f2 = m4(o2), o2 = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f2 + this._c | 0, this._d = p3 + this._d | 0, this._e = m5 + this._e | 0;
    };
    ua.prototype._hash = function() {
      var t = c4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Mp.exports = ua;
  });
  Ep = T((_I, Sp) => {
    var y4 = Ie(), xp = pn2(), w4 = Te().Buffer, M4 = [1518500249, 1859775393, -1894007588, -899497514], _4 = new Array(80);
    function la() {
      this.init(), this._w = _4, xp.call(this, 64, 56);
    }
    y4(la, xp);
    la.prototype.init = function() {
      return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
    };
    function x4(t) {
      return t << 1 | t >>> 31;
    }
    function S4(t) {
      return t << 5 | t >>> 27;
    }
    function E42(t) {
      return t << 30 | t >>> 2;
    }
    function A4(t, e, r, o2) {
      return t === 0 ? e & r | ~e & o2 : t === 2 ? e & r | e & o2 | r & o2 : e ^ r ^ o2;
    }
    la.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f2 = this._c | 0, p3 = this._d | 0, m4 = this._e | 0, y3 = 0;y3 < 16; ++y3)
        e[y3] = t.readInt32BE(y3 * 4);
      for (;y3 < 80; ++y3)
        e[y3] = x4(e[y3 - 3] ^ e[y3 - 8] ^ e[y3 - 14] ^ e[y3 - 16]);
      for (var M5 = 0;M5 < 80; ++M5) {
        var x3 = ~~(M5 / 20), S2 = S4(r) + A4(x3, o2, f2, p3) + m4 + e[M5] + M4[x3] | 0;
        m4 = p3, p3 = f2, f2 = E42(o2), o2 = r, r = S2;
      }
      this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f2 + this._c | 0, this._d = p3 + this._d | 0, this._e = m4 + this._e | 0;
    };
    la.prototype._hash = function() {
      var t = w4.allocUnsafe(20);
      return t.writeInt32BE(this._a | 0, 0), t.writeInt32BE(this._b | 0, 4), t.writeInt32BE(this._c | 0, 8), t.writeInt32BE(this._d | 0, 12), t.writeInt32BE(this._e | 0, 16), t;
    };
    Sp.exports = la;
  });
  gh = T((xI, Rp) => {
    var R4 = Ie(), Ap = pn2(), B4 = Te().Buffer, q4 = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298], I4 = new Array(64);
    function da() {
      this.init(), this._w = I4, Ap.call(this, 64, 56);
    }
    R4(da, Ap);
    da.prototype.init = function() {
      return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
    };
    function T4(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function k4(t, e, r) {
      return t & e | r & (t | e);
    }
    function L4(t) {
      return (t >>> 2 | t << 30) ^ (t >>> 13 | t << 19) ^ (t >>> 22 | t << 10);
    }
    function N42(t) {
      return (t >>> 6 | t << 26) ^ (t >>> 11 | t << 21) ^ (t >>> 25 | t << 7);
    }
    function D4(t) {
      return (t >>> 7 | t << 25) ^ (t >>> 18 | t << 14) ^ t >>> 3;
    }
    function P4(t) {
      return (t >>> 17 | t << 15) ^ (t >>> 19 | t << 13) ^ t >>> 10;
    }
    da.prototype._update = function(t) {
      for (var e = this._w, r = this._a | 0, o2 = this._b | 0, f2 = this._c | 0, p3 = this._d | 0, m4 = this._e | 0, y3 = this._f | 0, M4 = this._g | 0, x3 = this._h | 0, S2 = 0;S2 < 16; ++S2)
        e[S2] = t.readInt32BE(S2 * 4);
      for (;S2 < 64; ++S2)
        e[S2] = P4(e[S2 - 2]) + e[S2 - 7] + D4(e[S2 - 15]) + e[S2 - 16] | 0;
      for (var E6 = 0;E6 < 64; ++E6) {
        var B3 = x3 + N42(m4) + T4(m4, y3, M4) + q4[E6] + e[E6] | 0, q = L4(r) + k4(r, o2, f2) | 0;
        x3 = M4, M4 = y3, y3 = m4, m4 = p3 + B3 | 0, p3 = f2, f2 = o2, o2 = r, r = B3 + q | 0;
      }
      this._a = r + this._a | 0, this._b = o2 + this._b | 0, this._c = f2 + this._c | 0, this._d = p3 + this._d | 0, this._e = m4 + this._e | 0, this._f = y3 + this._f | 0, this._g = M4 + this._g | 0, this._h = x3 + this._h | 0;
    };
    da.prototype._hash = function() {
      var t = B4.allocUnsafe(32);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t.writeInt32BE(this._h, 28), t;
    };
    Rp.exports = da;
  });
  qp = T((SI, Bp) => {
    var C4 = Ie(), O4 = gh(), F4 = pn2(), U4 = Te().Buffer, z4 = new Array(64);
    function Io() {
      this.init(), this._w = z4, F4.call(this, 64, 56);
    }
    C4(Io, O4);
    Io.prototype.init = function() {
      return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
    };
    Io.prototype._hash = function() {
      var t = U4.allocUnsafe(28);
      return t.writeInt32BE(this._a, 0), t.writeInt32BE(this._b, 4), t.writeInt32BE(this._c, 8), t.writeInt32BE(this._d, 12), t.writeInt32BE(this._e, 16), t.writeInt32BE(this._f, 20), t.writeInt32BE(this._g, 24), t;
    };
    Bp.exports = Io;
  });
  yh = T((EI, Pp) => {
    var H4 = Ie(), Dp = pn2(), W4 = Te().Buffer, Ip = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591], K4 = new Array(160);
    function ca() {
      this.init(), this._w = K4, Dp.call(this, 128, 112);
    }
    H4(ca, Dp);
    ca.prototype.init = function() {
      return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
    };
    function Tp(t, e, r) {
      return r ^ t & (e ^ r);
    }
    function kp(t, e, r) {
      return t & e | r & (t | e);
    }
    function Lp(t, e) {
      return (t >>> 28 | e << 4) ^ (e >>> 2 | t << 30) ^ (e >>> 7 | t << 25);
    }
    function Np(t, e) {
      return (t >>> 14 | e << 18) ^ (t >>> 18 | e << 14) ^ (e >>> 9 | t << 23);
    }
    function j4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ t >>> 7;
    }
    function Z4(t, e) {
      return (t >>> 1 | e << 31) ^ (t >>> 8 | e << 24) ^ (t >>> 7 | e << 25);
    }
    function V4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ t >>> 6;
    }
    function $4(t, e) {
      return (t >>> 19 | e << 13) ^ (e >>> 29 | t << 3) ^ (t >>> 6 | e << 26);
    }
    function Pt(t, e) {
      return t >>> 0 < e >>> 0 ? 1 : 0;
    }
    ca.prototype._update = function(t) {
      for (var e = this._w, r = this._ah | 0, o2 = this._bh | 0, f2 = this._ch | 0, p3 = this._dh | 0, m4 = this._eh | 0, y3 = this._fh | 0, M4 = this._gh | 0, x3 = this._hh | 0, S2 = this._al | 0, E6 = this._bl | 0, B3 = this._cl | 0, q = this._dl | 0, L3 = this._el | 0, ge = this._fl | 0, _e3 = this._gl | 0, N5 = this._hl | 0, we = 0;we < 32; we += 2)
        e[we] = t.readInt32BE(we * 4), e[we + 1] = t.readInt32BE(we * 4 + 4);
      for (;we < 160; we += 2) {
        var ye = e[we - 30], xe = e[we - 15 * 2 + 1], Re = j4(ye, xe), Ee = Z4(xe, ye);
        ye = e[we - 2 * 2], xe = e[we - 2 * 2 + 1];
        var Ae2 = V4(ye, xe), P2 = $4(xe, ye), Se3 = e[we - 7 * 2], v2 = e[we - 7 * 2 + 1], i = e[we - 16 * 2], a3 = e[we - 16 * 2 + 1], h3 = Ee + v2 | 0, s2 = Re + Se3 + Pt(h3, Ee) | 0;
        h3 = h3 + P2 | 0, s2 = s2 + Ae2 + Pt(h3, P2) | 0, h3 = h3 + a3 | 0, s2 = s2 + i + Pt(h3, a3) | 0, e[we] = s2, e[we + 1] = h3;
      }
      for (var u2 = 0;u2 < 160; u2 += 2) {
        s2 = e[u2], h3 = e[u2 + 1];
        var c2 = kp(r, o2, f2), b5 = kp(S2, E6, B3), l3 = Lp(r, S2), n = Lp(S2, r), d3 = Np(m4, L3), w3 = Np(L3, m4), g3 = Ip[u2], _3 = Ip[u2 + 1], A3 = Tp(m4, y3, M4), R2 = Tp(L3, ge, _e3), I4 = N5 + w3 | 0, Me = x3 + d3 + Pt(I4, N5) | 0;
        I4 = I4 + R2 | 0, Me = Me + A3 + Pt(I4, R2) | 0, I4 = I4 + _3 | 0, Me = Me + g3 + Pt(I4, _3) | 0, I4 = I4 + h3 | 0, Me = Me + s2 + Pt(I4, h3) | 0;
        var k4 = n + b5 | 0, D2 = l3 + c2 + Pt(k4, n) | 0;
        x3 = M4, N5 = _e3, M4 = y3, _e3 = ge, y3 = m4, ge = L3, L3 = q + I4 | 0, m4 = p3 + Me + Pt(L3, q) | 0, p3 = f2, q = B3, f2 = o2, B3 = E6, o2 = r, E6 = S2, S2 = I4 + k4 | 0, r = Me + D2 + Pt(S2, I4) | 0;
      }
      this._al = this._al + S2 | 0, this._bl = this._bl + E6 | 0, this._cl = this._cl + B3 | 0, this._dl = this._dl + q | 0, this._el = this._el + L3 | 0, this._fl = this._fl + ge | 0, this._gl = this._gl + _e3 | 0, this._hl = this._hl + N5 | 0, this._ah = this._ah + r + Pt(this._al, S2) | 0, this._bh = this._bh + o2 + Pt(this._bl, E6) | 0, this._ch = this._ch + f2 + Pt(this._cl, B3) | 0, this._dh = this._dh + p3 + Pt(this._dl, q) | 0, this._eh = this._eh + m4 + Pt(this._el, L3) | 0, this._fh = this._fh + y3 + Pt(this._fl, ge) | 0, this._gh = this._gh + M4 + Pt(this._gl, _e3) | 0, this._hh = this._hh + x3 + Pt(this._hl, N5) | 0;
    };
    ca.prototype._hash = function() {
      var t = W4.allocUnsafe(64);
      function e(r, o2, f2) {
        t.writeInt32BE(r, f2), t.writeInt32BE(o2, f2 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), e(this._gh, this._gl, 48), e(this._hh, this._hl, 56), t;
    };
    Pp.exports = ca;
  });
  Op = T((AI, Cp) => {
    var G4 = Ie(), Y4 = yh(), X4 = pn2(), J4 = Te().Buffer, Q4 = new Array(160);
    function To() {
      this.init(), this._w = Q4, X4.call(this, 128, 112);
    }
    G4(To, Y4);
    To.prototype.init = function() {
      return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
    };
    To.prototype._hash = function() {
      var t = J4.allocUnsafe(48);
      function e(r, o2, f2) {
        t.writeInt32BE(r, f2), t.writeInt32BE(o2, f2 + 4);
      }
      return e(this._ah, this._al, 0), e(this._bh, this._bl, 8), e(this._ch, this._cl, 16), e(this._dh, this._dl, 24), e(this._eh, this._el, 32), e(this._fh, this._fl, 40), t;
    };
    Cp.exports = To;
  });
  ko = T((ci2, Fp) => {
    var ci2 = Fp.exports = function(e) {
      e = e.toLowerCase();
      var r = ci2[e];
      if (!r)
        throw new Error(e + " is not supported (we accept pull requests)");
      return new r;
    };
    ci2.sha = _p();
    ci2.sha1 = Ep();
    ci2.sha224 = qp();
    ci2.sha256 = gh();
    ci2.sha384 = Op();
    ci2.sha512 = yh();
  });
  Tt3 = T((RI, Up) => {
    Up.exports = { ArrayIsArray(t) {
      return Array.isArray(t);
    }, ArrayPrototypeIncludes(t, e) {
      return t.includes(e);
    }, ArrayPrototypeIndexOf(t, e) {
      return t.indexOf(e);
    }, ArrayPrototypeJoin(t, e) {
      return t.join(e);
    }, ArrayPrototypeMap(t, e) {
      return t.map(e);
    }, ArrayPrototypePop(t, e) {
      return t.pop(e);
    }, ArrayPrototypePush(t, e) {
      return t.push(e);
    }, ArrayPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, Error, FunctionPrototypeCall(t, e, ...r) {
      return t.call(e, ...r);
    }, FunctionPrototypeSymbolHasInstance(t, e) {
      return Function.prototype[Symbol.hasInstance].call(t, e);
    }, MathFloor: Math.floor, Number, NumberIsInteger: Number.isInteger, NumberIsNaN: Number.isNaN, NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER, NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER, NumberParseInt: Number.parseInt, ObjectDefineProperties(t, e) {
      return Object.defineProperties(t, e);
    }, ObjectDefineProperty(t, e, r) {
      return Object.defineProperty(t, e, r);
    }, ObjectGetOwnPropertyDescriptor(t, e) {
      return Object.getOwnPropertyDescriptor(t, e);
    }, ObjectKeys(t) {
      return Object.keys(t);
    }, ObjectSetPrototypeOf(t, e) {
      return Object.setPrototypeOf(t, e);
    }, Promise, PromisePrototypeCatch(t, e) {
      return t.catch(e);
    }, PromisePrototypeThen(t, e, r) {
      return t.then(e, r);
    }, PromiseReject(t) {
      return Promise.reject(t);
    }, ReflectApply: Reflect.apply, RegExpPrototypeTest(t, e) {
      return t.test(e);
    }, SafeSet: Set, String, StringPrototypeSlice(t, e, r) {
      return t.slice(e, r);
    }, StringPrototypeToLowerCase(t) {
      return t.toLowerCase();
    }, StringPrototypeToUpperCase(t) {
      return t.toUpperCase();
    }, StringPrototypeTrim(t) {
      return t.trim();
    }, Symbol, SymbolAsyncIterator: Symbol.asyncIterator, SymbolHasInstance: Symbol.hasInstance, SymbolIterator: Symbol.iterator, TypedArrayPrototypeSet(t, e, r) {
      return t.set(e, r);
    }, Uint8Array };
  });
  Gr2 = T((BI, Mh) => {
    var e_ = Ut2(), t_ = Object.getPrototypeOf(async function() {}).constructor, zp = globalThis.Blob || e_.Blob, r_ = typeof zp < "u" ? function(e) {
      return e instanceof zp;
    } : function(e) {
      return false;
    }, wh = class extends Error {
      constructor(e) {
        if (!Array.isArray(e))
          throw new TypeError(`Expected input to be an Array, got ${typeof e}`);
        let r = "";
        for (let o2 = 0;o2 < e.length; o2++)
          r += `    ${e[o2].stack}
`;
        super(r), this.name = "AggregateError", this.errors = e;
      }
    };
    Mh.exports = { AggregateError: wh, kEmptyObject: Object.freeze({}), once(t) {
      let e = false;
      return function(...r) {
        e || (e = true, t.apply(this, r));
      };
    }, createDeferredPromise: function() {
      let t, e;
      return { promise: new Promise((o2, f2) => {
        t = o2, e = f2;
      }), resolve: t, reject: e };
    }, promisify(t) {
      return new Promise((e, r) => {
        t((o2, ...f2) => o2 ? r(o2) : e(...f2));
      });
    }, debuglog() {
      return function() {};
    }, format(t, ...e) {
      return t.replace(/%([sdifj])/g, function(...[r, o2]) {
        let f2 = e.shift();
        return o2 === "f" ? f2.toFixed(6) : o2 === "j" ? JSON.stringify(f2) : o2 === "s" && typeof f2 == "object" ? `${f2.constructor !== Object ? f2.constructor.name : ""} {}`.trim() : f2.toString();
      });
    }, inspect(t) {
      switch (typeof t) {
        case "string":
          if (t.includes("'"))
            if (t.includes('"')) {
              if (!t.includes("`") && !t.includes("${"))
                return `\`${t}\``;
            } else
              return `"${t}"`;
          return `'${t}'`;
        case "number":
          return isNaN(t) ? "NaN" : Object.is(t, -0) ? String(t) : t;
        case "bigint":
          return `${String(t)}n`;
        case "boolean":
        case "undefined":
          return String(t);
        case "object":
          return "{}";
      }
    }, types: { isAsyncFunction(t) {
      return t instanceof t_;
    }, isArrayBufferView(t) {
      return ArrayBuffer.isView(t);
    } }, isBlob: r_ };
    Mh.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  });
  No = T((qI, Lo) => {
    var { AbortController: Hp, AbortSignal: i_ } = typeof self < "u" ? self : typeof window < "u" ? window : undefined;
    Lo.exports = Hp;
    Lo.exports.AbortSignal = i_;
    Lo.exports.default = Hp;
  });
  Jt = T((II, jp) => {
    var { format: n_, inspect: Do, AggregateError: f_ } = Gr2(), a_ = globalThis.AggregateError || f_, o_ = Symbol("kIsNodeError"), s_ = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"], h_ = /^([A-Z][a-z0-9]*)+$/, u_ = "__node_internal_", Po = {};
    function vn(t, e) {
      if (!t)
        throw new Po.ERR_INTERNAL_ASSERTION(e);
    }
    function Wp(t) {
      let e = "", r = t.length, o2 = t[0] === "-" ? 1 : 0;
      for (;r >= o2 + 4; r -= 3)
        e = `_${t.slice(r - 3, r)}${e}`;
      return `${t.slice(0, r)}${e}`;
    }
    function l_(t, e, r) {
      if (typeof e == "function")
        return vn(e.length <= r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${e.length}).`), e(...r);
      let o2 = (e.match(/%[dfijoOs]/g) || []).length;
      return vn(o2 === r.length, `Code: ${t}; The provided arguments length (${r.length}) does not match the required ones (${o2}).`), r.length === 0 ? e : n_(e, ...r);
    }
    function zt(t, e, r) {
      r || (r = Error);

      class o2 extends r {
        constructor(...p3) {
          super(l_(t, e, p3));
        }
        toString() {
          return `${this.name} [${t}]: ${this.message}`;
        }
      }
      Object.defineProperties(o2.prototype, { name: { value: r.name, writable: true, enumerable: false, configurable: true }, toString: { value() {
        return `${this.name} [${t}]: ${this.message}`;
      }, writable: true, enumerable: false, configurable: true } }), o2.prototype.code = t, o2.prototype[o_] = true, Po[t] = o2;
    }
    function Kp(t) {
      let e = u_ + t.name;
      return Object.defineProperty(t, "name", { value: e }), t;
    }
    function d_(t, e) {
      if (t && e && t !== e) {
        if (Array.isArray(e.errors))
          return e.errors.push(t), e;
        let r = new a_([e, t], e.message);
        return r.code = e.code, r;
      }
      return t || e;
    }
    var _h = class extends Error {
      constructor(e = "The operation was aborted", r = undefined) {
        if (r !== undefined && typeof r != "object")
          throw new Po.ERR_INVALID_ARG_TYPE("options", "Object", r);
        super(e, r), this.code = "ABORT_ERR", this.name = "AbortError";
      }
    };
    zt("ERR_ASSERTION", "%s", Error);
    zt("ERR_INVALID_ARG_TYPE", (t, e, r) => {
      vn(typeof t == "string", "'name' must be a string"), Array.isArray(e) || (e = [e]);
      let o2 = "The ";
      t.endsWith(" argument") ? o2 += `${t} ` : o2 += `"${t}" ${t.includes(".") ? "property" : "argument"} `, o2 += "must be ";
      let f2 = [], p3 = [], m4 = [];
      for (let M4 of e)
        vn(typeof M4 == "string", "All expected entries have to be of type string"), s_.includes(M4) ? f2.push(M4.toLowerCase()) : h_.test(M4) ? p3.push(M4) : (vn(M4 !== "object", 'The value "object" should be written as "Object"'), m4.push(M4));
      if (p3.length > 0) {
        let M4 = f2.indexOf("object");
        M4 !== -1 && (f2.splice(f2, M4, 1), p3.push("Object"));
      }
      if (f2.length > 0) {
        switch (f2.length) {
          case 1:
            o2 += `of type ${f2[0]}`;
            break;
          case 2:
            o2 += `one of type ${f2[0]} or ${f2[1]}`;
            break;
          default: {
            let M4 = f2.pop();
            o2 += `one of type ${f2.join(", ")}, or ${M4}`;
          }
        }
        (p3.length > 0 || m4.length > 0) && (o2 += " or ");
      }
      if (p3.length > 0) {
        switch (p3.length) {
          case 1:
            o2 += `an instance of ${p3[0]}`;
            break;
          case 2:
            o2 += `an instance of ${p3[0]} or ${p3[1]}`;
            break;
          default: {
            let M4 = p3.pop();
            o2 += `an instance of ${p3.join(", ")}, or ${M4}`;
          }
        }
        m4.length > 0 && (o2 += " or ");
      }
      switch (m4.length) {
        case 0:
          break;
        case 1:
          m4[0].toLowerCase() !== m4[0] && (o2 += "an "), o2 += `${m4[0]}`;
          break;
        case 2:
          o2 += `one of ${m4[0]} or ${m4[1]}`;
          break;
        default: {
          let M4 = m4.pop();
          o2 += `one of ${m4.join(", ")}, or ${M4}`;
        }
      }
      if (r == null)
        o2 += `. Received ${r}`;
      else if (typeof r == "function" && r.name)
        o2 += `. Received function ${r.name}`;
      else if (typeof r == "object") {
        var y3;
        (y3 = r.constructor) !== null && y3 !== undefined && y3.name ? o2 += `. Received an instance of ${r.constructor.name}` : o2 += `. Received ${Do(r, { depth: -1 })}`;
      } else {
        let M4 = Do(r, { colors: false });
        M4.length > 25 && (M4 = `${M4.slice(0, 25)}...`), o2 += `. Received type ${typeof r} (${M4})`;
      }
      return o2;
    }, TypeError);
    zt("ERR_INVALID_ARG_VALUE", (t, e, r = "is invalid") => {
      let o2 = Do(e);
      return o2.length > 128 && (o2 = o2.slice(0, 128) + "..."), `The ${t.includes(".") ? "property" : "argument"} '${t}' ${r}. Received ${o2}`;
    }, TypeError);
    zt("ERR_INVALID_RETURN_VALUE", (t, e, r) => {
      var o2;
      let f2 = r != null && (o2 = r.constructor) !== null && o2 !== undefined && o2.name ? `instance of ${r.constructor.name}` : `type ${typeof r}`;
      return `Expected ${t} to be returned from the "${e}" function but got ${f2}.`;
    }, TypeError);
    zt("ERR_MISSING_ARGS", (...t) => {
      vn(t.length > 0, "At least one arg needs to be specified");
      let e, r = t.length;
      switch (t = (Array.isArray(t) ? t : [t]).map((o2) => `"${o2}"`).join(" or "), r) {
        case 1:
          e += `The ${t[0]} argument`;
          break;
        case 2:
          e += `The ${t[0]} and ${t[1]} arguments`;
          break;
        default:
          {
            let o2 = t.pop();
            e += `The ${t.join(", ")}, and ${o2} arguments`;
          }
          break;
      }
      return `${e} must be specified`;
    }, TypeError);
    zt("ERR_OUT_OF_RANGE", (t, e, r) => {
      vn(e, 'Missing "range" argument');
      let o2;
      return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o2 = Wp(String(r)) : typeof r == "bigint" ? (o2 = String(r), (r > 2n ** 32n || r < -(2n ** 32n)) && (o2 = Wp(o2)), o2 += "n") : o2 = Do(r), `The value of "${t}" is out of range. It must be ${e}. Received ${o2}`;
    }, RangeError);
    zt("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    zt("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    zt("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    zt("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    zt("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    zt("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    zt("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    zt("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    zt("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    zt("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    zt("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    jp.exports = { AbortError: _h, aggregateTwoErrors: Kp(d_), hideStackFrames: Kp, codes: Po };
  });
  pa = T((TI, Qp) => {
    var { ArrayIsArray: $p, ArrayPrototypeIncludes: Gp, ArrayPrototypeJoin: Yp, ArrayPrototypeMap: c_, NumberIsInteger: Sh, NumberIsNaN: p_, NumberMAX_SAFE_INTEGER: v_, NumberMIN_SAFE_INTEGER: b_, NumberParseInt: m_, ObjectPrototypeHasOwnProperty: g_, RegExpPrototypeExec: y_, String: w_, StringPrototypeToUpperCase: M_, StringPrototypeTrim: __ } = Tt3(), { hideStackFrames: Ir2, codes: { ERR_SOCKET_BAD_PORT: x_, ERR_INVALID_ARG_TYPE: tr, ERR_INVALID_ARG_VALUE: Co, ERR_OUT_OF_RANGE: bn, ERR_UNKNOWN_SIGNAL: Zp } } = Jt(), { normalizeEncoding: S_ } = Gr2(), { isAsyncFunction: E_, isArrayBufferView: A_ } = Gr2().types, Vp = {};
    function R_(t) {
      return t === (t | 0);
    }
    function B_(t) {
      return t === t >>> 0;
    }
    var q_ = /^[0-7]+$/, I_ = "must be a 32-bit unsigned integer or an octal string";
    function T_(t, e, r) {
      if (typeof t > "u" && (t = r), typeof t == "string") {
        if (y_(q_, t) === null)
          throw new Co(e, t, I_);
        t = m_(t, 8);
      }
      return Xp(t, e), t;
    }
    var k_ = Ir2((t, e, r = b_, o2 = v_) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o2)
        throw new bn(e, `>= ${r} && <= ${o2}`, t);
    }), L_ = Ir2((t, e, r = -2147483648, o2 = 2147483647) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      if (t < r || t > o2)
        throw new bn(e, `>= ${r} && <= ${o2}`, t);
    }), Xp = Ir2((t, e, r = false) => {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (!Sh(t))
        throw new bn(e, "an integer", t);
      let o2 = r ? 1 : 0, f2 = 4294967295;
      if (t < o2 || t > f2)
        throw new bn(e, `>= ${o2} && <= ${f2}`, t);
    });
    function Jp(t, e) {
      if (typeof t != "string")
        throw new tr(e, "string", t);
    }
    function N_(t, e, r = undefined, o2) {
      if (typeof t != "number")
        throw new tr(e, "number", t);
      if (r != null && t < r || o2 != null && t > o2 || (r != null || o2 != null) && p_(t))
        throw new bn(e, `${r != null ? `>= ${r}` : ""}${r != null && o2 != null ? " && " : ""}${o2 != null ? `<= ${o2}` : ""}`, t);
    }
    var D_ = Ir2((t, e, r) => {
      if (!Gp(r, t)) {
        let o2 = Yp(c_(r, (p3) => typeof p3 == "string" ? `'${p3}'` : w_(p3)), ", "), f2 = "must be one of: " + o2;
        throw new Co(e, t, f2);
      }
    });
    function P_(t, e) {
      if (typeof t != "boolean")
        throw new tr(e, "boolean", t);
    }
    function xh(t, e, r) {
      return t == null || !g_(t, e) ? r : t[e];
    }
    var C_ = Ir2((t, e, r = null) => {
      let o2 = xh(r, "allowArray", false), f2 = xh(r, "allowFunction", false);
      if (!xh(r, "nullable", false) && t === null || !o2 && $p(t) || typeof t != "object" && (!f2 || typeof t != "function"))
        throw new tr(e, "Object", t);
    }), O_ = Ir2((t, e, r = 0) => {
      if (!$p(t))
        throw new tr(e, "Array", t);
      if (t.length < r) {
        let o2 = `must be longer than ${r}`;
        throw new Co(e, t, o2);
      }
    });
    function F_(t, e = "signal") {
      if (Jp(t, e), Vp[t] === undefined)
        throw Vp[M_(t)] !== undefined ? new Zp(t + " (signals must use all capital letters)") : new Zp(t);
    }
    var U_ = Ir2((t, e = "buffer") => {
      if (!A_(t))
        throw new tr(e, ["Buffer", "TypedArray", "DataView"], t);
    });
    function z_(t, e) {
      let r = S_(e), o2 = t.length;
      if (r === "hex" && o2 % 2 !== 0)
        throw new Co("encoding", e, `is invalid for data of length ${o2}`);
    }
    function H_(t, e = "Port", r = true) {
      if (typeof t != "number" && typeof t != "string" || typeof t == "string" && __(t).length === 0 || +t !== +t >>> 0 || t > 65535 || t === 0 && !r)
        throw new x_(e, t, r);
      return t | 0;
    }
    var W_ = Ir2((t, e) => {
      if (t !== undefined && (t === null || typeof t != "object" || !("aborted" in t)))
        throw new tr(e, "AbortSignal", t);
    }), K_ = Ir2((t, e) => {
      if (typeof t != "function")
        throw new tr(e, "Function", t);
    }), j_ = Ir2((t, e) => {
      if (typeof t != "function" || E_(t))
        throw new tr(e, "Function", t);
    }), Z_ = Ir2((t, e) => {
      if (t !== undefined)
        throw new tr(e, "undefined", t);
    });
    function V_(t, e, r) {
      if (!Gp(r, t))
        throw new tr(e, `('${Yp(r, "|")}')`, t);
    }
    Qp.exports = { isInt32: R_, isUint32: B_, parseFileMode: T_, validateArray: O_, validateBoolean: P_, validateBuffer: U_, validateEncoding: z_, validateFunction: K_, validateInt32: L_, validateInteger: k_, validateNumber: N_, validateObject: C_, validateOneOf: D_, validatePlainFunction: j_, validatePort: H_, validateSignalName: F_, validateString: Jp, validateUint32: Xp, validateUndefined: Z_, validateUnion: V_, validateAbortSignal: W_ };
  });
  Rh = T((kI, i1) => {
    var dt3 = i1.exports = {}, Yr, Xr;
    function Eh() {
      throw new Error("setTimeout has not been defined");
    }
    function Ah() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        typeof setTimeout == "function" ? Yr = setTimeout : Yr = Eh;
      } catch {
        Yr = Eh;
      }
      try {
        typeof clearTimeout == "function" ? Xr = clearTimeout : Xr = Ah;
      } catch {
        Xr = Ah;
      }
    })();
    function e1(t) {
      if (Yr === setTimeout)
        return setTimeout(t, 0);
      if ((Yr === Eh || !Yr) && setTimeout)
        return Yr = setTimeout, setTimeout(t, 0);
      try {
        return Yr(t, 0);
      } catch {
        try {
          return Yr.call(null, t, 0);
        } catch {
          return Yr.call(this, t, 0);
        }
      }
    }
    function $_(t) {
      if (Xr === clearTimeout)
        return clearTimeout(t);
      if ((Xr === Ah || !Xr) && clearTimeout)
        return Xr = clearTimeout, clearTimeout(t);
      try {
        return Xr(t);
      } catch {
        try {
          return Xr.call(null, t);
        } catch {
          return Xr.call(this, t);
        }
      }
    }
    var pi3 = [], nf = false, mn, Oo = -1;
    function G_() {
      !nf || !mn || (nf = false, mn.length ? pi3 = mn.concat(pi3) : Oo = -1, pi3.length && t1());
    }
    function t1() {
      if (!nf) {
        var t = e1(G_);
        nf = true;
        for (var e = pi3.length;e; ) {
          for (mn = pi3, pi3 = [];++Oo < e; )
            mn && mn[Oo].run();
          Oo = -1, e = pi3.length;
        }
        mn = null, nf = false, $_(t);
      }
    }
    dt3.nextTick = function(t) {
      var e = new Array(arguments.length - 1);
      if (arguments.length > 1)
        for (var r = 1;r < arguments.length; r++)
          e[r - 1] = arguments[r];
      pi3.push(new r1(t, e)), pi3.length === 1 && !nf && e1(t1);
    };
    function r1(t, e) {
      this.fun = t, this.array = e;
    }
    r1.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    dt3.title = "browser";
    dt3.browser = true;
    dt3.env = {};
    dt3.argv = [];
    dt3.version = "";
    dt3.versions = {};
    function vi3() {}
    dt3.on = vi3;
    dt3.addListener = vi3;
    dt3.once = vi3;
    dt3.off = vi3;
    dt3.removeListener = vi3;
    dt3.removeAllListeners = vi3;
    dt3.emit = vi3;
    dt3.prependListener = vi3;
    dt3.prependOnceListener = vi3;
    dt3.listeners = function(t) {
      return [];
    };
    dt3.binding = function(t) {
      throw new Error("process.binding is not supported");
    };
    dt3.cwd = function() {
      return "/";
    };
    dt3.chdir = function(t) {
      throw new Error("process.chdir is not supported");
    };
    dt3.umask = function() {
      return 0;
    };
  });
  pr2 = {};
  Ja(pr2, { default: () => Y_ });
  Oi = R0(() => {
    ot2(pr2, rn2(Rh()));
    Y_ = rn2(Rh());
  });
  Fi = T((NI, v1) => {
    var { Symbol: Fo, SymbolAsyncIterator: n1, SymbolIterator: f1 } = Tt3(), a1 = Fo("kDestroyed"), o1 = Fo("kIsErrored"), Bh = Fo("kIsReadable"), s1 = Fo("kIsDisturbed");
    function Uo(t, e = false) {
      var r;
      return !!(t && typeof t.pipe == "function" && typeof t.on == "function" && (!e || typeof t.pause == "function" && typeof t.resume == "function") && (!t._writableState || ((r = t._readableState) === null || r === undefined ? undefined : r.readable) !== false) && (!t._writableState || t._readableState));
    }
    function zo(t) {
      var e;
      return !!(t && typeof t.write == "function" && typeof t.on == "function" && (!t._readableState || ((e = t._writableState) === null || e === undefined ? undefined : e.writable) !== false));
    }
    function X_(t) {
      return !!(t && typeof t.pipe == "function" && t._readableState && typeof t.on == "function" && typeof t.write == "function");
    }
    function gn(t) {
      return t && (t._readableState || t._writableState || typeof t.write == "function" && typeof t.on == "function" || typeof t.pipe == "function" && typeof t.on == "function");
    }
    function J_(t, e) {
      return t == null ? false : e === true ? typeof t[n1] == "function" : e === false ? typeof t[f1] == "function" : typeof t[n1] == "function" || typeof t[f1] == "function";
    }
    function Ho(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o2 = e || r;
      return !!(t.destroyed || t[a1] || o2 != null && o2.destroyed);
    }
    function h1(t) {
      if (!zo(t))
        return null;
      if (t.writableEnded === true)
        return true;
      let e = t._writableState;
      return e != null && e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function Q_(t, e) {
      if (!zo(t))
        return null;
      if (t.writableFinished === true)
        return true;
      let r = t._writableState;
      return r != null && r.errored ? false : typeof r?.finished != "boolean" ? null : !!(r.finished || e === false && r.ended === true && r.length === 0);
    }
    function e8(t) {
      if (!Uo(t))
        return null;
      if (t.readableEnded === true)
        return true;
      let e = t._readableState;
      return !e || e.errored ? false : typeof e?.ended != "boolean" ? null : e.ended;
    }
    function u1(t, e) {
      if (!Uo(t))
        return null;
      let r = t._readableState;
      return r != null && r.errored ? false : typeof r?.endEmitted != "boolean" ? null : !!(r.endEmitted || e === false && r.ended === true && r.length === 0);
    }
    function l1(t) {
      return t && t[Bh] != null ? t[Bh] : typeof t?.readable != "boolean" ? null : Ho(t) ? false : Uo(t) && t.readable && !u1(t);
    }
    function d1(t) {
      return typeof t?.writable != "boolean" ? null : Ho(t) ? false : zo(t) && t.writable && !h1(t);
    }
    function t8(t, e) {
      return gn(t) ? Ho(t) ? true : !(e?.readable !== false && l1(t) || e?.writable !== false && d1(t)) : null;
    }
    function r8(t) {
      var e, r;
      return gn(t) ? t.writableErrored ? t.writableErrored : (e = (r = t._writableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function i8(t) {
      var e, r;
      return gn(t) ? t.readableErrored ? t.readableErrored : (e = (r = t._readableState) === null || r === undefined ? undefined : r.errored) !== null && e !== undefined ? e : null : null;
    }
    function n8(t) {
      if (!gn(t))
        return null;
      if (typeof t.closed == "boolean")
        return t.closed;
      let { _writableState: e, _readableState: r } = t;
      return typeof e?.closed == "boolean" || typeof r?.closed == "boolean" ? e?.closed || r?.closed : typeof t._closed == "boolean" && c1(t) ? t._closed : null;
    }
    function c1(t) {
      return typeof t._closed == "boolean" && typeof t._defaultKeepAlive == "boolean" && typeof t._removedConnection == "boolean" && typeof t._removedContLen == "boolean";
    }
    function p1(t) {
      return typeof t._sent100 == "boolean" && c1(t);
    }
    function f8(t) {
      var e;
      return typeof t._consuming == "boolean" && typeof t._dumped == "boolean" && ((e = t.req) === null || e === undefined ? undefined : e.upgradeOrConnect) === undefined;
    }
    function a8(t) {
      if (!gn(t))
        return null;
      let { _writableState: e, _readableState: r } = t, o2 = e || r;
      return !o2 && p1(t) || !!(o2 && o2.autoDestroy && o2.emitClose && o2.closed === false);
    }
    function o8(t) {
      var e;
      return !!(t && ((e = t[s1]) !== null && e !== undefined ? e : t.readableDidRead || t.readableAborted));
    }
    function s8(t) {
      var e, r, o2, f2, p3, m4, y3, M4, x3, S2;
      return !!(t && ((e = (r = (o2 = (f2 = (p3 = (m4 = t[o1]) !== null && m4 !== undefined ? m4 : t.readableErrored) !== null && p3 !== undefined ? p3 : t.writableErrored) !== null && f2 !== undefined ? f2 : (y3 = t._readableState) === null || y3 === undefined ? undefined : y3.errorEmitted) !== null && o2 !== undefined ? o2 : (M4 = t._writableState) === null || M4 === undefined ? undefined : M4.errorEmitted) !== null && r !== undefined ? r : (x3 = t._readableState) === null || x3 === undefined ? undefined : x3.errored) !== null && e !== undefined ? e : (S2 = t._writableState) === null || S2 === undefined ? undefined : S2.errored));
    }
    v1.exports = { kDestroyed: a1, isDisturbed: o8, kIsDisturbed: s1, isErrored: s8, kIsErrored: o1, isReadable: l1, kIsReadable: Bh, isClosed: n8, isDestroyed: Ho, isDuplexNodeStream: X_, isFinished: t8, isIterable: J_, isReadableNodeStream: Uo, isReadableEnded: e8, isReadableFinished: u1, isReadableErrored: i8, isNodeStream: gn, isWritable: d1, isWritableNodeStream: zo, isWritableEnded: h1, isWritableFinished: Q_, isWritableErrored: r8, isServerRequest: f8, isServerResponse: p1, willEmitClose: a8 };
  });
  Ui = T((DI, Ih) => {
    var ff = (Oi(), ur2(pr2)), { AbortError: h8, codes: u8 } = Jt(), { ERR_INVALID_ARG_TYPE: l8, ERR_STREAM_PREMATURE_CLOSE: b1 } = u8, { kEmptyObject: m1, once: g1 } = Gr2(), { validateAbortSignal: d8, validateFunction: c8, validateObject: p8 } = pa(), { Promise: v8 } = Tt3(), { isClosed: b8, isReadable: y1, isReadableNodeStream: qh, isReadableFinished: w1, isReadableErrored: m8, isWritable: M1, isWritableNodeStream: _1, isWritableFinished: x1, isWritableErrored: g8, isNodeStream: y8, willEmitClose: w8 } = Fi();
    function M8(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    var _8 = () => {};
    function S1(t, e, r) {
      var o2, f2;
      arguments.length === 2 ? (r = e, e = m1) : e == null ? e = m1 : p8(e, "options"), c8(r, "callback"), d8(e.signal, "options.signal"), r = g1(r);
      let p3 = (o2 = e.readable) !== null && o2 !== undefined ? o2 : qh(t), m4 = (f2 = e.writable) !== null && f2 !== undefined ? f2 : _1(t);
      if (!y8(t))
        throw new l8("stream", "Stream", t);
      let { _writableState: y3, _readableState: M4 } = t, x3 = () => {
        t.writable || B3();
      }, S2 = w8(t) && qh(t) === p3 && _1(t) === m4, E6 = x1(t, false), B3 = () => {
        E6 = true, t.destroyed && (S2 = false), !(S2 && (!t.readable || p3)) && (!p3 || q) && r.call(t);
      }, q = w1(t, false), L3 = () => {
        q = true, t.destroyed && (S2 = false), !(S2 && (!t.writable || m4)) && (!m4 || E6) && r.call(t);
      }, ge = (xe) => {
        r.call(t, xe);
      }, _e3 = b8(t), N5 = () => {
        _e3 = true;
        let xe = g8(t) || m8(t);
        if (xe && typeof xe != "boolean")
          return r.call(t, xe);
        if (p3 && !q && qh(t, true) && !w1(t, false))
          return r.call(t, new b1);
        if (m4 && !E6 && !x1(t, false))
          return r.call(t, new b1);
        r.call(t);
      }, we = () => {
        t.req.on("finish", B3);
      };
      M8(t) ? (t.on("complete", B3), S2 || t.on("abort", N5), t.req ? we() : t.on("request", we)) : m4 && !y3 && (t.on("end", x3), t.on("close", x3)), !S2 && typeof t.aborted == "boolean" && t.on("aborted", N5), t.on("end", L3), t.on("finish", B3), e.error !== false && t.on("error", ge), t.on("close", N5), _e3 ? ff.nextTick(N5) : y3 != null && y3.errorEmitted || M4 != null && M4.errorEmitted ? S2 || ff.nextTick(N5) : (!p3 && (!S2 || y1(t)) && (E6 || M1(t) === false) || !m4 && (!S2 || M1(t)) && (q || y1(t) === false) || M4 && t.req && t.aborted) && ff.nextTick(N5);
      let ye = () => {
        r = _8, t.removeListener("aborted", N5), t.removeListener("complete", B3), t.removeListener("abort", N5), t.removeListener("request", we), t.req && t.req.removeListener("finish", B3), t.removeListener("end", x3), t.removeListener("close", x3), t.removeListener("finish", B3), t.removeListener("end", L3), t.removeListener("error", ge), t.removeListener("close", N5);
      };
      if (e.signal && !_e3) {
        let xe = () => {
          let Re = r;
          ye(), Re.call(t, new h8(undefined, { cause: e.signal.reason }));
        };
        if (e.signal.aborted)
          ff.nextTick(xe);
        else {
          let Re = r;
          r = g1((...Ee) => {
            e.signal.removeEventListener("abort", xe), Re.apply(t, Ee);
          }), e.signal.addEventListener("abort", xe);
        }
      }
      return ye;
    }
    function x8(t, e) {
      return new v8((r, o2) => {
        S1(t, e, (f2) => {
          f2 ? o2(f2) : r();
        });
      });
    }
    Ih.exports = S1;
    Ih.exports.finished = x8;
  });
  k1 = T((PI, Lh) => {
    var B1 = globalThis.AbortController || No().AbortController, { codes: { ERR_INVALID_ARG_TYPE: va, ERR_MISSING_ARGS: S8, ERR_OUT_OF_RANGE: E8 }, AbortError: Jr2 } = Jt(), { validateAbortSignal: af, validateInteger: A8, validateObject: of } = pa(), R8 = Tt3().Symbol("kWeak"), { finished: B8 } = Ui(), { ArrayPrototypePush: q8, MathFloor: I8, Number: T8, NumberIsNaN: k8, Promise: E1, PromiseReject: A1, PromisePrototypeThen: L8, Symbol: q1 } = Tt3(), Wo = q1("kEmpty"), R1 = q1("kEof");
    function Ko(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal");
      let r = 1;
      return e?.concurrency != null && (r = I8(e.concurrency)), A8(r, "concurrency", 1), async function* () {
        var f2, p3;
        let m4 = new B1, y3 = this, M4 = [], x3 = m4.signal, S2 = { signal: x3 }, E6 = () => m4.abort();
        e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted && E6(), e == null || (p3 = e.signal) === null || p3 === undefined || p3.addEventListener("abort", E6);
        let B3, q, L3 = false;
        function ge() {
          L3 = true;
        }
        async function _e3() {
          try {
            for await (let ye of y3) {
              var N5;
              if (L3)
                return;
              if (x3.aborted)
                throw new Jr2;
              try {
                ye = t(ye, S2);
              } catch (xe) {
                ye = A1(xe);
              }
              ye !== Wo && (typeof ((N5 = ye) === null || N5 === undefined ? undefined : N5.catch) == "function" && ye.catch(ge), M4.push(ye), B3 && (B3(), B3 = null), !L3 && M4.length && M4.length >= r && await new E1((xe) => {
                q = xe;
              }));
            }
            M4.push(R1);
          } catch (ye) {
            let xe = A1(ye);
            L8(xe, undefined, ge), M4.push(xe);
          } finally {
            var we;
            L3 = true, B3 && (B3(), B3 = null), e == null || (we = e.signal) === null || we === undefined || we.removeEventListener("abort", E6);
          }
        }
        _e3();
        try {
          for (;; ) {
            for (;M4.length > 0; ) {
              let N5 = await M4[0];
              if (N5 === R1)
                return;
              if (x3.aborted)
                throw new Jr2;
              N5 !== Wo && (yield N5), M4.shift(), q && (q(), q = null);
            }
            await new E1((N5) => {
              B3 = N5;
            });
          }
        } finally {
          m4.abort(), L3 = true, q && (q(), q = null);
        }
      }.call(this);
    }
    function N8(t = undefined) {
      return t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal"), async function* () {
        let r = 0;
        for await (let f2 of this) {
          var o2;
          if (t != null && (o2 = t.signal) !== null && o2 !== undefined && o2.aborted)
            throw new Jr2({ cause: t.signal.reason });
          yield [r++, f2];
        }
      }.call(this);
    }
    async function I1(t, e = undefined) {
      for await (let r of kh.call(this, t, e))
        return true;
      return false;
    }
    async function D8(t, e = undefined) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      return !await I1.call(this, async (...r) => !await t(...r), e);
    }
    async function P8(t, e) {
      for await (let r of kh.call(this, t, e))
        return r;
    }
    async function C8(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o2, f2) {
        return await t(o2, f2), Wo;
      }
      for await (let o2 of Ko.call(this, r, e))
        ;
    }
    function kh(t, e) {
      if (typeof t != "function")
        throw new va("fn", ["Function", "AsyncFunction"], t);
      async function r(o2, f2) {
        return await t(o2, f2) ? o2 : Wo;
      }
      return Ko.call(this, r, e);
    }
    var Th = class extends S8 {
      constructor() {
        super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function O8(t, e, r) {
      var o2;
      if (typeof t != "function")
        throw new va("reducer", ["Function", "AsyncFunction"], t);
      r != null && of(r, "options"), r?.signal != null && af(r.signal, "options.signal");
      let f2 = arguments.length > 1;
      if (r != null && (o2 = r.signal) !== null && o2 !== undefined && o2.aborted) {
        let x3 = new Jr2(undefined, { cause: r.signal.reason });
        throw this.once("error", () => {}), await B8(this.destroy(x3)), x3;
      }
      let p3 = new B1, m4 = p3.signal;
      if (r != null && r.signal) {
        let x3 = { once: true, [R8]: this };
        r.signal.addEventListener("abort", () => p3.abort(), x3);
      }
      let y3 = false;
      try {
        for await (let x3 of this) {
          var M4;
          if (y3 = true, r != null && (M4 = r.signal) !== null && M4 !== undefined && M4.aborted)
            throw new Jr2;
          f2 ? e = await t(e, x3, { signal: m4 }) : (e = x3, f2 = true);
        }
        if (!y3 && !f2)
          throw new Th;
      } finally {
        p3.abort();
      }
      return e;
    }
    async function F8(t) {
      t != null && of(t, "options"), t?.signal != null && af(t.signal, "options.signal");
      let e = [];
      for await (let o2 of this) {
        var r;
        if (t != null && (r = t.signal) !== null && r !== undefined && r.aborted)
          throw new Jr2(undefined, { cause: t.signal.reason });
        q8(e, o2);
      }
      return e;
    }
    function U8(t, e) {
      let r = Ko.call(this, t, e);
      return async function* () {
        for await (let f2 of r)
          yield* f2;
      }.call(this);
    }
    function T1(t) {
      if (t = T8(t), k8(t))
        return 0;
      if (t < 0)
        throw new E8("number", ">= 0", t);
      return t;
    }
    function z8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o2;
        if (e != null && (o2 = e.signal) !== null && o2 !== undefined && o2.aborted)
          throw new Jr2;
        for await (let p3 of this) {
          var f2;
          if (e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted)
            throw new Jr2;
          t-- <= 0 && (yield p3);
        }
      }.call(this);
    }
    function H8(t, e = undefined) {
      return e != null && of(e, "options"), e?.signal != null && af(e.signal, "options.signal"), t = T1(t), async function* () {
        var o2;
        if (e != null && (o2 = e.signal) !== null && o2 !== undefined && o2.aborted)
          throw new Jr2;
        for await (let p3 of this) {
          var f2;
          if (e != null && (f2 = e.signal) !== null && f2 !== undefined && f2.aborted)
            throw new Jr2;
          if (t-- > 0)
            yield p3;
          else
            return;
        }
      }.call(this);
    }
    Lh.exports.streamReturningOperators = { asIndexedPairs: N8, drop: z8, filter: kh, flatMap: U8, map: Ko, take: H8 };
    Lh.exports.promiseReturningOperators = { every: D8, forEach: C8, reduce: O8, toArray: F8, some: I1, find: P8 };
  });
  yn = T((CI, U1) => {
    var zi = (Oi(), ur2(pr2)), { aggregateTwoErrors: W8, codes: { ERR_MULTIPLE_CALLBACK: K8 }, AbortError: j8 } = Jt(), { Symbol: D1 } = Tt3(), { kDestroyed: Z8, isDestroyed: V8, isFinished: $8, isServerRequest: G8 } = Fi(), P1 = D1("kDestroy"), Nh = D1("kConstruct");
    function C1(t, e, r) {
      t && (t.stack, e && !e.errored && (e.errored = t), r && !r.errored && (r.errored = t));
    }
    function Y8(t, e) {
      let r = this._readableState, o2 = this._writableState, f2 = o2 || r;
      return o2 && o2.destroyed || r && r.destroyed ? (typeof e == "function" && e(), this) : (C1(t, o2, r), o2 && (o2.destroyed = true), r && (r.destroyed = true), f2.constructed ? L1(this, t, e) : this.once(P1, function(p3) {
        L1(this, W8(p3, t), e);
      }), this);
    }
    function L1(t, e, r) {
      let o2 = false;
      function f2(p3) {
        if (o2)
          return;
        o2 = true;
        let { _readableState: m4, _writableState: y3 } = t;
        C1(p3, y3, m4), y3 && (y3.closed = true), m4 && (m4.closed = true), typeof r == "function" && r(p3), p3 ? zi.nextTick(X8, t, p3) : zi.nextTick(O1, t);
      }
      try {
        t._destroy(e || null, f2);
      } catch (p3) {
        f2(p3);
      }
    }
    function X8(t, e) {
      Dh(t, e), O1(t);
    }
    function O1(t) {
      let { _readableState: e, _writableState: r } = t;
      r && (r.closeEmitted = true), e && (e.closeEmitted = true), (r && r.emitClose || e && e.emitClose) && t.emit("close");
    }
    function Dh(t, e) {
      let { _readableState: r, _writableState: o2 } = t;
      o2 && o2.errorEmitted || r && r.errorEmitted || (o2 && (o2.errorEmitted = true), r && (r.errorEmitted = true), t.emit("error", e));
    }
    function J8() {
      let t = this._readableState, e = this._writableState;
      t && (t.constructed = true, t.closed = false, t.closeEmitted = false, t.destroyed = false, t.errored = null, t.errorEmitted = false, t.reading = false, t.ended = t.readable === false, t.endEmitted = t.readable === false), e && (e.constructed = true, e.destroyed = false, e.closed = false, e.closeEmitted = false, e.errored = null, e.errorEmitted = false, e.finalCalled = false, e.prefinished = false, e.ended = e.writable === false, e.ending = e.writable === false, e.finished = e.writable === false);
    }
    function Ph(t, e, r) {
      let { _readableState: o2, _writableState: f2 } = t;
      if (f2 && f2.destroyed || o2 && o2.destroyed)
        return this;
      o2 && o2.autoDestroy || f2 && f2.autoDestroy ? t.destroy(e) : e && (e.stack, f2 && !f2.errored && (f2.errored = e), o2 && !o2.errored && (o2.errored = e), r ? zi.nextTick(Dh, t, e) : Dh(t, e));
    }
    function Q8(t, e) {
      if (typeof t._construct != "function")
        return;
      let { _readableState: r, _writableState: o2 } = t;
      r && (r.constructed = false), o2 && (o2.constructed = false), t.once(Nh, e), !(t.listenerCount(Nh) > 1) && zi.nextTick(e5, t);
    }
    function e5(t) {
      let e = false;
      function r(o2) {
        if (e) {
          Ph(t, o2 ?? new K8);
          return;
        }
        e = true;
        let { _readableState: f2, _writableState: p3 } = t, m4 = p3 || f2;
        f2 && (f2.constructed = true), p3 && (p3.constructed = true), m4.destroyed ? t.emit(P1, o2) : o2 ? Ph(t, o2, true) : zi.nextTick(t5, t);
      }
      try {
        t._construct(r);
      } catch (o2) {
        r(o2);
      }
    }
    function t5(t) {
      t.emit(Nh);
    }
    function N1(t) {
      return t && t.setHeader && typeof t.abort == "function";
    }
    function F1(t) {
      t.emit("close");
    }
    function r5(t, e) {
      t.emit("error", e), zi.nextTick(F1, t);
    }
    function i5(t, e) {
      !t || V8(t) || (!e && !$8(t) && (e = new j8), G8(t) ? (t.socket = null, t.destroy(e)) : N1(t) ? t.abort() : N1(t.req) ? t.req.abort() : typeof t.destroy == "function" ? t.destroy(e) : typeof t.close == "function" ? t.close() : e ? zi.nextTick(r5, t, e) : zi.nextTick(F1, t), t.destroyed || (t[Z8] = true));
    }
    U1.exports = { construct: Q8, destroyer: i5, destroy: Y8, undestroy: J8, errorOrDestroy: Ph };
  });
  Vo = T((OI, H1) => {
    var { ArrayIsArray: n5, ObjectSetPrototypeOf: z1 } = Tt3(), { EventEmitter: jo } = ki();
    function Zo(t) {
      jo.call(this, t);
    }
    z1(Zo.prototype, jo.prototype);
    z1(Zo, jo);
    Zo.prototype.pipe = function(t, e) {
      let r = this;
      function o2(S2) {
        t.writable && t.write(S2) === false && r.pause && r.pause();
      }
      r.on("data", o2);
      function f2() {
        r.readable && r.resume && r.resume();
      }
      t.on("drain", f2), !t._isStdio && (!e || e.end !== false) && (r.on("end", m4), r.on("close", y3));
      let p3 = false;
      function m4() {
        p3 || (p3 = true, t.end());
      }
      function y3() {
        p3 || (p3 = true, typeof t.destroy == "function" && t.destroy());
      }
      function M4(S2) {
        x3(), jo.listenerCount(this, "error") === 0 && this.emit("error", S2);
      }
      Ch(r, "error", M4), Ch(t, "error", M4);
      function x3() {
        r.removeListener("data", o2), t.removeListener("drain", f2), r.removeListener("end", m4), r.removeListener("close", y3), r.removeListener("error", M4), t.removeListener("error", M4), r.removeListener("end", x3), r.removeListener("close", x3), t.removeListener("close", x3);
      }
      return r.on("end", x3), r.on("close", x3), t.on("close", x3), t.emit("pipe", r), t;
    };
    function Ch(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : n5(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    H1.exports = { Stream: Zo, prependListener: Ch };
  });
  Go = T((FI, $o) => {
    var { AbortError: f5, codes: a5 } = Jt(), o5 = Ui(), { ERR_INVALID_ARG_TYPE: W1 } = a5, s5 = (t, e) => {
      if (typeof t != "object" || !("aborted" in t))
        throw new W1(e, "AbortSignal", t);
    };
    function h5(t) {
      return !!(t && typeof t.pipe == "function");
    }
    $o.exports.addAbortSignal = function(e, r) {
      if (s5(e, "signal"), !h5(r))
        throw new W1("stream", "stream.Stream", r);
      return $o.exports.addAbortSignalNoValidate(e, r);
    };
    $o.exports.addAbortSignalNoValidate = function(t, e) {
      if (typeof t != "object" || !("aborted" in t))
        return e;
      let r = () => {
        e.destroy(new f5(undefined, { cause: t.reason }));
      };
      return t.aborted ? r() : (t.addEventListener("abort", r), o5(e, () => t.removeEventListener("abort", r))), e;
    };
  });
  Z1 = T((zI, j1) => {
    var { StringPrototypeSlice: K1, SymbolIterator: u5, TypedArrayPrototypeSet: Yo, Uint8Array: l5 } = Tt3(), { Buffer: Oh } = Ut2(), { inspect: d5 } = Gr2();
    j1.exports = class {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      push(e) {
        let r = { data: e, next: null };
        this.length > 0 ? this.tail.next = r : this.head = r, this.tail = r, ++this.length;
      }
      unshift(e) {
        let r = { data: e, next: this.head };
        this.length === 0 && (this.tail = r), this.head = r, ++this.length;
      }
      shift() {
        if (this.length === 0)
          return;
        let e = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;
      }
      clear() {
        this.head = this.tail = null, this.length = 0;
      }
      join(e) {
        if (this.length === 0)
          return "";
        let r = this.head, o2 = "" + r.data;
        for (;(r = r.next) !== null; )
          o2 += e + r.data;
        return o2;
      }
      concat(e) {
        if (this.length === 0)
          return Oh.alloc(0);
        let r = Oh.allocUnsafe(e >>> 0), o2 = this.head, f2 = 0;
        for (;o2; )
          Yo(r, o2.data, f2), f2 += o2.data.length, o2 = o2.next;
        return r;
      }
      consume(e, r) {
        let o2 = this.head.data;
        if (e < o2.length) {
          let f2 = o2.slice(0, e);
          return this.head.data = o2.slice(e), f2;
        }
        return e === o2.length ? this.shift() : r ? this._getString(e) : this._getBuffer(e);
      }
      first() {
        return this.head.data;
      }
      *[u5]() {
        for (let e = this.head;e; e = e.next)
          yield e.data;
      }
      _getString(e) {
        let r = "", o2 = this.head, f2 = 0;
        do {
          let p3 = o2.data;
          if (e > p3.length)
            r += p3, e -= p3.length;
          else {
            e === p3.length ? (r += p3, ++f2, o2.next ? this.head = o2.next : this.head = this.tail = null) : (r += K1(p3, 0, e), this.head = o2, o2.data = K1(p3, e));
            break;
          }
          ++f2;
        } while ((o2 = o2.next) !== null);
        return this.length -= f2, r;
      }
      _getBuffer(e) {
        let r = Oh.allocUnsafe(e), o2 = e, f2 = this.head, p3 = 0;
        do {
          let m4 = f2.data;
          if (e > m4.length)
            Yo(r, m4, o2 - e), e -= m4.length;
          else {
            e === m4.length ? (Yo(r, m4, o2 - e), ++p3, f2.next ? this.head = f2.next : this.head = this.tail = null) : (Yo(r, new l5(m4.buffer, m4.byteOffset, e), o2 - e), this.head = f2, f2.data = m4.slice(e));
            break;
          }
          ++p3;
        } while ((f2 = f2.next) !== null);
        return this.length -= p3, r;
      }
      [Symbol.for("nodejs.util.inspect.custom")](e, r) {
        return d5(this, { ...r, depth: 0, customInspect: false });
      }
    };
  });
  Xo = T((HI, $1) => {
    var { MathFloor: c5, NumberIsInteger: p5 } = Tt3(), { ERR_INVALID_ARG_VALUE: v5 } = Jt().codes;
    function b5(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function V1(t) {
      return t ? 16 : 16 * 1024;
    }
    function m5(t, e, r, o2) {
      let f2 = b5(e, o2, r);
      if (f2 != null) {
        if (!p5(f2) || f2 < 0) {
          let p3 = o2 ? `options.${r}` : "options.highWaterMark";
          throw new v5(p3, f2);
        }
        return c5(f2);
      }
      return V1(t.objectMode);
    }
    $1.exports = { getHighWaterMark: m5, getDefaultHighWaterMark: V1 };
  });
  Fh = T((WI, J1) => {
    var G1 = (Oi(), ur2(pr2)), { PromisePrototypeThen: g5, SymbolAsyncIterator: Y1, SymbolIterator: X1 } = Tt3(), { Buffer: y5 } = Ut2(), { ERR_INVALID_ARG_TYPE: w5, ERR_STREAM_NULL_VALUES: M5 } = Jt().codes;
    function _5(t, e, r) {
      let o2;
      if (typeof e == "string" || e instanceof y5)
        return new t({ objectMode: true, ...r, read() {
          this.push(e), this.push(null);
        } });
      let f2;
      if (e && e[Y1])
        f2 = true, o2 = e[Y1]();
      else if (e && e[X1])
        f2 = false, o2 = e[X1]();
      else
        throw new w5("iterable", ["Iterable"], e);
      let p3 = new t({ objectMode: true, highWaterMark: 1, ...r }), m4 = false;
      p3._read = function() {
        m4 || (m4 = true, M4());
      }, p3._destroy = function(x3, S2) {
        g5(y3(x3), () => G1.nextTick(S2, x3), (E6) => G1.nextTick(S2, E6 || x3));
      };
      async function y3(x3) {
        let S2 = x3 != null, E6 = typeof o2.throw == "function";
        if (S2 && E6) {
          let { value: B3, done: q } = await o2.throw(x3);
          if (await B3, q)
            return;
        }
        if (typeof o2.return == "function") {
          let { value: B3 } = await o2.return();
          await B3;
        }
      }
      async function M4() {
        for (;; ) {
          try {
            let { value: x3, done: S2 } = f2 ? await o2.next() : o2.next();
            if (S2)
              p3.push(null);
            else {
              let E6 = x3 && typeof x3.then == "function" ? await x3 : x3;
              if (E6 === null)
                throw m4 = false, new M5;
              if (p3.push(E6))
                continue;
              m4 = false;
            }
          } catch (x3) {
            p3.destroy(x3);
          }
          break;
        }
      }
      return p3;
    }
    J1.exports = _5;
  });
  ba = T((KI, lv) => {
    var Tr = (Oi(), ur2(pr2)), { ArrayPrototypeIndexOf: x5, NumberIsInteger: S5, NumberIsNaN: E52, NumberParseInt: A5, ObjectDefineProperties: tv, ObjectKeys: R5, ObjectSetPrototypeOf: rv, Promise: B5, SafeSet: q5, SymbolAsyncIterator: I5, Symbol: T5 } = Tt3();
    lv.exports = Le;
    Le.ReadableState = jh;
    var { EventEmitter: k5 } = ki(), { Stream: Hi2, prependListener: L5 } = Vo(), { Buffer: Uh } = Ut2(), { addAbortSignal: N5 } = Go(), D5 = Ui(), Pe2 = Gr2().debuglog("stream", (t) => {
      Pe2 = t;
    }), P5 = Z1(), hf = yn(), { getHighWaterMark: C5, getDefaultHighWaterMark: O5 } = Xo(), { aggregateTwoErrors: Q1, codes: { ERR_INVALID_ARG_TYPE: F5, ERR_METHOD_NOT_IMPLEMENTED: U5, ERR_OUT_OF_RANGE: z5, ERR_STREAM_PUSH_AFTER_EOF: H5, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: W5 } } = Jt(), { validateObject: K5 } = pa(), wn = T5("kPaused"), { StringDecoder: iv } = co(), j5 = Fh();
    rv(Le.prototype, Hi2.prototype);
    rv(Le, Hi2);
    var zh = () => {}, { errorOrDestroy: sf } = hf;
    function jh(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr2()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.readableObjectMode)), this.highWaterMark = t ? C5(this, t, "readableHighWaterMark", r) : O5(false), this.buffer = new P5, this.length = 0, this.pipes = [], this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.constructed = true, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this[wn] = null, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.destroyed = false, this.errored = null, this.closed = false, this.closeEmitted = false, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = false, this.readingMore = false, this.dataEmitted = false, this.decoder = null, this.encoding = null, t && t.encoding && (this.decoder = new iv(t.encoding), this.encoding = t.encoding);
    }
    function Le(t) {
      if (!(this instanceof Le))
        return new Le(t);
      let e = this instanceof Qr2();
      this._readableState = new jh(t, this, e), t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.construct == "function" && (this._construct = t.construct), t.signal && !e && N5(t.signal, this)), Hi2.call(this, t), hf.construct(this, () => {
        this._readableState.needReadable && Jo2(this, this._readableState);
      });
    }
    Le.prototype.destroy = hf.destroy;
    Le.prototype._undestroy = hf.undestroy;
    Le.prototype._destroy = function(t, e) {
      e(t);
    };
    Le.prototype[k5.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    Le.prototype.push = function(t, e) {
      return nv(this, t, e, false);
    };
    Le.prototype.unshift = function(t, e) {
      return nv(this, t, e, true);
    };
    function nv(t, e, r, o2) {
      Pe2("readableAddChunk", e);
      let f2 = t._readableState, p3;
      if (f2.objectMode || (typeof e == "string" ? (r = r || f2.defaultEncoding, f2.encoding !== r && (o2 && f2.encoding ? e = Uh.from(e, r).toString(f2.encoding) : (e = Uh.from(e, r), r = ""))) : e instanceof Uh ? r = "" : Hi2._isUint8Array(e) ? (e = Hi2._uint8ArrayToBuffer(e), r = "") : e != null && (p3 = new F5("chunk", ["string", "Buffer", "Uint8Array"], e))), p3)
        sf(t, p3);
      else if (e === null)
        f2.reading = false, $5(t, f2);
      else if (f2.objectMode || e && e.length > 0)
        if (o2)
          if (f2.endEmitted)
            sf(t, new W5);
          else {
            if (f2.destroyed || f2.errored)
              return false;
            Hh(t, f2, e, true);
          }
        else if (f2.ended)
          sf(t, new H5);
        else {
          if (f2.destroyed || f2.errored)
            return false;
          f2.reading = false, f2.decoder && !r ? (e = f2.decoder.write(e), f2.objectMode || e.length !== 0 ? Hh(t, f2, e, false) : Jo2(t, f2)) : Hh(t, f2, e, false);
        }
      else
        o2 || (f2.reading = false, Jo2(t, f2));
      return !f2.ended && (f2.length < f2.highWaterMark || f2.length === 0);
    }
    function Hh(t, e, r, o2) {
      e.flowing && e.length === 0 && !e.sync && t.listenerCount("data") > 0 ? (e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null, e.dataEmitted = true, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Qo(t)), Jo2(t, e);
    }
    Le.prototype.isPaused = function() {
      let t = this._readableState;
      return t[wn] === true || t.flowing === false;
    };
    Le.prototype.setEncoding = function(t) {
      let e = new iv(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      let r = this._readableState.buffer, o2 = "";
      for (let f2 of r)
        o2 += e.write(f2);
      return r.clear(), o2 !== "" && r.push(o2), this._readableState.length = o2.length, this;
    };
    var Z5 = 1073741824;
    function V5(t) {
      if (t > Z5)
        throw new z5("size", "<= 1GiB", t);
      return t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++, t;
    }
    function ev(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : E52(t) ? e.flowing && e.length ? e.buffer.first().length : e.length : t <= e.length ? t : e.ended ? e.length : 0;
    }
    Le.prototype.read = function(t) {
      Pe2("read", t), t === undefined ? t = NaN : S5(t) || (t = A5(t, 10));
      let e = this._readableState, r = t;
      if (t > e.highWaterMark && (e.highWaterMark = V5(t)), t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return Pe2("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Wh(this) : Qo(this), null;
      if (t = ev(t, e), t === 0 && e.ended)
        return e.length === 0 && Wh(this), null;
      let o2 = e.needReadable;
      if (Pe2("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, Pe2("length less than watermark", o2)), e.ended || e.reading || e.destroyed || e.errored || !e.constructed)
        o2 = false, Pe2("reading, ended or constructing", o2);
      else if (o2) {
        Pe2("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true);
        try {
          this._read(e.highWaterMark);
        } catch (p3) {
          sf(this, p3);
        }
        e.sync = false, e.reading || (t = ev(r, e));
      }
      let f2;
      return t > 0 ? f2 = hv(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.multiAwaitDrain ? e.awaitDrainWriters.clear() : e.awaitDrainWriters = null), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Wh(this)), f2 !== null && !e.errorEmitted && !e.closeEmitted && (e.dataEmitted = true, this.emit("data", f2)), f2;
    };
    function $5(t, e) {
      if (Pe2("onEofChunk"), !e.ended) {
        if (e.decoder) {
          let r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Qo(t) : (e.needReadable = false, e.emittedReadable = true, fv(t));
      }
    }
    function Qo(t) {
      let e = t._readableState;
      Pe2("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (Pe2("emitReadable", e.flowing), e.emittedReadable = true, Tr.nextTick(fv, t));
    }
    function fv(t) {
      let e = t._readableState;
      Pe2("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && !e.errored && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ov(t);
    }
    function Jo2(t, e) {
      !e.readingMore && e.constructed && (e.readingMore = true, Tr.nextTick(G5, t, e));
    }
    function G5(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        let r = e.length;
        if (Pe2("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Le.prototype._read = function(t) {
      throw new U5("_read()");
    };
    Le.prototype.pipe = function(t, e) {
      let r = this, o2 = this._readableState;
      o2.pipes.length === 1 && (o2.multiAwaitDrain || (o2.multiAwaitDrain = true, o2.awaitDrainWriters = new q5(o2.awaitDrainWriters ? [o2.awaitDrainWriters] : []))), o2.pipes.push(t), Pe2("pipe count=%d opts=%j", o2.pipes.length, e);
      let p3 = (!e || e.end !== false) && t !== Tr.stdout && t !== Tr.stderr ? y3 : _e3;
      o2.endEmitted ? Tr.nextTick(p3) : r.once("end", p3), t.on("unpipe", m4);
      function m4(N6, we) {
        Pe2("onunpipe"), N6 === r && we && we.hasUnpiped === false && (we.hasUnpiped = true, S2());
      }
      function y3() {
        Pe2("onend"), t.end();
      }
      let M4, x3 = false;
      function S2() {
        Pe2("cleanup"), t.removeListener("close", L3), t.removeListener("finish", ge), M4 && t.removeListener("drain", M4), t.removeListener("error", q), t.removeListener("unpipe", m4), r.removeListener("end", y3), r.removeListener("end", _e3), r.removeListener("data", B3), x3 = true, M4 && o2.awaitDrainWriters && (!t._writableState || t._writableState.needDrain) && M4();
      }
      function E6() {
        x3 || (o2.pipes.length === 1 && o2.pipes[0] === t ? (Pe2("false write response, pause", 0), o2.awaitDrainWriters = t, o2.multiAwaitDrain = false) : o2.pipes.length > 1 && o2.pipes.includes(t) && (Pe2("false write response, pause", o2.awaitDrainWriters.size), o2.awaitDrainWriters.add(t)), r.pause()), M4 || (M4 = Y5(r, t), t.on("drain", M4));
      }
      r.on("data", B3);
      function B3(N6) {
        Pe2("ondata");
        let we = t.write(N6);
        Pe2("dest.write", we), we === false && E6();
      }
      function q(N6) {
        if (Pe2("onerror", N6), _e3(), t.removeListener("error", q), t.listenerCount("error") === 0) {
          let we = t._writableState || t._readableState;
          we && !we.errorEmitted ? sf(t, N6) : t.emit("error", N6);
        }
      }
      L5(t, "error", q);
      function L3() {
        t.removeListener("finish", ge), _e3();
      }
      t.once("close", L3);
      function ge() {
        Pe2("onfinish"), t.removeListener("close", L3), _e3();
      }
      t.once("finish", ge);
      function _e3() {
        Pe2("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), t.writableNeedDrain === true ? o2.flowing && E6() : o2.flowing || (Pe2("pipe resume"), r.resume()), t;
    };
    function Y5(t, e) {
      return function() {
        let o2 = t._readableState;
        o2.awaitDrainWriters === e ? (Pe2("pipeOnDrain", 1), o2.awaitDrainWriters = null) : o2.multiAwaitDrain && (Pe2("pipeOnDrain", o2.awaitDrainWriters.size), o2.awaitDrainWriters.delete(e)), (!o2.awaitDrainWriters || o2.awaitDrainWriters.size === 0) && t.listenerCount("data") && t.resume();
      };
    }
    Le.prototype.unpipe = function(t) {
      let e = this._readableState, r = { hasUnpiped: false };
      if (e.pipes.length === 0)
        return this;
      if (!t) {
        let f2 = e.pipes;
        e.pipes = [], this.pause();
        for (let p3 = 0;p3 < f2.length; p3++)
          f2[p3].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      let o2 = x5(e.pipes, t);
      return o2 === -1 ? this : (e.pipes.splice(o2, 1), e.pipes.length === 0 && this.pause(), t.emit("unpipe", this, r), this);
    };
    Le.prototype.on = function(t, e) {
      let r = Hi2.prototype.on.call(this, t, e), o2 = this._readableState;
      return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, Pe2("on readable", o2.length, o2.reading), o2.length ? Qo(this) : o2.reading || Tr.nextTick(X5, this)), r;
    };
    Le.prototype.addListener = Le.prototype.on;
    Le.prototype.removeListener = function(t, e) {
      let r = Hi2.prototype.removeListener.call(this, t, e);
      return t === "readable" && Tr.nextTick(av, this), r;
    };
    Le.prototype.off = Le.prototype.removeListener;
    Le.prototype.removeAllListeners = function(t) {
      let e = Hi2.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && Tr.nextTick(av, this), e;
    };
    function av(t) {
      let e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && e[wn] === false ? e.flowing = true : t.listenerCount("data") > 0 ? t.resume() : e.readableListening || (e.flowing = null);
    }
    function X5(t) {
      Pe2("readable nexttick read 0"), t.read(0);
    }
    Le.prototype.resume = function() {
      let t = this._readableState;
      return t.flowing || (Pe2("resume"), t.flowing = !t.readableListening, J5(this, t)), t[wn] = false, this;
    };
    function J5(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, Tr.nextTick(Q5, t, e));
    }
    function Q5(t, e) {
      Pe2("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ov(t), e.flowing && !e.reading && t.read(0);
    }
    Le.prototype.pause = function() {
      return Pe2("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (Pe2("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState[wn] = true, this;
    };
    function ov(t) {
      let e = t._readableState;
      for (Pe2("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Le.prototype.wrap = function(t) {
      let e = false;
      t.on("data", (o2) => {
        !this.push(o2) && t.pause && (e = true, t.pause());
      }), t.on("end", () => {
        this.push(null);
      }), t.on("error", (o2) => {
        sf(this, o2);
      }), t.on("close", () => {
        this.destroy();
      }), t.on("destroy", () => {
        this.destroy();
      }), this._read = () => {
        e && t.resume && (e = false, t.resume());
      };
      let r = R5(t);
      for (let o2 = 1;o2 < r.length; o2++) {
        let f2 = r[o2];
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = t[f2].bind(t));
      }
      return this;
    };
    Le.prototype[I5] = function() {
      return sv(this);
    };
    Le.prototype.iterator = function(t) {
      return t !== undefined && K5(t, "options"), sv(this, t);
    };
    function sv(t, e) {
      typeof t.read != "function" && (t = Le.wrap(t, { objectMode: true }));
      let r = ex(t, e);
      return r.stream = t, r;
    }
    async function* ex(t, e) {
      let r = zh;
      function o2(m4) {
        this === t ? (r(), r = zh) : r = m4;
      }
      t.on("readable", o2);
      let f2, p3 = D5(t, { writable: false }, (m4) => {
        f2 = m4 ? Q1(f2, m4) : null, r(), r = zh;
      });
      try {
        for (;; ) {
          let m4 = t.destroyed ? null : t.read();
          if (m4 !== null)
            yield m4;
          else {
            if (f2)
              throw f2;
            if (f2 === null)
              return;
            await new B5(o2);
          }
        }
      } catch (m4) {
        throw f2 = Q1(f2, m4), f2;
      } finally {
        (f2 || e?.destroyOnReturn !== false) && (f2 === undefined || t._readableState.autoDestroy) ? hf.destroyer(t, null) : (t.off("readable", o2), p3());
      }
    }
    tv(Le.prototype, { readable: { __proto__: null, get() {
      let t = this._readableState;
      return !!t && t.readable !== false && !t.destroyed && !t.errorEmitted && !t.endEmitted;
    }, set(t) {
      this._readableState && (this._readableState.readable = !!t);
    } }, readableDidRead: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.dataEmitted;
    } }, readableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
    } }, readableHighWaterMark: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } }, readableBuffer: { __proto__: null, enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } }, readableFlowing: { __proto__: null, enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(t) {
      this._readableState && (this._readableState.flowing = t);
    } }, readableLength: { __proto__: null, enumerable: false, get() {
      return this._readableState.length;
    } }, readableObjectMode: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.objectMode : false;
    } }, readableEncoding: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.encoding : null;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.errored : null;
    } }, closed: { __proto__: null, get() {
      return this._readableState ? this._readableState.closed : false;
    } }, destroyed: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.destroyed : false;
    }, set(t) {
      !this._readableState || (this._readableState.destroyed = t);
    } }, readableEnded: { __proto__: null, enumerable: false, get() {
      return this._readableState ? this._readableState.endEmitted : false;
    } } });
    tv(jh.prototype, { pipesCount: { __proto__: null, get() {
      return this.pipes.length;
    } }, paused: { __proto__: null, get() {
      return this[wn] !== false;
    }, set(t) {
      this[wn] = !!t;
    } } });
    Le._fromList = hv;
    function hv(t, e) {
      if (e.length === 0)
        return null;
      let r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Wh(t) {
      let e = t._readableState;
      Pe2("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, Tr.nextTick(tx, e, t));
    }
    function tx(t, e) {
      if (Pe2("endReadableNT", t.endEmitted, t.length), !t.errored && !t.closeEmitted && !t.endEmitted && t.length === 0) {
        if (t.endEmitted = true, e.emit("end"), e.writable && e.allowHalfOpen === false)
          Tr.nextTick(rx, e);
        else if (t.autoDestroy) {
          let r = e._writableState;
          (!r || r.autoDestroy && (r.finished || r.writable === false)) && e.destroy();
        }
      }
    }
    function rx(t) {
      t.writable && !t.writableEnded && !t.destroyed && t.end();
    }
    Le.from = function(t, e) {
      return j5(Le, t, e);
    };
    var Kh;
    function uv() {
      return Kh === undefined && (Kh = {}), Kh;
    }
    Le.fromWeb = function(t, e) {
      return uv().newStreamReadableFromReadableStream(t, e);
    };
    Le.toWeb = function(t, e) {
      return uv().newReadableStreamFromStreamReadable(t, e);
    };
    Le.wrap = function(t, e) {
      var r, o2;
      return new Le({ objectMode: (r = (o2 = t.readableObjectMode) !== null && o2 !== undefined ? o2 : t.objectMode) !== null && r !== undefined ? r : true, ...e, destroy(f2, p3) {
        hf.destroyer(t, f2), p3(f2);
      } }).wrap(t);
    };
  });
  Jh = T((jI, xv) => {
    var Mn = (Oi(), ur2(pr2)), { ArrayPrototypeSlice: pv, Error: ix, FunctionPrototypeSymbolHasInstance: vv, ObjectDefineProperty: bv, ObjectDefineProperties: nx, ObjectSetPrototypeOf: mv, StringPrototypeToLowerCase: fx, Symbol: ax, SymbolHasInstance: ox } = Tt3();
    xv.exports = st3;
    st3.WritableState = ya;
    var { EventEmitter: sx } = ki(), ma = Vo().Stream, { Buffer: es } = Ut2(), is = yn(), { addAbortSignal: hx } = Go(), { getHighWaterMark: ux, getDefaultHighWaterMark: lx } = Xo(), { ERR_INVALID_ARG_TYPE: dx, ERR_METHOD_NOT_IMPLEMENTED: cx, ERR_MULTIPLE_CALLBACK: gv, ERR_STREAM_CANNOT_PIPE: px, ERR_STREAM_DESTROYED: ga, ERR_STREAM_ALREADY_FINISHED: vx, ERR_STREAM_NULL_VALUES: bx, ERR_STREAM_WRITE_AFTER_END: mx, ERR_UNKNOWN_ENCODING: yv } = Jt().codes, { errorOrDestroy: uf } = is;
    mv(st3.prototype, ma.prototype);
    mv(st3, ma);
    function $h() {}
    var lf = ax("kOnFinished");
    function ya(t, e, r) {
      typeof r != "boolean" && (r = e instanceof Qr2()), this.objectMode = !!(t && t.objectMode), r && (this.objectMode = this.objectMode || !!(t && t.writableObjectMode)), this.highWaterMark = t ? ux(this, t, "writableHighWaterMark", r) : lx(false), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      let o2 = !!(t && t.decodeStrings === false);
      this.decodeStrings = !o2, this.defaultEncoding = t && t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = yx.bind(undefined, e), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, rs(this), this.pendingcb = 0, this.constructed = true, this.prefinished = false, this.errorEmitted = false, this.emitClose = !t || t.emitClose !== false, this.autoDestroy = !t || t.autoDestroy !== false, this.errored = null, this.closed = false, this.closeEmitted = false, this[lf] = [];
    }
    function rs(t) {
      t.buffered = [], t.bufferedIndex = 0, t.allBuffers = true, t.allNoop = true;
    }
    ya.prototype.getBuffer = function() {
      return pv(this.buffered, this.bufferedIndex);
    };
    bv(ya.prototype, "bufferedRequestCount", { __proto__: null, get() {
      return this.buffered.length - this.bufferedIndex;
    } });
    function st3(t) {
      let e = this instanceof Qr2();
      if (!e && !vv(st3, this))
        return new st3(t);
      this._writableState = new ya(t, this, e), t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final), typeof t.construct == "function" && (this._construct = t.construct), t.signal && hx(t.signal, this)), ma.call(this, t), is.construct(this, () => {
        let r = this._writableState;
        r.writing || Yh(this, r), Xh(this, r);
      });
    }
    bv(st3, ox, { __proto__: null, value: function(t) {
      return vv(this, t) ? true : this !== st3 ? false : t && t._writableState instanceof ya;
    } });
    st3.prototype.pipe = function() {
      uf(this, new px);
    };
    function wv(t, e, r, o2) {
      let f2 = t._writableState;
      if (typeof r == "function")
        o2 = r, r = f2.defaultEncoding;
      else {
        if (!r)
          r = f2.defaultEncoding;
        else if (r !== "buffer" && !es.isEncoding(r))
          throw new yv(r);
        typeof o2 != "function" && (o2 = $h);
      }
      if (e === null)
        throw new bx;
      if (!f2.objectMode)
        if (typeof e == "string")
          f2.decodeStrings !== false && (e = es.from(e, r), r = "buffer");
        else if (e instanceof es)
          r = "buffer";
        else if (ma._isUint8Array(e))
          e = ma._uint8ArrayToBuffer(e), r = "buffer";
        else
          throw new dx("chunk", ["string", "Buffer", "Uint8Array"], e);
      let p3;
      return f2.ending ? p3 = new mx : f2.destroyed && (p3 = new ga("write")), p3 ? (Mn.nextTick(o2, p3), uf(t, p3, true), p3) : (f2.pendingcb++, gx(t, f2, e, r, o2));
    }
    st3.prototype.write = function(t, e, r) {
      return wv(this, t, e, r) === true;
    };
    st3.prototype.cork = function() {
      this._writableState.corked++;
    };
    st3.prototype.uncork = function() {
      let t = this._writableState;
      t.corked && (t.corked--, t.writing || Yh(this, t));
    };
    st3.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = fx(e)), !es.isEncoding(e))
        throw new yv(e);
      return this._writableState.defaultEncoding = e, this;
    };
    function gx(t, e, r, o2, f2) {
      let p3 = e.objectMode ? 1 : r.length;
      e.length += p3;
      let m4 = e.length < e.highWaterMark;
      return m4 || (e.needDrain = true), e.writing || e.corked || e.errored || !e.constructed ? (e.buffered.push({ chunk: r, encoding: o2, callback: f2 }), e.allBuffers && o2 !== "buffer" && (e.allBuffers = false), e.allNoop && f2 !== $h && (e.allNoop = false)) : (e.writelen = p3, e.writecb = f2, e.writing = true, e.sync = true, t._write(r, o2, e.onwrite), e.sync = false), m4 && !e.errored && !e.destroyed;
    }
    function dv(t, e, r, o2, f2, p3, m4) {
      e.writelen = o2, e.writecb = m4, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new ga("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p3, e.onwrite), e.sync = false;
    }
    function cv(t, e, r, o2) {
      --e.pendingcb, o2(r), Gh(e), uf(t, r);
    }
    function yx(t, e) {
      let r = t._writableState, o2 = r.sync, f2 = r.writecb;
      if (typeof f2 != "function") {
        uf(t, new gv);
        return;
      }
      r.writing = false, r.writecb = null, r.length -= r.writelen, r.writelen = 0, e ? (e.stack, r.errored || (r.errored = e), t._readableState && !t._readableState.errored && (t._readableState.errored = e), o2 ? Mn.nextTick(cv, t, r, e, f2) : cv(t, r, e, f2)) : (r.buffered.length > r.bufferedIndex && Yh(t, r), o2 ? r.afterWriteTickInfo !== null && r.afterWriteTickInfo.cb === f2 ? r.afterWriteTickInfo.count++ : (r.afterWriteTickInfo = { count: 1, cb: f2, stream: t, state: r }, Mn.nextTick(wx, r.afterWriteTickInfo)) : Mv(t, r, 1, f2));
    }
    function wx({ stream: t, state: e, count: r, cb: o2 }) {
      return e.afterWriteTickInfo = null, Mv(t, e, r, o2);
    }
    function Mv(t, e, r, o2) {
      for (!e.ending && !t.destroyed && e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));r-- > 0; )
        e.pendingcb--, o2();
      e.destroyed && Gh(e), Xh(t, e);
    }
    function Gh(t) {
      if (t.writing)
        return;
      for (let f2 = t.bufferedIndex;f2 < t.buffered.length; ++f2) {
        var e;
        let { chunk: p3, callback: m4 } = t.buffered[f2], y3 = t.objectMode ? 1 : p3.length;
        t.length -= y3, m4((e = t.errored) !== null && e !== undefined ? e : new ga("write"));
      }
      let r = t[lf].splice(0);
      for (let f2 = 0;f2 < r.length; f2++) {
        var o2;
        r[f2]((o2 = t.errored) !== null && o2 !== undefined ? o2 : new ga("end"));
      }
      rs(t);
    }
    function Yh(t, e) {
      if (e.corked || e.bufferProcessing || e.destroyed || !e.constructed)
        return;
      let { buffered: r, bufferedIndex: o2, objectMode: f2 } = e, p3 = r.length - o2;
      if (!p3)
        return;
      let m4 = o2;
      if (e.bufferProcessing = true, p3 > 1 && t._writev) {
        e.pendingcb -= p3 - 1;
        let y3 = e.allNoop ? $h : (x3) => {
          for (let S2 = m4;S2 < r.length; ++S2)
            r[S2].callback(x3);
        }, M4 = e.allNoop && m4 === 0 ? r : pv(r, m4);
        M4.allBuffers = e.allBuffers, dv(t, e, true, e.length, M4, "", y3), rs(e);
      } else {
        do {
          let { chunk: y3, encoding: M4, callback: x3 } = r[m4];
          r[m4++] = null;
          let S2 = f2 ? 1 : y3.length;
          dv(t, e, false, S2, y3, M4, x3);
        } while (m4 < r.length && !e.writing);
        m4 === r.length ? rs(e) : m4 > 256 ? (r.splice(0, m4), e.bufferedIndex = 0) : e.bufferedIndex = m4;
      }
      e.bufferProcessing = false;
    }
    st3.prototype._write = function(t, e, r) {
      if (this._writev)
        this._writev([{ chunk: t, encoding: e }], r);
      else
        throw new cx("_write()");
    };
    st3.prototype._writev = null;
    st3.prototype.end = function(t, e, r) {
      let o2 = this._writableState;
      typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null);
      let f2;
      if (t != null) {
        let p3 = wv(this, t, e);
        p3 instanceof ix && (f2 = p3);
      }
      return o2.corked && (o2.corked = 1, this.uncork()), f2 || (!o2.errored && !o2.ending ? (o2.ending = true, Xh(this, o2, true), o2.ended = true) : o2.finished ? f2 = new vx("end") : o2.destroyed && (f2 = new ga("end"))), typeof r == "function" && (f2 || o2.finished ? Mn.nextTick(r, f2) : o2[lf].push(r)), this;
    };
    function ts(t) {
      return t.ending && !t.destroyed && t.constructed && t.length === 0 && !t.errored && t.buffered.length === 0 && !t.finished && !t.writing && !t.errorEmitted && !t.closeEmitted;
    }
    function Mx(t, e) {
      let r = false;
      function o2(f2) {
        if (r) {
          uf(t, f2 ?? gv());
          return;
        }
        if (r = true, e.pendingcb--, f2) {
          let p3 = e[lf].splice(0);
          for (let m4 = 0;m4 < p3.length; m4++)
            p3[m4](f2);
          uf(t, f2, e.sync);
        } else
          ts(e) && (e.prefinished = true, t.emit("prefinish"), e.pendingcb++, Mn.nextTick(Vh, t, e));
      }
      e.sync = true, e.pendingcb++;
      try {
        t._final(o2);
      } catch (f2) {
        o2(f2);
      }
      e.sync = false;
    }
    function _x(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.finalCalled = true, Mx(t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Xh(t, e, r) {
      ts(e) && (_x(t, e), e.pendingcb === 0 && (r ? (e.pendingcb++, Mn.nextTick((o2, f2) => {
        ts(f2) ? Vh(o2, f2) : f2.pendingcb--;
      }, t, e)) : ts(e) && (e.pendingcb++, Vh(t, e))));
    }
    function Vh(t, e) {
      e.pendingcb--, e.finished = true;
      let r = e[lf].splice(0);
      for (let o2 = 0;o2 < r.length; o2++)
        r[o2]();
      if (t.emit("finish"), e.autoDestroy) {
        let o2 = t._readableState;
        (!o2 || o2.autoDestroy && (o2.endEmitted || o2.readable === false)) && t.destroy();
      }
    }
    nx(st3.prototype, { closed: { __proto__: null, get() {
      return this._writableState ? this._writableState.closed : false;
    } }, destroyed: { __proto__: null, get() {
      return this._writableState ? this._writableState.destroyed : false;
    }, set(t) {
      this._writableState && (this._writableState.destroyed = t);
    } }, writable: { __proto__: null, get() {
      let t = this._writableState;
      return !!t && t.writable !== false && !t.destroyed && !t.errored && !t.ending && !t.ended;
    }, set(t) {
      this._writableState && (this._writableState.writable = !!t);
    } }, writableFinished: { __proto__: null, get() {
      return this._writableState ? this._writableState.finished : false;
    } }, writableObjectMode: { __proto__: null, get() {
      return this._writableState ? this._writableState.objectMode : false;
    } }, writableBuffer: { __proto__: null, get() {
      return this._writableState && this._writableState.getBuffer();
    } }, writableEnded: { __proto__: null, get() {
      return this._writableState ? this._writableState.ending : false;
    } }, writableNeedDrain: { __proto__: null, get() {
      let t = this._writableState;
      return t ? !t.destroyed && !t.ending && t.needDrain : false;
    } }, writableHighWaterMark: { __proto__: null, get() {
      return this._writableState && this._writableState.highWaterMark;
    } }, writableCorked: { __proto__: null, get() {
      return this._writableState ? this._writableState.corked : 0;
    } }, writableLength: { __proto__: null, get() {
      return this._writableState && this._writableState.length;
    } }, errored: { __proto__: null, enumerable: false, get() {
      return this._writableState ? this._writableState.errored : null;
    } }, writableAborted: { __proto__: null, enumerable: false, get: function() {
      return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
    } } });
    var xx = is.destroy;
    st3.prototype.destroy = function(t, e) {
      let r = this._writableState;
      return !r.destroyed && (r.bufferedIndex < r.buffered.length || r[lf].length) && Mn.nextTick(Gh, r), xx.call(this, t, e), this;
    };
    st3.prototype._undestroy = is.undestroy;
    st3.prototype._destroy = function(t, e) {
      e(t);
    };
    st3.prototype[sx.captureRejectionSymbol] = function(t) {
      this.destroy(t);
    };
    var Zh;
    function _v() {
      return Zh === undefined && (Zh = {}), Zh;
    }
    st3.fromWeb = function(t, e) {
      return _v().newStreamWritableFromWritableStream(t, e);
    };
    st3.toWeb = function(t) {
      return _v().newWritableStreamFromStreamWritable(t);
    };
  });
  Dv = T((ZI, Nv) => {
    var Qh = (Oi(), ur2(pr2)), Sx = Ut2(), { isReadable: Ex, isWritable: Ax, isIterable: Sv, isNodeStream: Rx, isReadableNodeStream: Ev, isWritableNodeStream: Av, isDuplexNodeStream: Bx } = Fi(), Rv = Ui(), { AbortError: Lv, codes: { ERR_INVALID_ARG_TYPE: qx, ERR_INVALID_RETURN_VALUE: Bv } } = Jt(), { destroyer: df } = yn(), Ix = Qr2(), Tx = ba(), { createDeferredPromise: qv } = Gr2(), Iv = Fh(), Tv = globalThis.Blob || Sx.Blob, kx = typeof Tv < "u" ? function(e) {
      return e instanceof Tv;
    } : function(e) {
      return false;
    }, Lx = globalThis.AbortController || No().AbortController, { FunctionPrototypeCall: kv } = Tt3(), _n2 = class extends Ix {
      constructor(e) {
        super(e), e?.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), e?.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true);
      }
    };
    Nv.exports = function t(e, r) {
      if (Bx(e))
        return e;
      if (Ev(e))
        return ns({ readable: e });
      if (Av(e))
        return ns({ writable: e });
      if (Rx(e))
        return ns({ writable: false, readable: false });
      if (typeof e == "function") {
        let { value: f2, write: p3, final: m4, destroy: y3 } = Nx(e);
        if (Sv(f2))
          return Iv(_n2, f2, { objectMode: true, write: p3, final: m4, destroy: y3 });
        let M4 = f2?.then;
        if (typeof M4 == "function") {
          let x3, S2 = kv(M4, f2, (E6) => {
            if (E6 != null)
              throw new Bv("nully", "body", E6);
          }, (E6) => {
            df(x3, E6);
          });
          return x3 = new _n2({ objectMode: true, readable: false, write: p3, final(E6) {
            m4(async () => {
              try {
                await S2, Qh.nextTick(E6, null);
              } catch (B3) {
                Qh.nextTick(E6, B3);
              }
            });
          }, destroy: y3 });
        }
        throw new Bv("Iterable, AsyncIterable or AsyncFunction", r, f2);
      }
      if (kx(e))
        return t(e.arrayBuffer());
      if (Sv(e))
        return Iv(_n2, e, { objectMode: true, writable: false });
      if (typeof e?.writable == "object" || typeof e?.readable == "object") {
        let f2 = e != null && e.readable ? Ev(e?.readable) ? e?.readable : t(e.readable) : undefined, p3 = e != null && e.writable ? Av(e?.writable) ? e?.writable : t(e.writable) : undefined;
        return ns({ readable: f2, writable: p3 });
      }
      let o2 = e?.then;
      if (typeof o2 == "function") {
        let f2;
        return kv(o2, e, (p3) => {
          p3 != null && f2.push(p3), f2.push(null);
        }, (p3) => {
          df(f2, p3);
        }), f2 = new _n2({ objectMode: true, writable: false, read() {} });
      }
      throw new qx(r, ["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"], e);
    };
    function Nx(t) {
      let { promise: e, resolve: r } = qv(), o2 = new Lx, f2 = o2.signal;
      return { value: t(async function* () {
        for (;; ) {
          let m4 = e;
          e = null;
          let { chunk: y3, done: M4, cb: x3 } = await m4;
          if (Qh.nextTick(x3), M4)
            return;
          if (f2.aborted)
            throw new Lv(undefined, { cause: f2.reason });
          ({ promise: e, resolve: r } = qv()), yield y3;
        }
      }(), { signal: f2 }), write(m4, y3, M4) {
        let x3 = r;
        r = null, x3({ chunk: m4, done: false, cb: M4 });
      }, final(m4) {
        let y3 = r;
        r = null, y3({ done: true, cb: m4 });
      }, destroy(m4, y3) {
        o2.abort(), y3(m4);
      } };
    }
    function ns(t) {
      let e = t.readable && typeof t.readable.read != "function" ? Tx.wrap(t.readable) : t.readable, r = t.writable, o2 = !!Ex(e), f2 = !!Ax(r), p3, m4, y3, M4, x3;
      function S2(E6) {
        let B3 = M4;
        M4 = null, B3 ? B3(E6) : E6 ? x3.destroy(E6) : !o2 && !f2 && x3.destroy();
      }
      return x3 = new _n2({ readableObjectMode: !!(e != null && e.readableObjectMode), writableObjectMode: !!(r != null && r.writableObjectMode), readable: o2, writable: f2 }), f2 && (Rv(r, (E6) => {
        f2 = false, E6 && df(e, E6), S2(E6);
      }), x3._write = function(E6, B3, q) {
        r.write(E6, B3) ? q() : p3 = q;
      }, x3._final = function(E6) {
        r.end(), m4 = E6;
      }, r.on("drain", function() {
        if (p3) {
          let E6 = p3;
          p3 = null, E6();
        }
      }), r.on("finish", function() {
        if (m4) {
          let E6 = m4;
          m4 = null, E6();
        }
      })), o2 && (Rv(e, (E6) => {
        o2 = false, E6 && df(e, E6), S2(E6);
      }), e.on("readable", function() {
        if (y3) {
          let E6 = y3;
          y3 = null, E6();
        }
      }), e.on("end", function() {
        x3.push(null);
      }), x3._read = function() {
        for (;; ) {
          let E6 = e.read();
          if (E6 === null) {
            y3 = x3._read;
            return;
          }
          if (!x3.push(E6))
            return;
        }
      }), x3._destroy = function(E6, B3) {
        !E6 && M4 !== null && (E6 = new Lv), y3 = null, p3 = null, m4 = null, M4 === null ? B3(E6) : (M4 = B3, df(r, E6), df(e, E6));
      }, x3;
    }
  });
  Qr2 = T((VI, Ov) => {
    var { ObjectDefineProperties: Dx, ObjectGetOwnPropertyDescriptor: bi3, ObjectKeys: Px, ObjectSetPrototypeOf: Pv } = Tt3();
    Ov.exports = kr;
    var ru = ba(), vr3 = Jh();
    Pv(kr.prototype, ru.prototype);
    Pv(kr, ru);
    {
      let t = Px(vr3.prototype);
      for (let e = 0;e < t.length; e++) {
        let r = t[e];
        kr.prototype[r] || (kr.prototype[r] = vr3.prototype[r]);
      }
    }
    function kr(t) {
      if (!(this instanceof kr))
        return new kr(t);
      ru.call(this, t), vr3.call(this, t), t ? (this.allowHalfOpen = t.allowHalfOpen !== false, t.readable === false && (this._readableState.readable = false, this._readableState.ended = true, this._readableState.endEmitted = true), t.writable === false && (this._writableState.writable = false, this._writableState.ending = true, this._writableState.ended = true, this._writableState.finished = true)) : this.allowHalfOpen = true;
    }
    Dx(kr.prototype, { writable: { __proto__: null, ...bi3(vr3.prototype, "writable") }, writableHighWaterMark: { __proto__: null, ...bi3(vr3.prototype, "writableHighWaterMark") }, writableObjectMode: { __proto__: null, ...bi3(vr3.prototype, "writableObjectMode") }, writableBuffer: { __proto__: null, ...bi3(vr3.prototype, "writableBuffer") }, writableLength: { __proto__: null, ...bi3(vr3.prototype, "writableLength") }, writableFinished: { __proto__: null, ...bi3(vr3.prototype, "writableFinished") }, writableCorked: { __proto__: null, ...bi3(vr3.prototype, "writableCorked") }, writableEnded: { __proto__: null, ...bi3(vr3.prototype, "writableEnded") }, writableNeedDrain: { __proto__: null, ...bi3(vr3.prototype, "writableNeedDrain") }, destroyed: { __proto__: null, get() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set(t) {
      this._readableState && this._writableState && (this._readableState.destroyed = t, this._writableState.destroyed = t);
    } } });
    var eu;
    function Cv() {
      return eu === undefined && (eu = {}), eu;
    }
    kr.fromWeb = function(t, e) {
      return Cv().newStreamDuplexFromReadableWritablePair(t, e);
    };
    kr.toWeb = function(t) {
      return Cv().newReadableWritablePairFromDuplex(t);
    };
    var tu;
    kr.from = function(t) {
      return tu || (tu = Dv()), tu(t, "body");
    };
  });
  fu2 = T(($I, Uv) => {
    var { ObjectSetPrototypeOf: Fv, Symbol: Cx } = Tt3();
    Uv.exports = mi3;
    var { ERR_METHOD_NOT_IMPLEMENTED: Ox } = Jt().codes, nu = Qr2(), { getHighWaterMark: Fx } = Xo();
    Fv(mi3.prototype, nu.prototype);
    Fv(mi3, nu);
    var wa = Cx("kCallback");
    function mi3(t) {
      if (!(this instanceof mi3))
        return new mi3(t);
      let e = t ? Fx(this, t, "readableHighWaterMark", true) : null;
      e === 0 && (t = { ...t, highWaterMark: null, readableHighWaterMark: e, writableHighWaterMark: t.writableHighWaterMark || 0 }), nu.call(this, t), this._readableState.sync = false, this[wa] = null, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", Ux);
    }
    function iu2(t) {
      typeof this._flush == "function" && !this.destroyed ? this._flush((e, r) => {
        if (e) {
          t ? t(e) : this.destroy(e);
          return;
        }
        r != null && this.push(r), this.push(null), t && t();
      }) : (this.push(null), t && t());
    }
    function Ux() {
      this._final !== iu2 && iu2.call(this);
    }
    mi3.prototype._final = iu2;
    mi3.prototype._transform = function(t, e, r) {
      throw new Ox("_transform()");
    };
    mi3.prototype._write = function(t, e, r) {
      let o2 = this._readableState, f2 = this._writableState, p3 = o2.length;
      this._transform(t, e, (m4, y3) => {
        if (m4) {
          r(m4);
          return;
        }
        y3 != null && this.push(y3), f2.ended || p3 === o2.length || o2.length < o2.highWaterMark ? r() : this[wa] = r;
      });
    };
    mi3.prototype._read = function() {
      if (this[wa]) {
        let t = this[wa];
        this[wa] = null, t();
      }
    };
  });
  ou2 = T((GI, Hv) => {
    var { ObjectSetPrototypeOf: zv } = Tt3();
    Hv.exports = cf;
    var au2 = fu2();
    zv(cf.prototype, au2.prototype);
    zv(cf, au2);
    function cf(t) {
      if (!(this instanceof cf))
        return new cf(t);
      au2.call(this, t);
    }
    cf.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  os = T((YI, Gv) => {
    var fs = (Oi(), ur2(pr2)), { ArrayIsArray: zx, Promise: Hx, SymbolAsyncIterator: Wx } = Tt3(), as = Ui(), { once: Kx } = Gr2(), jx = yn(), Wv = Qr2(), { aggregateTwoErrors: Zx, codes: { ERR_INVALID_ARG_TYPE: Vv, ERR_INVALID_RETURN_VALUE: su2, ERR_MISSING_ARGS: Vx, ERR_STREAM_DESTROYED: $x, ERR_STREAM_PREMATURE_CLOSE: Gx }, AbortError: Yx } = Jt(), { validateFunction: Xx, validateAbortSignal: Jx } = pa(), { isIterable: pf, isReadable: hu2, isReadableNodeStream: du, isNodeStream: Kv } = Fi(), Qx = globalThis.AbortController || No().AbortController, uu2, lu2;
    function jv(t, e, r) {
      let o2 = false;
      t.on("close", () => {
        o2 = true;
      });
      let f2 = as(t, { readable: e, writable: r }, (p3) => {
        o2 = !p3;
      });
      return { destroy: (p3) => {
        o2 || (o2 = true, jx.destroyer(t, p3 || new $x("pipe")));
      }, cleanup: f2 };
    }
    function e7(t) {
      return Xx(t[t.length - 1], "streams[stream.length - 1]"), t.pop();
    }
    function t7(t) {
      if (pf(t))
        return t;
      if (du(t))
        return r7(t);
      throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], t);
    }
    async function* r7(t) {
      lu2 || (lu2 = ba()), yield* lu2.prototype[Wx].call(t);
    }
    async function Zv(t, e, r, { end: o2 }) {
      let f2, p3 = null, m4 = (x3) => {
        if (x3 && (f2 = x3), p3) {
          let S2 = p3;
          p3 = null, S2();
        }
      }, y3 = () => new Hx((x3, S2) => {
        f2 ? S2(f2) : p3 = () => {
          f2 ? S2(f2) : x3();
        };
      });
      e.on("drain", m4);
      let M4 = as(e, { readable: false }, m4);
      try {
        e.writableNeedDrain && await y3();
        for await (let x3 of t)
          e.write(x3) || await y3();
        o2 && e.end(), await y3(), r();
      } catch (x3) {
        r(f2 !== x3 ? Zx(f2, x3) : x3);
      } finally {
        M4(), e.off("drain", m4);
      }
    }
    function i7(...t) {
      return $v(t, Kx(e7(t)));
    }
    function $v(t, e, r) {
      if (t.length === 1 && zx(t[0]) && (t = t[0]), t.length < 2)
        throw new Vx("streams");
      let o2 = new Qx, f2 = o2.signal, p3 = r?.signal, m4 = [];
      Jx(p3, "options.signal");
      function y3() {
        q(new Yx);
      }
      p3?.addEventListener("abort", y3);
      let M4, x3, S2 = [], E6 = 0;
      function B3(N5) {
        q(N5, --E6 === 0);
      }
      function q(N5, we) {
        if (N5 && (!M4 || M4.code === "ERR_STREAM_PREMATURE_CLOSE") && (M4 = N5), !(!M4 && !we)) {
          for (;S2.length; )
            S2.shift()(M4);
          p3?.removeEventListener("abort", y3), o2.abort(), we && (M4 || m4.forEach((ye) => ye()), fs.nextTick(e, M4, x3));
        }
      }
      let L3;
      for (let N5 = 0;N5 < t.length; N5++) {
        let we = t[N5], ye = N5 < t.length - 1, xe = N5 > 0, Re = ye || r?.end !== false, Ee = N5 === t.length - 1;
        if (Kv(we)) {
          let Ae2 = function(P2) {
            P2 && P2.name !== "AbortError" && P2.code !== "ERR_STREAM_PREMATURE_CLOSE" && B3(P2);
          };
          var _e3 = Ae2;
          if (Re) {
            let { destroy: P2, cleanup: Se3 } = jv(we, ye, xe);
            S2.push(P2), hu2(we) && Ee && m4.push(Se3);
          }
          we.on("error", Ae2), hu2(we) && Ee && m4.push(() => {
            we.removeListener("error", Ae2);
          });
        }
        if (N5 === 0)
          if (typeof we == "function") {
            if (L3 = we({ signal: f2 }), !pf(L3))
              throw new su2("Iterable, AsyncIterable or Stream", "source", L3);
          } else
            pf(we) || du(we) ? L3 = we : L3 = Wv.from(we);
        else if (typeof we == "function")
          if (L3 = t7(L3), L3 = we(L3, { signal: f2 }), ye) {
            if (!pf(L3, true))
              throw new su2("AsyncIterable", `transform[${N5 - 1}]`, L3);
          } else {
            var ge;
            uu2 || (uu2 = ou2());
            let Ae2 = new uu2({ objectMode: true }), P2 = (ge = L3) === null || ge === undefined ? undefined : ge.then;
            if (typeof P2 == "function")
              E6++, P2.call(L3, (i) => {
                x3 = i, i != null && Ae2.write(i), Re && Ae2.end(), fs.nextTick(B3);
              }, (i) => {
                Ae2.destroy(i), fs.nextTick(B3, i);
              });
            else if (pf(L3, true))
              E6++, Zv(L3, Ae2, B3, { end: Re });
            else
              throw new su2("AsyncIterable or Promise", "destination", L3);
            L3 = Ae2;
            let { destroy: Se3, cleanup: v2 } = jv(L3, false, true);
            S2.push(Se3), Ee && m4.push(v2);
          }
        else if (Kv(we)) {
          if (du(L3)) {
            E6 += 2;
            let Ae2 = n7(L3, we, B3, { end: Re });
            hu2(we) && Ee && m4.push(Ae2);
          } else if (pf(L3))
            E6++, Zv(L3, we, B3, { end: Re });
          else
            throw new Vv("val", ["Readable", "Iterable", "AsyncIterable"], L3);
          L3 = we;
        } else
          L3 = Wv.from(we);
      }
      return (f2 != null && f2.aborted || p3 != null && p3.aborted) && fs.nextTick(y3), L3;
    }
    function n7(t, e, r, { end: o2 }) {
      let f2 = false;
      return e.on("close", () => {
        f2 || r(new Gx);
      }), t.pipe(e, { end: o2 }), o2 ? t.once("end", () => {
        f2 = true, e.end();
      }) : r(), as(t, { readable: true, writable: false }, (p3) => {
        let m4 = t._readableState;
        p3 && p3.code === "ERR_STREAM_PREMATURE_CLOSE" && m4 && m4.ended && !m4.errored && !m4.errorEmitted ? t.once("end", r).once("error", r) : r(p3);
      }), as(e, { readable: false, writable: true }, r);
    }
    Gv.exports = { pipelineImpl: $v, pipeline: i7 };
  });
  eb = T((XI, Qv) => {
    var { pipeline: f7 } = os(), ss = Qr2(), { destroyer: a7 } = yn(), { isNodeStream: o7, isReadable: Yv, isWritable: Xv } = Fi(), { AbortError: s7, codes: { ERR_INVALID_ARG_VALUE: Jv, ERR_MISSING_ARGS: h7 } } = Jt();
    Qv.exports = function(...e) {
      if (e.length === 0)
        throw new h7("streams");
      if (e.length === 1)
        return ss.from(e[0]);
      let r = [...e];
      if (typeof e[0] == "function" && (e[0] = ss.from(e[0])), typeof e[e.length - 1] == "function") {
        let q = e.length - 1;
        e[q] = ss.from(e[q]);
      }
      for (let q = 0;q < e.length; ++q)
        if (!!o7(e[q])) {
          if (q < e.length - 1 && !Yv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be readable");
          if (q > 0 && !Xv(e[q]))
            throw new Jv(`streams[${q}]`, r[q], "must be writable");
        }
      let o2, f2, p3, m4, y3;
      function M4(q) {
        let L3 = m4;
        m4 = null, L3 ? L3(q) : q ? y3.destroy(q) : !B3 && !E6 && y3.destroy();
      }
      let x3 = e[0], S2 = f7(e, M4), E6 = !!Xv(x3), B3 = !!Yv(S2);
      return y3 = new ss({ writableObjectMode: !!(x3 != null && x3.writableObjectMode), readableObjectMode: !!(S2 != null && S2.writableObjectMode), writable: E6, readable: B3 }), E6 && (y3._write = function(q, L3, ge) {
        x3.write(q, L3) ? ge() : o2 = ge;
      }, y3._final = function(q) {
        x3.end(), f2 = q;
      }, x3.on("drain", function() {
        if (o2) {
          let q = o2;
          o2 = null, q();
        }
      }), S2.on("finish", function() {
        if (f2) {
          let q = f2;
          f2 = null, q();
        }
      })), B3 && (S2.on("readable", function() {
        if (p3) {
          let q = p3;
          p3 = null, q();
        }
      }), S2.on("end", function() {
        y3.push(null);
      }), y3._read = function() {
        for (;; ) {
          let q = S2.read();
          if (q === null) {
            p3 = y3._read;
            return;
          }
          if (!y3.push(q))
            return;
        }
      }), y3._destroy = function(q, L3) {
        !q && m4 !== null && (q = new s7), p3 = null, o2 = null, f2 = null, m4 === null ? L3(q) : (m4 = L3, a7(S2, q));
      }, y3;
    };
  });
  cu2 = T((JI, tb) => {
    var { ArrayPrototypePop: u7, Promise: l7 } = Tt3(), { isIterable: d7, isNodeStream: c7 } = Fi(), { pipelineImpl: p7 } = os(), { finished: v7 } = Ui();
    function b7(...t) {
      return new l7((e, r) => {
        let o2, f2, p3 = t[t.length - 1];
        if (p3 && typeof p3 == "object" && !c7(p3) && !d7(p3)) {
          let m4 = u7(t);
          o2 = m4.signal, f2 = m4.end;
        }
        p7(t, (m4, y3) => {
          m4 ? r(m4) : e(y3);
        }, { signal: o2, end: f2 });
      });
    }
    tb.exports = { finished: v7, pipeline: b7 };
  });
  lb = T((QI, ub) => {
    var { Buffer: m7 } = Ut2(), { ObjectDefineProperty: gi3, ObjectKeys: nb, ReflectApply: fb } = Tt3(), { promisify: { custom: ab } } = Gr2(), { streamReturningOperators: rb, promiseReturningOperators: ib } = k1(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ob } } = Jt(), g7 = eb(), { pipeline: sb } = os(), { destroyer: y7 } = yn(), hb = Ui(), pu = cu2(), vu = Fi(), ct2 = ub.exports = Vo().Stream;
    ct2.isDisturbed = vu.isDisturbed;
    ct2.isErrored = vu.isErrored;
    ct2.isReadable = vu.isReadable;
    ct2.Readable = ba();
    for (let t of nb(rb)) {
      let r = function(...o2) {
        if (new.target)
          throw ob();
        return ct2.Readable.from(fb(e, this, o2));
      };
      M7 = r;
      let e = rb[t];
      gi3(r, "name", { __proto__: null, value: e.name }), gi3(r, "length", { __proto__: null, value: e.length }), gi3(ct2.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    for (let t of nb(ib)) {
      let r = function(...f2) {
        if (new.target)
          throw ob();
        return fb(e, this, f2);
      };
      M7 = r;
      let e = ib[t];
      gi3(r, "name", { __proto__: null, value: e.name }), gi3(r, "length", { __proto__: null, value: e.length }), gi3(ct2.Readable.prototype, t, { __proto__: null, value: r, enumerable: false, configurable: true, writable: true });
    }
    var M7;
    ct2.Writable = Jh();
    ct2.Duplex = Qr2();
    ct2.Transform = fu2();
    ct2.PassThrough = ou2();
    ct2.pipeline = sb;
    var { addAbortSignal: w7 } = Go();
    ct2.addAbortSignal = w7;
    ct2.finished = hb;
    ct2.destroy = y7;
    ct2.compose = g7;
    gi3(ct2, "promises", { __proto__: null, configurable: true, enumerable: true, get() {
      return pu;
    } });
    gi3(sb, ab, { __proto__: null, enumerable: true, get() {
      return pu.pipeline;
    } });
    gi3(hb, ab, { __proto__: null, enumerable: true, get() {
      return pu.finished;
    } });
    ct2.Stream = ct2;
    ct2._isUint8Array = function(e) {
      return e instanceof Uint8Array;
    };
    ct2._uint8ArrayToBuffer = function(e) {
      return m7.from(e.buffer, e.byteOffset, e.byteLength);
    };
  });
  bu = T((eT, pt2) => {
    var Lt2 = lb(), _7 = cu2(), x7 = Lt2.Readable.destroy;
    pt2.exports = Lt2.Readable;
    pt2.exports._uint8ArrayToBuffer = Lt2._uint8ArrayToBuffer;
    pt2.exports._isUint8Array = Lt2._isUint8Array;
    pt2.exports.isDisturbed = Lt2.isDisturbed;
    pt2.exports.isErrored = Lt2.isErrored;
    pt2.exports.isReadable = Lt2.isReadable;
    pt2.exports.Readable = Lt2.Readable;
    pt2.exports.Writable = Lt2.Writable;
    pt2.exports.Duplex = Lt2.Duplex;
    pt2.exports.Transform = Lt2.Transform;
    pt2.exports.PassThrough = Lt2.PassThrough;
    pt2.exports.addAbortSignal = Lt2.addAbortSignal;
    pt2.exports.finished = Lt2.finished;
    pt2.exports.destroy = Lt2.destroy;
    pt2.exports.destroy = x7;
    pt2.exports.pipeline = Lt2.pipeline;
    pt2.exports.compose = Lt2.compose;
    Object.defineProperty(Lt2, "promises", { configurable: true, enumerable: true, get() {
      return _7;
    } });
    pt2.exports.Stream = Lt2.Stream;
    pt2.exports.default = pt2.exports;
  });
  vf = {};
  Ja(vf, { default: () => S7 });
  db = R0(() => {
    ot2(vf, rn2(bu()));
    S7 = rn2(bu());
  });
  yi2 = T((rT, vb) => {
    var cb = Te().Buffer, pb = (db(), ur2(vf)).Transform, E7 = co().StringDecoder, A7 = Ie();
    function Lr(t) {
      pb.call(this), this.hashMode = typeof t == "string", this.hashMode ? this[t] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
    }
    A7(Lr, pb);
    Lr.prototype.update = function(t, e, r) {
      typeof t == "string" && (t = cb.from(t, e));
      var o2 = this._update(t);
      return this.hashMode ? this : (r && (o2 = this._toString(o2, r)), o2);
    };
    Lr.prototype.setAutoPadding = function() {};
    Lr.prototype.getAuthTag = function() {
      throw new Error("trying to get auth tag in unsupported state");
    };
    Lr.prototype.setAuthTag = function() {
      throw new Error("trying to set auth tag in unsupported state");
    };
    Lr.prototype.setAAD = function() {
      throw new Error("trying to set aad in unsupported state");
    };
    Lr.prototype._transform = function(t, e, r) {
      var o2;
      try {
        this.hashMode ? this._update(t) : this.push(this._update(t));
      } catch (f2) {
        o2 = f2;
      } finally {
        r(o2);
      }
    };
    Lr.prototype._flush = function(t) {
      var e;
      try {
        this.push(this.__final());
      } catch (r) {
        e = r;
      }
      t(e);
    };
    Lr.prototype._finalOrDigest = function(t) {
      var e = this.__final() || cb.alloc(0);
      return t && (e = this._toString(e, t, true)), e;
    };
    Lr.prototype._toString = function(t, e, r) {
      if (this._decoder || (this._decoder = new E7(e), this._encoding = e), this._encoding !== e)
        throw new Error("can't switch encodings");
      var o2 = this._decoder.write(t);
      return r && (o2 += this._decoder.end()), o2;
    };
    vb.exports = Lr;
  });
  bf = T((iT, mb) => {
    var R7 = Ie(), B7 = Ao(), q7 = Bo(), I7 = ko(), bb = yi2();
    function hs(t) {
      bb.call(this, "digest"), this._hash = t;
    }
    R7(hs, bb);
    hs.prototype._update = function(t) {
      this._hash.update(t);
    };
    hs.prototype._final = function() {
      return this._hash.digest();
    };
    mb.exports = function(e) {
      return e = e.toLowerCase(), e === "md5" ? new B7 : e === "rmd160" || e === "ripemd160" ? new q7 : new hs(I7(e));
    };
  });
  wb = T((nT, yb) => {
    var T7 = Ie(), xn = Te().Buffer, gb = yi2(), k7 = xn.alloc(128), mf = 64;
    function us(t, e) {
      gb.call(this, "digest"), typeof e == "string" && (e = xn.from(e)), this._alg = t, this._key = e, e.length > mf ? e = t(e) : e.length < mf && (e = xn.concat([e, k7], mf));
      for (var r = this._ipad = xn.allocUnsafe(mf), o2 = this._opad = xn.allocUnsafe(mf), f2 = 0;f2 < mf; f2++)
        r[f2] = e[f2] ^ 54, o2[f2] = e[f2] ^ 92;
      this._hash = [r];
    }
    T7(us, gb);
    us.prototype._update = function(t) {
      this._hash.push(t);
    };
    us.prototype._final = function() {
      var t = this._alg(xn.concat(this._hash));
      return this._alg(xn.concat([this._opad, t]));
    };
    yb.exports = us;
  });
  mu = T((fT, Mb) => {
    var L7 = Ao();
    Mb.exports = function(t) {
      return new L7().update(t).digest();
    };
  });
  wu = T((aT, xb) => {
    var N7 = Ie(), D7 = wb(), _b = yi2(), Ma = Te().Buffer, P7 = mu(), gu = Bo(), yu = ko(), C7 = Ma.alloc(128);
    function _a(t, e) {
      _b.call(this, "digest"), typeof e == "string" && (e = Ma.from(e));
      var r = t === "sha512" || t === "sha384" ? 128 : 64;
      if (this._alg = t, this._key = e, e.length > r) {
        var o2 = t === "rmd160" ? new gu : yu(t);
        e = o2.update(e).digest();
      } else
        e.length < r && (e = Ma.concat([e, C7], r));
      for (var f2 = this._ipad = Ma.allocUnsafe(r), p3 = this._opad = Ma.allocUnsafe(r), m4 = 0;m4 < r; m4++)
        f2[m4] = e[m4] ^ 54, p3[m4] = e[m4] ^ 92;
      this._hash = t === "rmd160" ? new gu : yu(t), this._hash.update(f2);
    }
    N7(_a, _b);
    _a.prototype._update = function(t) {
      this._hash.update(t);
    };
    _a.prototype._final = function() {
      var t = this._hash.digest(), e = this._alg === "rmd160" ? new gu : yu(this._alg);
      return e.update(this._opad).update(t).digest();
    };
    xb.exports = function(e, r) {
      return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new _a("rmd160", r) : e === "md5" ? new D7(P7, r) : new _a(e, r);
    };
  });
  Mu = T((oT, O7) => {
    O7.exports = { sha224WithRSAEncryption: { sign: "rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, "RSA-SHA224": { sign: "ecdsa/rsa", hash: "sha224", id: "302d300d06096086480165030402040500041c" }, sha256WithRSAEncryption: { sign: "rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, "RSA-SHA256": { sign: "ecdsa/rsa", hash: "sha256", id: "3031300d060960864801650304020105000420" }, sha384WithRSAEncryption: { sign: "rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, "RSA-SHA384": { sign: "ecdsa/rsa", hash: "sha384", id: "3041300d060960864801650304020205000430" }, sha512WithRSAEncryption: { sign: "rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA512": { sign: "ecdsa/rsa", hash: "sha512", id: "3051300d060960864801650304020305000440" }, "RSA-SHA1": { sign: "rsa", hash: "sha1", id: "3021300906052b0e03021a05000414" }, "ecdsa-with-SHA1": { sign: "ecdsa", hash: "sha1", id: "" }, sha256: { sign: "ecdsa", hash: "sha256", id: "" }, sha224: { sign: "ecdsa", hash: "sha224", id: "" }, sha384: { sign: "ecdsa", hash: "sha384", id: "" }, sha512: { sign: "ecdsa", hash: "sha512", id: "" }, "DSA-SHA": { sign: "dsa", hash: "sha1", id: "" }, "DSA-SHA1": { sign: "dsa", hash: "sha1", id: "" }, DSA: { sign: "dsa", hash: "sha1", id: "" }, "DSA-WITH-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-SHA224": { sign: "dsa", hash: "sha224", id: "" }, "DSA-WITH-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-SHA256": { sign: "dsa", hash: "sha256", id: "" }, "DSA-WITH-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-SHA384": { sign: "dsa", hash: "sha384", id: "" }, "DSA-WITH-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-SHA512": { sign: "dsa", hash: "sha512", id: "" }, "DSA-RIPEMD160": { sign: "dsa", hash: "rmd160", id: "" }, ripemd160WithRSA: { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, "RSA-RIPEMD160": { sign: "rsa", hash: "rmd160", id: "3021300906052b2403020105000414" }, md5WithRSAEncryption: { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" }, "RSA-MD5": { sign: "rsa", hash: "md5", id: "3020300c06082a864886f70d020505000410" } };
  });
  Eb = T((sT, Sb) => {
    Sb.exports = Mu();
  });
  _u = T((hT, Ab) => {
    var F7 = Math.pow(2, 30) - 1;
    Ab.exports = function(t, e) {
      if (typeof t != "number")
        throw new TypeError("Iterations not a number");
      if (t < 0)
        throw new TypeError("Bad iterations");
      if (typeof e != "number")
        throw new TypeError("Key length not a number");
      if (e < 0 || e > F7 || e !== e)
        throw new TypeError("Bad key length");
    };
  });
  xu = T((uT, Bb) => {
    var ls;
    global.process && global.process.browser ? ls = "utf-8" : global.process && global.process.version ? (Rb = parseInt(process.version.split(".")[0].slice(1), 10), ls = Rb >= 6 ? "utf-8" : "binary") : ls = "utf-8";
    var Rb;
    Bb.exports = ls;
  });
  Eu = T((lT, qb) => {
    var Su = Te().Buffer;
    qb.exports = function(t, e, r) {
      if (Su.isBuffer(t))
        return t;
      if (typeof t == "string")
        return Su.from(t, e);
      if (ArrayBuffer.isView(t))
        return Su.from(t.buffer);
      throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
    };
  });
  Au = T((dT, Lb) => {
    var U7 = mu(), z7 = Bo(), H7 = ko(), Sn2 = Te().Buffer, W7 = _u(), Ib = xu(), Tb = Eu(), K7 = Sn2.alloc(128), ds = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, rmd160: 20, ripemd160: 20 };
    function kb(t, e, r) {
      var o2 = j7(t), f2 = t === "sha512" || t === "sha384" ? 128 : 64;
      e.length > f2 ? e = o2(e) : e.length < f2 && (e = Sn2.concat([e, K7], f2));
      for (var p3 = Sn2.allocUnsafe(f2 + ds[t]), m4 = Sn2.allocUnsafe(f2 + ds[t]), y3 = 0;y3 < f2; y3++)
        p3[y3] = e[y3] ^ 54, m4[y3] = e[y3] ^ 92;
      var M4 = Sn2.allocUnsafe(f2 + r + 4);
      p3.copy(M4, 0, 0, f2), this.ipad1 = M4, this.ipad2 = p3, this.opad = m4, this.alg = t, this.blocksize = f2, this.hash = o2, this.size = ds[t];
    }
    kb.prototype.run = function(t, e) {
      t.copy(e, this.blocksize);
      var r = this.hash(e);
      return r.copy(this.opad, this.blocksize), this.hash(this.opad);
    };
    function j7(t) {
      function e(o2) {
        return H7(t).update(o2).digest();
      }
      function r(o2) {
        return new z7().update(o2).digest();
      }
      return t === "rmd160" || t === "ripemd160" ? r : t === "md5" ? U7 : e;
    }
    function Z7(t, e, r, o2, f2) {
      W7(r, o2), t = Tb(t, Ib, "Password"), e = Tb(e, Ib, "Salt"), f2 = f2 || "sha1";
      var p3 = new kb(f2, t, e.length), m4 = Sn2.allocUnsafe(o2), y3 = Sn2.allocUnsafe(e.length + 4);
      e.copy(y3, 0, 0, e.length);
      for (var M4 = 0, x3 = ds[f2], S2 = Math.ceil(o2 / x3), E6 = 1;E6 <= S2; E6++) {
        y3.writeUInt32BE(E6, e.length);
        for (var B3 = p3.run(y3, p3.ipad1), q = B3, L3 = 1;L3 < r; L3++) {
          q = p3.run(q, p3.ipad2);
          for (var ge = 0;ge < x3; ge++)
            B3[ge] ^= q[ge];
        }
        B3.copy(m4, M4), M4 += x3;
      }
      return m4;
    }
    Lb.exports = Z7;
  });
  Ub = T((cT, Fb) => {
    var Cb = Te().Buffer, V7 = _u(), Nb = xu(), Db = Au(), Pb = Eu(), cs, xa = global.crypto && global.crypto.subtle, $7 = { sha: "SHA-1", "sha-1": "SHA-1", sha1: "SHA-1", sha256: "SHA-256", "sha-256": "SHA-256", sha384: "SHA-384", "sha-384": "SHA-384", "sha-512": "SHA-512", sha512: "SHA-512" }, Ru = [];
    function G7(t) {
      if (global.process && !global.process.browser || !xa || !xa.importKey || !xa.deriveBits)
        return Promise.resolve(false);
      if (Ru[t] !== undefined)
        return Ru[t];
      cs = cs || Cb.alloc(8);
      var e = Ob(cs, cs, 10, 128, t).then(function() {
        return true;
      }).catch(function() {
        return false;
      });
      return Ru[t] = e, e;
    }
    var En;
    function Bu() {
      return En || (global.process && global.process.nextTick ? En = global.process.nextTick : global.queueMicrotask ? En = global.queueMicrotask : global.setImmediate ? En = global.setImmediate : En = global.setTimeout, En);
    }
    function Ob(t, e, r, o2, f2) {
      return xa.importKey("raw", t, { name: "PBKDF2" }, false, ["deriveBits"]).then(function(p3) {
        return xa.deriveBits({ name: "PBKDF2", salt: e, iterations: r, hash: { name: f2 } }, p3, o2 << 3);
      }).then(function(p3) {
        return Cb.from(p3);
      });
    }
    function Y7(t, e) {
      t.then(function(r) {
        Bu()(function() {
          e(null, r);
        });
      }, function(r) {
        Bu()(function() {
          e(r);
        });
      });
    }
    Fb.exports = function(t, e, r, o2, f2, p3) {
      typeof f2 == "function" && (p3 = f2, f2 = undefined), f2 = f2 || "sha1";
      var m4 = $7[f2.toLowerCase()];
      if (!m4 || typeof global.Promise != "function") {
        Bu()(function() {
          var y3;
          try {
            y3 = Db(t, e, r, o2, f2);
          } catch (M4) {
            return p3(M4);
          }
          p3(null, y3);
        });
        return;
      }
      if (V7(r, o2), t = Pb(t, Nb, "Password"), e = Pb(e, Nb, "Salt"), typeof p3 != "function")
        throw new Error("No callback provided to pbkdf2");
      Y7(G7(m4).then(function(y3) {
        return y3 ? Ob(t, e, r, o2, m4) : Db(t, e, r, o2, f2);
      }), p3);
    };
  });
  Iu = T((qu) => {
    qu.pbkdf2 = Ub();
    qu.pbkdf2Sync = Au();
  });
  Tu = T((br3) => {
    br3.readUInt32BE = function(e, r) {
      var o2 = e[0 + r] << 24 | e[1 + r] << 16 | e[2 + r] << 8 | e[3 + r];
      return o2 >>> 0;
    };
    br3.writeUInt32BE = function(e, r, o2) {
      e[0 + o2] = r >>> 24, e[1 + o2] = r >>> 16 & 255, e[2 + o2] = r >>> 8 & 255, e[3 + o2] = r & 255;
    };
    br3.ip = function(e, r, o2, f2) {
      for (var p3 = 0, m4 = 0, y3 = 6;y3 >= 0; y3 -= 2) {
        for (var M4 = 0;M4 <= 24; M4 += 8)
          p3 <<= 1, p3 |= r >>> M4 + y3 & 1;
        for (var M4 = 0;M4 <= 24; M4 += 8)
          p3 <<= 1, p3 |= e >>> M4 + y3 & 1;
      }
      for (var y3 = 6;y3 >= 0; y3 -= 2) {
        for (var M4 = 1;M4 <= 25; M4 += 8)
          m4 <<= 1, m4 |= r >>> M4 + y3 & 1;
        for (var M4 = 1;M4 <= 25; M4 += 8)
          m4 <<= 1, m4 |= e >>> M4 + y3 & 1;
      }
      o2[f2 + 0] = p3 >>> 0, o2[f2 + 1] = m4 >>> 0;
    };
    br3.rip = function(e, r, o2, f2) {
      for (var p3 = 0, m4 = 0, y3 = 0;y3 < 4; y3++)
        for (var M4 = 24;M4 >= 0; M4 -= 8)
          p3 <<= 1, p3 |= r >>> M4 + y3 & 1, p3 <<= 1, p3 |= e >>> M4 + y3 & 1;
      for (var y3 = 4;y3 < 8; y3++)
        for (var M4 = 24;M4 >= 0; M4 -= 8)
          m4 <<= 1, m4 |= r >>> M4 + y3 & 1, m4 <<= 1, m4 |= e >>> M4 + y3 & 1;
      o2[f2 + 0] = p3 >>> 0, o2[f2 + 1] = m4 >>> 0;
    };
    br3.pc1 = function(e, r, o2, f2) {
      for (var p3 = 0, m4 = 0, y3 = 7;y3 >= 5; y3--) {
        for (var M4 = 0;M4 <= 24; M4 += 8)
          p3 <<= 1, p3 |= r >> M4 + y3 & 1;
        for (var M4 = 0;M4 <= 24; M4 += 8)
          p3 <<= 1, p3 |= e >> M4 + y3 & 1;
      }
      for (var M4 = 0;M4 <= 24; M4 += 8)
        p3 <<= 1, p3 |= r >> M4 + y3 & 1;
      for (var y3 = 1;y3 <= 3; y3++) {
        for (var M4 = 0;M4 <= 24; M4 += 8)
          m4 <<= 1, m4 |= r >> M4 + y3 & 1;
        for (var M4 = 0;M4 <= 24; M4 += 8)
          m4 <<= 1, m4 |= e >> M4 + y3 & 1;
      }
      for (var M4 = 0;M4 <= 24; M4 += 8)
        m4 <<= 1, m4 |= e >> M4 + y3 & 1;
      o2[f2 + 0] = p3 >>> 0, o2[f2 + 1] = m4 >>> 0;
    };
    br3.r28shl = function(e, r) {
      return e << r & 268435455 | e >>> 28 - r;
    };
    var ps = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
    br3.pc2 = function(e, r, o2, f2) {
      for (var p3 = 0, m4 = 0, y3 = ps.length >>> 1, M4 = 0;M4 < y3; M4++)
        p3 <<= 1, p3 |= e >>> ps[M4] & 1;
      for (var M4 = y3;M4 < ps.length; M4++)
        m4 <<= 1, m4 |= r >>> ps[M4] & 1;
      o2[f2 + 0] = p3 >>> 0, o2[f2 + 1] = m4 >>> 0;
    };
    br3.expand = function(e, r, o2) {
      var f2 = 0, p3 = 0;
      f2 = (e & 1) << 5 | e >>> 27;
      for (var m4 = 23;m4 >= 15; m4 -= 4)
        f2 <<= 6, f2 |= e >>> m4 & 63;
      for (var m4 = 11;m4 >= 3; m4 -= 4)
        p3 |= e >>> m4 & 63, p3 <<= 6;
      p3 |= (e & 31) << 1 | e >>> 31, r[o2 + 0] = f2 >>> 0, r[o2 + 1] = p3 >>> 0;
    };
    var zb = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
    br3.substitute = function(e, r) {
      for (var o2 = 0, f2 = 0;f2 < 4; f2++) {
        var p3 = e >>> 18 - f2 * 6 & 63, m4 = zb[f2 * 64 + p3];
        o2 <<= 4, o2 |= m4;
      }
      for (var f2 = 0;f2 < 4; f2++) {
        var p3 = r >>> 18 - f2 * 6 & 63, m4 = zb[4 * 64 + f2 * 64 + p3];
        o2 <<= 4, o2 |= m4;
      }
      return o2 >>> 0;
    };
    var Hb = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
    br3.permute = function(e) {
      for (var r = 0, o2 = 0;o2 < Hb.length; o2++)
        r <<= 1, r |= e >>> Hb[o2] & 1;
      return r >>> 0;
    };
    br3.padSplit = function(e, r, o2) {
      for (var f2 = e.toString(2);f2.length < r; )
        f2 = "0" + f2;
      for (var p3 = [], m4 = 0;m4 < r; m4 += o2)
        p3.push(f2.slice(m4, m4 + o2));
      return p3.join(" ");
    };
  });
  ar2 = T((bT, Kb) => {
    Kb.exports = Wb;
    function Wb(t, e) {
      if (!t)
        throw new Error(e || "Assertion failed");
    }
    Wb.equal = function(e, r, o2) {
      if (e != r)
        throw new Error(o2 || "Assertion failed: " + e + " != " + r);
    };
  });
  vs = T((mT, jb) => {
    var X7 = ar2();
    function mr2(t) {
      this.options = t, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0;
    }
    jb.exports = mr2;
    mr2.prototype._init = function() {};
    mr2.prototype.update = function(e) {
      return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
    };
    mr2.prototype._buffer = function(e, r) {
      for (var o2 = Math.min(this.buffer.length - this.bufferOff, e.length - r), f2 = 0;f2 < o2; f2++)
        this.buffer[this.bufferOff + f2] = e[r + f2];
      return this.bufferOff += o2, o2;
    };
    mr2.prototype._flushBuffer = function(e, r) {
      return this._update(this.buffer, 0, e, r), this.bufferOff = 0, this.blockSize;
    };
    mr2.prototype._updateEncrypt = function(e) {
      var r = 0, o2 = 0, f2 = (this.bufferOff + e.length) / this.blockSize | 0, p3 = new Array(f2 * this.blockSize);
      this.bufferOff !== 0 && (r += this._buffer(e, r), this.bufferOff === this.buffer.length && (o2 += this._flushBuffer(p3, o2)));
      for (var m4 = e.length - (e.length - r) % this.blockSize;r < m4; r += this.blockSize)
        this._update(e, r, p3, o2), o2 += this.blockSize;
      for (;r < e.length; r++, this.bufferOff++)
        this.buffer[this.bufferOff] = e[r];
      return p3;
    };
    mr2.prototype._updateDecrypt = function(e) {
      for (var r = 0, o2 = 0, f2 = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, p3 = new Array(f2 * this.blockSize);f2 > 0; f2--)
        r += this._buffer(e, r), o2 += this._flushBuffer(p3, o2);
      return r += this._buffer(e, r), p3;
    };
    mr2.prototype.final = function(e) {
      var r;
      e && (r = this.update(e));
      var o2;
      return this.type === "encrypt" ? o2 = this._finalEncrypt() : o2 = this._finalDecrypt(), r ? r.concat(o2) : o2;
    };
    mr2.prototype._pad = function(e, r) {
      if (r === 0)
        return false;
      for (;r < e.length; )
        e[r++] = 0;
      return true;
    };
    mr2.prototype._finalEncrypt = function() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var e = new Array(this.blockSize);
      return this._update(this.buffer, 0, e, 0), e;
    };
    mr2.prototype._unpad = function(e) {
      return e;
    };
    mr2.prototype._finalDecrypt = function() {
      X7.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var e = new Array(this.blockSize);
      return this._flushBuffer(e, 0), this._unpad(e);
    };
  });
  ku = T((gT, $b) => {
    var Zb = ar2(), J7 = Ie(), Nt2 = Tu(), Vb = vs();
    function Q7() {
      this.tmp = new Array(2), this.keys = null;
    }
    function ei(t) {
      Vb.call(this, t);
      var e = new Q7;
      this._desState = e, this.deriveKeys(e, t.key);
    }
    J7(ei, Vb);
    $b.exports = ei;
    ei.create = function(e) {
      return new ei(e);
    };
    var e9 = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
    ei.prototype.deriveKeys = function(e, r) {
      e.keys = new Array(16 * 2), Zb.equal(r.length, this.blockSize, "Invalid key length");
      var o2 = Nt2.readUInt32BE(r, 0), f2 = Nt2.readUInt32BE(r, 4);
      Nt2.pc1(o2, f2, e.tmp, 0), o2 = e.tmp[0], f2 = e.tmp[1];
      for (var p3 = 0;p3 < e.keys.length; p3 += 2) {
        var m4 = e9[p3 >>> 1];
        o2 = Nt2.r28shl(o2, m4), f2 = Nt2.r28shl(f2, m4), Nt2.pc2(o2, f2, e.keys, p3);
      }
    };
    ei.prototype._update = function(e, r, o2, f2) {
      var p3 = this._desState, m4 = Nt2.readUInt32BE(e, r), y3 = Nt2.readUInt32BE(e, r + 4);
      Nt2.ip(m4, y3, p3.tmp, 0), m4 = p3.tmp[0], y3 = p3.tmp[1], this.type === "encrypt" ? this._encrypt(p3, m4, y3, p3.tmp, 0) : this._decrypt(p3, m4, y3, p3.tmp, 0), m4 = p3.tmp[0], y3 = p3.tmp[1], Nt2.writeUInt32BE(o2, m4, f2), Nt2.writeUInt32BE(o2, y3, f2 + 4);
    };
    ei.prototype._pad = function(e, r) {
      for (var o2 = e.length - r, f2 = r;f2 < e.length; f2++)
        e[f2] = o2;
      return true;
    };
    ei.prototype._unpad = function(e) {
      for (var r = e[e.length - 1], o2 = e.length - r;o2 < e.length; o2++)
        Zb.equal(e[o2], r);
      return e.slice(0, e.length - r);
    };
    ei.prototype._encrypt = function(e, r, o2, f2, p3) {
      for (var m4 = r, y3 = o2, M4 = 0;M4 < e.keys.length; M4 += 2) {
        var x3 = e.keys[M4], S2 = e.keys[M4 + 1];
        Nt2.expand(y3, e.tmp, 0), x3 ^= e.tmp[0], S2 ^= e.tmp[1];
        var E6 = Nt2.substitute(x3, S2), B3 = Nt2.permute(E6), q = y3;
        y3 = (m4 ^ B3) >>> 0, m4 = q;
      }
      Nt2.rip(y3, m4, f2, p3);
    };
    ei.prototype._decrypt = function(e, r, o2, f2, p3) {
      for (var m4 = o2, y3 = r, M4 = e.keys.length - 2;M4 >= 0; M4 -= 2) {
        var x3 = e.keys[M4], S2 = e.keys[M4 + 1];
        Nt2.expand(m4, e.tmp, 0), x3 ^= e.tmp[0], S2 ^= e.tmp[1];
        var E6 = Nt2.substitute(x3, S2), B3 = Nt2.permute(E6), q = m4;
        m4 = (y3 ^ B3) >>> 0, y3 = q;
      }
      Nt2.rip(m4, y3, f2, p3);
    };
  });
  Yb = T((Gb) => {
    var t9 = ar2(), r9 = Ie(), bs = {};
    function i9(t) {
      t9.equal(t.length, 8, "Invalid IV length"), this.iv = new Array(8);
      for (var e = 0;e < this.iv.length; e++)
        this.iv[e] = t[e];
    }
    function n9(t) {
      function e(p3) {
        t.call(this, p3), this._cbcInit();
      }
      r9(e, t);
      for (var r = Object.keys(bs), o2 = 0;o2 < r.length; o2++) {
        var f2 = r[o2];
        e.prototype[f2] = bs[f2];
      }
      return e.create = function(m4) {
        return new e(m4);
      }, e;
    }
    Gb.instantiate = n9;
    bs._cbcInit = function() {
      var e = new i9(this.options.iv);
      this._cbcState = e;
    };
    bs._update = function(e, r, o2, f2) {
      var p3 = this._cbcState, m4 = this.constructor.super_.prototype, y3 = p3.iv;
      if (this.type === "encrypt") {
        for (var M4 = 0;M4 < this.blockSize; M4++)
          y3[M4] ^= e[r + M4];
        m4._update.call(this, y3, 0, o2, f2);
        for (var M4 = 0;M4 < this.blockSize; M4++)
          y3[M4] = o2[f2 + M4];
      } else {
        m4._update.call(this, e, r, o2, f2);
        for (var M4 = 0;M4 < this.blockSize; M4++)
          o2[f2 + M4] ^= y3[M4];
        for (var M4 = 0;M4 < this.blockSize; M4++)
          y3[M4] = e[r + M4];
      }
    };
  });
  Qb = T((wT, Jb) => {
    var f9 = ar2(), a9 = Ie(), Xb = vs(), Wi2 = ku();
    function o9(t, e) {
      f9.equal(e.length, 24, "Invalid key length");
      var r = e.slice(0, 8), o2 = e.slice(8, 16), f2 = e.slice(16, 24);
      t === "encrypt" ? this.ciphers = [Wi2.create({ type: "encrypt", key: r }), Wi2.create({ type: "decrypt", key: o2 }), Wi2.create({ type: "encrypt", key: f2 })] : this.ciphers = [Wi2.create({ type: "decrypt", key: f2 }), Wi2.create({ type: "encrypt", key: o2 }), Wi2.create({ type: "decrypt", key: r })];
    }
    function An(t) {
      Xb.call(this, t);
      var e = new o9(this.type, this.options.key);
      this._edeState = e;
    }
    a9(An, Xb);
    Jb.exports = An;
    An.create = function(e) {
      return new An(e);
    };
    An.prototype._update = function(e, r, o2, f2) {
      var p3 = this._edeState;
      p3.ciphers[0]._update(e, r, o2, f2), p3.ciphers[1]._update(o2, f2, o2, f2), p3.ciphers[2]._update(o2, f2, o2, f2);
    };
    An.prototype._pad = Wi2.prototype._pad;
    An.prototype._unpad = Wi2.prototype._unpad;
  });
  em = T((gf) => {
    gf.utils = Tu();
    gf.Cipher = vs();
    gf.DES = ku();
    gf.CBC = Yb();
    gf.EDE = Qb();
  });
  im = T((_T, rm) => {
    var tm = yi2(), wi2 = em(), s9 = Ie(), Rn = Te().Buffer, Sa = { "des-ede3-cbc": wi2.CBC.instantiate(wi2.EDE), "des-ede3": wi2.EDE, "des-ede-cbc": wi2.CBC.instantiate(wi2.EDE), "des-ede": wi2.EDE, "des-cbc": wi2.CBC.instantiate(wi2.DES), "des-ecb": wi2.DES };
    Sa.des = Sa["des-cbc"];
    Sa.des3 = Sa["des-ede3-cbc"];
    rm.exports = ms;
    s9(ms, tm);
    function ms(t) {
      tm.call(this);
      var e = t.mode.toLowerCase(), r = Sa[e], o2;
      t.decrypt ? o2 = "decrypt" : o2 = "encrypt";
      var f2 = t.key;
      Rn.isBuffer(f2) || (f2 = Rn.from(f2)), (e === "des-ede" || e === "des-ede-cbc") && (f2 = Rn.concat([f2, f2.slice(0, 8)]));
      var p3 = t.iv;
      Rn.isBuffer(p3) || (p3 = Rn.from(p3)), this._des = r.create({ key: f2, iv: p3, type: o2 });
    }
    ms.prototype._update = function(t) {
      return Rn.from(this._des.update(t));
    };
    ms.prototype._final = function() {
      return Rn.from(this._des.final());
    };
  });
  nm = T((Lu) => {
    Lu.encrypt = function(t, e) {
      return t._cipher.encryptBlock(e);
    };
    Lu.decrypt = function(t, e) {
      return t._cipher.decryptBlock(e);
    };
  });
  yf = T((ST, fm) => {
    fm.exports = function(e, r) {
      for (var o2 = Math.min(e.length, r.length), f2 = new Buffer(o2), p3 = 0;p3 < o2; ++p3)
        f2[p3] = e[p3] ^ r[p3];
      return f2;
    };
  });
  om = T((Nu) => {
    var am = yf();
    Nu.encrypt = function(t, e) {
      var r = am(e, t._prev);
      return t._prev = t._cipher.encryptBlock(r), t._prev;
    };
    Nu.decrypt = function(t, e) {
      var r = t._prev;
      t._prev = e;
      var o2 = t._cipher.decryptBlock(e);
      return am(o2, r);
    };
  });
  um = T((hm) => {
    var Ea = Te().Buffer, h9 = yf();
    function sm(t, e, r) {
      var o2 = e.length, f2 = h9(e, t._cache);
      return t._cache = t._cache.slice(o2), t._prev = Ea.concat([t._prev, r ? e : f2]), f2;
    }
    hm.encrypt = function(t, e, r) {
      for (var o2 = Ea.allocUnsafe(0), f2;e.length; )
        if (t._cache.length === 0 && (t._cache = t._cipher.encryptBlock(t._prev), t._prev = Ea.allocUnsafe(0)), t._cache.length <= e.length)
          f2 = t._cache.length, o2 = Ea.concat([o2, sm(t, e.slice(0, f2), r)]), e = e.slice(f2);
        else {
          o2 = Ea.concat([o2, sm(t, e, r)]);
          break;
        }
      return o2;
    };
  });
  dm = T((lm) => {
    var Du = Te().Buffer;
    function u9(t, e, r) {
      var o2 = t._cipher.encryptBlock(t._prev), f2 = o2[0] ^ e;
      return t._prev = Du.concat([t._prev.slice(1), Du.from([r ? e : f2])]), f2;
    }
    lm.encrypt = function(t, e, r) {
      for (var o2 = e.length, f2 = Du.allocUnsafe(o2), p3 = -1;++p3 < o2; )
        f2[p3] = u9(t, e[p3], r);
      return f2;
    };
  });
  pm = T((cm) => {
    var gs = Te().Buffer;
    function l9(t, e, r) {
      for (var o2, f2 = -1, p3 = 8, m4 = 0, y3, M4;++f2 < p3; )
        o2 = t._cipher.encryptBlock(t._prev), y3 = e & 1 << 7 - f2 ? 128 : 0, M4 = o2[0] ^ y3, m4 += (M4 & 128) >> f2 % 8, t._prev = d9(t._prev, r ? y3 : M4);
      return m4;
    }
    function d9(t, e) {
      var r = t.length, o2 = -1, f2 = gs.allocUnsafe(t.length);
      for (t = gs.concat([t, gs.from([e])]);++o2 < r; )
        f2[o2] = t[o2] << 1 | t[o2 + 1] >> 7;
      return f2;
    }
    cm.encrypt = function(t, e, r) {
      for (var o2 = e.length, f2 = gs.allocUnsafe(o2), p3 = -1;++p3 < o2; )
        f2[p3] = l9(t, e[p3], r);
      return f2;
    };
  });
  bm = T((vm) => {
    var c9 = yf();
    function p9(t) {
      return t._prev = t._cipher.encryptBlock(t._prev), t._prev;
    }
    vm.encrypt = function(t, e) {
      for (;t._cache.length < e.length; )
        t._cache = Buffer.concat([t._cache, p9(t)]);
      var r = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), c9(e, r);
    };
  });
  Pu = T((IT, mm) => {
    function v9(t) {
      for (var e = t.length, r;e--; )
        if (r = t.readUInt8(e), r === 255)
          t.writeUInt8(0, e);
        else {
          r++, t.writeUInt8(r, e);
          break;
        }
    }
    mm.exports = v9;
  });
  Ou = T((ym) => {
    var b9 = yf(), gm = Te().Buffer, m9 = Pu();
    function g9(t) {
      var e = t._cipher.encryptBlockRaw(t._prev);
      return m9(t._prev), e;
    }
    var Cu = 16;
    ym.encrypt = function(t, e) {
      var r = Math.ceil(e.length / Cu), o2 = t._cache.length;
      t._cache = gm.concat([t._cache, gm.allocUnsafe(r * Cu)]);
      for (var f2 = 0;f2 < r; f2++) {
        var p3 = g9(t), m4 = o2 + f2 * Cu;
        t._cache.writeUInt32BE(p3[0], m4 + 0), t._cache.writeUInt32BE(p3[1], m4 + 4), t._cache.writeUInt32BE(p3[2], m4 + 8), t._cache.writeUInt32BE(p3[3], m4 + 12);
      }
      var y3 = t._cache.slice(0, e.length);
      return t._cache = t._cache.slice(e.length), b9(e, y3);
    };
  });
  Fu = T((kT, y9) => {
    y9.exports = { "aes-128-ecb": { cipher: "AES", key: 128, iv: 0, mode: "ECB", type: "block" }, "aes-192-ecb": { cipher: "AES", key: 192, iv: 0, mode: "ECB", type: "block" }, "aes-256-ecb": { cipher: "AES", key: 256, iv: 0, mode: "ECB", type: "block" }, "aes-128-cbc": { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, "aes-192-cbc": { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, "aes-256-cbc": { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, aes128: { cipher: "AES", key: 128, iv: 16, mode: "CBC", type: "block" }, aes192: { cipher: "AES", key: 192, iv: 16, mode: "CBC", type: "block" }, aes256: { cipher: "AES", key: 256, iv: 16, mode: "CBC", type: "block" }, "aes-128-cfb": { cipher: "AES", key: 128, iv: 16, mode: "CFB", type: "stream" }, "aes-192-cfb": { cipher: "AES", key: 192, iv: 16, mode: "CFB", type: "stream" }, "aes-256-cfb": { cipher: "AES", key: 256, iv: 16, mode: "CFB", type: "stream" }, "aes-128-cfb8": { cipher: "AES", key: 128, iv: 16, mode: "CFB8", type: "stream" }, "aes-192-cfb8": { cipher: "AES", key: 192, iv: 16, mode: "CFB8", type: "stream" }, "aes-256-cfb8": { cipher: "AES", key: 256, iv: 16, mode: "CFB8", type: "stream" }, "aes-128-cfb1": { cipher: "AES", key: 128, iv: 16, mode: "CFB1", type: "stream" }, "aes-192-cfb1": { cipher: "AES", key: 192, iv: 16, mode: "CFB1", type: "stream" }, "aes-256-cfb1": { cipher: "AES", key: 256, iv: 16, mode: "CFB1", type: "stream" }, "aes-128-ofb": { cipher: "AES", key: 128, iv: 16, mode: "OFB", type: "stream" }, "aes-192-ofb": { cipher: "AES", key: 192, iv: 16, mode: "OFB", type: "stream" }, "aes-256-ofb": { cipher: "AES", key: 256, iv: 16, mode: "OFB", type: "stream" }, "aes-128-ctr": { cipher: "AES", key: 128, iv: 16, mode: "CTR", type: "stream" }, "aes-192-ctr": { cipher: "AES", key: 192, iv: 16, mode: "CTR", type: "stream" }, "aes-256-ctr": { cipher: "AES", key: 256, iv: 16, mode: "CTR", type: "stream" }, "aes-128-gcm": { cipher: "AES", key: 128, iv: 12, mode: "GCM", type: "auth" }, "aes-192-gcm": { cipher: "AES", key: 192, iv: 12, mode: "GCM", type: "auth" }, "aes-256-gcm": { cipher: "AES", key: 256, iv: 12, mode: "GCM", type: "auth" } };
  });
  ws = T((LT, wm) => {
    var w9 = { ECB: nm(), CBC: om(), CFB: um(), CFB8: dm(), CFB1: pm(), OFB: bm(), CTR: Ou(), GCM: Ou() }, ys = Fu();
    for (Uu in ys)
      ys[Uu].module = w9[ys[Uu].mode];
    var Uu;
    wm.exports = ys;
  });
  Aa = T((NT, _m) => {
    var Ms = Te().Buffer;
    function Hu(t) {
      Ms.isBuffer(t) || (t = Ms.from(t));
      for (var e = t.length / 4 | 0, r = new Array(e), o2 = 0;o2 < e; o2++)
        r[o2] = t.readUInt32BE(o2 * 4);
      return r;
    }
    function zu(t) {
      for (var e = 0;e < t.length; t++)
        t[e] = 0;
    }
    function Mm(t, e, r, o2, f2) {
      for (var p3 = r[0], m4 = r[1], y3 = r[2], M4 = r[3], x3 = t[0] ^ e[0], S2 = t[1] ^ e[1], E6 = t[2] ^ e[2], B3 = t[3] ^ e[3], q, L3, ge, _e3, N5 = 4, we = 1;we < f2; we++)
        q = p3[x3 >>> 24] ^ m4[S2 >>> 16 & 255] ^ y3[E6 >>> 8 & 255] ^ M4[B3 & 255] ^ e[N5++], L3 = p3[S2 >>> 24] ^ m4[E6 >>> 16 & 255] ^ y3[B3 >>> 8 & 255] ^ M4[x3 & 255] ^ e[N5++], ge = p3[E6 >>> 24] ^ m4[B3 >>> 16 & 255] ^ y3[x3 >>> 8 & 255] ^ M4[S2 & 255] ^ e[N5++], _e3 = p3[B3 >>> 24] ^ m4[x3 >>> 16 & 255] ^ y3[S2 >>> 8 & 255] ^ M4[E6 & 255] ^ e[N5++], x3 = q, S2 = L3, E6 = ge, B3 = _e3;
      return q = (o2[x3 >>> 24] << 24 | o2[S2 >>> 16 & 255] << 16 | o2[E6 >>> 8 & 255] << 8 | o2[B3 & 255]) ^ e[N5++], L3 = (o2[S2 >>> 24] << 24 | o2[E6 >>> 16 & 255] << 16 | o2[B3 >>> 8 & 255] << 8 | o2[x3 & 255]) ^ e[N5++], ge = (o2[E6 >>> 24] << 24 | o2[B3 >>> 16 & 255] << 16 | o2[x3 >>> 8 & 255] << 8 | o2[S2 & 255]) ^ e[N5++], _e3 = (o2[B3 >>> 24] << 24 | o2[x3 >>> 16 & 255] << 16 | o2[S2 >>> 8 & 255] << 8 | o2[E6 & 255]) ^ e[N5++], q = q >>> 0, L3 = L3 >>> 0, ge = ge >>> 0, _e3 = _e3 >>> 0, [q, L3, ge, _e3];
    }
    var M9 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], kt = function() {
      for (var t = new Array(256), e = 0;e < 256; e++)
        e < 128 ? t[e] = e << 1 : t[e] = e << 1 ^ 283;
      for (var r = [], o2 = [], f2 = [[], [], [], []], p3 = [[], [], [], []], m4 = 0, y3 = 0, M4 = 0;M4 < 256; ++M4) {
        var x3 = y3 ^ y3 << 1 ^ y3 << 2 ^ y3 << 3 ^ y3 << 4;
        x3 = x3 >>> 8 ^ x3 & 255 ^ 99, r[m4] = x3, o2[x3] = m4;
        var S2 = t[m4], E6 = t[S2], B3 = t[E6], q = t[x3] * 257 ^ x3 * 16843008;
        f2[0][m4] = q << 24 | q >>> 8, f2[1][m4] = q << 16 | q >>> 16, f2[2][m4] = q << 8 | q >>> 24, f2[3][m4] = q, q = B3 * 16843009 ^ E6 * 65537 ^ S2 * 257 ^ m4 * 16843008, p3[0][x3] = q << 24 | q >>> 8, p3[1][x3] = q << 16 | q >>> 16, p3[2][x3] = q << 8 | q >>> 24, p3[3][x3] = q, m4 === 0 ? m4 = y3 = 1 : (m4 = S2 ^ t[t[t[B3 ^ S2]]], y3 ^= t[t[y3]]);
      }
      return { SBOX: r, INV_SBOX: o2, SUB_MIX: f2, INV_SUB_MIX: p3 };
    }();
    function gr3(t) {
      this._key = Hu(t), this._reset();
    }
    gr3.blockSize = 4 * 4;
    gr3.keySize = 256 / 8;
    gr3.prototype.blockSize = gr3.blockSize;
    gr3.prototype.keySize = gr3.keySize;
    gr3.prototype._reset = function() {
      for (var t = this._key, e = t.length, r = e + 6, o2 = (r + 1) * 4, f2 = [], p3 = 0;p3 < e; p3++)
        f2[p3] = t[p3];
      for (p3 = e;p3 < o2; p3++) {
        var m4 = f2[p3 - 1];
        p3 % e === 0 ? (m4 = m4 << 8 | m4 >>> 24, m4 = kt.SBOX[m4 >>> 24] << 24 | kt.SBOX[m4 >>> 16 & 255] << 16 | kt.SBOX[m4 >>> 8 & 255] << 8 | kt.SBOX[m4 & 255], m4 ^= M9[p3 / e | 0] << 24) : e > 6 && p3 % e === 4 && (m4 = kt.SBOX[m4 >>> 24] << 24 | kt.SBOX[m4 >>> 16 & 255] << 16 | kt.SBOX[m4 >>> 8 & 255] << 8 | kt.SBOX[m4 & 255]), f2[p3] = f2[p3 - e] ^ m4;
      }
      for (var y3 = [], M4 = 0;M4 < o2; M4++) {
        var x3 = o2 - M4, S2 = f2[x3 - (M4 % 4 ? 0 : 4)];
        M4 < 4 || x3 <= 4 ? y3[M4] = S2 : y3[M4] = kt.INV_SUB_MIX[0][kt.SBOX[S2 >>> 24]] ^ kt.INV_SUB_MIX[1][kt.SBOX[S2 >>> 16 & 255]] ^ kt.INV_SUB_MIX[2][kt.SBOX[S2 >>> 8 & 255]] ^ kt.INV_SUB_MIX[3][kt.SBOX[S2 & 255]];
      }
      this._nRounds = r, this._keySchedule = f2, this._invKeySchedule = y3;
    };
    gr3.prototype.encryptBlockRaw = function(t) {
      return t = Hu(t), Mm(t, this._keySchedule, kt.SUB_MIX, kt.SBOX, this._nRounds);
    };
    gr3.prototype.encryptBlock = function(t) {
      var e = this.encryptBlockRaw(t), r = Ms.allocUnsafe(16);
      return r.writeUInt32BE(e[0], 0), r.writeUInt32BE(e[1], 4), r.writeUInt32BE(e[2], 8), r.writeUInt32BE(e[3], 12), r;
    };
    gr3.prototype.decryptBlock = function(t) {
      t = Hu(t);
      var e = t[1];
      t[1] = t[3], t[3] = e;
      var r = Mm(t, this._invKeySchedule, kt.INV_SUB_MIX, kt.INV_SBOX, this._nRounds), o2 = Ms.allocUnsafe(16);
      return o2.writeUInt32BE(r[0], 0), o2.writeUInt32BE(r[3], 4), o2.writeUInt32BE(r[2], 8), o2.writeUInt32BE(r[1], 12), o2;
    };
    gr3.prototype.scrub = function() {
      zu(this._keySchedule), zu(this._invKeySchedule), zu(this._key);
    };
    _m.exports.AES = gr3;
  });
  Em = T((DT, Sm) => {
    var wf = Te().Buffer, _9 = wf.alloc(16, 0);
    function x9(t) {
      return [t.readUInt32BE(0), t.readUInt32BE(4), t.readUInt32BE(8), t.readUInt32BE(12)];
    }
    function xm(t) {
      var e = wf.allocUnsafe(16);
      return e.writeUInt32BE(t[0] >>> 0, 0), e.writeUInt32BE(t[1] >>> 0, 4), e.writeUInt32BE(t[2] >>> 0, 8), e.writeUInt32BE(t[3] >>> 0, 12), e;
    }
    function Ra(t) {
      this.h = t, this.state = wf.alloc(16, 0), this.cache = wf.allocUnsafe(0);
    }
    Ra.prototype.ghash = function(t) {
      for (var e = -1;++e < t.length; )
        this.state[e] ^= t[e];
      this._multiply();
    };
    Ra.prototype._multiply = function() {
      for (var t = x9(this.h), e = [0, 0, 0, 0], r, o2, f2, p3 = -1;++p3 < 128; ) {
        for (o2 = (this.state[~~(p3 / 8)] & 1 << 7 - p3 % 8) !== 0, o2 && (e[0] ^= t[0], e[1] ^= t[1], e[2] ^= t[2], e[3] ^= t[3]), f2 = (t[3] & 1) !== 0, r = 3;r > 0; r--)
          t[r] = t[r] >>> 1 | (t[r - 1] & 1) << 31;
        t[0] = t[0] >>> 1, f2 && (t[0] = t[0] ^ 225 << 24);
      }
      this.state = xm(e);
    };
    Ra.prototype.update = function(t) {
      this.cache = wf.concat([this.cache, t]);
      for (var e;this.cache.length >= 16; )
        e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(e);
    };
    Ra.prototype.final = function(t, e) {
      return this.cache.length && this.ghash(wf.concat([this.cache, _9], 16)), this.ghash(xm([0, t, 0, e])), this.state;
    };
    Sm.exports = Ra;
  });
  Wu = T((PT, Bm) => {
    var S9 = Aa(), rr = Te().Buffer, Am = yi2(), E9 = Ie(), Rm = Em(), A9 = yf(), R9 = Pu();
    function B9(t, e) {
      var r = 0;
      t.length !== e.length && r++;
      for (var o2 = Math.min(t.length, e.length), f2 = 0;f2 < o2; ++f2)
        r += t[f2] ^ e[f2];
      return r;
    }
    function q9(t, e, r) {
      if (e.length === 12)
        return t._finID = rr.concat([e, rr.from([0, 0, 0, 1])]), rr.concat([e, rr.from([0, 0, 0, 2])]);
      var o2 = new Rm(r), f2 = e.length, p3 = f2 % 16;
      o2.update(e), p3 && (p3 = 16 - p3, o2.update(rr.alloc(p3, 0))), o2.update(rr.alloc(8, 0));
      var m4 = f2 * 8, y3 = rr.alloc(8);
      y3.writeUIntBE(m4, 0, 8), o2.update(y3), t._finID = o2.state;
      var M4 = rr.from(t._finID);
      return R9(M4), M4;
    }
    function Bn2(t, e, r, o2) {
      Am.call(this);
      var f2 = rr.alloc(4, 0);
      this._cipher = new S9.AES(e);
      var p3 = this._cipher.encryptBlock(f2);
      this._ghash = new Rm(p3), r = q9(this, r, p3), this._prev = rr.from(r), this._cache = rr.allocUnsafe(0), this._secCache = rr.allocUnsafe(0), this._decrypt = o2, this._alen = 0, this._len = 0, this._mode = t, this._authTag = null, this._called = false;
    }
    E9(Bn2, Am);
    Bn2.prototype._update = function(t) {
      if (!this._called && this._alen) {
        var e = 16 - this._alen % 16;
        e < 16 && (e = rr.alloc(e, 0), this._ghash.update(e));
      }
      this._called = true;
      var r = this._mode.encrypt(this, t);
      return this._decrypt ? this._ghash.update(t) : this._ghash.update(r), this._len += t.length, r;
    };
    Bn2.prototype._final = function() {
      if (this._decrypt && !this._authTag)
        throw new Error("Unsupported state or unable to authenticate data");
      var t = A9(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
      if (this._decrypt && B9(t, this._authTag))
        throw new Error("Unsupported state or unable to authenticate data");
      this._authTag = t, this._cipher.scrub();
    };
    Bn2.prototype.getAuthTag = function() {
      if (this._decrypt || !rr.isBuffer(this._authTag))
        throw new Error("Attempting to get auth tag in unsupported state");
      return this._authTag;
    };
    Bn2.prototype.setAuthTag = function(e) {
      if (!this._decrypt)
        throw new Error("Attempting to set auth tag in unsupported state");
      this._authTag = e;
    };
    Bn2.prototype.setAAD = function(e) {
      if (this._called)
        throw new Error("Attempting to set AAD in unsupported state");
      this._ghash.update(e), this._alen += e.length;
    };
    Bm.exports = Bn2;
  });
  ju = T((CT, Im) => {
    var I9 = Aa(), Ku = Te().Buffer, qm = yi2(), T9 = Ie();
    function _s(t, e, r, o2) {
      qm.call(this), this._cipher = new I9.AES(e), this._prev = Ku.from(r), this._cache = Ku.allocUnsafe(0), this._secCache = Ku.allocUnsafe(0), this._decrypt = o2, this._mode = t;
    }
    T9(_s, qm);
    _s.prototype._update = function(t) {
      return this._mode.encrypt(this, t, this._decrypt);
    };
    _s.prototype._final = function() {
      this._cipher.scrub();
    };
    Im.exports = _s;
  });
  Ba = T((OT, Tm) => {
    var qn = Te().Buffer, k9 = Ao();
    function L9(t, e, r, o2) {
      if (qn.isBuffer(t) || (t = qn.from(t, "binary")), e && (qn.isBuffer(e) || (e = qn.from(e, "binary")), e.length !== 8))
        throw new RangeError("salt should be Buffer with 8 byte length");
      for (var f2 = r / 8, p3 = qn.alloc(f2), m4 = qn.alloc(o2 || 0), y3 = qn.alloc(0);f2 > 0 || o2 > 0; ) {
        var M4 = new k9;
        M4.update(y3), M4.update(t), e && M4.update(e), y3 = M4.digest();
        var x3 = 0;
        if (f2 > 0) {
          var S2 = p3.length - f2;
          x3 = Math.min(f2, y3.length), y3.copy(p3, S2, 0, x3), f2 -= x3;
        }
        if (x3 < y3.length && o2 > 0) {
          var E6 = m4.length - o2, B3 = Math.min(o2, y3.length - x3);
          y3.copy(m4, E6, x3, x3 + B3), o2 -= B3;
        }
      }
      return y3.fill(0), { key: p3, iv: m4 };
    }
    Tm.exports = L9;
  });
  Dm = T((Zu) => {
    var km = ws(), N9 = Wu(), Mi = Te().Buffer, D9 = ju(), Lm = yi2(), P9 = Aa(), C9 = Ba(), O9 = Ie();
    function qa(t, e, r) {
      Lm.call(this), this._cache = new xs, this._cipher = new P9.AES(e), this._prev = Mi.from(r), this._mode = t, this._autopadding = true;
    }
    O9(qa, Lm);
    qa.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o2 = [];e = this._cache.get(); )
        r = this._mode.encrypt(this, e), o2.push(r);
      return Mi.concat(o2);
    };
    var F9 = Mi.alloc(16, 16);
    qa.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return t = this._mode.encrypt(this, t), this._cipher.scrub(), t;
      if (!t.equals(F9))
        throw this._cipher.scrub(), new Error("data not multiple of block length");
    };
    qa.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function xs() {
      this.cache = Mi.allocUnsafe(0);
    }
    xs.prototype.add = function(t) {
      this.cache = Mi.concat([this.cache, t]);
    };
    xs.prototype.get = function() {
      if (this.cache.length > 15) {
        var t = this.cache.slice(0, 16);
        return this.cache = this.cache.slice(16), t;
      }
      return null;
    };
    xs.prototype.flush = function() {
      for (var t = 16 - this.cache.length, e = Mi.allocUnsafe(t), r = -1;++r < t; )
        e.writeUInt8(t, r);
      return Mi.concat([this.cache, e]);
    };
    function Nm(t, e, r) {
      var o2 = km[t.toLowerCase()];
      if (!o2)
        throw new TypeError("invalid suite type");
      if (typeof e == "string" && (e = Mi.from(e)), e.length !== o2.key / 8)
        throw new TypeError("invalid key length " + e.length);
      if (typeof r == "string" && (r = Mi.from(r)), o2.mode !== "GCM" && r.length !== o2.iv)
        throw new TypeError("invalid iv length " + r.length);
      return o2.type === "stream" ? new D9(o2.module, e, r) : o2.type === "auth" ? new N9(o2.module, e, r) : new qa(o2.module, e, r);
    }
    function U9(t, e) {
      var r = km[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o2 = C9(e, false, r.key, r.iv);
      return Nm(t, o2.key, o2.iv);
    }
    Zu.createCipheriv = Nm;
    Zu.createCipher = U9;
  });
  Fm = T((Vu) => {
    var z9 = Wu(), Mf = Te().Buffer, Pm = ws(), H9 = ju(), Cm = yi2(), W9 = Aa(), K9 = Ba(), j9 = Ie();
    function Ia(t, e, r) {
      Cm.call(this), this._cache = new Ss, this._last = undefined, this._cipher = new W9.AES(e), this._prev = Mf.from(r), this._mode = t, this._autopadding = true;
    }
    j9(Ia, Cm);
    Ia.prototype._update = function(t) {
      this._cache.add(t);
      for (var e, r, o2 = [];e = this._cache.get(this._autopadding); )
        r = this._mode.decrypt(this, e), o2.push(r);
      return Mf.concat(o2);
    };
    Ia.prototype._final = function() {
      var t = this._cache.flush();
      if (this._autopadding)
        return Z9(this._mode.decrypt(this, t));
      if (t)
        throw new Error("data not multiple of block length");
    };
    Ia.prototype.setAutoPadding = function(t) {
      return this._autopadding = !!t, this;
    };
    function Ss() {
      this.cache = Mf.allocUnsafe(0);
    }
    Ss.prototype.add = function(t) {
      this.cache = Mf.concat([this.cache, t]);
    };
    Ss.prototype.get = function(t) {
      var e;
      if (t) {
        if (this.cache.length > 16)
          return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      } else if (this.cache.length >= 16)
        return e = this.cache.slice(0, 16), this.cache = this.cache.slice(16), e;
      return null;
    };
    Ss.prototype.flush = function() {
      if (this.cache.length)
        return this.cache;
    };
    function Z9(t) {
      var e = t[15];
      if (e < 1 || e > 16)
        throw new Error("unable to decrypt data");
      for (var r = -1;++r < e; )
        if (t[r + (16 - e)] !== e)
          throw new Error("unable to decrypt data");
      if (e !== 16)
        return t.slice(0, 16 - e);
    }
    function Om(t, e, r) {
      var o2 = Pm[t.toLowerCase()];
      if (!o2)
        throw new TypeError("invalid suite type");
      if (typeof r == "string" && (r = Mf.from(r)), o2.mode !== "GCM" && r.length !== o2.iv)
        throw new TypeError("invalid iv length " + r.length);
      if (typeof e == "string" && (e = Mf.from(e)), e.length !== o2.key / 8)
        throw new TypeError("invalid key length " + e.length);
      return o2.type === "stream" ? new H9(o2.module, e, r, true) : o2.type === "auth" ? new z9(o2.module, e, r, true) : new Ia(o2.module, e, r);
    }
    function V9(t, e) {
      var r = Pm[t.toLowerCase()];
      if (!r)
        throw new TypeError("invalid suite type");
      var o2 = K9(e, false, r.key, r.iv);
      return Om(t, o2.key, o2.iv);
    }
    Vu.createDecipher = V9;
    Vu.createDecipheriv = Om;
  });
  Es = T((Nr) => {
    var Um = Dm(), zm = Fm(), $9 = Fu();
    function G9() {
      return Object.keys($9);
    }
    Nr.createCipher = Nr.Cipher = Um.createCipher;
    Nr.createCipheriv = Nr.Cipheriv = Um.createCipheriv;
    Nr.createDecipher = Nr.Decipher = zm.createDecipher;
    Nr.createDecipheriv = Nr.Decipheriv = zm.createDecipheriv;
    Nr.listCiphers = Nr.getCiphers = G9;
  });
  Hm = T((_i3) => {
    _i3["des-ecb"] = { key: 8, iv: 0 };
    _i3["des-cbc"] = _i3.des = { key: 8, iv: 8 };
    _i3["des-ede3-cbc"] = _i3.des3 = { key: 24, iv: 8 };
    _i3["des-ede3"] = { key: 24, iv: 0 };
    _i3["des-ede-cbc"] = { key: 16, iv: 8 };
    _i3["des-ede"] = { key: 16, iv: 0 };
  });
  Vm = T((Dr2) => {
    var Wm = im(), $u = Es(), Ki2 = ws(), xi3 = Hm(), Km = Ba();
    function Y9(t, e) {
      t = t.toLowerCase();
      var r, o2;
      if (Ki2[t])
        r = Ki2[t].key, o2 = Ki2[t].iv;
      else if (xi3[t])
        r = xi3[t].key * 8, o2 = xi3[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f2 = Km(e, false, r, o2);
      return jm(t, f2.key, f2.iv);
    }
    function X9(t, e) {
      t = t.toLowerCase();
      var r, o2;
      if (Ki2[t])
        r = Ki2[t].key, o2 = Ki2[t].iv;
      else if (xi3[t])
        r = xi3[t].key * 8, o2 = xi3[t].iv;
      else
        throw new TypeError("invalid suite type");
      var f2 = Km(e, false, r, o2);
      return Zm(t, f2.key, f2.iv);
    }
    function jm(t, e, r) {
      if (t = t.toLowerCase(), Ki2[t])
        return $u.createCipheriv(t, e, r);
      if (xi3[t])
        return new Wm({ key: e, iv: r, mode: t });
      throw new TypeError("invalid suite type");
    }
    function Zm(t, e, r) {
      if (t = t.toLowerCase(), Ki2[t])
        return $u.createDecipheriv(t, e, r);
      if (xi3[t])
        return new Wm({ key: e, iv: r, mode: t, decrypt: true });
      throw new TypeError("invalid suite type");
    }
    function J9() {
      return Object.keys(xi3).concat($u.getCiphers());
    }
    Dr2.createCipher = Dr2.Cipher = Y9;
    Dr2.createCipheriv = Dr2.Cipheriv = jm;
    Dr2.createDecipher = Dr2.Decipher = X9;
    Dr2.createDecipheriv = Dr2.Decipheriv = Zm;
    Dr2.listCiphers = Dr2.getCiphers = J9;
  });
  ji2 = T(() => {});
  Yu = T(($m, Gu2) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o2(v2, i) {
        v2.super_ = i;
        var a3 = function() {};
        a3.prototype = i.prototype, v2.prototype = new a3, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a3) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v2 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {}
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f2.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f2.prototype._init = function(i, a3, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h3);
        if (typeof i == "object")
          return this._initArray(i, a3, h3);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s2 = 0;
        i[0] === "-" && (s2++, this.negative = 1), s2 < i.length && (a3 === 16 ? this._parseHex(i, s2, h3) : (this._parseBase(i, a3, s2), h3 === "le" && this._initArray(this.toArray(), a3, h3)));
      }, f2.prototype._initNumber = function(i, a3, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a3, h3);
      }, f2.prototype._initArray = function(i, a3, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u2, c2, b5 = 0;
        if (h3 === "be")
          for (s2 = i.length - 1, u2 = 0;s2 >= 0; s2 -= 3)
            c2 = i[s2] | i[s2 - 1] << 8 | i[s2 - 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        else if (h3 === "le")
          for (s2 = 0, u2 = 0;s2 < i.length; s2 += 3)
            c2 = i[s2] | i[s2 + 1] << 8 | i[s2 + 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        return this.strip();
      };
      function m4(v2, i) {
        var a3 = v2.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y3(v2, i, a3) {
        var h3 = m4(v2, a3);
        return a3 - 1 >= i && (h3 |= m4(v2, a3 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a3, h3) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u2 = 0, c2 = 0, b5;
        if (h3 === "be")
          for (s2 = i.length - 1;s2 >= a3; s2 -= 2)
            b5 = y3(i, a3, s2) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        else {
          var l3 = i.length - a3;
          for (s2 = l3 % 2 === 0 ? a3 + 1 : a3;s2 < i.length; s2 += 2)
            b5 = y3(i, a3, s2) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        }
        this.strip();
      };
      function M4(v2, i, a3, h3) {
        for (var s2 = 0, u2 = Math.min(v2.length, a3), c2 = i;c2 < u2; c2++) {
          var b5 = v2.charCodeAt(c2) - 48;
          s2 *= h3, b5 >= 49 ? s2 += b5 - 49 + 10 : b5 >= 17 ? s2 += b5 - 17 + 10 : s2 += b5;
        }
        return s2;
      }
      f2.prototype._parseBase = function(i, a3, h3) {
        this.words = [0], this.length = 1;
        for (var s2 = 0, u2 = 1;u2 <= 67108863; u2 *= a3)
          s2++;
        s2--, u2 = u2 / a3 | 0;
        for (var c2 = i.length - h3, b5 = c2 % s2, l3 = Math.min(c2, c2 - b5) + h3, n = 0, d3 = h3;d3 < l3; d3 += s2)
          n = M4(i, d3, d3 + s2, a3), this.imuln(u2), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b5 !== 0) {
          var w3 = 1;
          for (n = M4(i, d3, i.length, a3), d3 = 0;d3 < b5; d3++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s2 = 0, u2 = 0, c2 = 0;c2 < this.length; c2++) {
            var b5 = this.words[c2], l3 = ((b5 << s2 | u2) & 16777215).toString(16);
            u2 = b5 >>> 24 - s2 & 16777215, u2 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l3.length] + l3 + h3 : h3 = l3 + h3, s2 += 2, s2 >= 26 && (s2 -= 26, c2--);
          }
          for (u2 !== 0 && (h3 = u2.toString(16) + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d3 = E6[i];
          h3 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g3 = w3.modn(d3).toString(i);
            w3 = w3.idivn(d3), w3.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f2.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f2.prototype.toArrayLike = function(i, a3, h3) {
        var s2 = this.byteLength(), u2 = h3 || Math.max(1, s2);
        r(s2 <= u2, "byte array longer than desired length"), r(u2 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b5 = new i(u2), l3, n, d3 = this.clone();
        if (c2) {
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[n] = l3;
          for (;n < u2; n++)
            b5[n] = 0;
        } else {
          for (n = 0;n < u2 - s2; n++)
            b5[n] = 0;
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[u2 - n - 1] = l3;
        }
        return b5;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a3 = i, h3 = 0;
        return a3 >= 4096 && (h3 += 13, a3 >>>= 13), a3 >= 64 && (h3 += 7, a3 >>>= 7), a3 >= 8 && (h3 += 4, a3 >>>= 4), a3 >= 2 && (h3 += 2, a3 >>>= 2), h3 + a3;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h3 = 0;
        return (a3 & 8191) === 0 && (h3 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h3 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h3 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h3 += 2, a3 >>>= 2), (a3 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v2) {
        for (var i = new Array(v2.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h3 = a3 / 26 | 0, s2 = a3 % 26;
          i[a3] = (v2.words[h3] & 1 << s2) >>> s2;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h3 = this._zeroBits(this.words[a3]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h3 = 0;h3 < a3.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a3, h3;
        this.length > i.length ? (a3 = this, h3 = i) : (a3 = i, h3 = this);
        for (var s2 = 0;s2 < h3.length; s2++)
          this.words[s2] = a3.words[s2] ^ h3.words[s2];
        if (this !== a3)
          for (;s2 < a3.length; s2++)
            this.words[s2] = a3.words[s2];
        return this.length = a3.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a3), h3 > 0 && a3--;
        for (var s2 = 0;s2 < a3; s2++)
          this.words[s2] = ~this.words[s2] & 67108863;
        return h3 > 0 && (this.words[s2] = ~this.words[s2] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s2 = i % 26;
        return this._expand(h3 + 1), a3 ? this.words[h3] = this.words[h3] | 1 << s2 : this.words[h3] = this.words[h3] & ~(1 << s2), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h3, s2;
        this.length > i.length ? (h3 = this, s2 = i) : (h3 = i, s2 = this);
        for (var u2 = 0, c2 = 0;c2 < s2.length; c2++)
          a3 = (h3.words[c2] | 0) + (s2.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        for (;u2 !== 0 && c2 < h3.length; c2++)
          a3 = (h3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        if (this.length = h3.length, u2 !== 0)
          this.words[this.length] = u2, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s2, u2;
        h3 > 0 ? (s2 = this, u2 = i) : (s2 = i, u2 = this);
        for (var c2 = 0, b5 = 0;b5 < u2.length; b5++)
          a3 = (s2.words[b5] | 0) - (u2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        for (;c2 !== 0 && b5 < s2.length; b5++)
          a3 = (s2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        if (c2 === 0 && b5 < s2.length && s2 !== this)
          for (;b5 < s2.length; b5++)
            this.words[b5] = s2.words[b5];
        return this.length = Math.max(this.length, b5), s2 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative;
        var h3 = v2.length + i.length | 0;
        a3.length = h3, h3 = h3 - 1 | 0;
        var s2 = v2.words[0] | 0, u2 = i.words[0] | 0, c2 = s2 * u2, b5 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b5;
        for (var n = 1;n < h3; n++) {
          for (var d3 = l3 >>> 26, w3 = l3 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v2.length + 1);_3 <= g3; _3++) {
            var A3 = n - _3 | 0;
            s2 = v2.words[A3] | 0, u2 = i.words[_3] | 0, c2 = s2 * u2 + w3, d3 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d3 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L3 = function(i, a3, h3) {
        var s2 = i.words, u2 = a3.words, c2 = h3.words, b5 = 0, l3, n, d3, w3 = s2[0] | 0, g3 = w3 & 8191, _3 = w3 >>> 13, A3 = s2[1] | 0, R2 = A3 & 8191, I4 = A3 >>> 13, Me = s2[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt3 = s2[3] | 0, C3 = nt3 & 8191, O2 = nt3 >>> 13, vt = s2[4] | 0, F3 = vt & 8191, U2 = vt >>> 13, bt4 = s2[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt3 = s2[6] | 0, W = mt3 & 8191, K4 = mt3 >>> 13, gt3 = s2[7] | 0, j4 = gt3 & 8191, Z2 = gt3 >>> 13, yt2 = s2[8] | 0, V4 = yt2 & 8191, $ = yt2 >>> 13, wt = s2[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u2[0] | 0, X3 = Mt & 8191, J3 = Mt >>> 13, _t3 = u2[1] | 0, Q4 = _t3 & 8191, ee = _t3 >>> 13, xt3 = u2[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St = u2[3] | 0, ie = St & 8191, ne = St >>> 13, Et2 = u2[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At4 = u2[5] | 0, oe3 = At4 & 8191, se2 = At4 >>> 13, Rt = u2[6] | 0, he = Rt & 8191, ue4 = Rt >>> 13, Bt = u2[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt2 = u2[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u2[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a3.negative, h3.length = 19, l3 = Math.imul(g3, X3), n = Math.imul(g3, J3), n = n + Math.imul(_3, X3) | 0, d3 = Math.imul(_3, J3);
        var ft = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l3 = Math.imul(R2, X3), n = Math.imul(R2, J3), n = n + Math.imul(I4, X3) | 0, d3 = Math.imul(I4, J3), l3 = l3 + Math.imul(g3, Q4) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q4) | 0, d3 = d3 + Math.imul(_3, ee) | 0;
        var Be = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X3), n = Math.imul(k4, J3), n = n + Math.imul(D2, X3) | 0, d3 = Math.imul(D2, J3), l3 = l3 + Math.imul(R2, Q4) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I4, Q4) | 0, d3 = d3 + Math.imul(I4, ee) | 0, l3 = l3 + Math.imul(g3, te2) | 0, n = n + Math.imul(g3, re2) | 0, n = n + Math.imul(_3, te2) | 0, d3 = d3 + Math.imul(_3, re2) | 0;
        var qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C3, X3), n = Math.imul(C3, J3), n = n + Math.imul(O2, X3) | 0, d3 = Math.imul(O2, J3), l3 = l3 + Math.imul(k4, Q4) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q4) | 0, d3 = d3 + Math.imul(D2, ee) | 0, l3 = l3 + Math.imul(R2, te2) | 0, n = n + Math.imul(R2, re2) | 0, n = n + Math.imul(I4, te2) | 0, d3 = d3 + Math.imul(I4, re2) | 0, l3 = l3 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d3 = d3 + Math.imul(_3, ne) | 0;
        var ze = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F3, X3), n = Math.imul(F3, J3), n = n + Math.imul(U2, X3) | 0, d3 = Math.imul(U2, J3), l3 = l3 + Math.imul(C3, Q4) | 0, n = n + Math.imul(C3, ee) | 0, n = n + Math.imul(O2, Q4) | 0, d3 = d3 + Math.imul(O2, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D2, te2) | 0, d3 = d3 + Math.imul(D2, re2) | 0, l3 = l3 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I4, ie) | 0, d3 = d3 + Math.imul(I4, ne) | 0, l3 = l3 + Math.imul(g3, fe3) | 0, n = n + Math.imul(g3, ae2) | 0, n = n + Math.imul(_3, fe3) | 0, d3 = d3 + Math.imul(_3, ae2) | 0;
        var He3 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X3), n = Math.imul(z, J3), n = n + Math.imul(H3, X3) | 0, d3 = Math.imul(H3, J3), l3 = l3 + Math.imul(F3, Q4) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U2, Q4) | 0, d3 = d3 + Math.imul(U2, ee) | 0, l3 = l3 + Math.imul(C3, te2) | 0, n = n + Math.imul(C3, re2) | 0, n = n + Math.imul(O2, te2) | 0, d3 = d3 + Math.imul(O2, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d3 = d3 + Math.imul(D2, ne) | 0, l3 = l3 + Math.imul(R2, fe3) | 0, n = n + Math.imul(R2, ae2) | 0, n = n + Math.imul(I4, fe3) | 0, d3 = d3 + Math.imul(I4, ae2) | 0, l3 = l3 + Math.imul(g3, oe3) | 0, n = n + Math.imul(g3, se2) | 0, n = n + Math.imul(_3, oe3) | 0, d3 = d3 + Math.imul(_3, se2) | 0;
        var We2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X3), n = Math.imul(W, J3), n = n + Math.imul(K4, X3) | 0, d3 = Math.imul(K4, J3), l3 = l3 + Math.imul(z, Q4) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q4) | 0, d3 = d3 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F3, te2) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U2, te2) | 0, d3 = d3 + Math.imul(U2, re2) | 0, l3 = l3 + Math.imul(C3, ie) | 0, n = n + Math.imul(C3, ne) | 0, n = n + Math.imul(O2, ie) | 0, d3 = d3 + Math.imul(O2, ne) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D2, fe3) | 0, d3 = d3 + Math.imul(D2, ae2) | 0, l3 = l3 + Math.imul(R2, oe3) | 0, n = n + Math.imul(R2, se2) | 0, n = n + Math.imul(I4, oe3) | 0, d3 = d3 + Math.imul(I4, se2) | 0, l3 = l3 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue4) | 0, n = n + Math.imul(_3, he) | 0, d3 = d3 + Math.imul(_3, ue4) | 0;
        var Ke2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j4, X3), n = Math.imul(j4, J3), n = n + Math.imul(Z2, X3) | 0, d3 = Math.imul(Z2, J3), l3 = l3 + Math.imul(W, Q4) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K4, Q4) | 0, d3 = d3 + Math.imul(K4, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d3 = d3 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U2, ie) | 0, d3 = d3 + Math.imul(U2, ne) | 0, l3 = l3 + Math.imul(C3, fe3) | 0, n = n + Math.imul(C3, ae2) | 0, n = n + Math.imul(O2, fe3) | 0, d3 = d3 + Math.imul(O2, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se2) | 0, n = n + Math.imul(D2, oe3) | 0, d3 = d3 + Math.imul(D2, se2) | 0, l3 = l3 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue4) | 0, n = n + Math.imul(I4, he) | 0, d3 = d3 + Math.imul(I4, ue4) | 0, l3 = l3 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d3 = d3 + Math.imul(_3, de) | 0;
        var je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V4, X3), n = Math.imul(V4, J3), n = n + Math.imul($, X3) | 0, d3 = Math.imul($, J3), l3 = l3 + Math.imul(j4, Q4) | 0, n = n + Math.imul(j4, ee) | 0, n = n + Math.imul(Z2, Q4) | 0, d3 = d3 + Math.imul(Z2, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K4, te2) | 0, d3 = d3 + Math.imul(K4, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H3, ie) | 0, d3 = d3 + Math.imul(H3, ne) | 0, l3 = l3 + Math.imul(F3, fe3) | 0, n = n + Math.imul(F3, ae2) | 0, n = n + Math.imul(U2, fe3) | 0, d3 = d3 + Math.imul(U2, ae2) | 0, l3 = l3 + Math.imul(C3, oe3) | 0, n = n + Math.imul(C3, se2) | 0, n = n + Math.imul(O2, oe3) | 0, d3 = d3 + Math.imul(O2, se2) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D2, he) | 0, d3 = d3 + Math.imul(D2, ue4) | 0, l3 = l3 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I4, le) | 0, d3 = d3 + Math.imul(I4, de) | 0, l3 = l3 + Math.imul(g3, ce3) | 0, n = n + Math.imul(g3, pe2) | 0, n = n + Math.imul(_3, ce3) | 0, d3 = d3 + Math.imul(_3, pe2) | 0;
        var Ze2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X3), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X3) | 0, d3 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V4, Q4) | 0, n = n + Math.imul(V4, ee) | 0, n = n + Math.imul($, Q4) | 0, d3 = d3 + Math.imul($, ee) | 0, l3 = l3 + Math.imul(j4, te2) | 0, n = n + Math.imul(j4, re2) | 0, n = n + Math.imul(Z2, te2) | 0, d3 = d3 + Math.imul(Z2, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K4, ie) | 0, d3 = d3 + Math.imul(K4, ne) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d3 = d3 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F3, oe3) | 0, n = n + Math.imul(F3, se2) | 0, n = n + Math.imul(U2, oe3) | 0, d3 = d3 + Math.imul(U2, se2) | 0, l3 = l3 + Math.imul(C3, he) | 0, n = n + Math.imul(C3, ue4) | 0, n = n + Math.imul(O2, he) | 0, d3 = d3 + Math.imul(O2, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d3 = d3 + Math.imul(D2, de) | 0, l3 = l3 + Math.imul(R2, ce3) | 0, n = n + Math.imul(R2, pe2) | 0, n = n + Math.imul(I4, ce3) | 0, d3 = d3 + Math.imul(I4, pe2) | 0, l3 = l3 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d3 = d3 + Math.imul(_3, be) | 0;
        var Ve = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q4), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q4) | 0, d3 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V4, te2) | 0, n = n + Math.imul(V4, re2) | 0, n = n + Math.imul($, te2) | 0, d3 = d3 + Math.imul($, re2) | 0, l3 = l3 + Math.imul(j4, ie) | 0, n = n + Math.imul(j4, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d3 = d3 + Math.imul(Z2, ne) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K4, fe3) | 0, d3 = d3 + Math.imul(K4, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se2) | 0, n = n + Math.imul(H3, oe3) | 0, d3 = d3 + Math.imul(H3, se2) | 0, l3 = l3 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue4) | 0, n = n + Math.imul(U2, he) | 0, d3 = d3 + Math.imul(U2, ue4) | 0, l3 = l3 + Math.imul(C3, le) | 0, n = n + Math.imul(C3, de) | 0, n = n + Math.imul(O2, le) | 0, d3 = d3 + Math.imul(O2, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D2, ce3) | 0, d3 = d3 + Math.imul(D2, pe2) | 0, l3 = l3 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I4, ve) | 0, d3 = d3 + Math.imul(I4, be) | 0;
        var $e2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d3 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V4, ie) | 0, n = n + Math.imul(V4, ne) | 0, n = n + Math.imul($, ie) | 0, d3 = d3 + Math.imul($, ne) | 0, l3 = l3 + Math.imul(j4, fe3) | 0, n = n + Math.imul(j4, ae2) | 0, n = n + Math.imul(Z2, fe3) | 0, d3 = d3 + Math.imul(Z2, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se2) | 0, n = n + Math.imul(K4, oe3) | 0, d3 = d3 + Math.imul(K4, se2) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d3 = d3 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U2, le) | 0, d3 = d3 + Math.imul(U2, de) | 0, l3 = l3 + Math.imul(C3, ce3) | 0, n = n + Math.imul(C3, pe2) | 0, n = n + Math.imul(O2, ce3) | 0, d3 = d3 + Math.imul(O2, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d3 = d3 + Math.imul(D2, be) | 0;
        var Ge = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y3, ie) | 0, d3 = Math.imul(Y3, ne), l3 = l3 + Math.imul(V4, fe3) | 0, n = n + Math.imul(V4, ae2) | 0, n = n + Math.imul($, fe3) | 0, d3 = d3 + Math.imul($, ae2) | 0, l3 = l3 + Math.imul(j4, oe3) | 0, n = n + Math.imul(j4, se2) | 0, n = n + Math.imul(Z2, oe3) | 0, d3 = d3 + Math.imul(Z2, se2) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K4, he) | 0, d3 = d3 + Math.imul(K4, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d3 = d3 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F3, ce3) | 0, n = n + Math.imul(F3, pe2) | 0, n = n + Math.imul(U2, ce3) | 0, d3 = d3 + Math.imul(U2, pe2) | 0, l3 = l3 + Math.imul(C3, ve) | 0, n = n + Math.imul(C3, be) | 0, n = n + Math.imul(O2, ve) | 0, d3 = d3 + Math.imul(O2, be) | 0;
        var Ye = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d3 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V4, oe3) | 0, n = n + Math.imul(V4, se2) | 0, n = n + Math.imul($, oe3) | 0, d3 = d3 + Math.imul($, se2) | 0, l3 = l3 + Math.imul(j4, he) | 0, n = n + Math.imul(j4, ue4) | 0, n = n + Math.imul(Z2, he) | 0, d3 = d3 + Math.imul(Z2, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K4, le) | 0, d3 = d3 + Math.imul(K4, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d3 = d3 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U2, ve) | 0, d3 = d3 + Math.imul(U2, be) | 0;
        var Xe = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se2), n = n + Math.imul(Y3, oe3) | 0, d3 = Math.imul(Y3, se2), l3 = l3 + Math.imul(V4, he) | 0, n = n + Math.imul(V4, ue4) | 0, n = n + Math.imul($, he) | 0, d3 = d3 + Math.imul($, ue4) | 0, l3 = l3 + Math.imul(j4, le) | 0, n = n + Math.imul(j4, de) | 0, n = n + Math.imul(Z2, le) | 0, d3 = d3 + Math.imul(Z2, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K4, ce3) | 0, d3 = d3 + Math.imul(K4, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H3, ve) | 0, d3 = d3 + Math.imul(H3, be) | 0;
        var Je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d3 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V4, le) | 0, n = n + Math.imul(V4, de) | 0, n = n + Math.imul($, le) | 0, d3 = d3 + Math.imul($, de) | 0, l3 = l3 + Math.imul(j4, ce3) | 0, n = n + Math.imul(j4, pe2) | 0, n = n + Math.imul(Z2, ce3) | 0, d3 = d3 + Math.imul(Z2, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K4, ve) | 0, d3 = d3 + Math.imul(K4, be) | 0;
        var Qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d3 = Math.imul(Y3, de), l3 = l3 + Math.imul(V4, ce3) | 0, n = n + Math.imul(V4, pe2) | 0, n = n + Math.imul($, ce3) | 0, d3 = d3 + Math.imul($, pe2) | 0, l3 = l3 + Math.imul(j4, ve) | 0, n = n + Math.imul(j4, be) | 0, n = n + Math.imul(Z2, ve) | 0, d3 = d3 + Math.imul(Z2, be) | 0;
        var et4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (et4 >>> 26) | 0, et4 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d3 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V4, ve) | 0, n = n + Math.imul(V4, be) | 0, n = n + Math.imul($, ve) | 0, d3 = d3 + Math.imul($, be) | 0;
        var tt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y3, ve) | 0, d3 = Math.imul(Y3, be);
        var rt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b5 = (d3 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et4, c2[17] = tt4, c2[18] = rt4, b5 !== 0 && (c2[19] = b5, h3.length++), h3;
      };
      Math.imul || (L3 = q);
      function ge(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative, a3.length = v2.length + i.length;
        for (var h3 = 0, s2 = 0, u2 = 0;u2 < a3.length - 1; u2++) {
          var c2 = s2;
          s2 = 0;
          for (var b5 = h3 & 67108863, l3 = Math.min(u2, i.length - 1), n = Math.max(0, u2 - v2.length + 1);n <= l3; n++) {
            var d3 = u2 - n, w3 = v2.words[d3] | 0, g3 = i.words[n] | 0, _3 = w3 * g3, A3 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A3 = A3 + b5 | 0, b5 = A3 & 67108863, c2 = c2 + (A3 >>> 26) | 0, s2 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u2] = b5, h3 = c2, c2 = s2;
        }
        return h3 !== 0 ? a3.words[u2] = h3 : a3.length--, a3.strip();
      }
      function _e3(v2, i, a3) {
        var h3 = new N5;
        return h3.mulp(v2, i, a3);
      }
      f2.prototype.mulTo = function(i, a3) {
        var h3, s2 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a3) : s2 < 63 ? h3 = q(this, i, a3) : s2 < 1024 ? h3 = ge(this, i, a3) : h3 = _e3(this, i, a3), h3;
      };
      function N5(v2, i) {
        this.x = v2, this.y = i;
      }
      N5.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s2 = 0;s2 < i; s2++)
          a3[s2] = this.revBin(s2, h3, i);
        return a3;
      }, N5.prototype.revBin = function(i, a3, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s2 = 0, u2 = 0;u2 < a3; u2++)
          s2 |= (i & 1) << a3 - u2 - 1, i >>= 1;
        return s2;
      }, N5.prototype.permute = function(i, a3, h3, s2, u2, c2) {
        for (var b5 = 0;b5 < c2; b5++)
          s2[b5] = a3[i[b5]], u2[b5] = h3[i[b5]];
      }, N5.prototype.transform = function(i, a3, h3, s2, u2, c2) {
        this.permute(c2, i, a3, h3, s2, u2);
        for (var b5 = 1;b5 < u2; b5 <<= 1)
          for (var l3 = b5 << 1, n = Math.cos(2 * Math.PI / l3), d3 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u2; w3 += l3)
            for (var g3 = n, _3 = d3, A3 = 0;A3 < b5; A3++) {
              var R2 = h3[w3 + A3], I4 = s2[w3 + A3], Me = h3[w3 + A3 + b5], k4 = s2[w3 + A3 + b5], D2 = g3 * Me - _3 * k4;
              k4 = g3 * k4 + _3 * Me, Me = D2, h3[w3 + A3] = R2 + Me, s2[w3 + A3] = I4 + k4, h3[w3 + A3 + b5] = R2 - Me, s2[w3 + A3 + b5] = I4 - k4, A3 !== l3 && (D2 = n * g3 - d3 * _3, _3 = n * _3 + d3 * g3, g3 = D2);
            }
      }, N5.prototype.guessLen13b = function(i, a3) {
        var h3 = Math.max(a3, i) | 1, s2 = h3 & 1, u2 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u2++;
        return 1 << u2 + 1 + s2;
      }, N5.prototype.conjugate = function(i, a3, h3) {
        if (!(h3 <= 1))
          for (var s2 = 0;s2 < h3 / 2; s2++) {
            var u2 = i[s2];
            i[s2] = i[h3 - s2 - 1], i[h3 - s2 - 1] = u2, u2 = a3[s2], a3[s2] = -a3[h3 - s2 - 1], a3[h3 - s2 - 1] = -u2;
          }
      }, N5.prototype.normalize13b = function(i, a3) {
        for (var h3 = 0, s2 = 0;s2 < a3 / 2; s2++) {
          var u2 = Math.round(i[2 * s2 + 1] / a3) * 8192 + Math.round(i[2 * s2] / a3) + h3;
          i[s2] = u2 & 67108863, u2 < 67108864 ? h3 = 0 : h3 = u2 / 67108864 | 0;
        }
        return i;
      }, N5.prototype.convert13b = function(i, a3, h3, s2) {
        for (var u2 = 0, c2 = 0;c2 < a3; c2++)
          u2 = u2 + (i[c2] | 0), h3[2 * c2] = u2 & 8191, u2 = u2 >>> 13, h3[2 * c2 + 1] = u2 & 8191, u2 = u2 >>> 13;
        for (c2 = 2 * a3;c2 < s2; ++c2)
          h3[c2] = 0;
        r(u2 === 0), r((u2 & -8192) === 0);
      }, N5.prototype.stub = function(i) {
        for (var a3 = new Array(i), h3 = 0;h3 < i; h3++)
          a3[h3] = 0;
        return a3;
      }, N5.prototype.mulp = function(i, a3, h3) {
        var s2 = 2 * this.guessLen13b(i.length, a3.length), u2 = this.makeRBT(s2), c2 = this.stub(s2), b5 = new Array(s2), l3 = new Array(s2), n = new Array(s2), d3 = new Array(s2), w3 = new Array(s2), g3 = new Array(s2), _3 = h3.words;
        _3.length = s2, this.convert13b(i.words, i.length, b5, s2), this.convert13b(a3.words, a3.length, d3, s2), this.transform(b5, c2, l3, n, s2, u2), this.transform(d3, c2, w3, g3, s2, u2);
        for (var A3 = 0;A3 < s2; A3++) {
          var R2 = l3[A3] * w3[A3] - n[A3] * g3[A3];
          n[A3] = l3[A3] * g3[A3] + n[A3] * w3[A3], l3[A3] = R2;
        }
        return this.conjugate(l3, n, s2), this.transform(l3, n, _3, c2, s2, u2), this.conjugate(_3, c2, s2), this.normalize13b(_3, s2), h3.negative = i.negative ^ a3.negative, h3.length = i.length + a3.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f2.prototype.mulf = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h3 = 0;h3 < this.length; h3++) {
          var s2 = (this.words[h3] | 0) * i, u2 = (s2 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s2 / 67108864 | 0, a3 += u2 >>> 26, this.words[h3] = u2 & 67108863;
        }
        return a3 !== 0 && (this.words[h3] = a3, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f2(1);
        for (var h3 = this, s2 = 0;s2 < a3.length && a3[s2] === 0; s2++, h3 = h3.sqr())
          ;
        if (++s2 < a3.length)
          for (var u2 = h3.sqr();s2 < a3.length; s2++, u2 = u2.sqr())
            a3[s2] !== 0 && (h3 = h3.mul(u2));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s2 = 67108863 >>> 26 - a3 << 26 - a3, u2;
        if (a3 !== 0) {
          var c2 = 0;
          for (u2 = 0;u2 < this.length; u2++) {
            var b5 = this.words[u2] & s2, l3 = (this.words[u2] | 0) - b5 << a3;
            this.words[u2] = l3 | c2, c2 = b5 >>> 26 - a3;
          }
          c2 && (this.words[u2] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u2 = this.length - 1;u2 >= 0; u2--)
            this.words[u2 + h3] = this.words[u2];
          for (u2 = 0;u2 < h3; u2++)
            this.words[u2] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a3, h3) {
        r(typeof i == "number" && i >= 0);
        var s2;
        a3 ? s2 = (a3 - a3 % 26) / 26 : s2 = 0;
        var u2 = i % 26, c2 = Math.min((i - u2) / 26, this.length), b5 = 67108863 ^ 67108863 >>> u2 << u2, l3 = h3;
        if (s2 -= c2, s2 = Math.max(0, s2), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d3 = 0;
        for (n = this.length - 1;n >= 0 && (d3 !== 0 || n >= s2); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d3 << 26 - u2 | w3 >>> u2, d3 = w3 & b5;
        }
        return l3 && d3 !== 0 && (l3.words[l3.length++] = d3), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a3, h3) {
        return r(this.negative === 0), this.iushrn(i, a3, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h3)
          return false;
        var u2 = this.words[h3];
        return !!(u2 & s2);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a3 !== 0 && h3++, this.length = Math.min(h3, this.length), a3 !== 0) {
          var s2 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s2;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a3, h3) {
        var s2 = i.length + h3, u2;
        this._expand(s2);
        var c2, b5 = 0;
        for (u2 = 0;u2 < i.length; u2++) {
          c2 = (this.words[u2 + h3] | 0) + b5;
          var l3 = (i.words[u2] | 0) * a3;
          c2 -= l3 & 67108863, b5 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u2 + h3] = c2 & 67108863;
        }
        for (;u2 < this.length - h3; u2++)
          c2 = (this.words[u2 + h3] | 0) + b5, b5 = c2 >> 26, this.words[u2 + h3] = c2 & 67108863;
        if (b5 === 0)
          return this.strip();
        for (r(b5 === -1), b5 = 0, u2 = 0;u2 < this.length; u2++)
          c2 = -(this.words[u2] | 0) + b5, b5 = c2 >> 26, this.words[u2] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a3) {
        var h3 = this.length - i.length, s2 = this.clone(), u2 = i, c2 = u2.words[u2.length - 1] | 0, b5 = this._countBits(c2);
        h3 = 26 - b5, h3 !== 0 && (u2 = u2.ushln(h3), s2.iushln(h3), c2 = u2.words[u2.length - 1] | 0);
        var l3 = s2.length - u2.length, n;
        if (a3 !== "mod") {
          n = new f2(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d3 = 0;d3 < n.length; d3++)
            n.words[d3] = 0;
        }
        var w3 = s2.clone()._ishlnsubmul(u2, 1, l3);
        w3.negative === 0 && (s2 = w3, n && (n.words[l3] = 1));
        for (var g3 = l3 - 1;g3 >= 0; g3--) {
          var _3 = (s2.words[u2.length + g3] | 0) * 67108864 + (s2.words[u2.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s2._ishlnsubmul(u2, _3, g3);s2.negative !== 0; )
            _3--, s2.negative = 0, s2._ishlnsubmul(u2, 1, g3), s2.isZero() || (s2.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s2.strip(), a3 !== "div" && h3 !== 0 && s2.iushrn(h3), { div: n || null, mod: s2 };
      }, f2.prototype.divmod = function(i, a3, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s2, u2, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s2 = c2.div.neg()), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.iadd(i)), { div: s2, mod: u2 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s2 = c2.div.neg()), { div: s2, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.isub(i)), { div: c2.div, mod: u2 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h3 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s2 = i.ushrn(1), u2 = i.andln(1), c2 = h3.cmp(s2);
        return c2 < 0 || u2 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h3 = 0, s2 = this.length - 1;s2 >= 0; s2--)
          h3 = (a3 * h3 + (this.words[s2] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = (this.words[h3] | 0) + a3 * 67108864;
          this.words[h3] = s2 / i | 0, a3 = s2 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f2(1), u2 = new f2(0), c2 = new f2(0), b5 = new f2(1), l3 = 0;a3.isEven() && h3.isEven(); )
          a3.iushrn(1), h3.iushrn(1), ++l3;
        for (var n = h3.clone(), d3 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g3 = 1;(a3.words[0] & g3) === 0 && w3 < 26; ++w3, g3 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s2.isOdd() || u2.isOdd()) && (s2.iadd(n), u2.isub(d3)), s2.iushrn(1), u2.iushrn(1);
          for (var _3 = 0, A3 = 1;(h3.words[0] & A3) === 0 && _3 < 26; ++_3, A3 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b5.isOdd()) && (c2.iadd(n), b5.isub(d3)), c2.iushrn(1), b5.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s2.isub(c2), u2.isub(b5)) : (h3.isub(a3), c2.isub(s2), b5.isub(u2));
        }
        return { a: c2, b: b5, gcd: h3.iushln(l3) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f2(1), u2 = new f2(0), c2 = h3.clone();a3.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b5 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b5 < 26; ++b5, l3 <<= 1)
            ;
          if (b5 > 0)
            for (a3.iushrn(b5);b5-- > 0; )
              s2.isOdd() && s2.iadd(c2), s2.iushrn(1);
          for (var n = 0, d3 = 1;(h3.words[0] & d3) === 0 && n < 26; ++n, d3 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u2.isOdd() && u2.iadd(c2), u2.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s2.isub(u2)) : (h3.isub(a3), u2.isub(s2));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s2 : w3 = u2, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h3 = i.clone();
        a3.negative = 0, h3.negative = 0;
        for (var s2 = 0;a3.isEven() && h3.isEven(); s2++)
          a3.iushrn(1), h3.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u2 = a3.cmp(h3);
          if (u2 < 0) {
            var c2 = a3;
            a3 = h3, h3 = c2;
          } else if (u2 === 0 || h3.cmpn(1) === 0)
            break;
          a3.isub(h3);
        } while (true);
        return h3.iushln(s2);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h3 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s2, this;
        for (var u2 = s2, c2 = h3;u2 !== 0 && c2 < this.length; c2++) {
          var b5 = this.words[c2] | 0;
          b5 += u2, u2 = b5 >>> 26, b5 &= 67108863, this.words[c2] = b5;
        }
        return u2 !== 0 && (this.words[c2] = u2, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s2 = this.words[0] | 0;
          h3 = s2 === i ? 0 : s2 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = this.words[h3] | 0, u2 = i.words[h3] | 0;
          if (s2 !== u2) {
            s2 < u2 ? a3 = -1 : s2 > u2 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a3 = i, h3;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h3 = a3.bitLength();
        while (h3 > this.n);
        var s2 = h3 < this.n ? -1 : a3.ucmp(this.p);
        return s2 === 0 ? (a3.words[0] = 0, a3.length = 1) : s2 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe, ye), xe.prototype.split = function(i, a3) {
        for (var h3 = 4194303, s2 = Math.min(i.length, 9), u2 = 0;u2 < s2; u2++)
          a3.words[u2] = i.words[u2];
        if (a3.length = s2, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h3, u2 = 10;u2 < i.length; u2++) {
          var b5 = i.words[u2] | 0;
          i.words[u2 - 10] = (b5 & h3) << 4 | c2 >>> 22, c2 = b5;
        }
        c2 >>>= 22, i.words[u2 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = i.words[h3] | 0;
          a3 += s2 * 977, i.words[h3] = a3 & 67108863, a3 = s2 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = (i.words[h3] | 0) * 19 + a3, u2 = s2 & 67108863;
          s2 >>>= 26, i.words[h3] = u2, a3 = s2;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.add(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.iadd(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.sub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.isub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P2.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P2.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s2 = this.m.subn(1), u2 = 0;!s2.isZero() && s2.andln(1) === 0; )
          u2++, s2.iushrn(1);
        r(!s2.isZero());
        var c2 = new f2(1).toRed(this), b5 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l3).cmp(b5) !== 0; )
          n.redIAdd(b5);
        for (var d3 = this.pow(n, s2), w3 = this.pow(i, s2.addn(1).iushrn(1)), g3 = this.pow(i, s2), _3 = u2;g3.cmp(c2) !== 0; ) {
          for (var A3 = g3, R2 = 0;A3.cmp(c2) !== 0; R2++)
            A3 = A3.redSqr();
          r(R2 < _3);
          var I4 = this.pow(d3, new f2(1).iushln(_3 - R2 - 1));
          w3 = w3.redMul(I4), d3 = I4.redSqr(), g3 = g3.redMul(d3), _3 = R2;
        }
        return w3;
      }, P2.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P2.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f2(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s2 = new Array(1 << h3);
        s2[0] = new f2(1).toRed(this), s2[1] = i;
        for (var u2 = 2;u2 < s2.length; u2++)
          s2[u2] = this.mul(s2[u2 - 1], i);
        var c2 = s2[0], b5 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u2 = a3.length - 1;u2 >= 0; u2--) {
          for (var d3 = a3.words[u2], w3 = n - 1;w3 >= 0; w3--) {
            var g3 = d3 >> w3 & 1;
            if (c2 !== s2[0] && (c2 = this.sqr(c2)), g3 === 0 && b5 === 0) {
              l3 = 0;
              continue;
            }
            b5 <<= 1, b5 |= g3, l3++, !(l3 !== h3 && (u2 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s2[b5]), l3 = 0, b5 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P2.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f2.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v2) {
        P2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P2), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a3), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s2).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a3), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s2).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Gu2 > "u" || Gu2, $m);
  });
  Ym = T((Gm, Xu) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o2(v2, i) {
        v2.super_ = i;
        var a3 = function() {};
        a3.prototype = i.prototype, v2.prototype = new a3, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a3) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v2 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {}
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f2.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f2.prototype._init = function(i, a3, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h3);
        if (typeof i == "object")
          return this._initArray(i, a3, h3);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s2 = 0;
        i[0] === "-" && (s2++, this.negative = 1), s2 < i.length && (a3 === 16 ? this._parseHex(i, s2, h3) : (this._parseBase(i, a3, s2), h3 === "le" && this._initArray(this.toArray(), a3, h3)));
      }, f2.prototype._initNumber = function(i, a3, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a3, h3);
      }, f2.prototype._initArray = function(i, a3, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u2, c2, b5 = 0;
        if (h3 === "be")
          for (s2 = i.length - 1, u2 = 0;s2 >= 0; s2 -= 3)
            c2 = i[s2] | i[s2 - 1] << 8 | i[s2 - 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        else if (h3 === "le")
          for (s2 = 0, u2 = 0;s2 < i.length; s2 += 3)
            c2 = i[s2] | i[s2 + 1] << 8 | i[s2 + 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        return this.strip();
      };
      function m4(v2, i) {
        var a3 = v2.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y3(v2, i, a3) {
        var h3 = m4(v2, a3);
        return a3 - 1 >= i && (h3 |= m4(v2, a3 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a3, h3) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s2 = 0;s2 < this.length; s2++)
          this.words[s2] = 0;
        var u2 = 0, c2 = 0, b5;
        if (h3 === "be")
          for (s2 = i.length - 1;s2 >= a3; s2 -= 2)
            b5 = y3(i, a3, s2) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        else {
          var l3 = i.length - a3;
          for (s2 = l3 % 2 === 0 ? a3 + 1 : a3;s2 < i.length; s2 += 2)
            b5 = y3(i, a3, s2) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        }
        this.strip();
      };
      function M4(v2, i, a3, h3) {
        for (var s2 = 0, u2 = Math.min(v2.length, a3), c2 = i;c2 < u2; c2++) {
          var b5 = v2.charCodeAt(c2) - 48;
          s2 *= h3, b5 >= 49 ? s2 += b5 - 49 + 10 : b5 >= 17 ? s2 += b5 - 17 + 10 : s2 += b5;
        }
        return s2;
      }
      f2.prototype._parseBase = function(i, a3, h3) {
        this.words = [0], this.length = 1;
        for (var s2 = 0, u2 = 1;u2 <= 67108863; u2 *= a3)
          s2++;
        s2--, u2 = u2 / a3 | 0;
        for (var c2 = i.length - h3, b5 = c2 % s2, l3 = Math.min(c2, c2 - b5) + h3, n = 0, d3 = h3;d3 < l3; d3 += s2)
          n = M4(i, d3, d3 + s2, a3), this.imuln(u2), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b5 !== 0) {
          var w3 = 1;
          for (n = M4(i, d3, i.length, a3), d3 = 0;d3 < b5; d3++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s2 = 0, u2 = 0, c2 = 0;c2 < this.length; c2++) {
            var b5 = this.words[c2], l3 = ((b5 << s2 | u2) & 16777215).toString(16);
            u2 = b5 >>> 24 - s2 & 16777215, u2 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l3.length] + l3 + h3 : h3 = l3 + h3, s2 += 2, s2 >= 26 && (s2 -= 26, c2--);
          }
          for (u2 !== 0 && (h3 = u2.toString(16) + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d3 = E6[i];
          h3 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g3 = w3.modn(d3).toString(i);
            w3 = w3.idivn(d3), w3.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f2.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f2.prototype.toArrayLike = function(i, a3, h3) {
        var s2 = this.byteLength(), u2 = h3 || Math.max(1, s2);
        r(s2 <= u2, "byte array longer than desired length"), r(u2 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b5 = new i(u2), l3, n, d3 = this.clone();
        if (c2) {
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[n] = l3;
          for (;n < u2; n++)
            b5[n] = 0;
        } else {
          for (n = 0;n < u2 - s2; n++)
            b5[n] = 0;
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[u2 - n - 1] = l3;
        }
        return b5;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a3 = i, h3 = 0;
        return a3 >= 4096 && (h3 += 13, a3 >>>= 13), a3 >= 64 && (h3 += 7, a3 >>>= 7), a3 >= 8 && (h3 += 4, a3 >>>= 4), a3 >= 2 && (h3 += 2, a3 >>>= 2), h3 + a3;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h3 = 0;
        return (a3 & 8191) === 0 && (h3 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h3 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h3 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h3 += 2, a3 >>>= 2), (a3 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v2) {
        for (var i = new Array(v2.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h3 = a3 / 26 | 0, s2 = a3 % 26;
          i[a3] = (v2.words[h3] & 1 << s2) >>> s2;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h3 = this._zeroBits(this.words[a3]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h3 = 0;h3 < a3.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a3, h3;
        this.length > i.length ? (a3 = this, h3 = i) : (a3 = i, h3 = this);
        for (var s2 = 0;s2 < h3.length; s2++)
          this.words[s2] = a3.words[s2] ^ h3.words[s2];
        if (this !== a3)
          for (;s2 < a3.length; s2++)
            this.words[s2] = a3.words[s2];
        return this.length = a3.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a3), h3 > 0 && a3--;
        for (var s2 = 0;s2 < a3; s2++)
          this.words[s2] = ~this.words[s2] & 67108863;
        return h3 > 0 && (this.words[s2] = ~this.words[s2] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s2 = i % 26;
        return this._expand(h3 + 1), a3 ? this.words[h3] = this.words[h3] | 1 << s2 : this.words[h3] = this.words[h3] & ~(1 << s2), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h3, s2;
        this.length > i.length ? (h3 = this, s2 = i) : (h3 = i, s2 = this);
        for (var u2 = 0, c2 = 0;c2 < s2.length; c2++)
          a3 = (h3.words[c2] | 0) + (s2.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        for (;u2 !== 0 && c2 < h3.length; c2++)
          a3 = (h3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        if (this.length = h3.length, u2 !== 0)
          this.words[this.length] = u2, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s2, u2;
        h3 > 0 ? (s2 = this, u2 = i) : (s2 = i, u2 = this);
        for (var c2 = 0, b5 = 0;b5 < u2.length; b5++)
          a3 = (s2.words[b5] | 0) - (u2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        for (;c2 !== 0 && b5 < s2.length; b5++)
          a3 = (s2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        if (c2 === 0 && b5 < s2.length && s2 !== this)
          for (;b5 < s2.length; b5++)
            this.words[b5] = s2.words[b5];
        return this.length = Math.max(this.length, b5), s2 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative;
        var h3 = v2.length + i.length | 0;
        a3.length = h3, h3 = h3 - 1 | 0;
        var s2 = v2.words[0] | 0, u2 = i.words[0] | 0, c2 = s2 * u2, b5 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b5;
        for (var n = 1;n < h3; n++) {
          for (var d3 = l3 >>> 26, w3 = l3 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v2.length + 1);_3 <= g3; _3++) {
            var A3 = n - _3 | 0;
            s2 = v2.words[A3] | 0, u2 = i.words[_3] | 0, c2 = s2 * u2 + w3, d3 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d3 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L3 = function(i, a3, h3) {
        var s2 = i.words, u2 = a3.words, c2 = h3.words, b5 = 0, l3, n, d3, w3 = s2[0] | 0, g3 = w3 & 8191, _3 = w3 >>> 13, A3 = s2[1] | 0, R2 = A3 & 8191, I4 = A3 >>> 13, Me = s2[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt3 = s2[3] | 0, C3 = nt3 & 8191, O2 = nt3 >>> 13, vt = s2[4] | 0, F3 = vt & 8191, U2 = vt >>> 13, bt4 = s2[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt3 = s2[6] | 0, W = mt3 & 8191, K4 = mt3 >>> 13, gt3 = s2[7] | 0, j4 = gt3 & 8191, Z2 = gt3 >>> 13, yt2 = s2[8] | 0, V4 = yt2 & 8191, $ = yt2 >>> 13, wt = s2[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u2[0] | 0, X3 = Mt & 8191, J3 = Mt >>> 13, _t3 = u2[1] | 0, Q4 = _t3 & 8191, ee = _t3 >>> 13, xt3 = u2[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St = u2[3] | 0, ie = St & 8191, ne = St >>> 13, Et2 = u2[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At4 = u2[5] | 0, oe3 = At4 & 8191, se2 = At4 >>> 13, Rt = u2[6] | 0, he = Rt & 8191, ue4 = Rt >>> 13, Bt = u2[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt2 = u2[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u2[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a3.negative, h3.length = 19, l3 = Math.imul(g3, X3), n = Math.imul(g3, J3), n = n + Math.imul(_3, X3) | 0, d3 = Math.imul(_3, J3);
        var ft = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l3 = Math.imul(R2, X3), n = Math.imul(R2, J3), n = n + Math.imul(I4, X3) | 0, d3 = Math.imul(I4, J3), l3 = l3 + Math.imul(g3, Q4) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q4) | 0, d3 = d3 + Math.imul(_3, ee) | 0;
        var Be = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X3), n = Math.imul(k4, J3), n = n + Math.imul(D2, X3) | 0, d3 = Math.imul(D2, J3), l3 = l3 + Math.imul(R2, Q4) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I4, Q4) | 0, d3 = d3 + Math.imul(I4, ee) | 0, l3 = l3 + Math.imul(g3, te2) | 0, n = n + Math.imul(g3, re2) | 0, n = n + Math.imul(_3, te2) | 0, d3 = d3 + Math.imul(_3, re2) | 0;
        var qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C3, X3), n = Math.imul(C3, J3), n = n + Math.imul(O2, X3) | 0, d3 = Math.imul(O2, J3), l3 = l3 + Math.imul(k4, Q4) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q4) | 0, d3 = d3 + Math.imul(D2, ee) | 0, l3 = l3 + Math.imul(R2, te2) | 0, n = n + Math.imul(R2, re2) | 0, n = n + Math.imul(I4, te2) | 0, d3 = d3 + Math.imul(I4, re2) | 0, l3 = l3 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d3 = d3 + Math.imul(_3, ne) | 0;
        var ze = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F3, X3), n = Math.imul(F3, J3), n = n + Math.imul(U2, X3) | 0, d3 = Math.imul(U2, J3), l3 = l3 + Math.imul(C3, Q4) | 0, n = n + Math.imul(C3, ee) | 0, n = n + Math.imul(O2, Q4) | 0, d3 = d3 + Math.imul(O2, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D2, te2) | 0, d3 = d3 + Math.imul(D2, re2) | 0, l3 = l3 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I4, ie) | 0, d3 = d3 + Math.imul(I4, ne) | 0, l3 = l3 + Math.imul(g3, fe3) | 0, n = n + Math.imul(g3, ae2) | 0, n = n + Math.imul(_3, fe3) | 0, d3 = d3 + Math.imul(_3, ae2) | 0;
        var He3 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X3), n = Math.imul(z, J3), n = n + Math.imul(H3, X3) | 0, d3 = Math.imul(H3, J3), l3 = l3 + Math.imul(F3, Q4) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U2, Q4) | 0, d3 = d3 + Math.imul(U2, ee) | 0, l3 = l3 + Math.imul(C3, te2) | 0, n = n + Math.imul(C3, re2) | 0, n = n + Math.imul(O2, te2) | 0, d3 = d3 + Math.imul(O2, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d3 = d3 + Math.imul(D2, ne) | 0, l3 = l3 + Math.imul(R2, fe3) | 0, n = n + Math.imul(R2, ae2) | 0, n = n + Math.imul(I4, fe3) | 0, d3 = d3 + Math.imul(I4, ae2) | 0, l3 = l3 + Math.imul(g3, oe3) | 0, n = n + Math.imul(g3, se2) | 0, n = n + Math.imul(_3, oe3) | 0, d3 = d3 + Math.imul(_3, se2) | 0;
        var We2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X3), n = Math.imul(W, J3), n = n + Math.imul(K4, X3) | 0, d3 = Math.imul(K4, J3), l3 = l3 + Math.imul(z, Q4) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q4) | 0, d3 = d3 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F3, te2) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U2, te2) | 0, d3 = d3 + Math.imul(U2, re2) | 0, l3 = l3 + Math.imul(C3, ie) | 0, n = n + Math.imul(C3, ne) | 0, n = n + Math.imul(O2, ie) | 0, d3 = d3 + Math.imul(O2, ne) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D2, fe3) | 0, d3 = d3 + Math.imul(D2, ae2) | 0, l3 = l3 + Math.imul(R2, oe3) | 0, n = n + Math.imul(R2, se2) | 0, n = n + Math.imul(I4, oe3) | 0, d3 = d3 + Math.imul(I4, se2) | 0, l3 = l3 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue4) | 0, n = n + Math.imul(_3, he) | 0, d3 = d3 + Math.imul(_3, ue4) | 0;
        var Ke2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j4, X3), n = Math.imul(j4, J3), n = n + Math.imul(Z2, X3) | 0, d3 = Math.imul(Z2, J3), l3 = l3 + Math.imul(W, Q4) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K4, Q4) | 0, d3 = d3 + Math.imul(K4, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d3 = d3 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U2, ie) | 0, d3 = d3 + Math.imul(U2, ne) | 0, l3 = l3 + Math.imul(C3, fe3) | 0, n = n + Math.imul(C3, ae2) | 0, n = n + Math.imul(O2, fe3) | 0, d3 = d3 + Math.imul(O2, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se2) | 0, n = n + Math.imul(D2, oe3) | 0, d3 = d3 + Math.imul(D2, se2) | 0, l3 = l3 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue4) | 0, n = n + Math.imul(I4, he) | 0, d3 = d3 + Math.imul(I4, ue4) | 0, l3 = l3 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d3 = d3 + Math.imul(_3, de) | 0;
        var je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V4, X3), n = Math.imul(V4, J3), n = n + Math.imul($, X3) | 0, d3 = Math.imul($, J3), l3 = l3 + Math.imul(j4, Q4) | 0, n = n + Math.imul(j4, ee) | 0, n = n + Math.imul(Z2, Q4) | 0, d3 = d3 + Math.imul(Z2, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K4, te2) | 0, d3 = d3 + Math.imul(K4, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H3, ie) | 0, d3 = d3 + Math.imul(H3, ne) | 0, l3 = l3 + Math.imul(F3, fe3) | 0, n = n + Math.imul(F3, ae2) | 0, n = n + Math.imul(U2, fe3) | 0, d3 = d3 + Math.imul(U2, ae2) | 0, l3 = l3 + Math.imul(C3, oe3) | 0, n = n + Math.imul(C3, se2) | 0, n = n + Math.imul(O2, oe3) | 0, d3 = d3 + Math.imul(O2, se2) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D2, he) | 0, d3 = d3 + Math.imul(D2, ue4) | 0, l3 = l3 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I4, le) | 0, d3 = d3 + Math.imul(I4, de) | 0, l3 = l3 + Math.imul(g3, ce3) | 0, n = n + Math.imul(g3, pe2) | 0, n = n + Math.imul(_3, ce3) | 0, d3 = d3 + Math.imul(_3, pe2) | 0;
        var Ze2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X3), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X3) | 0, d3 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V4, Q4) | 0, n = n + Math.imul(V4, ee) | 0, n = n + Math.imul($, Q4) | 0, d3 = d3 + Math.imul($, ee) | 0, l3 = l3 + Math.imul(j4, te2) | 0, n = n + Math.imul(j4, re2) | 0, n = n + Math.imul(Z2, te2) | 0, d3 = d3 + Math.imul(Z2, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K4, ie) | 0, d3 = d3 + Math.imul(K4, ne) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d3 = d3 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F3, oe3) | 0, n = n + Math.imul(F3, se2) | 0, n = n + Math.imul(U2, oe3) | 0, d3 = d3 + Math.imul(U2, se2) | 0, l3 = l3 + Math.imul(C3, he) | 0, n = n + Math.imul(C3, ue4) | 0, n = n + Math.imul(O2, he) | 0, d3 = d3 + Math.imul(O2, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d3 = d3 + Math.imul(D2, de) | 0, l3 = l3 + Math.imul(R2, ce3) | 0, n = n + Math.imul(R2, pe2) | 0, n = n + Math.imul(I4, ce3) | 0, d3 = d3 + Math.imul(I4, pe2) | 0, l3 = l3 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d3 = d3 + Math.imul(_3, be) | 0;
        var Ve = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q4), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q4) | 0, d3 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V4, te2) | 0, n = n + Math.imul(V4, re2) | 0, n = n + Math.imul($, te2) | 0, d3 = d3 + Math.imul($, re2) | 0, l3 = l3 + Math.imul(j4, ie) | 0, n = n + Math.imul(j4, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d3 = d3 + Math.imul(Z2, ne) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K4, fe3) | 0, d3 = d3 + Math.imul(K4, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se2) | 0, n = n + Math.imul(H3, oe3) | 0, d3 = d3 + Math.imul(H3, se2) | 0, l3 = l3 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue4) | 0, n = n + Math.imul(U2, he) | 0, d3 = d3 + Math.imul(U2, ue4) | 0, l3 = l3 + Math.imul(C3, le) | 0, n = n + Math.imul(C3, de) | 0, n = n + Math.imul(O2, le) | 0, d3 = d3 + Math.imul(O2, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D2, ce3) | 0, d3 = d3 + Math.imul(D2, pe2) | 0, l3 = l3 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I4, ve) | 0, d3 = d3 + Math.imul(I4, be) | 0;
        var $e2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d3 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V4, ie) | 0, n = n + Math.imul(V4, ne) | 0, n = n + Math.imul($, ie) | 0, d3 = d3 + Math.imul($, ne) | 0, l3 = l3 + Math.imul(j4, fe3) | 0, n = n + Math.imul(j4, ae2) | 0, n = n + Math.imul(Z2, fe3) | 0, d3 = d3 + Math.imul(Z2, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se2) | 0, n = n + Math.imul(K4, oe3) | 0, d3 = d3 + Math.imul(K4, se2) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d3 = d3 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U2, le) | 0, d3 = d3 + Math.imul(U2, de) | 0, l3 = l3 + Math.imul(C3, ce3) | 0, n = n + Math.imul(C3, pe2) | 0, n = n + Math.imul(O2, ce3) | 0, d3 = d3 + Math.imul(O2, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d3 = d3 + Math.imul(D2, be) | 0;
        var Ge = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y3, ie) | 0, d3 = Math.imul(Y3, ne), l3 = l3 + Math.imul(V4, fe3) | 0, n = n + Math.imul(V4, ae2) | 0, n = n + Math.imul($, fe3) | 0, d3 = d3 + Math.imul($, ae2) | 0, l3 = l3 + Math.imul(j4, oe3) | 0, n = n + Math.imul(j4, se2) | 0, n = n + Math.imul(Z2, oe3) | 0, d3 = d3 + Math.imul(Z2, se2) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K4, he) | 0, d3 = d3 + Math.imul(K4, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d3 = d3 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F3, ce3) | 0, n = n + Math.imul(F3, pe2) | 0, n = n + Math.imul(U2, ce3) | 0, d3 = d3 + Math.imul(U2, pe2) | 0, l3 = l3 + Math.imul(C3, ve) | 0, n = n + Math.imul(C3, be) | 0, n = n + Math.imul(O2, ve) | 0, d3 = d3 + Math.imul(O2, be) | 0;
        var Ye = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d3 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V4, oe3) | 0, n = n + Math.imul(V4, se2) | 0, n = n + Math.imul($, oe3) | 0, d3 = d3 + Math.imul($, se2) | 0, l3 = l3 + Math.imul(j4, he) | 0, n = n + Math.imul(j4, ue4) | 0, n = n + Math.imul(Z2, he) | 0, d3 = d3 + Math.imul(Z2, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K4, le) | 0, d3 = d3 + Math.imul(K4, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d3 = d3 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U2, ve) | 0, d3 = d3 + Math.imul(U2, be) | 0;
        var Xe = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se2), n = n + Math.imul(Y3, oe3) | 0, d3 = Math.imul(Y3, se2), l3 = l3 + Math.imul(V4, he) | 0, n = n + Math.imul(V4, ue4) | 0, n = n + Math.imul($, he) | 0, d3 = d3 + Math.imul($, ue4) | 0, l3 = l3 + Math.imul(j4, le) | 0, n = n + Math.imul(j4, de) | 0, n = n + Math.imul(Z2, le) | 0, d3 = d3 + Math.imul(Z2, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K4, ce3) | 0, d3 = d3 + Math.imul(K4, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H3, ve) | 0, d3 = d3 + Math.imul(H3, be) | 0;
        var Je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d3 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V4, le) | 0, n = n + Math.imul(V4, de) | 0, n = n + Math.imul($, le) | 0, d3 = d3 + Math.imul($, de) | 0, l3 = l3 + Math.imul(j4, ce3) | 0, n = n + Math.imul(j4, pe2) | 0, n = n + Math.imul(Z2, ce3) | 0, d3 = d3 + Math.imul(Z2, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K4, ve) | 0, d3 = d3 + Math.imul(K4, be) | 0;
        var Qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d3 = Math.imul(Y3, de), l3 = l3 + Math.imul(V4, ce3) | 0, n = n + Math.imul(V4, pe2) | 0, n = n + Math.imul($, ce3) | 0, d3 = d3 + Math.imul($, pe2) | 0, l3 = l3 + Math.imul(j4, ve) | 0, n = n + Math.imul(j4, be) | 0, n = n + Math.imul(Z2, ve) | 0, d3 = d3 + Math.imul(Z2, be) | 0;
        var et4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (et4 >>> 26) | 0, et4 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d3 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V4, ve) | 0, n = n + Math.imul(V4, be) | 0, n = n + Math.imul($, ve) | 0, d3 = d3 + Math.imul($, be) | 0;
        var tt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y3, ve) | 0, d3 = Math.imul(Y3, be);
        var rt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b5 = (d3 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et4, c2[17] = tt4, c2[18] = rt4, b5 !== 0 && (c2[19] = b5, h3.length++), h3;
      };
      Math.imul || (L3 = q);
      function ge(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative, a3.length = v2.length + i.length;
        for (var h3 = 0, s2 = 0, u2 = 0;u2 < a3.length - 1; u2++) {
          var c2 = s2;
          s2 = 0;
          for (var b5 = h3 & 67108863, l3 = Math.min(u2, i.length - 1), n = Math.max(0, u2 - v2.length + 1);n <= l3; n++) {
            var d3 = u2 - n, w3 = v2.words[d3] | 0, g3 = i.words[n] | 0, _3 = w3 * g3, A3 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A3 = A3 + b5 | 0, b5 = A3 & 67108863, c2 = c2 + (A3 >>> 26) | 0, s2 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u2] = b5, h3 = c2, c2 = s2;
        }
        return h3 !== 0 ? a3.words[u2] = h3 : a3.length--, a3.strip();
      }
      function _e3(v2, i, a3) {
        var h3 = new N5;
        return h3.mulp(v2, i, a3);
      }
      f2.prototype.mulTo = function(i, a3) {
        var h3, s2 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a3) : s2 < 63 ? h3 = q(this, i, a3) : s2 < 1024 ? h3 = ge(this, i, a3) : h3 = _e3(this, i, a3), h3;
      };
      function N5(v2, i) {
        this.x = v2, this.y = i;
      }
      N5.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s2 = 0;s2 < i; s2++)
          a3[s2] = this.revBin(s2, h3, i);
        return a3;
      }, N5.prototype.revBin = function(i, a3, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s2 = 0, u2 = 0;u2 < a3; u2++)
          s2 |= (i & 1) << a3 - u2 - 1, i >>= 1;
        return s2;
      }, N5.prototype.permute = function(i, a3, h3, s2, u2, c2) {
        for (var b5 = 0;b5 < c2; b5++)
          s2[b5] = a3[i[b5]], u2[b5] = h3[i[b5]];
      }, N5.prototype.transform = function(i, a3, h3, s2, u2, c2) {
        this.permute(c2, i, a3, h3, s2, u2);
        for (var b5 = 1;b5 < u2; b5 <<= 1)
          for (var l3 = b5 << 1, n = Math.cos(2 * Math.PI / l3), d3 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u2; w3 += l3)
            for (var g3 = n, _3 = d3, A3 = 0;A3 < b5; A3++) {
              var R2 = h3[w3 + A3], I4 = s2[w3 + A3], Me = h3[w3 + A3 + b5], k4 = s2[w3 + A3 + b5], D2 = g3 * Me - _3 * k4;
              k4 = g3 * k4 + _3 * Me, Me = D2, h3[w3 + A3] = R2 + Me, s2[w3 + A3] = I4 + k4, h3[w3 + A3 + b5] = R2 - Me, s2[w3 + A3 + b5] = I4 - k4, A3 !== l3 && (D2 = n * g3 - d3 * _3, _3 = n * _3 + d3 * g3, g3 = D2);
            }
      }, N5.prototype.guessLen13b = function(i, a3) {
        var h3 = Math.max(a3, i) | 1, s2 = h3 & 1, u2 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u2++;
        return 1 << u2 + 1 + s2;
      }, N5.prototype.conjugate = function(i, a3, h3) {
        if (!(h3 <= 1))
          for (var s2 = 0;s2 < h3 / 2; s2++) {
            var u2 = i[s2];
            i[s2] = i[h3 - s2 - 1], i[h3 - s2 - 1] = u2, u2 = a3[s2], a3[s2] = -a3[h3 - s2 - 1], a3[h3 - s2 - 1] = -u2;
          }
      }, N5.prototype.normalize13b = function(i, a3) {
        for (var h3 = 0, s2 = 0;s2 < a3 / 2; s2++) {
          var u2 = Math.round(i[2 * s2 + 1] / a3) * 8192 + Math.round(i[2 * s2] / a3) + h3;
          i[s2] = u2 & 67108863, u2 < 67108864 ? h3 = 0 : h3 = u2 / 67108864 | 0;
        }
        return i;
      }, N5.prototype.convert13b = function(i, a3, h3, s2) {
        for (var u2 = 0, c2 = 0;c2 < a3; c2++)
          u2 = u2 + (i[c2] | 0), h3[2 * c2] = u2 & 8191, u2 = u2 >>> 13, h3[2 * c2 + 1] = u2 & 8191, u2 = u2 >>> 13;
        for (c2 = 2 * a3;c2 < s2; ++c2)
          h3[c2] = 0;
        r(u2 === 0), r((u2 & -8192) === 0);
      }, N5.prototype.stub = function(i) {
        for (var a3 = new Array(i), h3 = 0;h3 < i; h3++)
          a3[h3] = 0;
        return a3;
      }, N5.prototype.mulp = function(i, a3, h3) {
        var s2 = 2 * this.guessLen13b(i.length, a3.length), u2 = this.makeRBT(s2), c2 = this.stub(s2), b5 = new Array(s2), l3 = new Array(s2), n = new Array(s2), d3 = new Array(s2), w3 = new Array(s2), g3 = new Array(s2), _3 = h3.words;
        _3.length = s2, this.convert13b(i.words, i.length, b5, s2), this.convert13b(a3.words, a3.length, d3, s2), this.transform(b5, c2, l3, n, s2, u2), this.transform(d3, c2, w3, g3, s2, u2);
        for (var A3 = 0;A3 < s2; A3++) {
          var R2 = l3[A3] * w3[A3] - n[A3] * g3[A3];
          n[A3] = l3[A3] * g3[A3] + n[A3] * w3[A3], l3[A3] = R2;
        }
        return this.conjugate(l3, n, s2), this.transform(l3, n, _3, c2, s2, u2), this.conjugate(_3, c2, s2), this.normalize13b(_3, s2), h3.negative = i.negative ^ a3.negative, h3.length = i.length + a3.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f2.prototype.mulf = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h3 = 0;h3 < this.length; h3++) {
          var s2 = (this.words[h3] | 0) * i, u2 = (s2 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s2 / 67108864 | 0, a3 += u2 >>> 26, this.words[h3] = u2 & 67108863;
        }
        return a3 !== 0 && (this.words[h3] = a3, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f2(1);
        for (var h3 = this, s2 = 0;s2 < a3.length && a3[s2] === 0; s2++, h3 = h3.sqr())
          ;
        if (++s2 < a3.length)
          for (var u2 = h3.sqr();s2 < a3.length; s2++, u2 = u2.sqr())
            a3[s2] !== 0 && (h3 = h3.mul(u2));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s2 = 67108863 >>> 26 - a3 << 26 - a3, u2;
        if (a3 !== 0) {
          var c2 = 0;
          for (u2 = 0;u2 < this.length; u2++) {
            var b5 = this.words[u2] & s2, l3 = (this.words[u2] | 0) - b5 << a3;
            this.words[u2] = l3 | c2, c2 = b5 >>> 26 - a3;
          }
          c2 && (this.words[u2] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u2 = this.length - 1;u2 >= 0; u2--)
            this.words[u2 + h3] = this.words[u2];
          for (u2 = 0;u2 < h3; u2++)
            this.words[u2] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a3, h3) {
        r(typeof i == "number" && i >= 0);
        var s2;
        a3 ? s2 = (a3 - a3 % 26) / 26 : s2 = 0;
        var u2 = i % 26, c2 = Math.min((i - u2) / 26, this.length), b5 = 67108863 ^ 67108863 >>> u2 << u2, l3 = h3;
        if (s2 -= c2, s2 = Math.max(0, s2), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d3 = 0;
        for (n = this.length - 1;n >= 0 && (d3 !== 0 || n >= s2); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d3 << 26 - u2 | w3 >>> u2, d3 = w3 & b5;
        }
        return l3 && d3 !== 0 && (l3.words[l3.length++] = d3), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a3, h3) {
        return r(this.negative === 0), this.iushrn(i, a3, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h3)
          return false;
        var u2 = this.words[h3];
        return !!(u2 & s2);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a3 !== 0 && h3++, this.length = Math.min(h3, this.length), a3 !== 0) {
          var s2 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s2;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a3, h3) {
        var s2 = i.length + h3, u2;
        this._expand(s2);
        var c2, b5 = 0;
        for (u2 = 0;u2 < i.length; u2++) {
          c2 = (this.words[u2 + h3] | 0) + b5;
          var l3 = (i.words[u2] | 0) * a3;
          c2 -= l3 & 67108863, b5 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u2 + h3] = c2 & 67108863;
        }
        for (;u2 < this.length - h3; u2++)
          c2 = (this.words[u2 + h3] | 0) + b5, b5 = c2 >> 26, this.words[u2 + h3] = c2 & 67108863;
        if (b5 === 0)
          return this.strip();
        for (r(b5 === -1), b5 = 0, u2 = 0;u2 < this.length; u2++)
          c2 = -(this.words[u2] | 0) + b5, b5 = c2 >> 26, this.words[u2] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a3) {
        var h3 = this.length - i.length, s2 = this.clone(), u2 = i, c2 = u2.words[u2.length - 1] | 0, b5 = this._countBits(c2);
        h3 = 26 - b5, h3 !== 0 && (u2 = u2.ushln(h3), s2.iushln(h3), c2 = u2.words[u2.length - 1] | 0);
        var l3 = s2.length - u2.length, n;
        if (a3 !== "mod") {
          n = new f2(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d3 = 0;d3 < n.length; d3++)
            n.words[d3] = 0;
        }
        var w3 = s2.clone()._ishlnsubmul(u2, 1, l3);
        w3.negative === 0 && (s2 = w3, n && (n.words[l3] = 1));
        for (var g3 = l3 - 1;g3 >= 0; g3--) {
          var _3 = (s2.words[u2.length + g3] | 0) * 67108864 + (s2.words[u2.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s2._ishlnsubmul(u2, _3, g3);s2.negative !== 0; )
            _3--, s2.negative = 0, s2._ishlnsubmul(u2, 1, g3), s2.isZero() || (s2.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s2.strip(), a3 !== "div" && h3 !== 0 && s2.iushrn(h3), { div: n || null, mod: s2 };
      }, f2.prototype.divmod = function(i, a3, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s2, u2, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s2 = c2.div.neg()), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.iadd(i)), { div: s2, mod: u2 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s2 = c2.div.neg()), { div: s2, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.isub(i)), { div: c2.div, mod: u2 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h3 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s2 = i.ushrn(1), u2 = i.andln(1), c2 = h3.cmp(s2);
        return c2 < 0 || u2 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h3 = 0, s2 = this.length - 1;s2 >= 0; s2--)
          h3 = (a3 * h3 + (this.words[s2] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = (this.words[h3] | 0) + a3 * 67108864;
          this.words[h3] = s2 / i | 0, a3 = s2 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f2(1), u2 = new f2(0), c2 = new f2(0), b5 = new f2(1), l3 = 0;a3.isEven() && h3.isEven(); )
          a3.iushrn(1), h3.iushrn(1), ++l3;
        for (var n = h3.clone(), d3 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g3 = 1;(a3.words[0] & g3) === 0 && w3 < 26; ++w3, g3 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s2.isOdd() || u2.isOdd()) && (s2.iadd(n), u2.isub(d3)), s2.iushrn(1), u2.iushrn(1);
          for (var _3 = 0, A3 = 1;(h3.words[0] & A3) === 0 && _3 < 26; ++_3, A3 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b5.isOdd()) && (c2.iadd(n), b5.isub(d3)), c2.iushrn(1), b5.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s2.isub(c2), u2.isub(b5)) : (h3.isub(a3), c2.isub(s2), b5.isub(u2));
        }
        return { a: c2, b: b5, gcd: h3.iushln(l3) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s2 = new f2(1), u2 = new f2(0), c2 = h3.clone();a3.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b5 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b5 < 26; ++b5, l3 <<= 1)
            ;
          if (b5 > 0)
            for (a3.iushrn(b5);b5-- > 0; )
              s2.isOdd() && s2.iadd(c2), s2.iushrn(1);
          for (var n = 0, d3 = 1;(h3.words[0] & d3) === 0 && n < 26; ++n, d3 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u2.isOdd() && u2.iadd(c2), u2.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s2.isub(u2)) : (h3.isub(a3), u2.isub(s2));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s2 : w3 = u2, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h3 = i.clone();
        a3.negative = 0, h3.negative = 0;
        for (var s2 = 0;a3.isEven() && h3.isEven(); s2++)
          a3.iushrn(1), h3.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u2 = a3.cmp(h3);
          if (u2 < 0) {
            var c2 = a3;
            a3 = h3, h3 = c2;
          } else if (u2 === 0 || h3.cmpn(1) === 0)
            break;
          a3.isub(h3);
        } while (true);
        return h3.iushln(s2);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h3 = (i - a3) / 26, s2 = 1 << a3;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s2, this;
        for (var u2 = s2, c2 = h3;u2 !== 0 && c2 < this.length; c2++) {
          var b5 = this.words[c2] | 0;
          b5 += u2, u2 = b5 >>> 26, b5 &= 67108863, this.words[c2] = b5;
        }
        return u2 !== 0 && (this.words[c2] = u2, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s2 = this.words[0] | 0;
          h3 = s2 === i ? 0 : s2 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s2 = this.words[h3] | 0, u2 = i.words[h3] | 0;
          if (s2 !== u2) {
            s2 < u2 ? a3 = -1 : s2 > u2 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a3 = i, h3;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h3 = a3.bitLength();
        while (h3 > this.n);
        var s2 = h3 < this.n ? -1 : a3.ucmp(this.p);
        return s2 === 0 ? (a3.words[0] = 0, a3.length = 1) : s2 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe, ye), xe.prototype.split = function(i, a3) {
        for (var h3 = 4194303, s2 = Math.min(i.length, 9), u2 = 0;u2 < s2; u2++)
          a3.words[u2] = i.words[u2];
        if (a3.length = s2, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h3, u2 = 10;u2 < i.length; u2++) {
          var b5 = i.words[u2] | 0;
          i.words[u2 - 10] = (b5 & h3) << 4 | c2 >>> 22, c2 = b5;
        }
        c2 >>>= 22, i.words[u2 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = i.words[h3] | 0;
          a3 += s2 * 977, i.words[h3] = a3 & 67108863, a3 = s2 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s2 = (i.words[h3] | 0) * 19 + a3, u2 = s2 & 67108863;
          s2 >>>= 26, i.words[h3] = u2, a3 = s2;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.add(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.iadd(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.sub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.isub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P2.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P2.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s2 = this.m.subn(1), u2 = 0;!s2.isZero() && s2.andln(1) === 0; )
          u2++, s2.iushrn(1);
        r(!s2.isZero());
        var c2 = new f2(1).toRed(this), b5 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l3).cmp(b5) !== 0; )
          n.redIAdd(b5);
        for (var d3 = this.pow(n, s2), w3 = this.pow(i, s2.addn(1).iushrn(1)), g3 = this.pow(i, s2), _3 = u2;g3.cmp(c2) !== 0; ) {
          for (var A3 = g3, R2 = 0;A3.cmp(c2) !== 0; R2++)
            A3 = A3.redSqr();
          r(R2 < _3);
          var I4 = this.pow(d3, new f2(1).iushln(_3 - R2 - 1));
          w3 = w3.redMul(I4), d3 = I4.redSqr(), g3 = g3.redMul(d3), _3 = R2;
        }
        return w3;
      }, P2.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P2.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f2(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s2 = new Array(1 << h3);
        s2[0] = new f2(1).toRed(this), s2[1] = i;
        for (var u2 = 2;u2 < s2.length; u2++)
          s2[u2] = this.mul(s2[u2 - 1], i);
        var c2 = s2[0], b5 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u2 = a3.length - 1;u2 >= 0; u2--) {
          for (var d3 = a3.words[u2], w3 = n - 1;w3 >= 0; w3--) {
            var g3 = d3 >> w3 & 1;
            if (c2 !== s2[0] && (c2 = this.sqr(c2)), g3 === 0 && b5 === 0) {
              l3 = 0;
              continue;
            }
            b5 <<= 1, b5 |= g3, l3++, !(l3 !== h3 && (u2 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s2[b5]), l3 = 0, b5 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P2.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f2.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v2) {
        P2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P2), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a3), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s2).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a3), s2 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s2).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Xu > "u" || Xu, Gm);
  });
  Xm = T(() => {});
  As = T(($T, el) => {
    var Ju;
    el.exports = function(e) {
      return Ju || (Ju = new Zi(null)), Ju.generate(e);
    };
    function Zi(t) {
      this.rand = t;
    }
    el.exports.Rand = Zi;
    Zi.prototype.generate = function(e) {
      return this._rand(e);
    };
    Zi.prototype._rand = function(e) {
      if (this.rand.getBytes)
        return this.rand.getBytes(e);
      for (var r = new Uint8Array(e), o2 = 0;o2 < r.length; o2++)
        r[o2] = this.rand.getByte();
      return r;
    };
    if (typeof self == "object")
      self.crypto && self.crypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.crypto.getRandomValues(r), r;
      } : self.msCrypto && self.msCrypto.getRandomValues ? Zi.prototype._rand = function(e) {
        var r = new Uint8Array(e);
        return self.msCrypto.getRandomValues(r), r;
      } : typeof window == "object" && (Zi.prototype._rand = function() {
        throw new Error("Not implemented yet");
      });
    else
      try {
        if (Qu = Xm(), typeof Qu.randomBytes != "function")
          throw new Error("Not supported");
        Zi.prototype._rand = function(e) {
          return Qu.randomBytes(e);
        };
      } catch {}
    var Qu;
  });
  tl = T((GT, Jm) => {
    var In = Ym(), Q9 = As();
    function Tn(t) {
      this.rand = t || new Q9.Rand;
    }
    Jm.exports = Tn;
    Tn.create = function(e) {
      return new Tn(e);
    };
    Tn.prototype._randbelow = function(e) {
      var r = e.bitLength(), o2 = Math.ceil(r / 8);
      do
        var f2 = new In(this.rand.generate(o2));
      while (f2.cmp(e) >= 0);
      return f2;
    };
    Tn.prototype._randrange = function(e, r) {
      var o2 = r.sub(e);
      return e.add(this._randbelow(o2));
    };
    Tn.prototype.test = function(e, r, o2) {
      var f2 = e.bitLength(), p3 = In.mont(e), m4 = new In(1).toRed(p3);
      r || (r = Math.max(1, f2 / 48 | 0));
      for (var y3 = e.subn(1), M4 = 0;!y3.testn(M4); M4++)
        ;
      for (var x3 = e.shrn(M4), S2 = y3.toRed(p3), E6 = true;r > 0; r--) {
        var B3 = this._randrange(new In(2), y3);
        o2 && o2(B3);
        var q = B3.toRed(p3).redPow(x3);
        if (!(q.cmp(m4) === 0 || q.cmp(S2) === 0)) {
          for (var L3 = 1;L3 < M4; L3++) {
            if (q = q.redSqr(), q.cmp(m4) === 0)
              return false;
            if (q.cmp(S2) === 0)
              break;
          }
          if (L3 === M4)
            return false;
        }
      }
      return E6;
    };
    Tn.prototype.getDivisor = function(e, r) {
      var o2 = e.bitLength(), f2 = In.mont(e), p3 = new In(1).toRed(f2);
      r || (r = Math.max(1, o2 / 48 | 0));
      for (var m4 = e.subn(1), y3 = 0;!m4.testn(y3); y3++)
        ;
      for (var M4 = e.shrn(y3), x3 = m4.toRed(f2);r > 0; r--) {
        var S2 = this._randrange(new In(2), m4), E6 = e.gcd(S2);
        if (E6.cmpn(1) !== 0)
          return E6;
        var B3 = S2.toRed(f2).redPow(M4);
        if (!(B3.cmp(p3) === 0 || B3.cmp(x3) === 0)) {
          for (var q = 1;q < y3; q++) {
            if (B3 = B3.redSqr(), B3.cmp(p3) === 0)
              return B3.fromRed().subn(1).gcd(e);
            if (B3.cmp(x3) === 0)
              break;
          }
          if (q === y3)
            return B3 = B3.redSqr(), B3.fromRed().subn(1).gcd(e);
        }
      }
      return false;
    };
  });
  ol = T((ek, tg) => {
    var eS = on();
    tg.exports = al2;
    al2.simpleSieve = nl;
    al2.fermatTest = fl2;
    var Ht2 = Yu(), tS = new Ht2(24), rS = tl(), Qm = new rS, iS = new Ht2(1), il = new Ht2(2), nS = new Ht2(5), YT = new Ht2(16), XT = new Ht2(8), fS = new Ht2(10), aS = new Ht2(3), JT = new Ht2(7), oS = new Ht2(11), eg = new Ht2(4), QT = new Ht2(12), rl = null;
    function sS() {
      if (rl !== null)
        return rl;
      var t = 1048576, e = [];
      e[0] = 2;
      for (var r = 1, o2 = 3;o2 < t; o2 += 2) {
        for (var f2 = Math.ceil(Math.sqrt(o2)), p3 = 0;p3 < r && e[p3] <= f2 && o2 % e[p3] !== 0; p3++)
          ;
        r !== p3 && e[p3] <= f2 || (e[r++] = o2);
      }
      return rl = e, e;
    }
    function nl(t) {
      for (var e = sS(), r = 0;r < e.length; r++)
        if (t.modn(e[r]) === 0)
          return t.cmpn(e[r]) === 0;
      return true;
    }
    function fl2(t) {
      var e = Ht2.mont(t);
      return il.toRed(e).redPow(t.subn(1)).fromRed().cmpn(1) === 0;
    }
    function al2(t, e) {
      if (t < 16)
        return e === 2 || e === 5 ? new Ht2([140, 123]) : new Ht2([140, 39]);
      e = new Ht2(e);
      for (var r, o2;; ) {
        for (r = new Ht2(eS(Math.ceil(t / 8)));r.bitLength() > t; )
          r.ishrn(1);
        if (r.isEven() && r.iadd(iS), r.testn(1) || r.iadd(il), e.cmp(il)) {
          if (!e.cmp(nS))
            for (;r.mod(fS).cmp(aS); )
              r.iadd(eg);
        } else
          for (;r.mod(tS).cmp(oS); )
            r.iadd(eg);
        if (o2 = r.shrn(1), nl(o2) && nl(r) && fl2(o2) && fl2(r) && Qm.test(o2) && Qm.test(r))
          return r;
      }
    }
  });
  rg = T((tk, hS) => {
    hS.exports = { modp1: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff" }, modp2: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff" }, modp5: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff" }, modp14: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff" }, modp15: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff" }, modp16: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff" }, modp17: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff" }, modp18: { gen: "02", prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff" } };
  });
  ag = T((rk, fg) => {
    var yr2 = Yu(), uS = tl(), ig = new uS, lS = new yr2(24), dS = new yr2(11), cS = new yr2(10), pS = new yr2(3), vS = new yr2(7), ng = ol(), bS = on();
    fg.exports = Si3;
    function mS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._pub = new yr2(t), this;
    }
    function gS(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this._priv = new yr2(t), this;
    }
    var Rs = {};
    function yS(t, e) {
      var r = e.toString("hex"), o2 = [r, t.toString(16)].join("_");
      if (o2 in Rs)
        return Rs[o2];
      var f2 = 0;
      if (t.isEven() || !ng.simpleSieve || !ng.fermatTest(t) || !ig.test(t))
        return f2 += 1, r === "02" || r === "05" ? f2 += 8 : f2 += 4, Rs[o2] = f2, f2;
      ig.test(t.shrn(1)) || (f2 += 2);
      var p3;
      switch (r) {
        case "02":
          t.mod(lS).cmp(dS) && (f2 += 8);
          break;
        case "05":
          p3 = t.mod(cS), p3.cmp(pS) && p3.cmp(vS) && (f2 += 8);
          break;
        default:
          f2 += 4;
      }
      return Rs[o2] = f2, f2;
    }
    function Si3(t, e, r) {
      this.setGenerator(e), this.__prime = new yr2(t), this._prime = yr2.mont(this.__prime), this._primeLen = t.length, this._pub = undefined, this._priv = undefined, this._primeCode = undefined, r ? (this.setPublicKey = mS, this.setPrivateKey = gS) : this._primeCode = 8;
    }
    Object.defineProperty(Si3.prototype, "verifyError", { enumerable: true, get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = yS(this.__prime, this.__gen)), this._primeCode;
    } });
    Si3.prototype.generateKeys = function() {
      return this._priv || (this._priv = new yr2(bS(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    Si3.prototype.computeSecret = function(t) {
      t = new yr2(t), t = t.toRed(this._prime);
      var e = t.redPow(this._priv).fromRed(), r = new Buffer(e.toArray()), o2 = this.getPrime();
      if (r.length < o2.length) {
        var f2 = new Buffer(o2.length - r.length);
        f2.fill(0), r = Buffer.concat([f2, r]);
      }
      return r;
    };
    Si3.prototype.getPublicKey = function(e) {
      return Bs(this._pub, e);
    };
    Si3.prototype.getPrivateKey = function(e) {
      return Bs(this._priv, e);
    };
    Si3.prototype.getPrime = function(t) {
      return Bs(this.__prime, t);
    };
    Si3.prototype.getGenerator = function(t) {
      return Bs(this._gen, t);
    };
    Si3.prototype.setGenerator = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.__gen = t, this._gen = new yr2(t), this;
    };
    function Bs(t, e) {
      var r = new Buffer(t.toArray());
      return e ? r.toString(e) : r;
    }
  });
  hg = T((_f) => {
    var wS = ol(), og = rg(), sl = ag();
    function MS(t) {
      var e = new Buffer(og[t].prime, "hex"), r = new Buffer(og[t].gen, "hex");
      return new sl(e, r);
    }
    var _S = { binary: true, hex: true, base64: true };
    function sg(t, e, r, o2) {
      return Buffer.isBuffer(e) || _S[e] === undefined ? sg(t, "binary", e, r) : (e = e || "binary", o2 = o2 || "binary", r = r || new Buffer([2]), Buffer.isBuffer(r) || (r = new Buffer(r, o2)), typeof t == "number" ? new sl(wS(t, r), r, true) : (Buffer.isBuffer(t) || (t = new Buffer(t, e)), new sl(t, r, true)));
    }
    _f.DiffieHellmanGroup = _f.createDiffieHellmanGroup = _f.getDiffieHellman = MS;
    _f.createDiffieHellman = _f.DiffieHellman = sg;
  });
  hl2 = T((nk, ug) => {
    ug.exports = ki().EventEmitter;
  });
  pg = T((fk, cg) => {
    function lg(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(t);
        e && (o2 = o2.filter(function(f2) {
          return Object.getOwnPropertyDescriptor(t, f2).enumerable;
        })), r.push.apply(r, o2);
      }
      return r;
    }
    function xS(t) {
      for (var e = 1;e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? lg(Object(r), true).forEach(function(o2) {
          SS(t, o2, r[o2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : lg(Object(r)).forEach(function(o2) {
          Object.defineProperty(t, o2, Object.getOwnPropertyDescriptor(r, o2));
        });
      }
      return t;
    }
    function SS(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    function ES(t, e) {
      if (!(t instanceof e))
        throw new TypeError("Cannot call a class as a function");
    }
    function dg(t, e) {
      for (var r = 0;r < e.length; r++) {
        var o2 = e[r];
        o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(t, o2.key, o2);
      }
    }
    function AS(t, e, r) {
      return e && dg(t.prototype, e), r && dg(t, r), t;
    }
    var RS = Ut2(), qs = RS.Buffer, BS = $f(), ul = BS.inspect, qS = ul && ul.custom || "inspect";
    function IS(t, e, r) {
      qs.prototype.copy.call(t, e, r);
    }
    cg.exports = function() {
      function t() {
        ES(this, t), this.head = null, this.tail = null, this.length = 0;
      }
      return AS(t, [{ key: "push", value: function(r) {
        var o2 = { data: r, next: null };
        this.length > 0 ? this.tail.next = o2 : this.head = o2, this.tail = o2, ++this.length;
      } }, { key: "unshift", value: function(r) {
        var o2 = { data: r, next: this.head };
        this.length === 0 && (this.tail = o2), this.head = o2, ++this.length;
      } }, { key: "shift", value: function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      } }, { key: "clear", value: function() {
        this.head = this.tail = null, this.length = 0;
      } }, { key: "join", value: function(r) {
        if (this.length === 0)
          return "";
        for (var o2 = this.head, f2 = "" + o2.data;o2 = o2.next; )
          f2 += r + o2.data;
        return f2;
      } }, { key: "concat", value: function(r) {
        if (this.length === 0)
          return qs.alloc(0);
        for (var o2 = qs.allocUnsafe(r >>> 0), f2 = this.head, p3 = 0;f2; )
          IS(f2.data, o2, p3), p3 += f2.data.length, f2 = f2.next;
        return o2;
      } }, { key: "consume", value: function(r, o2) {
        var f2;
        return r < this.head.data.length ? (f2 = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.length ? f2 = this.shift() : f2 = o2 ? this._getString(r) : this._getBuffer(r), f2;
      } }, { key: "first", value: function() {
        return this.head.data;
      } }, { key: "_getString", value: function(r) {
        var o2 = this.head, f2 = 1, p3 = o2.data;
        for (r -= p3.length;o2 = o2.next; ) {
          var m4 = o2.data, y3 = r > m4.length ? m4.length : r;
          if (y3 === m4.length ? p3 += m4 : p3 += m4.slice(0, r), r -= y3, r === 0) {
            y3 === m4.length ? (++f2, o2.next ? this.head = o2.next : this.head = this.tail = null) : (this.head = o2, o2.data = m4.slice(y3));
            break;
          }
          ++f2;
        }
        return this.length -= f2, p3;
      } }, { key: "_getBuffer", value: function(r) {
        var o2 = qs.allocUnsafe(r), f2 = this.head, p3 = 1;
        for (f2.data.copy(o2), r -= f2.data.length;f2 = f2.next; ) {
          var m4 = f2.data, y3 = r > m4.length ? m4.length : r;
          if (m4.copy(o2, o2.length - r, 0, y3), r -= y3, r === 0) {
            y3 === m4.length ? (++p3, f2.next ? this.head = f2.next : this.head = this.tail = null) : (this.head = f2, f2.data = m4.slice(y3));
            break;
          }
          ++p3;
        }
        return this.length -= p3, o2;
      } }, { key: qS, value: function(r, o2) {
        return ul(this, xS({}, o2, { depth: 0, customInspect: false }));
      } }]), t;
    }();
  });
  dl2 = T((ak, bg) => {
    function TS(t, e) {
      var r = this, o2 = this._readableState && this._readableState.destroyed, f2 = this._writableState && this._writableState.destroyed;
      return o2 || f2 ? (e ? e(t) : t && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(ll, this, t)) : process.nextTick(ll, this, t)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t || null, function(p3) {
        !e && p3 ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(Is, r) : (r._writableState.errorEmitted = true, process.nextTick(vg, r, p3)) : process.nextTick(vg, r, p3) : e ? (process.nextTick(Is, r), e(p3)) : process.nextTick(Is, r);
      }), this);
    }
    function vg(t, e) {
      ll(t, e), Is(t);
    }
    function Is(t) {
      t._writableState && !t._writableState.emitClose || t._readableState && !t._readableState.emitClose || t.emit("close");
    }
    function kS() {
      this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
    }
    function ll(t, e) {
      t.emit("error", e);
    }
    function LS(t, e) {
      var { _readableState: r, _writableState: o2 } = t;
      r && r.autoDestroy || o2 && o2.autoDestroy ? t.destroy(e) : t.emit("error", e);
    }
    bg.exports = { destroy: TS, undestroy: kS, errorOrDestroy: LS };
  });
  kn = T((ok, yg) => {
    function NS(t, e) {
      t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;
    }
    var gg = {};
    function wr(t, e, r) {
      r || (r = Error);
      function o2(p3, m4, y3) {
        return typeof e == "string" ? e : e(p3, m4, y3);
      }
      var f2 = function(p3) {
        NS(m4, p3);
        function m4(y3, M4, x3) {
          return p3.call(this, o2(y3, M4, x3)) || this;
        }
        return m4;
      }(r);
      f2.prototype.name = r.name, f2.prototype.code = t, gg[t] = f2;
    }
    function mg(t, e) {
      if (Array.isArray(t)) {
        var r = t.length;
        return t = t.map(function(o2) {
          return String(o2);
        }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : r === 2 ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0]);
      } else
        return "of ".concat(e, " ").concat(String(t));
    }
    function DS(t, e, r) {
      return t.substr(!r || r < 0 ? 0 : +r, e.length) === e;
    }
    function PS(t, e, r) {
      return (r === undefined || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e;
    }
    function CS(t, e, r) {
      return typeof r != "number" && (r = 0), r + e.length > t.length ? false : t.indexOf(e, r) !== -1;
    }
    wr("ERR_INVALID_OPT_VALUE", function(t, e) {
      return 'The value "' + e + '" is invalid for option "' + t + '"';
    }, TypeError);
    wr("ERR_INVALID_ARG_TYPE", function(t, e, r) {
      var o2;
      typeof e == "string" && DS(e, "not ") ? (o2 = "must not be", e = e.replace(/^not /, "")) : o2 = "must be";
      var f2;
      if (PS(t, " argument"))
        f2 = "The ".concat(t, " ").concat(o2, " ").concat(mg(e, "type"));
      else {
        var p3 = CS(t, ".") ? "property" : "argument";
        f2 = 'The "'.concat(t, '" ').concat(p3, " ").concat(o2, " ").concat(mg(e, "type"));
      }
      return f2 += ". Received type ".concat(typeof r), f2;
    }, TypeError);
    wr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    wr("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
      return "The " + t + " method is not implemented";
    });
    wr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    wr("ERR_STREAM_DESTROYED", function(t) {
      return "Cannot call " + t + " after a stream was destroyed";
    });
    wr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    wr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    wr("ERR_STREAM_WRITE_AFTER_END", "write after end");
    wr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    wr("ERR_UNKNOWN_ENCODING", function(t) {
      return "Unknown encoding: " + t;
    }, TypeError);
    wr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    yg.exports.codes = gg;
  });
  cl2 = T((sk, wg) => {
    var OS = kn().codes.ERR_INVALID_OPT_VALUE;
    function FS(t, e, r) {
      return t.highWaterMark != null ? t.highWaterMark : e ? t[r] : null;
    }
    function US(t, e, r, o2) {
      var f2 = FS(e, o2, r);
      if (f2 != null) {
        if (!(isFinite(f2) && Math.floor(f2) === f2) || f2 < 0) {
          var p3 = o2 ? r : "highWaterMark";
          throw new OS(p3, f2);
        }
        return Math.floor(f2);
      }
      return t.objectMode ? 16 : 16 * 1024;
    }
    wg.exports = { getHighWaterMark: US };
  });
  bl = T((hk, Ag) => {
    Ag.exports = ut2;
    function _g(t) {
      var e = this;
      this.next = null, this.entry = null, this.finish = function() {
        cE(e, t);
      };
    }
    var xf;
    ut2.WritableState = ka;
    var zS = { deprecate: G0() }, xg = hl2(), ks = Ut2().Buffer, HS = global.Uint8Array || function() {};
    function WS(t) {
      return ks.from(t);
    }
    function KS(t) {
      return ks.isBuffer(t) || t instanceof HS;
    }
    var vl = dl2(), jS = cl2(), ZS = jS.getHighWaterMark, Vi3 = kn().codes, VS = Vi3.ERR_INVALID_ARG_TYPE, $S = Vi3.ERR_METHOD_NOT_IMPLEMENTED, GS = Vi3.ERR_MULTIPLE_CALLBACK, YS = Vi3.ERR_STREAM_CANNOT_PIPE, XS = Vi3.ERR_STREAM_DESTROYED, JS = Vi3.ERR_STREAM_NULL_VALUES, QS = Vi3.ERR_STREAM_WRITE_AFTER_END, eE = Vi3.ERR_UNKNOWN_ENCODING, Sf = vl.errorOrDestroy;
    Ie()(ut2, xg);
    function tE() {}
    function ka(t, e, r) {
      xf = xf || Ln2(), t = t || {}, typeof r != "boolean" && (r = e instanceof xf), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = ZS(this, t, "writableHighWaterMark", r), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
      var o2 = t.decodeStrings === false;
      this.decodeStrings = !o2, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(f2) {
        sE(e, f2);
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new _g(this);
    }
    ka.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, r = [];e; )
        r.push(e), e = e.next;
      return r;
    };
    (function() {
      try {
        Object.defineProperty(ka.prototype, "buffer", { get: zS.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
      } catch {}
    })();
    var Ts;
    typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ts = Function.prototype[Symbol.hasInstance], Object.defineProperty(ut2, Symbol.hasInstance, { value: function(e) {
      return Ts.call(this, e) ? true : this !== ut2 ? false : e && e._writableState instanceof ka;
    } })) : Ts = function(e) {
      return e instanceof this;
    };
    function ut2(t) {
      xf = xf || Ln2();
      var e = this instanceof xf;
      if (!e && !Ts.call(ut2, this))
        return new ut2(t);
      this._writableState = new ka(t, this, e), this.writable = true, t && (typeof t.write == "function" && (this._write = t.write), typeof t.writev == "function" && (this._writev = t.writev), typeof t.destroy == "function" && (this._destroy = t.destroy), typeof t.final == "function" && (this._final = t.final)), xg.call(this);
    }
    ut2.prototype.pipe = function() {
      Sf(this, new YS);
    };
    function rE(t, e) {
      var r = new QS;
      Sf(t, r), process.nextTick(e, r);
    }
    function iE(t, e, r, o2) {
      var f2;
      return r === null ? f2 = new JS : typeof r != "string" && !e.objectMode && (f2 = new VS("chunk", ["string", "Buffer"], r)), f2 ? (Sf(t, f2), process.nextTick(o2, f2), false) : true;
    }
    ut2.prototype.write = function(t, e, r) {
      var o2 = this._writableState, f2 = false, p3 = !o2.objectMode && KS(t);
      return p3 && !ks.isBuffer(t) && (t = WS(t)), typeof e == "function" && (r = e, e = null), p3 ? e = "buffer" : e || (e = o2.defaultEncoding), typeof r != "function" && (r = tE), o2.ending ? rE(this, r) : (p3 || iE(this, o2, t, r)) && (o2.pendingcb++, f2 = fE(this, o2, p3, t, e, r)), f2;
    };
    ut2.prototype.cork = function() {
      this._writableState.corked++;
    };
    ut2.prototype.uncork = function() {
      var t = this._writableState;
      t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && Sg(this, t));
    };
    ut2.prototype.setDefaultEncoding = function(e) {
      if (typeof e == "string" && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1))
        throw new eE(e);
      return this._writableState.defaultEncoding = e, this;
    };
    Object.defineProperty(ut2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    function nE(t, e, r) {
      return !t.objectMode && t.decodeStrings !== false && typeof e == "string" && (e = ks.from(e, r)), e;
    }
    Object.defineProperty(ut2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    function fE(t, e, r, o2, f2, p3) {
      if (!r) {
        var m4 = nE(e, o2, f2);
        o2 !== m4 && (r = true, f2 = "buffer", o2 = m4);
      }
      var y3 = e.objectMode ? 1 : o2.length;
      e.length += y3;
      var M4 = e.length < e.highWaterMark;
      if (M4 || (e.needDrain = true), e.writing || e.corked) {
        var x3 = e.lastBufferedRequest;
        e.lastBufferedRequest = { chunk: o2, encoding: f2, isBuf: r, callback: p3, next: null }, x3 ? x3.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1;
      } else
        pl2(t, e, false, y3, o2, f2, p3);
      return M4;
    }
    function pl2(t, e, r, o2, f2, p3, m4) {
      e.writelen = o2, e.writecb = m4, e.writing = true, e.sync = true, e.destroyed ? e.onwrite(new XS("write")) : r ? t._writev(f2, e.onwrite) : t._write(f2, p3, e.onwrite), e.sync = false;
    }
    function aE(t, e, r, o2, f2) {
      --e.pendingcb, r ? (process.nextTick(f2, o2), process.nextTick(Ta, t, e), t._writableState.errorEmitted = true, Sf(t, o2)) : (f2(o2), t._writableState.errorEmitted = true, Sf(t, o2), Ta(t, e));
    }
    function oE(t) {
      t.writing = false, t.writecb = null, t.length -= t.writelen, t.writelen = 0;
    }
    function sE(t, e) {
      var r = t._writableState, o2 = r.sync, f2 = r.writecb;
      if (typeof f2 != "function")
        throw new GS;
      if (oE(r), e)
        aE(t, r, o2, e, f2);
      else {
        var p3 = Eg(r) || t.destroyed;
        !p3 && !r.corked && !r.bufferProcessing && r.bufferedRequest && Sg(t, r), o2 ? process.nextTick(Mg, t, r, p3, f2) : Mg(t, r, p3, f2);
      }
    }
    function Mg(t, e, r, o2) {
      r || hE(t, e), e.pendingcb--, o2(), Ta(t, e);
    }
    function hE(t, e) {
      e.length === 0 && e.needDrain && (e.needDrain = false, t.emit("drain"));
    }
    function Sg(t, e) {
      e.bufferProcessing = true;
      var r = e.bufferedRequest;
      if (t._writev && r && r.next) {
        var o2 = e.bufferedRequestCount, f2 = new Array(o2), p3 = e.corkedRequestsFree;
        p3.entry = r;
        for (var m4 = 0, y3 = true;r; )
          f2[m4] = r, r.isBuf || (y3 = false), r = r.next, m4 += 1;
        f2.allBuffers = y3, pl2(t, e, true, e.length, f2, "", p3.finish), e.pendingcb++, e.lastBufferedRequest = null, p3.next ? (e.corkedRequestsFree = p3.next, p3.next = null) : e.corkedRequestsFree = new _g(e), e.bufferedRequestCount = 0;
      } else {
        for (;r; ) {
          var { chunk: M4, encoding: x3, callback: S2 } = r, E6 = e.objectMode ? 1 : M4.length;
          if (pl2(t, e, false, E6, M4, x3, S2), r = r.next, e.bufferedRequestCount--, e.writing)
            break;
        }
        r === null && (e.lastBufferedRequest = null);
      }
      e.bufferedRequest = r, e.bufferProcessing = false;
    }
    ut2.prototype._write = function(t, e, r) {
      r(new $S("_write()"));
    };
    ut2.prototype._writev = null;
    ut2.prototype.end = function(t, e, r) {
      var o2 = this._writableState;
      return typeof t == "function" ? (r = t, t = null, e = null) : typeof e == "function" && (r = e, e = null), t != null && this.write(t, e), o2.corked && (o2.corked = 1, this.uncork()), o2.ending || dE(this, o2, r), this;
    };
    Object.defineProperty(ut2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function Eg(t) {
      return t.ending && t.length === 0 && t.bufferedRequest === null && !t.finished && !t.writing;
    }
    function uE(t, e) {
      t._final(function(r) {
        e.pendingcb--, r && Sf(t, r), e.prefinished = true, t.emit("prefinish"), Ta(t, e);
      });
    }
    function lE(t, e) {
      !e.prefinished && !e.finalCalled && (typeof t._final == "function" && !e.destroyed ? (e.pendingcb++, e.finalCalled = true, process.nextTick(uE, t, e)) : (e.prefinished = true, t.emit("prefinish")));
    }
    function Ta(t, e) {
      var r = Eg(e);
      if (r && (lE(t, e), e.pendingcb === 0 && (e.finished = true, t.emit("finish"), e.autoDestroy))) {
        var o2 = t._readableState;
        (!o2 || o2.autoDestroy && o2.endEmitted) && t.destroy();
      }
      return r;
    }
    function dE(t, e, r) {
      e.ending = true, Ta(t, e), r && (e.finished ? process.nextTick(r) : t.once("finish", r)), e.ended = true, t.writable = false;
    }
    function cE(t, e, r) {
      var o2 = t.entry;
      for (t.entry = null;o2; ) {
        var f2 = o2.callback;
        e.pendingcb--, f2(r), o2 = o2.next;
      }
      e.corkedRequestsFree.next = t;
    }
    Object.defineProperty(ut2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._writableState === undefined ? false : this._writableState.destroyed;
    }, set: function(e) {
      !this._writableState || (this._writableState.destroyed = e);
    } });
    ut2.prototype.destroy = vl.destroy;
    ut2.prototype._undestroy = vl.undestroy;
    ut2.prototype._destroy = function(t, e) {
      e(t);
    };
  });
  Ln2 = T((uk, Bg) => {
    var pE = Object.keys || function(t) {
      var e = [];
      for (var r in t)
        e.push(r);
      return e;
    };
    Bg.exports = ti2;
    var Rg = yl2(), gl = bl();
    Ie()(ti2, Rg);
    for (ml = pE(gl.prototype), Ls = 0;Ls < ml.length; Ls++)
      Ns = ml[Ls], ti2.prototype[Ns] || (ti2.prototype[Ns] = gl.prototype[Ns]);
    var ml, Ns, Ls;
    function ti2(t) {
      if (!(this instanceof ti2))
        return new ti2(t);
      Rg.call(this, t), gl.call(this, t), this.allowHalfOpen = true, t && (t.readable === false && (this.readable = false), t.writable === false && (this.writable = false), t.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", vE)));
    }
    Object.defineProperty(ti2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
      return this._writableState.highWaterMark;
    } });
    Object.defineProperty(ti2.prototype, "writableBuffer", { enumerable: false, get: function() {
      return this._writableState && this._writableState.getBuffer();
    } });
    Object.defineProperty(ti2.prototype, "writableLength", { enumerable: false, get: function() {
      return this._writableState.length;
    } });
    function vE() {
      this._writableState.ended || process.nextTick(bE, this);
    }
    function bE(t) {
      t.end();
    }
    Object.defineProperty(ti2.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined || this._writableState === undefined ? false : this._readableState.destroyed && this._writableState.destroyed;
    }, set: function(e) {
      this._readableState === undefined || this._writableState === undefined || (this._readableState.destroyed = e, this._writableState.destroyed = e);
    } });
  });
  Ds = T((lk, Tg) => {
    var qg = kn().codes.ERR_STREAM_PREMATURE_CLOSE;
    function mE(t) {
      var e = false;
      return function() {
        if (!e) {
          e = true;
          for (var r = arguments.length, o2 = new Array(r), f2 = 0;f2 < r; f2++)
            o2[f2] = arguments[f2];
          t.apply(this, o2);
        }
      };
    }
    function gE() {}
    function yE(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function Ig(t, e, r) {
      if (typeof e == "function")
        return Ig(t, null, e);
      e || (e = {}), r = mE(r || gE);
      var o2 = e.readable || e.readable !== false && t.readable, f2 = e.writable || e.writable !== false && t.writable, p3 = function() {
        t.writable || y3();
      }, m4 = t._writableState && t._writableState.finished, y3 = function() {
        f2 = false, m4 = true, o2 || r.call(t);
      }, M4 = t._readableState && t._readableState.endEmitted, x3 = function() {
        o2 = false, M4 = true, f2 || r.call(t);
      }, S2 = function(L3) {
        r.call(t, L3);
      }, E6 = function() {
        var L3;
        if (o2 && !M4)
          return (!t._readableState || !t._readableState.ended) && (L3 = new qg), r.call(t, L3);
        if (f2 && !m4)
          return (!t._writableState || !t._writableState.ended) && (L3 = new qg), r.call(t, L3);
      }, B3 = function() {
        t.req.on("finish", y3);
      };
      return yE(t) ? (t.on("complete", y3), t.on("abort", E6), t.req ? B3() : t.on("request", B3)) : f2 && !t._writableState && (t.on("end", p3), t.on("close", p3)), t.on("end", x3), t.on("finish", y3), e.error !== false && t.on("error", S2), t.on("close", E6), function() {
        t.removeListener("complete", y3), t.removeListener("abort", E6), t.removeListener("request", B3), t.req && t.req.removeListener("finish", y3), t.removeListener("end", p3), t.removeListener("close", p3), t.removeListener("finish", y3), t.removeListener("end", x3), t.removeListener("error", S2), t.removeListener("close", E6);
      };
    }
    Tg.exports = Ig;
  });
  Lg = T((dk, kg) => {
    var Ps;
    function $i(t, e, r) {
      return e in t ? Object.defineProperty(t, e, { value: r, enumerable: true, configurable: true, writable: true }) : t[e] = r, t;
    }
    var wE = Ds(), Gi3 = Symbol("lastResolve"), Nn2 = Symbol("lastReject"), La = Symbol("error"), Cs = Symbol("ended"), Dn2 = Symbol("lastPromise"), wl = Symbol("handlePromise"), Pn = Symbol("stream");
    function Yi2(t, e) {
      return { value: t, done: e };
    }
    function ME(t) {
      var e = t[Gi3];
      if (e !== null) {
        var r = t[Pn].read();
        r !== null && (t[Dn2] = null, t[Gi3] = null, t[Nn2] = null, e(Yi2(r, false)));
      }
    }
    function _E(t) {
      process.nextTick(ME, t);
    }
    function xE(t, e) {
      return function(r, o2) {
        t.then(function() {
          if (e[Cs]) {
            r(Yi2(undefined, true));
            return;
          }
          e[wl](r, o2);
        }, o2);
      };
    }
    var SE = Object.getPrototypeOf(function() {}), EE = Object.setPrototypeOf((Ps = { get stream() {
      return this[Pn];
    }, next: function() {
      var e = this, r = this[La];
      if (r !== null)
        return Promise.reject(r);
      if (this[Cs])
        return Promise.resolve(Yi2(undefined, true));
      if (this[Pn].destroyed)
        return new Promise(function(m4, y3) {
          process.nextTick(function() {
            e[La] ? y3(e[La]) : m4(Yi2(undefined, true));
          });
        });
      var o2 = this[Dn2], f2;
      if (o2)
        f2 = new Promise(xE(o2, this));
      else {
        var p3 = this[Pn].read();
        if (p3 !== null)
          return Promise.resolve(Yi2(p3, false));
        f2 = new Promise(this[wl]);
      }
      return this[Dn2] = f2, f2;
    } }, $i(Ps, Symbol.asyncIterator, function() {
      return this;
    }), $i(Ps, "return", function() {
      var e = this;
      return new Promise(function(r, o2) {
        e[Pn].destroy(null, function(f2) {
          if (f2) {
            o2(f2);
            return;
          }
          r(Yi2(undefined, true));
        });
      });
    }), Ps), SE), AE = function(e) {
      var r, o2 = Object.create(EE, (r = {}, $i(r, Pn, { value: e, writable: true }), $i(r, Gi3, { value: null, writable: true }), $i(r, Nn2, { value: null, writable: true }), $i(r, La, { value: null, writable: true }), $i(r, Cs, { value: e._readableState.endEmitted, writable: true }), $i(r, wl, { value: function(p3, m4) {
        var y3 = o2[Pn].read();
        y3 ? (o2[Dn2] = null, o2[Gi3] = null, o2[Nn2] = null, p3(Yi2(y3, false))) : (o2[Gi3] = p3, o2[Nn2] = m4);
      }, writable: true }), r));
      return o2[Dn2] = null, wE(e, function(f2) {
        if (f2 && f2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var p3 = o2[Nn2];
          p3 !== null && (o2[Dn2] = null, o2[Gi3] = null, o2[Nn2] = null, p3(f2)), o2[La] = f2;
          return;
        }
        var m4 = o2[Gi3];
        m4 !== null && (o2[Dn2] = null, o2[Gi3] = null, o2[Nn2] = null, m4(Yi2(undefined, true))), o2[Cs] = true;
      }), e.on("readable", _E.bind(null, o2)), o2;
    };
    kg.exports = AE;
  });
  Dg = T((ck, Ng) => {
    Ng.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  });
  yl2 = T((vk, jg) => {
    jg.exports = Oe;
    var Ef;
    Oe.ReadableState = Fg;
    var pk = ki().EventEmitter, Og = function(e, r) {
      return e.listeners(r).length;
    }, Da = hl2(), Os = Ut2().Buffer, RE = global.Uint8Array || function() {};
    function BE(t) {
      return Os.from(t);
    }
    function qE(t) {
      return Os.isBuffer(t) || t instanceof RE;
    }
    var Ml = $f(), De;
    Ml && Ml.debuglog ? De = Ml.debuglog("stream") : De = function() {};
    var IE = pg(), Bl = dl2(), TE = cl2(), kE = TE.getHighWaterMark, Fs = kn().codes, LE = Fs.ERR_INVALID_ARG_TYPE, NE = Fs.ERR_STREAM_PUSH_AFTER_EOF, DE = Fs.ERR_METHOD_NOT_IMPLEMENTED, PE = Fs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Af, _l, xl;
    Ie()(Oe, Da);
    var Na = Bl.errorOrDestroy, Sl = ["error", "close", "destroy", "pause", "resume"];
    function CE(t, e, r) {
      if (typeof t.prependListener == "function")
        return t.prependListener(e, r);
      !t._events || !t._events[e] ? t.on(e, r) : Array.isArray(t._events[e]) ? t._events[e].unshift(r) : t._events[e] = [r, t._events[e]];
    }
    function Fg(t, e, r) {
      Ef = Ef || Ln2(), t = t || {}, typeof r != "boolean" && (r = e instanceof Ef), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = kE(this, t, "readableHighWaterMark", r), this.buffer = new IE, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = t.emitClose !== false, this.autoDestroy = !!t.autoDestroy, this.destroyed = false, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t.encoding && (Af || (Af = (Qf(), ur2(Jf)).StringDecoder), this.decoder = new Af(t.encoding), this.encoding = t.encoding);
    }
    function Oe(t) {
      if (Ef = Ef || Ln2(), !(this instanceof Oe))
        return new Oe(t);
      var e = this instanceof Ef;
      this._readableState = new Fg(t, this, e), this.readable = true, t && (typeof t.read == "function" && (this._read = t.read), typeof t.destroy == "function" && (this._destroy = t.destroy)), Da.call(this);
    }
    Object.defineProperty(Oe.prototype, "destroyed", { enumerable: false, get: function() {
      return this._readableState === undefined ? false : this._readableState.destroyed;
    }, set: function(e) {
      !this._readableState || (this._readableState.destroyed = e);
    } });
    Oe.prototype.destroy = Bl.destroy;
    Oe.prototype._undestroy = Bl.undestroy;
    Oe.prototype._destroy = function(t, e) {
      e(t);
    };
    Oe.prototype.push = function(t, e) {
      var r = this._readableState, o2;
      return r.objectMode ? o2 = true : typeof t == "string" && (e = e || r.defaultEncoding, e !== r.encoding && (t = Os.from(t, e), e = ""), o2 = true), Ug(this, t, e, false, o2);
    };
    Oe.prototype.unshift = function(t) {
      return Ug(this, t, null, true, false);
    };
    function Ug(t, e, r, o2, f2) {
      De("readableAddChunk", e);
      var p3 = t._readableState;
      if (e === null)
        p3.reading = false, UE(t, p3);
      else {
        var m4;
        if (f2 || (m4 = OE(p3, e)), m4)
          Na(t, m4);
        else if (p3.objectMode || e && e.length > 0)
          if (typeof e != "string" && !p3.objectMode && Object.getPrototypeOf(e) !== Os.prototype && (e = BE(e)), o2)
            p3.endEmitted ? Na(t, new PE) : El(t, p3, e, true);
          else if (p3.ended)
            Na(t, new NE);
          else {
            if (p3.destroyed)
              return false;
            p3.reading = false, p3.decoder && !r ? (e = p3.decoder.write(e), p3.objectMode || e.length !== 0 ? El(t, p3, e, false) : Rl(t, p3)) : El(t, p3, e, false);
          }
        else
          o2 || (p3.reading = false, Rl(t, p3));
      }
      return !p3.ended && (p3.length < p3.highWaterMark || p3.length === 0);
    }
    function El(t, e, r, o2) {
      e.flowing && e.length === 0 && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, o2 ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && Us(t)), Rl(t, e);
    }
    function OE(t, e) {
      var r;
      return !qE(e) && typeof e != "string" && e !== undefined && !t.objectMode && (r = new LE("chunk", ["string", "Buffer", "Uint8Array"], e)), r;
    }
    Oe.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Oe.prototype.setEncoding = function(t) {
      Af || (Af = (Qf(), ur2(Jf)).StringDecoder);
      var e = new Af(t);
      this._readableState.decoder = e, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var r = this._readableState.buffer.head, o2 = "";r !== null; )
        o2 += e.write(r.data), r = r.next;
      return this._readableState.buffer.clear(), o2 !== "" && this._readableState.buffer.push(o2), this._readableState.length = o2.length, this;
    };
    var Pg = 1073741824;
    function FE(t) {
      return t >= Pg ? t = Pg : (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++), t;
    }
    function Cg(t, e) {
      return t <= 0 || e.length === 0 && e.ended ? 0 : e.objectMode ? 1 : t !== t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = FE(t)), t <= e.length ? t : e.ended ? e.length : (e.needReadable = true, 0));
    }
    Oe.prototype.read = function(t) {
      De("read", t), t = parseInt(t, 10);
      var e = this._readableState, r = t;
      if (t !== 0 && (e.emittedReadable = false), t === 0 && e.needReadable && ((e.highWaterMark !== 0 ? e.length >= e.highWaterMark : e.length > 0) || e.ended))
        return De("read: emitReadable", e.length, e.ended), e.length === 0 && e.ended ? Al(this) : Us(this), null;
      if (t = Cg(t, e), t === 0 && e.ended)
        return e.length === 0 && Al(this), null;
      var o2 = e.needReadable;
      De("need readable", o2), (e.length === 0 || e.length - t < e.highWaterMark) && (o2 = true, De("length less than watermark", o2)), e.ended || e.reading ? (o2 = false, De("reading or ended", o2)) : o2 && (De("do read"), e.reading = true, e.sync = true, e.length === 0 && (e.needReadable = true), this._read(e.highWaterMark), e.sync = false, e.reading || (t = Cg(r, e)));
      var f2;
      return t > 0 ? f2 = Wg(t, e) : f2 = null, f2 === null ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), e.length === 0 && (e.ended || (e.needReadable = true), r !== t && e.ended && Al(this)), f2 !== null && this.emit("data", f2), f2;
    };
    function UE(t, e) {
      if (De("onEofChunk"), !e.ended) {
        if (e.decoder) {
          var r = e.decoder.end();
          r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length);
        }
        e.ended = true, e.sync ? Us(t) : (e.needReadable = false, e.emittedReadable || (e.emittedReadable = true, zg(t)));
      }
    }
    function Us(t) {
      var e = t._readableState;
      De("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = false, e.emittedReadable || (De("emitReadable", e.flowing), e.emittedReadable = true, process.nextTick(zg, t));
    }
    function zg(t) {
      var e = t._readableState;
      De("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = false), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, ql(t);
    }
    function Rl(t, e) {
      e.readingMore || (e.readingMore = true, process.nextTick(zE, t, e));
    }
    function zE(t, e) {
      for (;!e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && e.length === 0); ) {
        var r = e.length;
        if (De("maybeReadMore read 0"), t.read(0), r === e.length)
          break;
      }
      e.readingMore = false;
    }
    Oe.prototype._read = function(t) {
      Na(this, new DE("_read()"));
    };
    Oe.prototype.pipe = function(t, e) {
      var r = this, o2 = this._readableState;
      switch (o2.pipesCount) {
        case 0:
          o2.pipes = t;
          break;
        case 1:
          o2.pipes = [o2.pipes, t];
          break;
        default:
          o2.pipes.push(t);
          break;
      }
      o2.pipesCount += 1, De("pipe count=%d opts=%j", o2.pipesCount, e);
      var f2 = (!e || e.end !== false) && t !== process.stdout && t !== process.stderr, p3 = f2 ? y3 : ge;
      o2.endEmitted ? process.nextTick(p3) : r.once("end", p3), t.on("unpipe", m4);
      function m4(_e3, N5) {
        De("onunpipe"), _e3 === r && N5 && N5.hasUnpiped === false && (N5.hasUnpiped = true, S2());
      }
      function y3() {
        De("onend"), t.end();
      }
      var M4 = HE(r);
      t.on("drain", M4);
      var x3 = false;
      function S2() {
        De("cleanup"), t.removeListener("close", q), t.removeListener("finish", L3), t.removeListener("drain", M4), t.removeListener("error", B3), t.removeListener("unpipe", m4), r.removeListener("end", y3), r.removeListener("end", ge), r.removeListener("data", E6), x3 = true, o2.awaitDrain && (!t._writableState || t._writableState.needDrain) && M4();
      }
      r.on("data", E6);
      function E6(_e3) {
        De("ondata");
        var N5 = t.write(_e3);
        De("dest.write", N5), N5 === false && ((o2.pipesCount === 1 && o2.pipes === t || o2.pipesCount > 1 && Kg(o2.pipes, t) !== -1) && !x3 && (De("false write response, pause", o2.awaitDrain), o2.awaitDrain++), r.pause());
      }
      function B3(_e3) {
        De("onerror", _e3), ge(), t.removeListener("error", B3), Og(t, "error") === 0 && Na(t, _e3);
      }
      CE(t, "error", B3);
      function q() {
        t.removeListener("finish", L3), ge();
      }
      t.once("close", q);
      function L3() {
        De("onfinish"), t.removeListener("close", q), ge();
      }
      t.once("finish", L3);
      function ge() {
        De("unpipe"), r.unpipe(t);
      }
      return t.emit("pipe", r), o2.flowing || (De("pipe resume"), r.resume()), t;
    };
    function HE(t) {
      return function() {
        var r = t._readableState;
        De("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && Og(t, "data") && (r.flowing = true, ql(t));
      };
    }
    Oe.prototype.unpipe = function(t) {
      var e = this._readableState, r = { hasUnpiped: false };
      if (e.pipesCount === 0)
        return this;
      if (e.pipesCount === 1)
        return t && t !== e.pipes ? this : (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = false, t && t.emit("unpipe", this, r), this);
      if (!t) {
        var { pipes: o2, pipesCount: f2 } = e;
        e.pipes = null, e.pipesCount = 0, e.flowing = false;
        for (var p3 = 0;p3 < f2; p3++)
          o2[p3].emit("unpipe", this, { hasUnpiped: false });
        return this;
      }
      var m4 = Kg(e.pipes, t);
      return m4 === -1 ? this : (e.pipes.splice(m4, 1), e.pipesCount -= 1, e.pipesCount === 1 && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r), this);
    };
    Oe.prototype.on = function(t, e) {
      var r = Da.prototype.on.call(this, t, e), o2 = this._readableState;
      return t === "data" ? (o2.readableListening = this.listenerCount("readable") > 0, o2.flowing !== false && this.resume()) : t === "readable" && !o2.endEmitted && !o2.readableListening && (o2.readableListening = o2.needReadable = true, o2.flowing = false, o2.emittedReadable = false, De("on readable", o2.length, o2.reading), o2.length ? Us(this) : o2.reading || process.nextTick(WE, this)), r;
    };
    Oe.prototype.addListener = Oe.prototype.on;
    Oe.prototype.removeListener = function(t, e) {
      var r = Da.prototype.removeListener.call(this, t, e);
      return t === "readable" && process.nextTick(Hg, this), r;
    };
    Oe.prototype.removeAllListeners = function(t) {
      var e = Da.prototype.removeAllListeners.apply(this, arguments);
      return (t === "readable" || t === undefined) && process.nextTick(Hg, this), e;
    };
    function Hg(t) {
      var e = t._readableState;
      e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = true : t.listenerCount("data") > 0 && t.resume();
    }
    function WE(t) {
      De("readable nexttick read 0"), t.read(0);
    }
    Oe.prototype.resume = function() {
      var t = this._readableState;
      return t.flowing || (De("resume"), t.flowing = !t.readableListening, KE(this, t)), t.paused = false, this;
    };
    function KE(t, e) {
      e.resumeScheduled || (e.resumeScheduled = true, process.nextTick(jE, t, e));
    }
    function jE(t, e) {
      De("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = false, t.emit("resume"), ql(t), e.flowing && !e.reading && t.read(0);
    }
    Oe.prototype.pause = function() {
      return De("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (De("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
    };
    function ql(t) {
      var e = t._readableState;
      for (De("flow", e.flowing);e.flowing && t.read() !== null; )
        ;
    }
    Oe.prototype.wrap = function(t) {
      var e = this, r = this._readableState, o2 = false;
      t.on("end", function() {
        if (De("wrapped end"), r.decoder && !r.ended) {
          var m4 = r.decoder.end();
          m4 && m4.length && e.push(m4);
        }
        e.push(null);
      }), t.on("data", function(m4) {
        if (De("wrapped data"), r.decoder && (m4 = r.decoder.write(m4)), !(r.objectMode && m4 == null) && !(!r.objectMode && (!m4 || !m4.length))) {
          var y3 = e.push(m4);
          y3 || (o2 = true, t.pause());
        }
      });
      for (var f2 in t)
        this[f2] === undefined && typeof t[f2] == "function" && (this[f2] = function(y3) {
          return function() {
            return t[y3].apply(t, arguments);
          };
        }(f2));
      for (var p3 = 0;p3 < Sl.length; p3++)
        t.on(Sl[p3], this.emit.bind(this, Sl[p3]));
      return this._read = function(m4) {
        De("wrapped _read", m4), o2 && (o2 = false, t.resume());
      }, this;
    };
    typeof Symbol == "function" && (Oe.prototype[Symbol.asyncIterator] = function() {
      return _l === undefined && (_l = Lg()), _l(this);
    });
    Object.defineProperty(Oe.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
      return this._readableState.highWaterMark;
    } });
    Object.defineProperty(Oe.prototype, "readableBuffer", { enumerable: false, get: function() {
      return this._readableState && this._readableState.buffer;
    } });
    Object.defineProperty(Oe.prototype, "readableFlowing", { enumerable: false, get: function() {
      return this._readableState.flowing;
    }, set: function(e) {
      this._readableState && (this._readableState.flowing = e);
    } });
    Oe._fromList = Wg;
    Object.defineProperty(Oe.prototype, "readableLength", { enumerable: false, get: function() {
      return this._readableState.length;
    } });
    function Wg(t, e) {
      if (e.length === 0)
        return null;
      var r;
      return e.objectMode ? r = e.buffer.shift() : !t || t >= e.length ? (e.decoder ? r = e.buffer.join("") : e.buffer.length === 1 ? r = e.buffer.first() : r = e.buffer.concat(e.length), e.buffer.clear()) : r = e.buffer.consume(t, e.decoder), r;
    }
    function Al(t) {
      var e = t._readableState;
      De("endReadable", e.endEmitted), e.endEmitted || (e.ended = true, process.nextTick(ZE, e, t));
    }
    function ZE(t, e) {
      if (De("endReadableNT", t.endEmitted, t.length), !t.endEmitted && t.length === 0 && (t.endEmitted = true, e.readable = false, e.emit("end"), t.autoDestroy)) {
        var r = e._writableState;
        (!r || r.autoDestroy && r.finished) && e.destroy();
      }
    }
    typeof Symbol == "function" && (Oe.from = function(t, e) {
      return xl === undefined && (xl = Dg()), xl(Oe, t, e);
    });
    function Kg(t, e) {
      for (var r = 0, o2 = t.length;r < o2; r++)
        if (t[r] === e)
          return r;
      return -1;
    }
  });
  Il = T((bk, Vg) => {
    Vg.exports = Ei2;
    var zs2 = kn().codes, VE = zs2.ERR_METHOD_NOT_IMPLEMENTED, $E = zs2.ERR_MULTIPLE_CALLBACK, GE = zs2.ERR_TRANSFORM_ALREADY_TRANSFORMING, YE = zs2.ERR_TRANSFORM_WITH_LENGTH_0, Hs2 = Ln2();
    Ie()(Ei2, Hs2);
    function XE(t, e) {
      var r = this._transformState;
      r.transforming = false;
      var o2 = r.writecb;
      if (o2 === null)
        return this.emit("error", new $E);
      r.writechunk = null, r.writecb = null, e != null && this.push(e), o2(t);
      var f2 = this._readableState;
      f2.reading = false, (f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
    }
    function Ei2(t) {
      if (!(this instanceof Ei2))
        return new Ei2(t);
      Hs2.call(this, t), this._transformState = { afterTransform: XE.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, t && (typeof t.transform == "function" && (this._transform = t.transform), typeof t.flush == "function" && (this._flush = t.flush)), this.on("prefinish", JE);
    }
    function JE() {
      var t = this;
      typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(e, r) {
        Zg(t, e, r);
      }) : Zg(this, null, null);
    }
    Ei2.prototype.push = function(t, e) {
      return this._transformState.needTransform = false, Hs2.prototype.push.call(this, t, e);
    };
    Ei2.prototype._transform = function(t, e, r) {
      r(new VE("_transform()"));
    };
    Ei2.prototype._write = function(t, e, r) {
      var o2 = this._transformState;
      if (o2.writecb = r, o2.writechunk = t, o2.writeencoding = e, !o2.transforming) {
        var f2 = this._readableState;
        (o2.needTransform || f2.needReadable || f2.length < f2.highWaterMark) && this._read(f2.highWaterMark);
      }
    };
    Ei2.prototype._read = function(t) {
      var e = this._transformState;
      e.writechunk !== null && !e.transforming ? (e.transforming = true, this._transform(e.writechunk, e.writeencoding, e.afterTransform)) : e.needTransform = true;
    };
    Ei2.prototype._destroy = function(t, e) {
      Hs2.prototype._destroy.call(this, t, function(r) {
        e(r);
      });
    };
    function Zg(t, e, r) {
      if (e)
        return t.emit("error", e);
      if (r != null && t.push(r), t._writableState.length)
        throw new YE;
      if (t._transformState.transforming)
        throw new GE;
      return t.push(null);
    }
  });
  Yg = T((mk, Gg) => {
    Gg.exports = Pa;
    var $g = Il();
    Ie()(Pa, $g);
    function Pa(t) {
      if (!(this instanceof Pa))
        return new Pa(t);
      $g.call(this, t);
    }
    Pa.prototype._transform = function(t, e, r) {
      r(null, t);
    };
  });
  t2 = T((gk, e2) => {
    var Tl;
    function QE(t) {
      var e = false;
      return function() {
        e || (e = true, t.apply(undefined, arguments));
      };
    }
    var Qg = kn().codes, eA = Qg.ERR_MISSING_ARGS, tA = Qg.ERR_STREAM_DESTROYED;
    function Xg(t) {
      if (t)
        throw t;
    }
    function rA(t) {
      return t.setHeader && typeof t.abort == "function";
    }
    function iA(t, e, r, o2) {
      o2 = QE(o2);
      var f2 = false;
      t.on("close", function() {
        f2 = true;
      }), Tl === undefined && (Tl = Ds()), Tl(t, { readable: e, writable: r }, function(m4) {
        if (m4)
          return o2(m4);
        f2 = true, o2();
      });
      var p3 = false;
      return function(m4) {
        if (!f2 && !p3) {
          if (p3 = true, rA(t))
            return t.abort();
          if (typeof t.destroy == "function")
            return t.destroy();
          o2(m4 || new tA("pipe"));
        }
      };
    }
    function Jg(t) {
      t();
    }
    function nA(t, e) {
      return t.pipe(e);
    }
    function fA(t) {
      return !t.length || typeof t[t.length - 1] != "function" ? Xg : t.pop();
    }
    function aA() {
      for (var t = arguments.length, e = new Array(t), r = 0;r < t; r++)
        e[r] = arguments[r];
      var o2 = fA(e);
      if (Array.isArray(e[0]) && (e = e[0]), e.length < 2)
        throw new eA("streams");
      var f2, p3 = e.map(function(m4, y3) {
        var M4 = y3 < e.length - 1, x3 = y3 > 0;
        return iA(m4, M4, x3, function(S2) {
          f2 || (f2 = S2), S2 && p3.forEach(Jg), !M4 && (p3.forEach(Jg), o2(f2));
        });
      });
      return e.reduce(nA);
    }
    e2.exports = aA;
  });
  i2 = T((Mr, r2) => {
    Mr = r2.exports = yl2();
    Mr.Stream = Mr;
    Mr.Readable = Mr;
    Mr.Writable = bl();
    Mr.Duplex = Ln2();
    Mr.Transform = Il();
    Mr.PassThrough = Yg();
    Mr.finished = Ds();
    Mr.pipeline = t2();
  });
  Ws2 = T((n2, kl) => {
    (function(t, e) {
      function r(h3, s2) {
        if (!h3)
          throw new Error(s2 || "Assertion failed");
      }
      function o2(h3, s2) {
        h3.super_ = s2;
        var u2 = function() {};
        u2.prototype = s2.prototype, h3.prototype = new u2, h3.prototype.constructor = h3;
      }
      function f2(h3, s2, u2) {
        if (f2.isBN(h3))
          return h3;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, h3 !== null && ((s2 === "le" || s2 === "be") && (u2 = s2, s2 = 10), this._init(h3 || 0, s2 || 10, u2 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {}
      f2.isBN = function(s2) {
        return s2 instanceof f2 ? true : s2 !== null && typeof s2 == "object" && s2.constructor.wordSize === f2.wordSize && Array.isArray(s2.words);
      }, f2.max = function(s2, u2) {
        return s2.cmp(u2) > 0 ? s2 : u2;
      }, f2.min = function(s2, u2) {
        return s2.cmp(u2) < 0 ? s2 : u2;
      }, f2.prototype._init = function(s2, u2, c2) {
        if (typeof s2 == "number")
          return this._initNumber(s2, u2, c2);
        if (typeof s2 == "object")
          return this._initArray(s2, u2, c2);
        u2 === "hex" && (u2 = 16), r(u2 === (u2 | 0) && u2 >= 2 && u2 <= 36), s2 = s2.toString().replace(/\s+/g, "");
        var b5 = 0;
        s2[0] === "-" && (b5++, this.negative = 1), b5 < s2.length && (u2 === 16 ? this._parseHex(s2, b5, c2) : (this._parseBase(s2, u2, b5), c2 === "le" && this._initArray(this.toArray(), u2, c2)));
      }, f2.prototype._initNumber = function(s2, u2, c2) {
        s2 < 0 && (this.negative = 1, s2 = -s2), s2 < 67108864 ? (this.words = [s2 & 67108863], this.length = 1) : s2 < 4503599627370496 ? (this.words = [s2 & 67108863, s2 / 67108864 & 67108863], this.length = 2) : (r(s2 < 9007199254740992), this.words = [s2 & 67108863, s2 / 67108864 & 67108863, 1], this.length = 3), c2 === "le" && this._initArray(this.toArray(), u2, c2);
      }, f2.prototype._initArray = function(s2, u2, c2) {
        if (r(typeof s2.length == "number"), s2.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(s2.length / 3), this.words = new Array(this.length);
        for (var b5 = 0;b5 < this.length; b5++)
          this.words[b5] = 0;
        var l3, n, d3 = 0;
        if (c2 === "be")
          for (b5 = s2.length - 1, l3 = 0;b5 >= 0; b5 -= 3)
            n = s2[b5] | s2[b5 - 1] << 8 | s2[b5 - 2] << 16, this.words[l3] |= n << d3 & 67108863, this.words[l3 + 1] = n >>> 26 - d3 & 67108863, d3 += 24, d3 >= 26 && (d3 -= 26, l3++);
        else if (c2 === "le")
          for (b5 = 0, l3 = 0;b5 < s2.length; b5 += 3)
            n = s2[b5] | s2[b5 + 1] << 8 | s2[b5 + 2] << 16, this.words[l3] |= n << d3 & 67108863, this.words[l3 + 1] = n >>> 26 - d3 & 67108863, d3 += 24, d3 >= 26 && (d3 -= 26, l3++);
        return this._strip();
      };
      function m4(h3, s2) {
        var u2 = h3.charCodeAt(s2);
        if (u2 >= 48 && u2 <= 57)
          return u2 - 48;
        if (u2 >= 65 && u2 <= 70)
          return u2 - 55;
        if (u2 >= 97 && u2 <= 102)
          return u2 - 87;
        r(false, "Invalid character in " + h3);
      }
      function y3(h3, s2, u2) {
        var c2 = m4(h3, u2);
        return u2 - 1 >= s2 && (c2 |= m4(h3, u2 - 1) << 4), c2;
      }
      f2.prototype._parseHex = function(s2, u2, c2) {
        this.length = Math.ceil((s2.length - u2) / 6), this.words = new Array(this.length);
        for (var b5 = 0;b5 < this.length; b5++)
          this.words[b5] = 0;
        var l3 = 0, n = 0, d3;
        if (c2 === "be")
          for (b5 = s2.length - 1;b5 >= u2; b5 -= 2)
            d3 = y3(s2, u2, b5) << l3, this.words[n] |= d3 & 67108863, l3 >= 18 ? (l3 -= 18, n += 1, this.words[n] |= d3 >>> 26) : l3 += 8;
        else {
          var w3 = s2.length - u2;
          for (b5 = w3 % 2 === 0 ? u2 + 1 : u2;b5 < s2.length; b5 += 2)
            d3 = y3(s2, u2, b5) << l3, this.words[n] |= d3 & 67108863, l3 >= 18 ? (l3 -= 18, n += 1, this.words[n] |= d3 >>> 26) : l3 += 8;
        }
        this._strip();
      };
      function M4(h3, s2, u2, c2) {
        for (var b5 = 0, l3 = 0, n = Math.min(h3.length, u2), d3 = s2;d3 < n; d3++) {
          var w3 = h3.charCodeAt(d3) - 48;
          b5 *= c2, w3 >= 49 ? l3 = w3 - 49 + 10 : w3 >= 17 ? l3 = w3 - 17 + 10 : l3 = w3, r(w3 >= 0 && l3 < c2, "Invalid character"), b5 += l3;
        }
        return b5;
      }
      f2.prototype._parseBase = function(s2, u2, c2) {
        this.words = [0], this.length = 1;
        for (var b5 = 0, l3 = 1;l3 <= 67108863; l3 *= u2)
          b5++;
        b5--, l3 = l3 / u2 | 0;
        for (var n = s2.length - c2, d3 = n % b5, w3 = Math.min(n, n - d3) + c2, g3 = 0, _3 = c2;_3 < w3; _3 += b5)
          g3 = M4(s2, _3, _3 + b5, u2), this.imuln(l3), this.words[0] + g3 < 67108864 ? this.words[0] += g3 : this._iaddn(g3);
        if (d3 !== 0) {
          var A3 = 1;
          for (g3 = M4(s2, _3, s2.length, u2), _3 = 0;_3 < d3; _3++)
            A3 *= u2;
          this.imuln(A3), this.words[0] + g3 < 67108864 ? this.words[0] += g3 : this._iaddn(g3);
        }
        this._strip();
      }, f2.prototype.copy = function(s2) {
        s2.words = new Array(this.length);
        for (var u2 = 0;u2 < this.length; u2++)
          s2.words[u2] = this.words[u2];
        s2.length = this.length, s2.negative = this.negative, s2.red = this.red;
      };
      function x3(h3, s2) {
        h3.words = s2.words, h3.length = s2.length, h3.negative = s2.negative, h3.red = s2.red;
      }
      if (f2.prototype._move = function(s2) {
        x3(s2, this);
      }, f2.prototype.clone = function() {
        var s2 = new f2(null);
        return this.copy(s2), s2;
      }, f2.prototype._expand = function(s2) {
        for (;this.length < s2; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype._strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          f2.prototype[Symbol.for("nodejs.util.inspect.custom")] = S2;
        } catch {
          f2.prototype.inspect = S2;
        }
      else
        f2.prototype.inspect = S2;
      function S2() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var E6 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], B3 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], q = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(s2, u2) {
        s2 = s2 || 10, u2 = u2 | 0 || 1;
        var c2;
        if (s2 === 16 || s2 === "hex") {
          c2 = "";
          for (var b5 = 0, l3 = 0, n = 0;n < this.length; n++) {
            var d3 = this.words[n], w3 = ((d3 << b5 | l3) & 16777215).toString(16);
            l3 = d3 >>> 24 - b5 & 16777215, b5 += 2, b5 >= 26 && (b5 -= 26, n--), l3 !== 0 || n !== this.length - 1 ? c2 = E6[6 - w3.length] + w3 + c2 : c2 = w3 + c2;
          }
          for (l3 !== 0 && (c2 = l3.toString(16) + c2);c2.length % u2 !== 0; )
            c2 = "0" + c2;
          return this.negative !== 0 && (c2 = "-" + c2), c2;
        }
        if (s2 === (s2 | 0) && s2 >= 2 && s2 <= 36) {
          var g3 = B3[s2], _3 = q[s2];
          c2 = "";
          var A3 = this.clone();
          for (A3.negative = 0;!A3.isZero(); ) {
            var R2 = A3.modrn(_3).toString(s2);
            A3 = A3.idivn(_3), A3.isZero() ? c2 = R2 + c2 : c2 = E6[g3 - R2.length] + R2 + c2;
          }
          for (this.isZero() && (c2 = "0" + c2);c2.length % u2 !== 0; )
            c2 = "0" + c2;
          return this.negative !== 0 && (c2 = "-" + c2), c2;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var s2 = this.words[0];
        return this.length === 2 ? s2 += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? s2 += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -s2 : s2;
      }, f2.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p3 && (f2.prototype.toBuffer = function(s2, u2) {
        return this.toArrayLike(p3, s2, u2);
      }), f2.prototype.toArray = function(s2, u2) {
        return this.toArrayLike(Array, s2, u2);
      };
      var L3 = function(s2, u2) {
        return s2.allocUnsafe ? s2.allocUnsafe(u2) : new s2(u2);
      };
      f2.prototype.toArrayLike = function(s2, u2, c2) {
        this._strip();
        var b5 = this.byteLength(), l3 = c2 || Math.max(1, b5);
        r(b5 <= l3, "byte array longer than desired length"), r(l3 > 0, "Requested array length <= 0");
        var n = L3(s2, l3), d3 = u2 === "le" ? "LE" : "BE";
        return this["_toArrayLike" + d3](n, b5), n;
      }, f2.prototype._toArrayLikeLE = function(s2, u2) {
        for (var c2 = 0, b5 = 0, l3 = 0, n = 0;l3 < this.length; l3++) {
          var d3 = this.words[l3] << n | b5;
          s2[c2++] = d3 & 255, c2 < s2.length && (s2[c2++] = d3 >> 8 & 255), c2 < s2.length && (s2[c2++] = d3 >> 16 & 255), n === 6 ? (c2 < s2.length && (s2[c2++] = d3 >> 24 & 255), b5 = 0, n = 0) : (b5 = d3 >>> 24, n += 2);
        }
        if (c2 < s2.length)
          for (s2[c2++] = b5;c2 < s2.length; )
            s2[c2++] = 0;
      }, f2.prototype._toArrayLikeBE = function(s2, u2) {
        for (var c2 = s2.length - 1, b5 = 0, l3 = 0, n = 0;l3 < this.length; l3++) {
          var d3 = this.words[l3] << n | b5;
          s2[c2--] = d3 & 255, c2 >= 0 && (s2[c2--] = d3 >> 8 & 255), c2 >= 0 && (s2[c2--] = d3 >> 16 & 255), n === 6 ? (c2 >= 0 && (s2[c2--] = d3 >> 24 & 255), b5 = 0, n = 0) : (b5 = d3 >>> 24, n += 2);
        }
        if (c2 >= 0)
          for (s2[c2--] = b5;c2 >= 0; )
            s2[c2--] = 0;
      }, Math.clz32 ? f2.prototype._countBits = function(s2) {
        return 32 - Math.clz32(s2);
      } : f2.prototype._countBits = function(s2) {
        var u2 = s2, c2 = 0;
        return u2 >= 4096 && (c2 += 13, u2 >>>= 13), u2 >= 64 && (c2 += 7, u2 >>>= 7), u2 >= 8 && (c2 += 4, u2 >>>= 4), u2 >= 2 && (c2 += 2, u2 >>>= 2), c2 + u2;
      }, f2.prototype._zeroBits = function(s2) {
        if (s2 === 0)
          return 26;
        var u2 = s2, c2 = 0;
        return (u2 & 8191) === 0 && (c2 += 13, u2 >>>= 13), (u2 & 127) === 0 && (c2 += 7, u2 >>>= 7), (u2 & 15) === 0 && (c2 += 4, u2 >>>= 4), (u2 & 3) === 0 && (c2 += 2, u2 >>>= 2), (u2 & 1) === 0 && c2++, c2;
      }, f2.prototype.bitLength = function() {
        var s2 = this.words[this.length - 1], u2 = this._countBits(s2);
        return (this.length - 1) * 26 + u2;
      };
      function ge(h3) {
        for (var s2 = new Array(h3.bitLength()), u2 = 0;u2 < s2.length; u2++) {
          var c2 = u2 / 26 | 0, b5 = u2 % 26;
          s2[u2] = h3.words[c2] >>> b5 & 1;
        }
        return s2;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var s2 = 0, u2 = 0;u2 < this.length; u2++) {
          var c2 = this._zeroBits(this.words[u2]);
          if (s2 += c2, c2 !== 26)
            break;
        }
        return s2;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(s2) {
        return this.negative !== 0 ? this.abs().inotn(s2).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(s2) {
        return this.testn(s2 - 1) ? this.notn(s2).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(s2) {
        for (;this.length < s2.length; )
          this.words[this.length++] = 0;
        for (var u2 = 0;u2 < s2.length; u2++)
          this.words[u2] = this.words[u2] | s2.words[u2];
        return this._strip();
      }, f2.prototype.ior = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuor(s2);
      }, f2.prototype.or = function(s2) {
        return this.length > s2.length ? this.clone().ior(s2) : s2.clone().ior(this);
      }, f2.prototype.uor = function(s2) {
        return this.length > s2.length ? this.clone().iuor(s2) : s2.clone().iuor(this);
      }, f2.prototype.iuand = function(s2) {
        var u2;
        this.length > s2.length ? u2 = s2 : u2 = this;
        for (var c2 = 0;c2 < u2.length; c2++)
          this.words[c2] = this.words[c2] & s2.words[c2];
        return this.length = u2.length, this._strip();
      }, f2.prototype.iand = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuand(s2);
      }, f2.prototype.and = function(s2) {
        return this.length > s2.length ? this.clone().iand(s2) : s2.clone().iand(this);
      }, f2.prototype.uand = function(s2) {
        return this.length > s2.length ? this.clone().iuand(s2) : s2.clone().iuand(this);
      }, f2.prototype.iuxor = function(s2) {
        var u2, c2;
        this.length > s2.length ? (u2 = this, c2 = s2) : (u2 = s2, c2 = this);
        for (var b5 = 0;b5 < c2.length; b5++)
          this.words[b5] = u2.words[b5] ^ c2.words[b5];
        if (this !== u2)
          for (;b5 < u2.length; b5++)
            this.words[b5] = u2.words[b5];
        return this.length = u2.length, this._strip();
      }, f2.prototype.ixor = function(s2) {
        return r((this.negative | s2.negative) === 0), this.iuxor(s2);
      }, f2.prototype.xor = function(s2) {
        return this.length > s2.length ? this.clone().ixor(s2) : s2.clone().ixor(this);
      }, f2.prototype.uxor = function(s2) {
        return this.length > s2.length ? this.clone().iuxor(s2) : s2.clone().iuxor(this);
      }, f2.prototype.inotn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u2 = Math.ceil(s2 / 26) | 0, c2 = s2 % 26;
        this._expand(u2), c2 > 0 && u2--;
        for (var b5 = 0;b5 < u2; b5++)
          this.words[b5] = ~this.words[b5] & 67108863;
        return c2 > 0 && (this.words[b5] = ~this.words[b5] & 67108863 >> 26 - c2), this._strip();
      }, f2.prototype.notn = function(s2) {
        return this.clone().inotn(s2);
      }, f2.prototype.setn = function(s2, u2) {
        r(typeof s2 == "number" && s2 >= 0);
        var c2 = s2 / 26 | 0, b5 = s2 % 26;
        return this._expand(c2 + 1), u2 ? this.words[c2] = this.words[c2] | 1 << b5 : this.words[c2] = this.words[c2] & ~(1 << b5), this._strip();
      }, f2.prototype.iadd = function(s2) {
        var u2;
        if (this.negative !== 0 && s2.negative === 0)
          return this.negative = 0, u2 = this.isub(s2), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && s2.negative !== 0)
          return s2.negative = 0, u2 = this.isub(s2), s2.negative = 1, u2._normSign();
        var c2, b5;
        this.length > s2.length ? (c2 = this, b5 = s2) : (c2 = s2, b5 = this);
        for (var l3 = 0, n = 0;n < b5.length; n++)
          u2 = (c2.words[n] | 0) + (b5.words[n] | 0) + l3, this.words[n] = u2 & 67108863, l3 = u2 >>> 26;
        for (;l3 !== 0 && n < c2.length; n++)
          u2 = (c2.words[n] | 0) + l3, this.words[n] = u2 & 67108863, l3 = u2 >>> 26;
        if (this.length = c2.length, l3 !== 0)
          this.words[this.length] = l3, this.length++;
        else if (c2 !== this)
          for (;n < c2.length; n++)
            this.words[n] = c2.words[n];
        return this;
      }, f2.prototype.add = function(s2) {
        var u2;
        return s2.negative !== 0 && this.negative === 0 ? (s2.negative = 0, u2 = this.sub(s2), s2.negative ^= 1, u2) : s2.negative === 0 && this.negative !== 0 ? (this.negative = 0, u2 = s2.sub(this), this.negative = 1, u2) : this.length > s2.length ? this.clone().iadd(s2) : s2.clone().iadd(this);
      }, f2.prototype.isub = function(s2) {
        if (s2.negative !== 0) {
          s2.negative = 0;
          var u2 = this.iadd(s2);
          return s2.negative = 1, u2._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(s2), this.negative = 1, this._normSign();
        var c2 = this.cmp(s2);
        if (c2 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var b5, l3;
        c2 > 0 ? (b5 = this, l3 = s2) : (b5 = s2, l3 = this);
        for (var n = 0, d3 = 0;d3 < l3.length; d3++)
          u2 = (b5.words[d3] | 0) - (l3.words[d3] | 0) + n, n = u2 >> 26, this.words[d3] = u2 & 67108863;
        for (;n !== 0 && d3 < b5.length; d3++)
          u2 = (b5.words[d3] | 0) + n, n = u2 >> 26, this.words[d3] = u2 & 67108863;
        if (n === 0 && d3 < b5.length && b5 !== this)
          for (;d3 < b5.length; d3++)
            this.words[d3] = b5.words[d3];
        return this.length = Math.max(this.length, d3), b5 !== this && (this.negative = 1), this._strip();
      }, f2.prototype.sub = function(s2) {
        return this.clone().isub(s2);
      };
      function _e3(h3, s2, u2) {
        u2.negative = s2.negative ^ h3.negative;
        var c2 = h3.length + s2.length | 0;
        u2.length = c2, c2 = c2 - 1 | 0;
        var b5 = h3.words[0] | 0, l3 = s2.words[0] | 0, n = b5 * l3, d3 = n & 67108863, w3 = n / 67108864 | 0;
        u2.words[0] = d3;
        for (var g3 = 1;g3 < c2; g3++) {
          for (var _3 = w3 >>> 26, A3 = w3 & 67108863, R2 = Math.min(g3, s2.length - 1), I4 = Math.max(0, g3 - h3.length + 1);I4 <= R2; I4++) {
            var Me = g3 - I4 | 0;
            b5 = h3.words[Me] | 0, l3 = s2.words[I4] | 0, n = b5 * l3 + A3, _3 += n / 67108864 | 0, A3 = n & 67108863;
          }
          u2.words[g3] = A3 | 0, w3 = _3 | 0;
        }
        return w3 !== 0 ? u2.words[g3] = w3 | 0 : u2.length--, u2._strip();
      }
      var N5 = function(s2, u2, c2) {
        var b5 = s2.words, l3 = u2.words, n = c2.words, d3 = 0, w3, g3, _3, A3 = b5[0] | 0, R2 = A3 & 8191, I4 = A3 >>> 13, Me = b5[1] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt3 = b5[2] | 0, C3 = nt3 & 8191, O2 = nt3 >>> 13, vt = b5[3] | 0, F3 = vt & 8191, U2 = vt >>> 13, bt4 = b5[4] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt3 = b5[5] | 0, W = mt3 & 8191, K4 = mt3 >>> 13, gt3 = b5[6] | 0, j4 = gt3 & 8191, Z2 = gt3 >>> 13, yt2 = b5[7] | 0, V4 = yt2 & 8191, $ = yt2 >>> 13, wt = b5[8] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = b5[9] | 0, X3 = Mt & 8191, J3 = Mt >>> 13, _t3 = l3[0] | 0, Q4 = _t3 & 8191, ee = _t3 >>> 13, xt3 = l3[1] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St = l3[2] | 0, ie = St & 8191, ne = St >>> 13, Et2 = l3[3] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At4 = l3[4] | 0, oe3 = At4 & 8191, se2 = At4 >>> 13, Rt = l3[5] | 0, he = Rt & 8191, ue4 = Rt >>> 13, Bt = l3[6] | 0, le = Bt & 8191, de = Bt >>> 13, qt2 = l3[7] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = l3[8] | 0, ve = It & 8191, be = It >>> 13, ft = l3[9] | 0, Be = ft & 8191, qe2 = ft >>> 13;
        c2.negative = s2.negative ^ u2.negative, c2.length = 19, w3 = Math.imul(R2, Q4), g3 = Math.imul(R2, ee), g3 = g3 + Math.imul(I4, Q4) | 0, _3 = Math.imul(I4, ee);
        var ze = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, w3 = Math.imul(k4, Q4), g3 = Math.imul(k4, ee), g3 = g3 + Math.imul(D2, Q4) | 0, _3 = Math.imul(D2, ee), w3 = w3 + Math.imul(R2, te2) | 0, g3 = g3 + Math.imul(R2, re2) | 0, g3 = g3 + Math.imul(I4, te2) | 0, _3 = _3 + Math.imul(I4, re2) | 0;
        var He3 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, w3 = Math.imul(C3, Q4), g3 = Math.imul(C3, ee), g3 = g3 + Math.imul(O2, Q4) | 0, _3 = Math.imul(O2, ee), w3 = w3 + Math.imul(k4, te2) | 0, g3 = g3 + Math.imul(k4, re2) | 0, g3 = g3 + Math.imul(D2, te2) | 0, _3 = _3 + Math.imul(D2, re2) | 0, w3 = w3 + Math.imul(R2, ie) | 0, g3 = g3 + Math.imul(R2, ne) | 0, g3 = g3 + Math.imul(I4, ie) | 0, _3 = _3 + Math.imul(I4, ne) | 0;
        var We2 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, w3 = Math.imul(F3, Q4), g3 = Math.imul(F3, ee), g3 = g3 + Math.imul(U2, Q4) | 0, _3 = Math.imul(U2, ee), w3 = w3 + Math.imul(C3, te2) | 0, g3 = g3 + Math.imul(C3, re2) | 0, g3 = g3 + Math.imul(O2, te2) | 0, _3 = _3 + Math.imul(O2, re2) | 0, w3 = w3 + Math.imul(k4, ie) | 0, g3 = g3 + Math.imul(k4, ne) | 0, g3 = g3 + Math.imul(D2, ie) | 0, _3 = _3 + Math.imul(D2, ne) | 0, w3 = w3 + Math.imul(R2, fe3) | 0, g3 = g3 + Math.imul(R2, ae2) | 0, g3 = g3 + Math.imul(I4, fe3) | 0, _3 = _3 + Math.imul(I4, ae2) | 0;
        var Ke2 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, w3 = Math.imul(z, Q4), g3 = Math.imul(z, ee), g3 = g3 + Math.imul(H3, Q4) | 0, _3 = Math.imul(H3, ee), w3 = w3 + Math.imul(F3, te2) | 0, g3 = g3 + Math.imul(F3, re2) | 0, g3 = g3 + Math.imul(U2, te2) | 0, _3 = _3 + Math.imul(U2, re2) | 0, w3 = w3 + Math.imul(C3, ie) | 0, g3 = g3 + Math.imul(C3, ne) | 0, g3 = g3 + Math.imul(O2, ie) | 0, _3 = _3 + Math.imul(O2, ne) | 0, w3 = w3 + Math.imul(k4, fe3) | 0, g3 = g3 + Math.imul(k4, ae2) | 0, g3 = g3 + Math.imul(D2, fe3) | 0, _3 = _3 + Math.imul(D2, ae2) | 0, w3 = w3 + Math.imul(R2, oe3) | 0, g3 = g3 + Math.imul(R2, se2) | 0, g3 = g3 + Math.imul(I4, oe3) | 0, _3 = _3 + Math.imul(I4, se2) | 0;
        var je = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, w3 = Math.imul(W, Q4), g3 = Math.imul(W, ee), g3 = g3 + Math.imul(K4, Q4) | 0, _3 = Math.imul(K4, ee), w3 = w3 + Math.imul(z, te2) | 0, g3 = g3 + Math.imul(z, re2) | 0, g3 = g3 + Math.imul(H3, te2) | 0, _3 = _3 + Math.imul(H3, re2) | 0, w3 = w3 + Math.imul(F3, ie) | 0, g3 = g3 + Math.imul(F3, ne) | 0, g3 = g3 + Math.imul(U2, ie) | 0, _3 = _3 + Math.imul(U2, ne) | 0, w3 = w3 + Math.imul(C3, fe3) | 0, g3 = g3 + Math.imul(C3, ae2) | 0, g3 = g3 + Math.imul(O2, fe3) | 0, _3 = _3 + Math.imul(O2, ae2) | 0, w3 = w3 + Math.imul(k4, oe3) | 0, g3 = g3 + Math.imul(k4, se2) | 0, g3 = g3 + Math.imul(D2, oe3) | 0, _3 = _3 + Math.imul(D2, se2) | 0, w3 = w3 + Math.imul(R2, he) | 0, g3 = g3 + Math.imul(R2, ue4) | 0, g3 = g3 + Math.imul(I4, he) | 0, _3 = _3 + Math.imul(I4, ue4) | 0;
        var Ze2 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, w3 = Math.imul(j4, Q4), g3 = Math.imul(j4, ee), g3 = g3 + Math.imul(Z2, Q4) | 0, _3 = Math.imul(Z2, ee), w3 = w3 + Math.imul(W, te2) | 0, g3 = g3 + Math.imul(W, re2) | 0, g3 = g3 + Math.imul(K4, te2) | 0, _3 = _3 + Math.imul(K4, re2) | 0, w3 = w3 + Math.imul(z, ie) | 0, g3 = g3 + Math.imul(z, ne) | 0, g3 = g3 + Math.imul(H3, ie) | 0, _3 = _3 + Math.imul(H3, ne) | 0, w3 = w3 + Math.imul(F3, fe3) | 0, g3 = g3 + Math.imul(F3, ae2) | 0, g3 = g3 + Math.imul(U2, fe3) | 0, _3 = _3 + Math.imul(U2, ae2) | 0, w3 = w3 + Math.imul(C3, oe3) | 0, g3 = g3 + Math.imul(C3, se2) | 0, g3 = g3 + Math.imul(O2, oe3) | 0, _3 = _3 + Math.imul(O2, se2) | 0, w3 = w3 + Math.imul(k4, he) | 0, g3 = g3 + Math.imul(k4, ue4) | 0, g3 = g3 + Math.imul(D2, he) | 0, _3 = _3 + Math.imul(D2, ue4) | 0, w3 = w3 + Math.imul(R2, le) | 0, g3 = g3 + Math.imul(R2, de) | 0, g3 = g3 + Math.imul(I4, le) | 0, _3 = _3 + Math.imul(I4, de) | 0;
        var Ve = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, w3 = Math.imul(V4, Q4), g3 = Math.imul(V4, ee), g3 = g3 + Math.imul($, Q4) | 0, _3 = Math.imul($, ee), w3 = w3 + Math.imul(j4, te2) | 0, g3 = g3 + Math.imul(j4, re2) | 0, g3 = g3 + Math.imul(Z2, te2) | 0, _3 = _3 + Math.imul(Z2, re2) | 0, w3 = w3 + Math.imul(W, ie) | 0, g3 = g3 + Math.imul(W, ne) | 0, g3 = g3 + Math.imul(K4, ie) | 0, _3 = _3 + Math.imul(K4, ne) | 0, w3 = w3 + Math.imul(z, fe3) | 0, g3 = g3 + Math.imul(z, ae2) | 0, g3 = g3 + Math.imul(H3, fe3) | 0, _3 = _3 + Math.imul(H3, ae2) | 0, w3 = w3 + Math.imul(F3, oe3) | 0, g3 = g3 + Math.imul(F3, se2) | 0, g3 = g3 + Math.imul(U2, oe3) | 0, _3 = _3 + Math.imul(U2, se2) | 0, w3 = w3 + Math.imul(C3, he) | 0, g3 = g3 + Math.imul(C3, ue4) | 0, g3 = g3 + Math.imul(O2, he) | 0, _3 = _3 + Math.imul(O2, ue4) | 0, w3 = w3 + Math.imul(k4, le) | 0, g3 = g3 + Math.imul(k4, de) | 0, g3 = g3 + Math.imul(D2, le) | 0, _3 = _3 + Math.imul(D2, de) | 0, w3 = w3 + Math.imul(R2, ce3) | 0, g3 = g3 + Math.imul(R2, pe2) | 0, g3 = g3 + Math.imul(I4, ce3) | 0, _3 = _3 + Math.imul(I4, pe2) | 0;
        var $e2 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, w3 = Math.imul(G2, Q4), g3 = Math.imul(G2, ee), g3 = g3 + Math.imul(Y3, Q4) | 0, _3 = Math.imul(Y3, ee), w3 = w3 + Math.imul(V4, te2) | 0, g3 = g3 + Math.imul(V4, re2) | 0, g3 = g3 + Math.imul($, te2) | 0, _3 = _3 + Math.imul($, re2) | 0, w3 = w3 + Math.imul(j4, ie) | 0, g3 = g3 + Math.imul(j4, ne) | 0, g3 = g3 + Math.imul(Z2, ie) | 0, _3 = _3 + Math.imul(Z2, ne) | 0, w3 = w3 + Math.imul(W, fe3) | 0, g3 = g3 + Math.imul(W, ae2) | 0, g3 = g3 + Math.imul(K4, fe3) | 0, _3 = _3 + Math.imul(K4, ae2) | 0, w3 = w3 + Math.imul(z, oe3) | 0, g3 = g3 + Math.imul(z, se2) | 0, g3 = g3 + Math.imul(H3, oe3) | 0, _3 = _3 + Math.imul(H3, se2) | 0, w3 = w3 + Math.imul(F3, he) | 0, g3 = g3 + Math.imul(F3, ue4) | 0, g3 = g3 + Math.imul(U2, he) | 0, _3 = _3 + Math.imul(U2, ue4) | 0, w3 = w3 + Math.imul(C3, le) | 0, g3 = g3 + Math.imul(C3, de) | 0, g3 = g3 + Math.imul(O2, le) | 0, _3 = _3 + Math.imul(O2, de) | 0, w3 = w3 + Math.imul(k4, ce3) | 0, g3 = g3 + Math.imul(k4, pe2) | 0, g3 = g3 + Math.imul(D2, ce3) | 0, _3 = _3 + Math.imul(D2, pe2) | 0, w3 = w3 + Math.imul(R2, ve) | 0, g3 = g3 + Math.imul(R2, be) | 0, g3 = g3 + Math.imul(I4, ve) | 0, _3 = _3 + Math.imul(I4, be) | 0;
        var Ge = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, w3 = Math.imul(X3, Q4), g3 = Math.imul(X3, ee), g3 = g3 + Math.imul(J3, Q4) | 0, _3 = Math.imul(J3, ee), w3 = w3 + Math.imul(G2, te2) | 0, g3 = g3 + Math.imul(G2, re2) | 0, g3 = g3 + Math.imul(Y3, te2) | 0, _3 = _3 + Math.imul(Y3, re2) | 0, w3 = w3 + Math.imul(V4, ie) | 0, g3 = g3 + Math.imul(V4, ne) | 0, g3 = g3 + Math.imul($, ie) | 0, _3 = _3 + Math.imul($, ne) | 0, w3 = w3 + Math.imul(j4, fe3) | 0, g3 = g3 + Math.imul(j4, ae2) | 0, g3 = g3 + Math.imul(Z2, fe3) | 0, _3 = _3 + Math.imul(Z2, ae2) | 0, w3 = w3 + Math.imul(W, oe3) | 0, g3 = g3 + Math.imul(W, se2) | 0, g3 = g3 + Math.imul(K4, oe3) | 0, _3 = _3 + Math.imul(K4, se2) | 0, w3 = w3 + Math.imul(z, he) | 0, g3 = g3 + Math.imul(z, ue4) | 0, g3 = g3 + Math.imul(H3, he) | 0, _3 = _3 + Math.imul(H3, ue4) | 0, w3 = w3 + Math.imul(F3, le) | 0, g3 = g3 + Math.imul(F3, de) | 0, g3 = g3 + Math.imul(U2, le) | 0, _3 = _3 + Math.imul(U2, de) | 0, w3 = w3 + Math.imul(C3, ce3) | 0, g3 = g3 + Math.imul(C3, pe2) | 0, g3 = g3 + Math.imul(O2, ce3) | 0, _3 = _3 + Math.imul(O2, pe2) | 0, w3 = w3 + Math.imul(k4, ve) | 0, g3 = g3 + Math.imul(k4, be) | 0, g3 = g3 + Math.imul(D2, ve) | 0, _3 = _3 + Math.imul(D2, be) | 0, w3 = w3 + Math.imul(R2, Be) | 0, g3 = g3 + Math.imul(R2, qe2) | 0, g3 = g3 + Math.imul(I4, Be) | 0, _3 = _3 + Math.imul(I4, qe2) | 0;
        var Ye = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, w3 = Math.imul(X3, te2), g3 = Math.imul(X3, re2), g3 = g3 + Math.imul(J3, te2) | 0, _3 = Math.imul(J3, re2), w3 = w3 + Math.imul(G2, ie) | 0, g3 = g3 + Math.imul(G2, ne) | 0, g3 = g3 + Math.imul(Y3, ie) | 0, _3 = _3 + Math.imul(Y3, ne) | 0, w3 = w3 + Math.imul(V4, fe3) | 0, g3 = g3 + Math.imul(V4, ae2) | 0, g3 = g3 + Math.imul($, fe3) | 0, _3 = _3 + Math.imul($, ae2) | 0, w3 = w3 + Math.imul(j4, oe3) | 0, g3 = g3 + Math.imul(j4, se2) | 0, g3 = g3 + Math.imul(Z2, oe3) | 0, _3 = _3 + Math.imul(Z2, se2) | 0, w3 = w3 + Math.imul(W, he) | 0, g3 = g3 + Math.imul(W, ue4) | 0, g3 = g3 + Math.imul(K4, he) | 0, _3 = _3 + Math.imul(K4, ue4) | 0, w3 = w3 + Math.imul(z, le) | 0, g3 = g3 + Math.imul(z, de) | 0, g3 = g3 + Math.imul(H3, le) | 0, _3 = _3 + Math.imul(H3, de) | 0, w3 = w3 + Math.imul(F3, ce3) | 0, g3 = g3 + Math.imul(F3, pe2) | 0, g3 = g3 + Math.imul(U2, ce3) | 0, _3 = _3 + Math.imul(U2, pe2) | 0, w3 = w3 + Math.imul(C3, ve) | 0, g3 = g3 + Math.imul(C3, be) | 0, g3 = g3 + Math.imul(O2, ve) | 0, _3 = _3 + Math.imul(O2, be) | 0, w3 = w3 + Math.imul(k4, Be) | 0, g3 = g3 + Math.imul(k4, qe2) | 0, g3 = g3 + Math.imul(D2, Be) | 0, _3 = _3 + Math.imul(D2, qe2) | 0;
        var Xe = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, w3 = Math.imul(X3, ie), g3 = Math.imul(X3, ne), g3 = g3 + Math.imul(J3, ie) | 0, _3 = Math.imul(J3, ne), w3 = w3 + Math.imul(G2, fe3) | 0, g3 = g3 + Math.imul(G2, ae2) | 0, g3 = g3 + Math.imul(Y3, fe3) | 0, _3 = _3 + Math.imul(Y3, ae2) | 0, w3 = w3 + Math.imul(V4, oe3) | 0, g3 = g3 + Math.imul(V4, se2) | 0, g3 = g3 + Math.imul($, oe3) | 0, _3 = _3 + Math.imul($, se2) | 0, w3 = w3 + Math.imul(j4, he) | 0, g3 = g3 + Math.imul(j4, ue4) | 0, g3 = g3 + Math.imul(Z2, he) | 0, _3 = _3 + Math.imul(Z2, ue4) | 0, w3 = w3 + Math.imul(W, le) | 0, g3 = g3 + Math.imul(W, de) | 0, g3 = g3 + Math.imul(K4, le) | 0, _3 = _3 + Math.imul(K4, de) | 0, w3 = w3 + Math.imul(z, ce3) | 0, g3 = g3 + Math.imul(z, pe2) | 0, g3 = g3 + Math.imul(H3, ce3) | 0, _3 = _3 + Math.imul(H3, pe2) | 0, w3 = w3 + Math.imul(F3, ve) | 0, g3 = g3 + Math.imul(F3, be) | 0, g3 = g3 + Math.imul(U2, ve) | 0, _3 = _3 + Math.imul(U2, be) | 0, w3 = w3 + Math.imul(C3, Be) | 0, g3 = g3 + Math.imul(C3, qe2) | 0, g3 = g3 + Math.imul(O2, Be) | 0, _3 = _3 + Math.imul(O2, qe2) | 0;
        var Je = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, w3 = Math.imul(X3, fe3), g3 = Math.imul(X3, ae2), g3 = g3 + Math.imul(J3, fe3) | 0, _3 = Math.imul(J3, ae2), w3 = w3 + Math.imul(G2, oe3) | 0, g3 = g3 + Math.imul(G2, se2) | 0, g3 = g3 + Math.imul(Y3, oe3) | 0, _3 = _3 + Math.imul(Y3, se2) | 0, w3 = w3 + Math.imul(V4, he) | 0, g3 = g3 + Math.imul(V4, ue4) | 0, g3 = g3 + Math.imul($, he) | 0, _3 = _3 + Math.imul($, ue4) | 0, w3 = w3 + Math.imul(j4, le) | 0, g3 = g3 + Math.imul(j4, de) | 0, g3 = g3 + Math.imul(Z2, le) | 0, _3 = _3 + Math.imul(Z2, de) | 0, w3 = w3 + Math.imul(W, ce3) | 0, g3 = g3 + Math.imul(W, pe2) | 0, g3 = g3 + Math.imul(K4, ce3) | 0, _3 = _3 + Math.imul(K4, pe2) | 0, w3 = w3 + Math.imul(z, ve) | 0, g3 = g3 + Math.imul(z, be) | 0, g3 = g3 + Math.imul(H3, ve) | 0, _3 = _3 + Math.imul(H3, be) | 0, w3 = w3 + Math.imul(F3, Be) | 0, g3 = g3 + Math.imul(F3, qe2) | 0, g3 = g3 + Math.imul(U2, Be) | 0, _3 = _3 + Math.imul(U2, qe2) | 0;
        var Qe2 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, w3 = Math.imul(X3, oe3), g3 = Math.imul(X3, se2), g3 = g3 + Math.imul(J3, oe3) | 0, _3 = Math.imul(J3, se2), w3 = w3 + Math.imul(G2, he) | 0, g3 = g3 + Math.imul(G2, ue4) | 0, g3 = g3 + Math.imul(Y3, he) | 0, _3 = _3 + Math.imul(Y3, ue4) | 0, w3 = w3 + Math.imul(V4, le) | 0, g3 = g3 + Math.imul(V4, de) | 0, g3 = g3 + Math.imul($, le) | 0, _3 = _3 + Math.imul($, de) | 0, w3 = w3 + Math.imul(j4, ce3) | 0, g3 = g3 + Math.imul(j4, pe2) | 0, g3 = g3 + Math.imul(Z2, ce3) | 0, _3 = _3 + Math.imul(Z2, pe2) | 0, w3 = w3 + Math.imul(W, ve) | 0, g3 = g3 + Math.imul(W, be) | 0, g3 = g3 + Math.imul(K4, ve) | 0, _3 = _3 + Math.imul(K4, be) | 0, w3 = w3 + Math.imul(z, Be) | 0, g3 = g3 + Math.imul(z, qe2) | 0, g3 = g3 + Math.imul(H3, Be) | 0, _3 = _3 + Math.imul(H3, qe2) | 0;
        var et4 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (et4 >>> 26) | 0, et4 &= 67108863, w3 = Math.imul(X3, he), g3 = Math.imul(X3, ue4), g3 = g3 + Math.imul(J3, he) | 0, _3 = Math.imul(J3, ue4), w3 = w3 + Math.imul(G2, le) | 0, g3 = g3 + Math.imul(G2, de) | 0, g3 = g3 + Math.imul(Y3, le) | 0, _3 = _3 + Math.imul(Y3, de) | 0, w3 = w3 + Math.imul(V4, ce3) | 0, g3 = g3 + Math.imul(V4, pe2) | 0, g3 = g3 + Math.imul($, ce3) | 0, _3 = _3 + Math.imul($, pe2) | 0, w3 = w3 + Math.imul(j4, ve) | 0, g3 = g3 + Math.imul(j4, be) | 0, g3 = g3 + Math.imul(Z2, ve) | 0, _3 = _3 + Math.imul(Z2, be) | 0, w3 = w3 + Math.imul(W, Be) | 0, g3 = g3 + Math.imul(W, qe2) | 0, g3 = g3 + Math.imul(K4, Be) | 0, _3 = _3 + Math.imul(K4, qe2) | 0;
        var tt4 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, w3 = Math.imul(X3, le), g3 = Math.imul(X3, de), g3 = g3 + Math.imul(J3, le) | 0, _3 = Math.imul(J3, de), w3 = w3 + Math.imul(G2, ce3) | 0, g3 = g3 + Math.imul(G2, pe2) | 0, g3 = g3 + Math.imul(Y3, ce3) | 0, _3 = _3 + Math.imul(Y3, pe2) | 0, w3 = w3 + Math.imul(V4, ve) | 0, g3 = g3 + Math.imul(V4, be) | 0, g3 = g3 + Math.imul($, ve) | 0, _3 = _3 + Math.imul($, be) | 0, w3 = w3 + Math.imul(j4, Be) | 0, g3 = g3 + Math.imul(j4, qe2) | 0, g3 = g3 + Math.imul(Z2, Be) | 0, _3 = _3 + Math.imul(Z2, qe2) | 0;
        var rt4 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, w3 = Math.imul(X3, ce3), g3 = Math.imul(X3, pe2), g3 = g3 + Math.imul(J3, ce3) | 0, _3 = Math.imul(J3, pe2), w3 = w3 + Math.imul(G2, ve) | 0, g3 = g3 + Math.imul(G2, be) | 0, g3 = g3 + Math.imul(Y3, ve) | 0, _3 = _3 + Math.imul(Y3, be) | 0, w3 = w3 + Math.imul(V4, Be) | 0, g3 = g3 + Math.imul(V4, qe2) | 0, g3 = g3 + Math.imul($, Be) | 0, _3 = _3 + Math.imul($, qe2) | 0;
        var S0 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (S0 >>> 26) | 0, S0 &= 67108863, w3 = Math.imul(X3, ve), g3 = Math.imul(X3, be), g3 = g3 + Math.imul(J3, ve) | 0, _3 = Math.imul(J3, be), w3 = w3 + Math.imul(G2, Be) | 0, g3 = g3 + Math.imul(G2, qe2) | 0, g3 = g3 + Math.imul(Y3, Be) | 0, _3 = _3 + Math.imul(Y3, qe2) | 0;
        var E0 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        d3 = (_3 + (g3 >>> 13) | 0) + (E0 >>> 26) | 0, E0 &= 67108863, w3 = Math.imul(X3, Be), g3 = Math.imul(X3, qe2), g3 = g3 + Math.imul(J3, Be) | 0, _3 = Math.imul(J3, qe2);
        var A0 = (d3 + w3 | 0) + ((g3 & 8191) << 13) | 0;
        return d3 = (_3 + (g3 >>> 13) | 0) + (A0 >>> 26) | 0, A0 &= 67108863, n[0] = ze, n[1] = He3, n[2] = We2, n[3] = Ke2, n[4] = je, n[5] = Ze2, n[6] = Ve, n[7] = $e2, n[8] = Ge, n[9] = Ye, n[10] = Xe, n[11] = Je, n[12] = Qe2, n[13] = et4, n[14] = tt4, n[15] = rt4, n[16] = S0, n[17] = E0, n[18] = A0, d3 !== 0 && (n[19] = d3, c2.length++), c2;
      };
      Math.imul || (N5 = _e3);
      function we(h3, s2, u2) {
        u2.negative = s2.negative ^ h3.negative, u2.length = h3.length + s2.length;
        for (var c2 = 0, b5 = 0, l3 = 0;l3 < u2.length - 1; l3++) {
          var n = b5;
          b5 = 0;
          for (var d3 = c2 & 67108863, w3 = Math.min(l3, s2.length - 1), g3 = Math.max(0, l3 - h3.length + 1);g3 <= w3; g3++) {
            var _3 = l3 - g3, A3 = h3.words[_3] | 0, R2 = s2.words[g3] | 0, I4 = A3 * R2, Me = I4 & 67108863;
            n = n + (I4 / 67108864 | 0) | 0, Me = Me + d3 | 0, d3 = Me & 67108863, n = n + (Me >>> 26) | 0, b5 += n >>> 26, n &= 67108863;
          }
          u2.words[l3] = d3, c2 = n, n = b5;
        }
        return c2 !== 0 ? u2.words[l3] = c2 : u2.length--, u2._strip();
      }
      function ye(h3, s2, u2) {
        return we(h3, s2, u2);
      }
      f2.prototype.mulTo = function(s2, u2) {
        var c2, b5 = this.length + s2.length;
        return this.length === 10 && s2.length === 10 ? c2 = N5(this, s2, u2) : b5 < 63 ? c2 = _e3(this, s2, u2) : b5 < 1024 ? c2 = we(this, s2, u2) : c2 = ye(this, s2, u2), c2;
      };
      function xe(h3, s2) {
        this.x = h3, this.y = s2;
      }
      xe.prototype.makeRBT = function(s2) {
        for (var u2 = new Array(s2), c2 = f2.prototype._countBits(s2) - 1, b5 = 0;b5 < s2; b5++)
          u2[b5] = this.revBin(b5, c2, s2);
        return u2;
      }, xe.prototype.revBin = function(s2, u2, c2) {
        if (s2 === 0 || s2 === c2 - 1)
          return s2;
        for (var b5 = 0, l3 = 0;l3 < u2; l3++)
          b5 |= (s2 & 1) << u2 - l3 - 1, s2 >>= 1;
        return b5;
      }, xe.prototype.permute = function(s2, u2, c2, b5, l3, n) {
        for (var d3 = 0;d3 < n; d3++)
          b5[d3] = u2[s2[d3]], l3[d3] = c2[s2[d3]];
      }, xe.prototype.transform = function(s2, u2, c2, b5, l3, n) {
        this.permute(n, s2, u2, c2, b5, l3);
        for (var d3 = 1;d3 < l3; d3 <<= 1)
          for (var w3 = d3 << 1, g3 = Math.cos(2 * Math.PI / w3), _3 = Math.sin(2 * Math.PI / w3), A3 = 0;A3 < l3; A3 += w3)
            for (var R2 = g3, I4 = _3, Me = 0;Me < d3; Me++) {
              var k4 = c2[A3 + Me], D2 = b5[A3 + Me], nt3 = c2[A3 + Me + d3], C3 = b5[A3 + Me + d3], O2 = R2 * nt3 - I4 * C3;
              C3 = R2 * C3 + I4 * nt3, nt3 = O2, c2[A3 + Me] = k4 + nt3, b5[A3 + Me] = D2 + C3, c2[A3 + Me + d3] = k4 - nt3, b5[A3 + Me + d3] = D2 - C3, Me !== w3 && (O2 = g3 * R2 - _3 * I4, I4 = g3 * I4 + _3 * R2, R2 = O2);
            }
      }, xe.prototype.guessLen13b = function(s2, u2) {
        var c2 = Math.max(u2, s2) | 1, b5 = c2 & 1, l3 = 0;
        for (c2 = c2 / 2 | 0;c2; c2 = c2 >>> 1)
          l3++;
        return 1 << l3 + 1 + b5;
      }, xe.prototype.conjugate = function(s2, u2, c2) {
        if (!(c2 <= 1))
          for (var b5 = 0;b5 < c2 / 2; b5++) {
            var l3 = s2[b5];
            s2[b5] = s2[c2 - b5 - 1], s2[c2 - b5 - 1] = l3, l3 = u2[b5], u2[b5] = -u2[c2 - b5 - 1], u2[c2 - b5 - 1] = -l3;
          }
      }, xe.prototype.normalize13b = function(s2, u2) {
        for (var c2 = 0, b5 = 0;b5 < u2 / 2; b5++) {
          var l3 = Math.round(s2[2 * b5 + 1] / u2) * 8192 + Math.round(s2[2 * b5] / u2) + c2;
          s2[b5] = l3 & 67108863, l3 < 67108864 ? c2 = 0 : c2 = l3 / 67108864 | 0;
        }
        return s2;
      }, xe.prototype.convert13b = function(s2, u2, c2, b5) {
        for (var l3 = 0, n = 0;n < u2; n++)
          l3 = l3 + (s2[n] | 0), c2[2 * n] = l3 & 8191, l3 = l3 >>> 13, c2[2 * n + 1] = l3 & 8191, l3 = l3 >>> 13;
        for (n = 2 * u2;n < b5; ++n)
          c2[n] = 0;
        r(l3 === 0), r((l3 & -8192) === 0);
      }, xe.prototype.stub = function(s2) {
        for (var u2 = new Array(s2), c2 = 0;c2 < s2; c2++)
          u2[c2] = 0;
        return u2;
      }, xe.prototype.mulp = function(s2, u2, c2) {
        var b5 = 2 * this.guessLen13b(s2.length, u2.length), l3 = this.makeRBT(b5), n = this.stub(b5), d3 = new Array(b5), w3 = new Array(b5), g3 = new Array(b5), _3 = new Array(b5), A3 = new Array(b5), R2 = new Array(b5), I4 = c2.words;
        I4.length = b5, this.convert13b(s2.words, s2.length, d3, b5), this.convert13b(u2.words, u2.length, _3, b5), this.transform(d3, n, w3, g3, b5, l3), this.transform(_3, n, A3, R2, b5, l3);
        for (var Me = 0;Me < b5; Me++) {
          var k4 = w3[Me] * A3[Me] - g3[Me] * R2[Me];
          g3[Me] = w3[Me] * R2[Me] + g3[Me] * A3[Me], w3[Me] = k4;
        }
        return this.conjugate(w3, g3, b5), this.transform(w3, g3, I4, n, b5, l3), this.conjugate(I4, n, b5), this.normalize13b(I4, b5), c2.negative = s2.negative ^ u2.negative, c2.length = s2.length + u2.length, c2._strip();
      }, f2.prototype.mul = function(s2) {
        var u2 = new f2(null);
        return u2.words = new Array(this.length + s2.length), this.mulTo(s2, u2);
      }, f2.prototype.mulf = function(s2) {
        var u2 = new f2(null);
        return u2.words = new Array(this.length + s2.length), ye(this, s2, u2);
      }, f2.prototype.imul = function(s2) {
        return this.clone().mulTo(s2, this);
      }, f2.prototype.imuln = function(s2) {
        var u2 = s2 < 0;
        u2 && (s2 = -s2), r(typeof s2 == "number"), r(s2 < 67108864);
        for (var c2 = 0, b5 = 0;b5 < this.length; b5++) {
          var l3 = (this.words[b5] | 0) * s2, n = (l3 & 67108863) + (c2 & 67108863);
          c2 >>= 26, c2 += l3 / 67108864 | 0, c2 += n >>> 26, this.words[b5] = n & 67108863;
        }
        return c2 !== 0 && (this.words[b5] = c2, this.length++), u2 ? this.ineg() : this;
      }, f2.prototype.muln = function(s2) {
        return this.clone().imuln(s2);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(s2) {
        var u2 = ge(s2);
        if (u2.length === 0)
          return new f2(1);
        for (var c2 = this, b5 = 0;b5 < u2.length && u2[b5] === 0; b5++, c2 = c2.sqr())
          ;
        if (++b5 < u2.length)
          for (var l3 = c2.sqr();b5 < u2.length; b5++, l3 = l3.sqr())
            u2[b5] !== 0 && (c2 = c2.mul(l3));
        return c2;
      }, f2.prototype.iushln = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u2 = s2 % 26, c2 = (s2 - u2) / 26, b5 = 67108863 >>> 26 - u2 << 26 - u2, l3;
        if (u2 !== 0) {
          var n = 0;
          for (l3 = 0;l3 < this.length; l3++) {
            var d3 = this.words[l3] & b5, w3 = (this.words[l3] | 0) - d3 << u2;
            this.words[l3] = w3 | n, n = d3 >>> 26 - u2;
          }
          n && (this.words[l3] = n, this.length++);
        }
        if (c2 !== 0) {
          for (l3 = this.length - 1;l3 >= 0; l3--)
            this.words[l3 + c2] = this.words[l3];
          for (l3 = 0;l3 < c2; l3++)
            this.words[l3] = 0;
          this.length += c2;
        }
        return this._strip();
      }, f2.prototype.ishln = function(s2) {
        return r(this.negative === 0), this.iushln(s2);
      }, f2.prototype.iushrn = function(s2, u2, c2) {
        r(typeof s2 == "number" && s2 >= 0);
        var b5;
        u2 ? b5 = (u2 - u2 % 26) / 26 : b5 = 0;
        var l3 = s2 % 26, n = Math.min((s2 - l3) / 26, this.length), d3 = 67108863 ^ 67108863 >>> l3 << l3, w3 = c2;
        if (b5 -= n, b5 = Math.max(0, b5), w3) {
          for (var g3 = 0;g3 < n; g3++)
            w3.words[g3] = this.words[g3];
          w3.length = n;
        }
        if (n !== 0)
          if (this.length > n)
            for (this.length -= n, g3 = 0;g3 < this.length; g3++)
              this.words[g3] = this.words[g3 + n];
          else
            this.words[0] = 0, this.length = 1;
        var _3 = 0;
        for (g3 = this.length - 1;g3 >= 0 && (_3 !== 0 || g3 >= b5); g3--) {
          var A3 = this.words[g3] | 0;
          this.words[g3] = _3 << 26 - l3 | A3 >>> l3, _3 = A3 & d3;
        }
        return w3 && _3 !== 0 && (w3.words[w3.length++] = _3), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, f2.prototype.ishrn = function(s2, u2, c2) {
        return r(this.negative === 0), this.iushrn(s2, u2, c2);
      }, f2.prototype.shln = function(s2) {
        return this.clone().ishln(s2);
      }, f2.prototype.ushln = function(s2) {
        return this.clone().iushln(s2);
      }, f2.prototype.shrn = function(s2) {
        return this.clone().ishrn(s2);
      }, f2.prototype.ushrn = function(s2) {
        return this.clone().iushrn(s2);
      }, f2.prototype.testn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u2 = s2 % 26, c2 = (s2 - u2) / 26, b5 = 1 << u2;
        if (this.length <= c2)
          return false;
        var l3 = this.words[c2];
        return !!(l3 & b5);
      }, f2.prototype.imaskn = function(s2) {
        r(typeof s2 == "number" && s2 >= 0);
        var u2 = s2 % 26, c2 = (s2 - u2) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= c2)
          return this;
        if (u2 !== 0 && c2++, this.length = Math.min(c2, this.length), u2 !== 0) {
          var b5 = 67108863 ^ 67108863 >>> u2 << u2;
          this.words[this.length - 1] &= b5;
        }
        return this._strip();
      }, f2.prototype.maskn = function(s2) {
        return this.clone().imaskn(s2);
      }, f2.prototype.iaddn = function(s2) {
        return r(typeof s2 == "number"), r(s2 < 67108864), s2 < 0 ? this.isubn(-s2) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= s2 ? (this.words[0] = s2 - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(s2), this.negative = 1, this) : this._iaddn(s2);
      }, f2.prototype._iaddn = function(s2) {
        this.words[0] += s2;
        for (var u2 = 0;u2 < this.length && this.words[u2] >= 67108864; u2++)
          this.words[u2] -= 67108864, u2 === this.length - 1 ? this.words[u2 + 1] = 1 : this.words[u2 + 1]++;
        return this.length = Math.max(this.length, u2 + 1), this;
      }, f2.prototype.isubn = function(s2) {
        if (r(typeof s2 == "number"), r(s2 < 67108864), s2 < 0)
          return this.iaddn(-s2);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(s2), this.negative = 1, this;
        if (this.words[0] -= s2, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var u2 = 0;u2 < this.length && this.words[u2] < 0; u2++)
            this.words[u2] += 67108864, this.words[u2 + 1] -= 1;
        return this._strip();
      }, f2.prototype.addn = function(s2) {
        return this.clone().iaddn(s2);
      }, f2.prototype.subn = function(s2) {
        return this.clone().isubn(s2);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(s2, u2, c2) {
        var b5 = s2.length + c2, l3;
        this._expand(b5);
        var n, d3 = 0;
        for (l3 = 0;l3 < s2.length; l3++) {
          n = (this.words[l3 + c2] | 0) + d3;
          var w3 = (s2.words[l3] | 0) * u2;
          n -= w3 & 67108863, d3 = (n >> 26) - (w3 / 67108864 | 0), this.words[l3 + c2] = n & 67108863;
        }
        for (;l3 < this.length - c2; l3++)
          n = (this.words[l3 + c2] | 0) + d3, d3 = n >> 26, this.words[l3 + c2] = n & 67108863;
        if (d3 === 0)
          return this._strip();
        for (r(d3 === -1), d3 = 0, l3 = 0;l3 < this.length; l3++)
          n = -(this.words[l3] | 0) + d3, d3 = n >> 26, this.words[l3] = n & 67108863;
        return this.negative = 1, this._strip();
      }, f2.prototype._wordDiv = function(s2, u2) {
        var c2 = this.length - s2.length, b5 = this.clone(), l3 = s2, n = l3.words[l3.length - 1] | 0, d3 = this._countBits(n);
        c2 = 26 - d3, c2 !== 0 && (l3 = l3.ushln(c2), b5.iushln(c2), n = l3.words[l3.length - 1] | 0);
        var w3 = b5.length - l3.length, g3;
        if (u2 !== "mod") {
          g3 = new f2(null), g3.length = w3 + 1, g3.words = new Array(g3.length);
          for (var _3 = 0;_3 < g3.length; _3++)
            g3.words[_3] = 0;
        }
        var A3 = b5.clone()._ishlnsubmul(l3, 1, w3);
        A3.negative === 0 && (b5 = A3, g3 && (g3.words[w3] = 1));
        for (var R2 = w3 - 1;R2 >= 0; R2--) {
          var I4 = (b5.words[l3.length + R2] | 0) * 67108864 + (b5.words[l3.length + R2 - 1] | 0);
          for (I4 = Math.min(I4 / n | 0, 67108863), b5._ishlnsubmul(l3, I4, R2);b5.negative !== 0; )
            I4--, b5.negative = 0, b5._ishlnsubmul(l3, 1, R2), b5.isZero() || (b5.negative ^= 1);
          g3 && (g3.words[R2] = I4);
        }
        return g3 && g3._strip(), b5._strip(), u2 !== "div" && c2 !== 0 && b5.iushrn(c2), { div: g3 || null, mod: b5 };
      }, f2.prototype.divmod = function(s2, u2, c2) {
        if (r(!s2.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var b5, l3, n;
        return this.negative !== 0 && s2.negative === 0 ? (n = this.neg().divmod(s2, u2), u2 !== "mod" && (b5 = n.div.neg()), u2 !== "div" && (l3 = n.mod.neg(), c2 && l3.negative !== 0 && l3.iadd(s2)), { div: b5, mod: l3 }) : this.negative === 0 && s2.negative !== 0 ? (n = this.divmod(s2.neg(), u2), u2 !== "mod" && (b5 = n.div.neg()), { div: b5, mod: n.mod }) : (this.negative & s2.negative) !== 0 ? (n = this.neg().divmod(s2.neg(), u2), u2 !== "div" && (l3 = n.mod.neg(), c2 && l3.negative !== 0 && l3.isub(s2)), { div: n.div, mod: l3 }) : s2.length > this.length || this.cmp(s2) < 0 ? { div: new f2(0), mod: this } : s2.length === 1 ? u2 === "div" ? { div: this.divn(s2.words[0]), mod: null } : u2 === "mod" ? { div: null, mod: new f2(this.modrn(s2.words[0])) } : { div: this.divn(s2.words[0]), mod: new f2(this.modrn(s2.words[0])) } : this._wordDiv(s2, u2);
      }, f2.prototype.div = function(s2) {
        return this.divmod(s2, "div", false).div;
      }, f2.prototype.mod = function(s2) {
        return this.divmod(s2, "mod", false).mod;
      }, f2.prototype.umod = function(s2) {
        return this.divmod(s2, "mod", true).mod;
      }, f2.prototype.divRound = function(s2) {
        var u2 = this.divmod(s2);
        if (u2.mod.isZero())
          return u2.div;
        var c2 = u2.div.negative !== 0 ? u2.mod.isub(s2) : u2.mod, b5 = s2.ushrn(1), l3 = s2.andln(1), n = c2.cmp(b5);
        return n < 0 || l3 === 1 && n === 0 ? u2.div : u2.div.negative !== 0 ? u2.div.isubn(1) : u2.div.iaddn(1);
      }, f2.prototype.modrn = function(s2) {
        var u2 = s2 < 0;
        u2 && (s2 = -s2), r(s2 <= 67108863);
        for (var c2 = (1 << 26) % s2, b5 = 0, l3 = this.length - 1;l3 >= 0; l3--)
          b5 = (c2 * b5 + (this.words[l3] | 0)) % s2;
        return u2 ? -b5 : b5;
      }, f2.prototype.modn = function(s2) {
        return this.modrn(s2);
      }, f2.prototype.idivn = function(s2) {
        var u2 = s2 < 0;
        u2 && (s2 = -s2), r(s2 <= 67108863);
        for (var c2 = 0, b5 = this.length - 1;b5 >= 0; b5--) {
          var l3 = (this.words[b5] | 0) + c2 * 67108864;
          this.words[b5] = l3 / s2 | 0, c2 = l3 % s2;
        }
        return this._strip(), u2 ? this.ineg() : this;
      }, f2.prototype.divn = function(s2) {
        return this.clone().idivn(s2);
      }, f2.prototype.egcd = function(s2) {
        r(s2.negative === 0), r(!s2.isZero());
        var u2 = this, c2 = s2.clone();
        u2.negative !== 0 ? u2 = u2.umod(s2) : u2 = u2.clone();
        for (var b5 = new f2(1), l3 = new f2(0), n = new f2(0), d3 = new f2(1), w3 = 0;u2.isEven() && c2.isEven(); )
          u2.iushrn(1), c2.iushrn(1), ++w3;
        for (var g3 = c2.clone(), _3 = u2.clone();!u2.isZero(); ) {
          for (var A3 = 0, R2 = 1;(u2.words[0] & R2) === 0 && A3 < 26; ++A3, R2 <<= 1)
            ;
          if (A3 > 0)
            for (u2.iushrn(A3);A3-- > 0; )
              (b5.isOdd() || l3.isOdd()) && (b5.iadd(g3), l3.isub(_3)), b5.iushrn(1), l3.iushrn(1);
          for (var I4 = 0, Me = 1;(c2.words[0] & Me) === 0 && I4 < 26; ++I4, Me <<= 1)
            ;
          if (I4 > 0)
            for (c2.iushrn(I4);I4-- > 0; )
              (n.isOdd() || d3.isOdd()) && (n.iadd(g3), d3.isub(_3)), n.iushrn(1), d3.iushrn(1);
          u2.cmp(c2) >= 0 ? (u2.isub(c2), b5.isub(n), l3.isub(d3)) : (c2.isub(u2), n.isub(b5), d3.isub(l3));
        }
        return { a: n, b: d3, gcd: c2.iushln(w3) };
      }, f2.prototype._invmp = function(s2) {
        r(s2.negative === 0), r(!s2.isZero());
        var u2 = this, c2 = s2.clone();
        u2.negative !== 0 ? u2 = u2.umod(s2) : u2 = u2.clone();
        for (var b5 = new f2(1), l3 = new f2(0), n = c2.clone();u2.cmpn(1) > 0 && c2.cmpn(1) > 0; ) {
          for (var d3 = 0, w3 = 1;(u2.words[0] & w3) === 0 && d3 < 26; ++d3, w3 <<= 1)
            ;
          if (d3 > 0)
            for (u2.iushrn(d3);d3-- > 0; )
              b5.isOdd() && b5.iadd(n), b5.iushrn(1);
          for (var g3 = 0, _3 = 1;(c2.words[0] & _3) === 0 && g3 < 26; ++g3, _3 <<= 1)
            ;
          if (g3 > 0)
            for (c2.iushrn(g3);g3-- > 0; )
              l3.isOdd() && l3.iadd(n), l3.iushrn(1);
          u2.cmp(c2) >= 0 ? (u2.isub(c2), b5.isub(l3)) : (c2.isub(u2), l3.isub(b5));
        }
        var A3;
        return u2.cmpn(1) === 0 ? A3 = b5 : A3 = l3, A3.cmpn(0) < 0 && A3.iadd(s2), A3;
      }, f2.prototype.gcd = function(s2) {
        if (this.isZero())
          return s2.abs();
        if (s2.isZero())
          return this.abs();
        var u2 = this.clone(), c2 = s2.clone();
        u2.negative = 0, c2.negative = 0;
        for (var b5 = 0;u2.isEven() && c2.isEven(); b5++)
          u2.iushrn(1), c2.iushrn(1);
        do {
          for (;u2.isEven(); )
            u2.iushrn(1);
          for (;c2.isEven(); )
            c2.iushrn(1);
          var l3 = u2.cmp(c2);
          if (l3 < 0) {
            var n = u2;
            u2 = c2, c2 = n;
          } else if (l3 === 0 || c2.cmpn(1) === 0)
            break;
          u2.isub(c2);
        } while (true);
        return c2.iushln(b5);
      }, f2.prototype.invm = function(s2) {
        return this.egcd(s2).a.umod(s2);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(s2) {
        return this.words[0] & s2;
      }, f2.prototype.bincn = function(s2) {
        r(typeof s2 == "number");
        var u2 = s2 % 26, c2 = (s2 - u2) / 26, b5 = 1 << u2;
        if (this.length <= c2)
          return this._expand(c2 + 1), this.words[c2] |= b5, this;
        for (var l3 = b5, n = c2;l3 !== 0 && n < this.length; n++) {
          var d3 = this.words[n] | 0;
          d3 += l3, l3 = d3 >>> 26, d3 &= 67108863, this.words[n] = d3;
        }
        return l3 !== 0 && (this.words[n] = l3, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(s2) {
        var u2 = s2 < 0;
        if (this.negative !== 0 && !u2)
          return -1;
        if (this.negative === 0 && u2)
          return 1;
        this._strip();
        var c2;
        if (this.length > 1)
          c2 = 1;
        else {
          u2 && (s2 = -s2), r(s2 <= 67108863, "Number is too big");
          var b5 = this.words[0] | 0;
          c2 = b5 === s2 ? 0 : b5 < s2 ? -1 : 1;
        }
        return this.negative !== 0 ? -c2 | 0 : c2;
      }, f2.prototype.cmp = function(s2) {
        if (this.negative !== 0 && s2.negative === 0)
          return -1;
        if (this.negative === 0 && s2.negative !== 0)
          return 1;
        var u2 = this.ucmp(s2);
        return this.negative !== 0 ? -u2 | 0 : u2;
      }, f2.prototype.ucmp = function(s2) {
        if (this.length > s2.length)
          return 1;
        if (this.length < s2.length)
          return -1;
        for (var u2 = 0, c2 = this.length - 1;c2 >= 0; c2--) {
          var b5 = this.words[c2] | 0, l3 = s2.words[c2] | 0;
          if (b5 !== l3) {
            b5 < l3 ? u2 = -1 : b5 > l3 && (u2 = 1);
            break;
          }
        }
        return u2;
      }, f2.prototype.gtn = function(s2) {
        return this.cmpn(s2) === 1;
      }, f2.prototype.gt = function(s2) {
        return this.cmp(s2) === 1;
      }, f2.prototype.gten = function(s2) {
        return this.cmpn(s2) >= 0;
      }, f2.prototype.gte = function(s2) {
        return this.cmp(s2) >= 0;
      }, f2.prototype.ltn = function(s2) {
        return this.cmpn(s2) === -1;
      }, f2.prototype.lt = function(s2) {
        return this.cmp(s2) === -1;
      }, f2.prototype.lten = function(s2) {
        return this.cmpn(s2) <= 0;
      }, f2.prototype.lte = function(s2) {
        return this.cmp(s2) <= 0;
      }, f2.prototype.eqn = function(s2) {
        return this.cmpn(s2) === 0;
      }, f2.prototype.eq = function(s2) {
        return this.cmp(s2) === 0;
      }, f2.red = function(s2) {
        return new i(s2);
      }, f2.prototype.toRed = function(s2) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), s2.convertTo(this)._forceRed(s2);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(s2) {
        return this.red = s2, this;
      }, f2.prototype.forceRed = function(s2) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(s2);
      }, f2.prototype.redAdd = function(s2) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, s2);
      }, f2.prototype.redIAdd = function(s2) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, s2);
      }, f2.prototype.redSub = function(s2) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, s2);
      }, f2.prototype.redISub = function(s2) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, s2);
      }, f2.prototype.redShl = function(s2) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, s2);
      }, f2.prototype.redMul = function(s2) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s2), this.red.mul(this, s2);
      }, f2.prototype.redIMul = function(s2) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, s2), this.red.imul(this, s2);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(s2) {
        return r(this.red && !s2.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, s2);
      };
      var Re = { k256: null, p224: null, p192: null, p25519: null };
      function Ee(h3, s2) {
        this.name = h3, this.p = new f2(s2, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ee.prototype._tmp = function() {
        var s2 = new f2(null);
        return s2.words = new Array(Math.ceil(this.n / 13)), s2;
      }, Ee.prototype.ireduce = function(s2) {
        var u2 = s2, c2;
        do
          this.split(u2, this.tmp), u2 = this.imulK(u2), u2 = u2.iadd(this.tmp), c2 = u2.bitLength();
        while (c2 > this.n);
        var b5 = c2 < this.n ? -1 : u2.ucmp(this.p);
        return b5 === 0 ? (u2.words[0] = 0, u2.length = 1) : b5 > 0 ? u2.isub(this.p) : u2.strip !== undefined ? u2.strip() : u2._strip(), u2;
      }, Ee.prototype.split = function(s2, u2) {
        s2.iushrn(this.n, 0, u2);
      }, Ee.prototype.imulK = function(s2) {
        return s2.imul(this.k);
      };
      function Ae2() {
        Ee.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(Ae2, Ee), Ae2.prototype.split = function(s2, u2) {
        for (var c2 = 4194303, b5 = Math.min(s2.length, 9), l3 = 0;l3 < b5; l3++)
          u2.words[l3] = s2.words[l3];
        if (u2.length = b5, s2.length <= 9) {
          s2.words[0] = 0, s2.length = 1;
          return;
        }
        var n = s2.words[9];
        for (u2.words[u2.length++] = n & c2, l3 = 10;l3 < s2.length; l3++) {
          var d3 = s2.words[l3] | 0;
          s2.words[l3 - 10] = (d3 & c2) << 4 | n >>> 22, n = d3;
        }
        n >>>= 22, s2.words[l3 - 10] = n, n === 0 && s2.length > 10 ? s2.length -= 10 : s2.length -= 9;
      }, Ae2.prototype.imulK = function(s2) {
        s2.words[s2.length] = 0, s2.words[s2.length + 1] = 0, s2.length += 2;
        for (var u2 = 0, c2 = 0;c2 < s2.length; c2++) {
          var b5 = s2.words[c2] | 0;
          u2 += b5 * 977, s2.words[c2] = u2 & 67108863, u2 = b5 * 64 + (u2 / 67108864 | 0);
        }
        return s2.words[s2.length - 1] === 0 && (s2.length--, s2.words[s2.length - 1] === 0 && s2.length--), s2;
      };
      function P2() {
        Ee.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(P2, Ee);
      function Se3() {
        Ee.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Se3, Ee);
      function v2() {
        Ee.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(v2, Ee), v2.prototype.imulK = function(s2) {
        for (var u2 = 0, c2 = 0;c2 < s2.length; c2++) {
          var b5 = (s2.words[c2] | 0) * 19 + u2, l3 = b5 & 67108863;
          b5 >>>= 26, s2.words[c2] = l3, u2 = b5;
        }
        return u2 !== 0 && (s2.words[s2.length++] = u2), s2;
      }, f2._prime = function(s2) {
        if (Re[s2])
          return Re[s2];
        var u2;
        if (s2 === "k256")
          u2 = new Ae2;
        else if (s2 === "p224")
          u2 = new P2;
        else if (s2 === "p192")
          u2 = new Se3;
        else if (s2 === "p25519")
          u2 = new v2;
        else
          throw new Error("Unknown prime " + s2);
        return Re[s2] = u2, u2;
      };
      function i(h3) {
        if (typeof h3 == "string") {
          var s2 = f2._prime(h3);
          this.m = s2.p, this.prime = s2;
        } else
          r(h3.gtn(1), "modulus must be greater than 1"), this.m = h3, this.prime = null;
      }
      i.prototype._verify1 = function(s2) {
        r(s2.negative === 0, "red works only with positives"), r(s2.red, "red works only with red numbers");
      }, i.prototype._verify2 = function(s2, u2) {
        r((s2.negative | u2.negative) === 0, "red works only with positives"), r(s2.red && s2.red === u2.red, "red works only with red numbers");
      }, i.prototype.imod = function(s2) {
        return this.prime ? this.prime.ireduce(s2)._forceRed(this) : (x3(s2, s2.umod(this.m)._forceRed(this)), s2);
      }, i.prototype.neg = function(s2) {
        return s2.isZero() ? s2.clone() : this.m.sub(s2)._forceRed(this);
      }, i.prototype.add = function(s2, u2) {
        this._verify2(s2, u2);
        var c2 = s2.add(u2);
        return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2._forceRed(this);
      }, i.prototype.iadd = function(s2, u2) {
        this._verify2(s2, u2);
        var c2 = s2.iadd(u2);
        return c2.cmp(this.m) >= 0 && c2.isub(this.m), c2;
      }, i.prototype.sub = function(s2, u2) {
        this._verify2(s2, u2);
        var c2 = s2.sub(u2);
        return c2.cmpn(0) < 0 && c2.iadd(this.m), c2._forceRed(this);
      }, i.prototype.isub = function(s2, u2) {
        this._verify2(s2, u2);
        var c2 = s2.isub(u2);
        return c2.cmpn(0) < 0 && c2.iadd(this.m), c2;
      }, i.prototype.shl = function(s2, u2) {
        return this._verify1(s2), this.imod(s2.ushln(u2));
      }, i.prototype.imul = function(s2, u2) {
        return this._verify2(s2, u2), this.imod(s2.imul(u2));
      }, i.prototype.mul = function(s2, u2) {
        return this._verify2(s2, u2), this.imod(s2.mul(u2));
      }, i.prototype.isqr = function(s2) {
        return this.imul(s2, s2.clone());
      }, i.prototype.sqr = function(s2) {
        return this.mul(s2, s2);
      }, i.prototype.sqrt = function(s2) {
        if (s2.isZero())
          return s2.clone();
        var u2 = this.m.andln(3);
        if (r(u2 % 2 === 1), u2 === 3) {
          var c2 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(s2, c2);
        }
        for (var b5 = this.m.subn(1), l3 = 0;!b5.isZero() && b5.andln(1) === 0; )
          l3++, b5.iushrn(1);
        r(!b5.isZero());
        var n = new f2(1).toRed(this), d3 = n.redNeg(), w3 = this.m.subn(1).iushrn(1), g3 = this.m.bitLength();
        for (g3 = new f2(2 * g3 * g3).toRed(this);this.pow(g3, w3).cmp(d3) !== 0; )
          g3.redIAdd(d3);
        for (var _3 = this.pow(g3, b5), A3 = this.pow(s2, b5.addn(1).iushrn(1)), R2 = this.pow(s2, b5), I4 = l3;R2.cmp(n) !== 0; ) {
          for (var Me = R2, k4 = 0;Me.cmp(n) !== 0; k4++)
            Me = Me.redSqr();
          r(k4 < I4);
          var D2 = this.pow(_3, new f2(1).iushln(I4 - k4 - 1));
          A3 = A3.redMul(D2), _3 = D2.redSqr(), R2 = R2.redMul(_3), I4 = k4;
        }
        return A3;
      }, i.prototype.invm = function(s2) {
        var u2 = s2._invmp(this.m);
        return u2.negative !== 0 ? (u2.negative = 0, this.imod(u2).redNeg()) : this.imod(u2);
      }, i.prototype.pow = function(s2, u2) {
        if (u2.isZero())
          return new f2(1).toRed(this);
        if (u2.cmpn(1) === 0)
          return s2.clone();
        var c2 = 4, b5 = new Array(1 << c2);
        b5[0] = new f2(1).toRed(this), b5[1] = s2;
        for (var l3 = 2;l3 < b5.length; l3++)
          b5[l3] = this.mul(b5[l3 - 1], s2);
        var n = b5[0], d3 = 0, w3 = 0, g3 = u2.bitLength() % 26;
        for (g3 === 0 && (g3 = 26), l3 = u2.length - 1;l3 >= 0; l3--) {
          for (var _3 = u2.words[l3], A3 = g3 - 1;A3 >= 0; A3--) {
            var R2 = _3 >> A3 & 1;
            if (n !== b5[0] && (n = this.sqr(n)), R2 === 0 && d3 === 0) {
              w3 = 0;
              continue;
            }
            d3 <<= 1, d3 |= R2, w3++, !(w3 !== c2 && (l3 !== 0 || A3 !== 0)) && (n = this.mul(n, b5[d3]), w3 = 0, d3 = 0);
          }
          g3 = 26;
        }
        return n;
      }, i.prototype.convertTo = function(s2) {
        var u2 = s2.umod(this.m);
        return u2 === s2 ? u2.clone() : u2;
      }, i.prototype.convertFrom = function(s2) {
        var u2 = s2.clone();
        return u2.red = null, u2;
      }, f2.mont = function(s2) {
        return new a3(s2);
      };
      function a3(h3) {
        i.call(this, h3), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(a3, i), a3.prototype.convertTo = function(s2) {
        return this.imod(s2.ushln(this.shift));
      }, a3.prototype.convertFrom = function(s2) {
        var u2 = this.imod(s2.mul(this.rinv));
        return u2.red = null, u2;
      }, a3.prototype.imul = function(s2, u2) {
        if (s2.isZero() || u2.isZero())
          return s2.words[0] = 0, s2.length = 1, s2;
        var c2 = s2.imul(u2), b5 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l3 = c2.isub(b5).iushrn(this.shift), n = l3;
        return l3.cmp(this.m) >= 0 ? n = l3.isub(this.m) : l3.cmpn(0) < 0 && (n = l3.iadd(this.m)), n._forceRed(this);
      }, a3.prototype.mul = function(s2, u2) {
        if (s2.isZero() || u2.isZero())
          return new f2(0)._forceRed(this);
        var c2 = s2.mul(u2), b5 = c2.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), l3 = c2.isub(b5).iushrn(this.shift), n = l3;
        return l3.cmp(this.m) >= 0 ? n = l3.isub(this.m) : l3.cmpn(0) < 0 && (n = l3.iadd(this.m)), n._forceRed(this);
      }, a3.prototype.invm = function(s2) {
        var u2 = this.imod(s2._invmp(this.m).mul(this.r2));
        return u2._forceRed(this);
      };
    })(typeof kl > "u" || kl, n2);
  });
  Ks2 = T((yk, o2) => {
    var Rf = Ws2(), oA = on();
    function sA(t) {
      var e = f2(t), r = e.toRed(Rf.mont(t.modulus)).redPow(new Rf(t.publicExponent)).fromRed();
      return { blinder: r, unblinder: e.invm(t.modulus) };
    }
    function f2(t) {
      var e = t.modulus.byteLength(), r;
      do
        r = new Rf(oA(e));
      while (r.cmp(t.modulus) >= 0 || !r.umod(t.prime1) || !r.umod(t.prime2));
      return r;
    }
    function a22(t, e) {
      var r = sA(e), o3 = e.modulus.byteLength(), f3 = new Rf(t).mul(r.blinder).umod(e.modulus), p3 = f3.toRed(Rf.mont(e.prime1)), m4 = f3.toRed(Rf.mont(e.prime2)), y3 = e.coefficient, M4 = e.prime1, x3 = e.prime2, S2 = p3.redPow(e.exponent1).fromRed(), E6 = m4.redPow(e.exponent2).fromRed(), B3 = S2.isub(E6).imul(y3).umod(M4).imul(x3);
      return E6.iadd(B3).imul(r.unblinder).umod(e.modulus).toArrayLike(Buffer, "be", o3);
    }
    a22.getr = f2;
    o2.exports = a22;
  });
  s2 = T((wk, hA) => {
    hA.exports = { name: "elliptic", version: "6.5.4", description: "EC cryptography", main: "lib/elliptic.js", files: ["lib"], scripts: { lint: "eslint lib test", "lint:fix": "npm run lint -- --fix", unit: "istanbul test _mocha --reporter=spec test/index.js", test: "npm run lint && npm run unit", version: "grunt dist && git add dist/" }, repository: { type: "git", url: "git@github.com:indutny/elliptic" }, keywords: ["EC", "Elliptic", "curve", "Cryptography"], author: "Fedor Indutny <fedor@indutny.com>", license: "MIT", bugs: { url: "https://github.com/indutny/elliptic/issues" }, homepage: "https://github.com/indutny/elliptic", devDependencies: { brfs: "^2.0.2", coveralls: "^3.1.0", eslint: "^7.6.0", grunt: "^1.2.1", "grunt-browserify": "^5.3.0", "grunt-cli": "^1.3.2", "grunt-contrib-connect": "^3.0.0", "grunt-contrib-copy": "^1.0.0", "grunt-contrib-uglify": "^5.0.0", "grunt-mocha-istanbul": "^5.0.2", "grunt-saucelabs": "^9.0.1", istanbul: "^0.4.5", mocha: "^8.0.1" }, dependencies: { "bn.js": "^4.11.9", brorand: "^1.1.0", "hash.js": "^1.0.0", "hmac-drbg": "^1.0.1", inherits: "^2.0.4", "minimalistic-assert": "^1.0.1", "minimalistic-crypto-utils": "^1.0.1" } };
  });
  ri2 = T((h22, Ll) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o2(v2, i) {
        v2.super_ = i;
        var a3 = function() {};
        a3.prototype = i.prototype, v2.prototype = new a3, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a3) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v2 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {}
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f2.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f2.prototype._init = function(i, a3, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h3);
        if (typeof i == "object")
          return this._initArray(i, a3, h3);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a3, s3), h3 === "le" && this._initArray(this.toArray(), a3, h3)));
      }, f2.prototype._initNumber = function(i, a3, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a3, h3);
      }, f2.prototype._initArray = function(i, a3, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2, c2, b5 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u2 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        else if (h3 === "le")
          for (s3 = 0, u2 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        return this.strip();
      };
      function m4(v2, i) {
        var a3 = v2.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y3(v2, i, a3) {
        var h3 = m4(v2, a3);
        return a3 - 1 >= i && (h3 |= m4(v2, a3 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a3, h3) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2 = 0, c2 = 0, b5;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        }
        this.strip();
      };
      function M4(v2, i, a3, h3) {
        for (var s3 = 0, u2 = Math.min(v2.length, a3), c2 = i;c2 < u2; c2++) {
          var b5 = v2.charCodeAt(c2) - 48;
          s3 *= h3, b5 >= 49 ? s3 += b5 - 49 + 10 : b5 >= 17 ? s3 += b5 - 17 + 10 : s3 += b5;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a3, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u2 = 1;u2 <= 67108863; u2 *= a3)
          s3++;
        s3--, u2 = u2 / a3 | 0;
        for (var c2 = i.length - h3, b5 = c2 % s3, l3 = Math.min(c2, c2 - b5) + h3, n = 0, d3 = h3;d3 < l3; d3 += s3)
          n = M4(i, d3, d3 + s3, a3), this.imuln(u2), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b5 !== 0) {
          var w3 = 1;
          for (n = M4(i, d3, i.length, a3), d3 = 0;d3 < b5; d3++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u2 = 0, c2 = 0;c2 < this.length; c2++) {
            var b5 = this.words[c2], l3 = ((b5 << s3 | u2) & 16777215).toString(16);
            u2 = b5 >>> 24 - s3 & 16777215, u2 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l3.length] + l3 + h3 : h3 = l3 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u2 !== 0 && (h3 = u2.toString(16) + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d3 = E6[i];
          h3 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g3 = w3.modn(d3).toString(i);
            w3 = w3.idivn(d3), w3.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f2.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f2.prototype.toArrayLike = function(i, a3, h3) {
        var s3 = this.byteLength(), u2 = h3 || Math.max(1, s3);
        r(s3 <= u2, "byte array longer than desired length"), r(u2 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b5 = new i(u2), l3, n, d3 = this.clone();
        if (c2) {
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[n] = l3;
          for (;n < u2; n++)
            b5[n] = 0;
        } else {
          for (n = 0;n < u2 - s3; n++)
            b5[n] = 0;
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[u2 - n - 1] = l3;
        }
        return b5;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a3 = i, h3 = 0;
        return a3 >= 4096 && (h3 += 13, a3 >>>= 13), a3 >= 64 && (h3 += 7, a3 >>>= 7), a3 >= 8 && (h3 += 4, a3 >>>= 4), a3 >= 2 && (h3 += 2, a3 >>>= 2), h3 + a3;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h3 = 0;
        return (a3 & 8191) === 0 && (h3 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h3 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h3 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h3 += 2, a3 >>>= 2), (a3 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v2) {
        for (var i = new Array(v2.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h3 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v2.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h3 = this._zeroBits(this.words[a3]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h3 = 0;h3 < a3.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a3, h3;
        this.length > i.length ? (a3 = this, h3 = i) : (a3 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a3.words[s3] ^ h3.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a3), h3 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a3 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u2 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        for (;u2 !== 0 && c2 < h3.length; c2++)
          a3 = (h3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        if (this.length = h3.length, u2 !== 0)
          this.words[this.length] = u2, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u2;
        h3 > 0 ? (s3 = this, u2 = i) : (s3 = i, u2 = this);
        for (var c2 = 0, b5 = 0;b5 < u2.length; b5++)
          a3 = (s3.words[b5] | 0) - (u2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        for (;c2 !== 0 && b5 < s3.length; b5++)
          a3 = (s3.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        if (c2 === 0 && b5 < s3.length && s3 !== this)
          for (;b5 < s3.length; b5++)
            this.words[b5] = s3.words[b5];
        return this.length = Math.max(this.length, b5), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative;
        var h3 = v2.length + i.length | 0;
        a3.length = h3, h3 = h3 - 1 | 0;
        var s3 = v2.words[0] | 0, u2 = i.words[0] | 0, c2 = s3 * u2, b5 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b5;
        for (var n = 1;n < h3; n++) {
          for (var d3 = l3 >>> 26, w3 = l3 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v2.length + 1);_3 <= g3; _3++) {
            var A3 = n - _3 | 0;
            s3 = v2.words[A3] | 0, u2 = i.words[_3] | 0, c2 = s3 * u2 + w3, d3 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d3 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L3 = function(i, a3, h3) {
        var s3 = i.words, u2 = a3.words, c2 = h3.words, b5 = 0, l3, n, d3, w3 = s3[0] | 0, g3 = w3 & 8191, _3 = w3 >>> 13, A3 = s3[1] | 0, R2 = A3 & 8191, I4 = A3 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt3 = s3[3] | 0, C3 = nt3 & 8191, O2 = nt3 >>> 13, vt = s3[4] | 0, F3 = vt & 8191, U2 = vt >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt3 = s3[6] | 0, W = mt3 & 8191, K4 = mt3 >>> 13, gt3 = s3[7] | 0, j4 = gt3 & 8191, Z2 = gt3 >>> 13, yt2 = s3[8] | 0, V4 = yt2 & 8191, $ = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u2[0] | 0, X3 = Mt & 8191, J3 = Mt >>> 13, _t3 = u2[1] | 0, Q4 = _t3 & 8191, ee = _t3 >>> 13, xt3 = u2[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St = u2[3] | 0, ie = St & 8191, ne = St >>> 13, Et2 = u2[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At4 = u2[5] | 0, oe3 = At4 & 8191, se2 = At4 >>> 13, Rt = u2[6] | 0, he = Rt & 8191, ue4 = Rt >>> 13, Bt = u2[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt2 = u2[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u2[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a3.negative, h3.length = 19, l3 = Math.imul(g3, X3), n = Math.imul(g3, J3), n = n + Math.imul(_3, X3) | 0, d3 = Math.imul(_3, J3);
        var ft = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l3 = Math.imul(R2, X3), n = Math.imul(R2, J3), n = n + Math.imul(I4, X3) | 0, d3 = Math.imul(I4, J3), l3 = l3 + Math.imul(g3, Q4) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q4) | 0, d3 = d3 + Math.imul(_3, ee) | 0;
        var Be = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X3), n = Math.imul(k4, J3), n = n + Math.imul(D2, X3) | 0, d3 = Math.imul(D2, J3), l3 = l3 + Math.imul(R2, Q4) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I4, Q4) | 0, d3 = d3 + Math.imul(I4, ee) | 0, l3 = l3 + Math.imul(g3, te2) | 0, n = n + Math.imul(g3, re2) | 0, n = n + Math.imul(_3, te2) | 0, d3 = d3 + Math.imul(_3, re2) | 0;
        var qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C3, X3), n = Math.imul(C3, J3), n = n + Math.imul(O2, X3) | 0, d3 = Math.imul(O2, J3), l3 = l3 + Math.imul(k4, Q4) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q4) | 0, d3 = d3 + Math.imul(D2, ee) | 0, l3 = l3 + Math.imul(R2, te2) | 0, n = n + Math.imul(R2, re2) | 0, n = n + Math.imul(I4, te2) | 0, d3 = d3 + Math.imul(I4, re2) | 0, l3 = l3 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d3 = d3 + Math.imul(_3, ne) | 0;
        var ze = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F3, X3), n = Math.imul(F3, J3), n = n + Math.imul(U2, X3) | 0, d3 = Math.imul(U2, J3), l3 = l3 + Math.imul(C3, Q4) | 0, n = n + Math.imul(C3, ee) | 0, n = n + Math.imul(O2, Q4) | 0, d3 = d3 + Math.imul(O2, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D2, te2) | 0, d3 = d3 + Math.imul(D2, re2) | 0, l3 = l3 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I4, ie) | 0, d3 = d3 + Math.imul(I4, ne) | 0, l3 = l3 + Math.imul(g3, fe3) | 0, n = n + Math.imul(g3, ae2) | 0, n = n + Math.imul(_3, fe3) | 0, d3 = d3 + Math.imul(_3, ae2) | 0;
        var He3 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X3), n = Math.imul(z, J3), n = n + Math.imul(H3, X3) | 0, d3 = Math.imul(H3, J3), l3 = l3 + Math.imul(F3, Q4) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U2, Q4) | 0, d3 = d3 + Math.imul(U2, ee) | 0, l3 = l3 + Math.imul(C3, te2) | 0, n = n + Math.imul(C3, re2) | 0, n = n + Math.imul(O2, te2) | 0, d3 = d3 + Math.imul(O2, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d3 = d3 + Math.imul(D2, ne) | 0, l3 = l3 + Math.imul(R2, fe3) | 0, n = n + Math.imul(R2, ae2) | 0, n = n + Math.imul(I4, fe3) | 0, d3 = d3 + Math.imul(I4, ae2) | 0, l3 = l3 + Math.imul(g3, oe3) | 0, n = n + Math.imul(g3, se2) | 0, n = n + Math.imul(_3, oe3) | 0, d3 = d3 + Math.imul(_3, se2) | 0;
        var We2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X3), n = Math.imul(W, J3), n = n + Math.imul(K4, X3) | 0, d3 = Math.imul(K4, J3), l3 = l3 + Math.imul(z, Q4) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q4) | 0, d3 = d3 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F3, te2) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U2, te2) | 0, d3 = d3 + Math.imul(U2, re2) | 0, l3 = l3 + Math.imul(C3, ie) | 0, n = n + Math.imul(C3, ne) | 0, n = n + Math.imul(O2, ie) | 0, d3 = d3 + Math.imul(O2, ne) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D2, fe3) | 0, d3 = d3 + Math.imul(D2, ae2) | 0, l3 = l3 + Math.imul(R2, oe3) | 0, n = n + Math.imul(R2, se2) | 0, n = n + Math.imul(I4, oe3) | 0, d3 = d3 + Math.imul(I4, se2) | 0, l3 = l3 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue4) | 0, n = n + Math.imul(_3, he) | 0, d3 = d3 + Math.imul(_3, ue4) | 0;
        var Ke2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j4, X3), n = Math.imul(j4, J3), n = n + Math.imul(Z2, X3) | 0, d3 = Math.imul(Z2, J3), l3 = l3 + Math.imul(W, Q4) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K4, Q4) | 0, d3 = d3 + Math.imul(K4, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d3 = d3 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U2, ie) | 0, d3 = d3 + Math.imul(U2, ne) | 0, l3 = l3 + Math.imul(C3, fe3) | 0, n = n + Math.imul(C3, ae2) | 0, n = n + Math.imul(O2, fe3) | 0, d3 = d3 + Math.imul(O2, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se2) | 0, n = n + Math.imul(D2, oe3) | 0, d3 = d3 + Math.imul(D2, se2) | 0, l3 = l3 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue4) | 0, n = n + Math.imul(I4, he) | 0, d3 = d3 + Math.imul(I4, ue4) | 0, l3 = l3 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d3 = d3 + Math.imul(_3, de) | 0;
        var je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V4, X3), n = Math.imul(V4, J3), n = n + Math.imul($, X3) | 0, d3 = Math.imul($, J3), l3 = l3 + Math.imul(j4, Q4) | 0, n = n + Math.imul(j4, ee) | 0, n = n + Math.imul(Z2, Q4) | 0, d3 = d3 + Math.imul(Z2, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K4, te2) | 0, d3 = d3 + Math.imul(K4, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H3, ie) | 0, d3 = d3 + Math.imul(H3, ne) | 0, l3 = l3 + Math.imul(F3, fe3) | 0, n = n + Math.imul(F3, ae2) | 0, n = n + Math.imul(U2, fe3) | 0, d3 = d3 + Math.imul(U2, ae2) | 0, l3 = l3 + Math.imul(C3, oe3) | 0, n = n + Math.imul(C3, se2) | 0, n = n + Math.imul(O2, oe3) | 0, d3 = d3 + Math.imul(O2, se2) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D2, he) | 0, d3 = d3 + Math.imul(D2, ue4) | 0, l3 = l3 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I4, le) | 0, d3 = d3 + Math.imul(I4, de) | 0, l3 = l3 + Math.imul(g3, ce3) | 0, n = n + Math.imul(g3, pe2) | 0, n = n + Math.imul(_3, ce3) | 0, d3 = d3 + Math.imul(_3, pe2) | 0;
        var Ze2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X3), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X3) | 0, d3 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V4, Q4) | 0, n = n + Math.imul(V4, ee) | 0, n = n + Math.imul($, Q4) | 0, d3 = d3 + Math.imul($, ee) | 0, l3 = l3 + Math.imul(j4, te2) | 0, n = n + Math.imul(j4, re2) | 0, n = n + Math.imul(Z2, te2) | 0, d3 = d3 + Math.imul(Z2, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K4, ie) | 0, d3 = d3 + Math.imul(K4, ne) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d3 = d3 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F3, oe3) | 0, n = n + Math.imul(F3, se2) | 0, n = n + Math.imul(U2, oe3) | 0, d3 = d3 + Math.imul(U2, se2) | 0, l3 = l3 + Math.imul(C3, he) | 0, n = n + Math.imul(C3, ue4) | 0, n = n + Math.imul(O2, he) | 0, d3 = d3 + Math.imul(O2, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d3 = d3 + Math.imul(D2, de) | 0, l3 = l3 + Math.imul(R2, ce3) | 0, n = n + Math.imul(R2, pe2) | 0, n = n + Math.imul(I4, ce3) | 0, d3 = d3 + Math.imul(I4, pe2) | 0, l3 = l3 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d3 = d3 + Math.imul(_3, be) | 0;
        var Ve = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q4), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q4) | 0, d3 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V4, te2) | 0, n = n + Math.imul(V4, re2) | 0, n = n + Math.imul($, te2) | 0, d3 = d3 + Math.imul($, re2) | 0, l3 = l3 + Math.imul(j4, ie) | 0, n = n + Math.imul(j4, ne) | 0, n = n + Math.imul(Z2, ie) | 0, d3 = d3 + Math.imul(Z2, ne) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K4, fe3) | 0, d3 = d3 + Math.imul(K4, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se2) | 0, n = n + Math.imul(H3, oe3) | 0, d3 = d3 + Math.imul(H3, se2) | 0, l3 = l3 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue4) | 0, n = n + Math.imul(U2, he) | 0, d3 = d3 + Math.imul(U2, ue4) | 0, l3 = l3 + Math.imul(C3, le) | 0, n = n + Math.imul(C3, de) | 0, n = n + Math.imul(O2, le) | 0, d3 = d3 + Math.imul(O2, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D2, ce3) | 0, d3 = d3 + Math.imul(D2, pe2) | 0, l3 = l3 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I4, ve) | 0, d3 = d3 + Math.imul(I4, be) | 0;
        var $e2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d3 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V4, ie) | 0, n = n + Math.imul(V4, ne) | 0, n = n + Math.imul($, ie) | 0, d3 = d3 + Math.imul($, ne) | 0, l3 = l3 + Math.imul(j4, fe3) | 0, n = n + Math.imul(j4, ae2) | 0, n = n + Math.imul(Z2, fe3) | 0, d3 = d3 + Math.imul(Z2, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se2) | 0, n = n + Math.imul(K4, oe3) | 0, d3 = d3 + Math.imul(K4, se2) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d3 = d3 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U2, le) | 0, d3 = d3 + Math.imul(U2, de) | 0, l3 = l3 + Math.imul(C3, ce3) | 0, n = n + Math.imul(C3, pe2) | 0, n = n + Math.imul(O2, ce3) | 0, d3 = d3 + Math.imul(O2, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d3 = d3 + Math.imul(D2, be) | 0;
        var Ge = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y3, ie) | 0, d3 = Math.imul(Y3, ne), l3 = l3 + Math.imul(V4, fe3) | 0, n = n + Math.imul(V4, ae2) | 0, n = n + Math.imul($, fe3) | 0, d3 = d3 + Math.imul($, ae2) | 0, l3 = l3 + Math.imul(j4, oe3) | 0, n = n + Math.imul(j4, se2) | 0, n = n + Math.imul(Z2, oe3) | 0, d3 = d3 + Math.imul(Z2, se2) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K4, he) | 0, d3 = d3 + Math.imul(K4, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d3 = d3 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F3, ce3) | 0, n = n + Math.imul(F3, pe2) | 0, n = n + Math.imul(U2, ce3) | 0, d3 = d3 + Math.imul(U2, pe2) | 0, l3 = l3 + Math.imul(C3, ve) | 0, n = n + Math.imul(C3, be) | 0, n = n + Math.imul(O2, ve) | 0, d3 = d3 + Math.imul(O2, be) | 0;
        var Ye = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d3 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V4, oe3) | 0, n = n + Math.imul(V4, se2) | 0, n = n + Math.imul($, oe3) | 0, d3 = d3 + Math.imul($, se2) | 0, l3 = l3 + Math.imul(j4, he) | 0, n = n + Math.imul(j4, ue4) | 0, n = n + Math.imul(Z2, he) | 0, d3 = d3 + Math.imul(Z2, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K4, le) | 0, d3 = d3 + Math.imul(K4, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d3 = d3 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U2, ve) | 0, d3 = d3 + Math.imul(U2, be) | 0;
        var Xe = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se2), n = n + Math.imul(Y3, oe3) | 0, d3 = Math.imul(Y3, se2), l3 = l3 + Math.imul(V4, he) | 0, n = n + Math.imul(V4, ue4) | 0, n = n + Math.imul($, he) | 0, d3 = d3 + Math.imul($, ue4) | 0, l3 = l3 + Math.imul(j4, le) | 0, n = n + Math.imul(j4, de) | 0, n = n + Math.imul(Z2, le) | 0, d3 = d3 + Math.imul(Z2, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K4, ce3) | 0, d3 = d3 + Math.imul(K4, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H3, ve) | 0, d3 = d3 + Math.imul(H3, be) | 0;
        var Je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d3 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V4, le) | 0, n = n + Math.imul(V4, de) | 0, n = n + Math.imul($, le) | 0, d3 = d3 + Math.imul($, de) | 0, l3 = l3 + Math.imul(j4, ce3) | 0, n = n + Math.imul(j4, pe2) | 0, n = n + Math.imul(Z2, ce3) | 0, d3 = d3 + Math.imul(Z2, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K4, ve) | 0, d3 = d3 + Math.imul(K4, be) | 0;
        var Qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d3 = Math.imul(Y3, de), l3 = l3 + Math.imul(V4, ce3) | 0, n = n + Math.imul(V4, pe2) | 0, n = n + Math.imul($, ce3) | 0, d3 = d3 + Math.imul($, pe2) | 0, l3 = l3 + Math.imul(j4, ve) | 0, n = n + Math.imul(j4, be) | 0, n = n + Math.imul(Z2, ve) | 0, d3 = d3 + Math.imul(Z2, be) | 0;
        var et4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (et4 >>> 26) | 0, et4 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d3 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V4, ve) | 0, n = n + Math.imul(V4, be) | 0, n = n + Math.imul($, ve) | 0, d3 = d3 + Math.imul($, be) | 0;
        var tt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y3, ve) | 0, d3 = Math.imul(Y3, be);
        var rt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b5 = (d3 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et4, c2[17] = tt4, c2[18] = rt4, b5 !== 0 && (c2[19] = b5, h3.length++), h3;
      };
      Math.imul || (L3 = q);
      function ge(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative, a3.length = v2.length + i.length;
        for (var h3 = 0, s3 = 0, u2 = 0;u2 < a3.length - 1; u2++) {
          var c2 = s3;
          s3 = 0;
          for (var b5 = h3 & 67108863, l3 = Math.min(u2, i.length - 1), n = Math.max(0, u2 - v2.length + 1);n <= l3; n++) {
            var d3 = u2 - n, w3 = v2.words[d3] | 0, g3 = i.words[n] | 0, _3 = w3 * g3, A3 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A3 = A3 + b5 | 0, b5 = A3 & 67108863, c2 = c2 + (A3 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u2] = b5, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a3.words[u2] = h3 : a3.length--, a3.strip();
      }
      function _e3(v2, i, a3) {
        var h3 = new N5;
        return h3.mulp(v2, i, a3);
      }
      f2.prototype.mulTo = function(i, a3) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a3) : s3 < 63 ? h3 = q(this, i, a3) : s3 < 1024 ? h3 = ge(this, i, a3) : h3 = _e3(this, i, a3), h3;
      };
      function N5(v2, i) {
        this.x = v2, this.y = i;
      }
      N5.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h3, i);
        return a3;
      }, N5.prototype.revBin = function(i, a3, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u2 = 0;u2 < a3; u2++)
          s3 |= (i & 1) << a3 - u2 - 1, i >>= 1;
        return s3;
      }, N5.prototype.permute = function(i, a3, h3, s3, u2, c2) {
        for (var b5 = 0;b5 < c2; b5++)
          s3[b5] = a3[i[b5]], u2[b5] = h3[i[b5]];
      }, N5.prototype.transform = function(i, a3, h3, s3, u2, c2) {
        this.permute(c2, i, a3, h3, s3, u2);
        for (var b5 = 1;b5 < u2; b5 <<= 1)
          for (var l3 = b5 << 1, n = Math.cos(2 * Math.PI / l3), d3 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u2; w3 += l3)
            for (var g3 = n, _3 = d3, A3 = 0;A3 < b5; A3++) {
              var R2 = h3[w3 + A3], I4 = s3[w3 + A3], Me = h3[w3 + A3 + b5], k4 = s3[w3 + A3 + b5], D2 = g3 * Me - _3 * k4;
              k4 = g3 * k4 + _3 * Me, Me = D2, h3[w3 + A3] = R2 + Me, s3[w3 + A3] = I4 + k4, h3[w3 + A3 + b5] = R2 - Me, s3[w3 + A3 + b5] = I4 - k4, A3 !== l3 && (D2 = n * g3 - d3 * _3, _3 = n * _3 + d3 * g3, g3 = D2);
            }
      }, N5.prototype.guessLen13b = function(i, a3) {
        var h3 = Math.max(a3, i) | 1, s3 = h3 & 1, u2 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u2++;
        return 1 << u2 + 1 + s3;
      }, N5.prototype.conjugate = function(i, a3, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u2 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u2, u2 = a3[s3], a3[s3] = -a3[h3 - s3 - 1], a3[h3 - s3 - 1] = -u2;
          }
      }, N5.prototype.normalize13b = function(i, a3) {
        for (var h3 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u2 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h3;
          i[s3] = u2 & 67108863, u2 < 67108864 ? h3 = 0 : h3 = u2 / 67108864 | 0;
        }
        return i;
      }, N5.prototype.convert13b = function(i, a3, h3, s3) {
        for (var u2 = 0, c2 = 0;c2 < a3; c2++)
          u2 = u2 + (i[c2] | 0), h3[2 * c2] = u2 & 8191, u2 = u2 >>> 13, h3[2 * c2 + 1] = u2 & 8191, u2 = u2 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u2 === 0), r((u2 & -8192) === 0);
      }, N5.prototype.stub = function(i) {
        for (var a3 = new Array(i), h3 = 0;h3 < i; h3++)
          a3[h3] = 0;
        return a3;
      }, N5.prototype.mulp = function(i, a3, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u2 = this.makeRBT(s3), c2 = this.stub(s3), b5 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d3 = new Array(s3), w3 = new Array(s3), g3 = new Array(s3), _3 = h3.words;
        _3.length = s3, this.convert13b(i.words, i.length, b5, s3), this.convert13b(a3.words, a3.length, d3, s3), this.transform(b5, c2, l3, n, s3, u2), this.transform(d3, c2, w3, g3, s3, u2);
        for (var A3 = 0;A3 < s3; A3++) {
          var R2 = l3[A3] * w3[A3] - n[A3] * g3[A3];
          n[A3] = l3[A3] * g3[A3] + n[A3] * w3[A3], l3[A3] = R2;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _3, c2, s3, u2), this.conjugate(_3, c2, s3), this.normalize13b(_3, s3), h3.negative = i.negative ^ a3.negative, h3.length = i.length + a3.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f2.prototype.mulf = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u2 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u2 >>> 26, this.words[h3] = u2 & 67108863;
        }
        return a3 !== 0 && (this.words[h3] = a3, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a3.length)
          for (var u2 = h3.sqr();s3 < a3.length; s3++, u2 = u2.sqr())
            a3[s3] !== 0 && (h3 = h3.mul(u2));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u2;
        if (a3 !== 0) {
          var c2 = 0;
          for (u2 = 0;u2 < this.length; u2++) {
            var b5 = this.words[u2] & s3, l3 = (this.words[u2] | 0) - b5 << a3;
            this.words[u2] = l3 | c2, c2 = b5 >>> 26 - a3;
          }
          c2 && (this.words[u2] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u2 = this.length - 1;u2 >= 0; u2--)
            this.words[u2 + h3] = this.words[u2];
          for (u2 = 0;u2 < h3; u2++)
            this.words[u2] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a3, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u2 = i % 26, c2 = Math.min((i - u2) / 26, this.length), b5 = 67108863 ^ 67108863 >>> u2 << u2, l3 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d3 = 0;
        for (n = this.length - 1;n >= 0 && (d3 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d3 << 26 - u2 | w3 >>> u2, d3 = w3 & b5;
        }
        return l3 && d3 !== 0 && (l3.words[l3.length++] = d3), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a3, h3) {
        return r(this.negative === 0), this.iushrn(i, a3, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return false;
        var u2 = this.words[h3];
        return !!(u2 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a3 !== 0 && h3++, this.length = Math.min(h3, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a3, h3) {
        var s3 = i.length + h3, u2;
        this._expand(s3);
        var c2, b5 = 0;
        for (u2 = 0;u2 < i.length; u2++) {
          c2 = (this.words[u2 + h3] | 0) + b5;
          var l3 = (i.words[u2] | 0) * a3;
          c2 -= l3 & 67108863, b5 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u2 + h3] = c2 & 67108863;
        }
        for (;u2 < this.length - h3; u2++)
          c2 = (this.words[u2 + h3] | 0) + b5, b5 = c2 >> 26, this.words[u2 + h3] = c2 & 67108863;
        if (b5 === 0)
          return this.strip();
        for (r(b5 === -1), b5 = 0, u2 = 0;u2 < this.length; u2++)
          c2 = -(this.words[u2] | 0) + b5, b5 = c2 >> 26, this.words[u2] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a3) {
        var h3 = this.length - i.length, s3 = this.clone(), u2 = i, c2 = u2.words[u2.length - 1] | 0, b5 = this._countBits(c2);
        h3 = 26 - b5, h3 !== 0 && (u2 = u2.ushln(h3), s3.iushln(h3), c2 = u2.words[u2.length - 1] | 0);
        var l3 = s3.length - u2.length, n;
        if (a3 !== "mod") {
          n = new f2(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d3 = 0;d3 < n.length; d3++)
            n.words[d3] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u2, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g3 = l3 - 1;g3 >= 0; g3--) {
          var _3 = (s3.words[u2.length + g3] | 0) * 67108864 + (s3.words[u2.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s3._ishlnsubmul(u2, _3, g3);s3.negative !== 0; )
            _3--, s3.negative = 0, s3._ishlnsubmul(u2, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a3, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u2, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.iadd(i)), { div: s3, mod: u2 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.isub(i)), { div: c2.div, mod: u2 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h3 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u2 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u2 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a3 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a3 * 67108864;
          this.words[h3] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = new f2(0), b5 = new f2(1), l3 = 0;a3.isEven() && h3.isEven(); )
          a3.iushrn(1), h3.iushrn(1), ++l3;
        for (var n = h3.clone(), d3 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g3 = 1;(a3.words[0] & g3) === 0 && w3 < 26; ++w3, g3 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u2.isOdd()) && (s3.iadd(n), u2.isub(d3)), s3.iushrn(1), u2.iushrn(1);
          for (var _3 = 0, A3 = 1;(h3.words[0] & A3) === 0 && _3 < 26; ++_3, A3 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b5.isOdd()) && (c2.iadd(n), b5.isub(d3)), c2.iushrn(1), b5.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(c2), u2.isub(b5)) : (h3.isub(a3), c2.isub(s3), b5.isub(u2));
        }
        return { a: c2, b: b5, gcd: h3.iushln(l3) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = h3.clone();a3.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b5 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b5 < 26; ++b5, l3 <<= 1)
            ;
          if (b5 > 0)
            for (a3.iushrn(b5);b5-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d3 = 1;(h3.words[0] & d3) === 0 && n < 26; ++n, d3 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u2.isOdd() && u2.iadd(c2), u2.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(u2)) : (h3.isub(a3), u2.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u2, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h3 = i.clone();
        a3.negative = 0, h3.negative = 0;
        for (var s3 = 0;a3.isEven() && h3.isEven(); s3++)
          a3.iushrn(1), h3.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u2 = a3.cmp(h3);
          if (u2 < 0) {
            var c2 = a3;
            a3 = h3, h3 = c2;
          } else if (u2 === 0 || h3.cmpn(1) === 0)
            break;
          a3.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u2 = s3, c2 = h3;u2 !== 0 && c2 < this.length; c2++) {
          var b5 = this.words[c2] | 0;
          b5 += u2, u2 = b5 >>> 26, b5 &= 67108863, this.words[c2] = b5;
        }
        return u2 !== 0 && (this.words[c2] = u2, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u2 = i.words[h3] | 0;
          if (s3 !== u2) {
            s3 < u2 ? a3 = -1 : s3 > u2 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a3 = i, h3;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h3 = a3.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe, ye), xe.prototype.split = function(i, a3) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u2 = 0;u2 < s3; u2++)
          a3.words[u2] = i.words[u2];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h3, u2 = 10;u2 < i.length; u2++) {
          var b5 = i.words[u2] | 0;
          i.words[u2 - 10] = (b5 & h3) << 4 | c2 >>> 22, c2 = b5;
        }
        c2 >>>= 22, i.words[u2 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a3 += s3 * 977, i.words[h3] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a3, u2 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u2, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.add(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.iadd(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.sub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.isub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P2.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P2.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u2 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u2++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b5 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l3).cmp(b5) !== 0; )
          n.redIAdd(b5);
        for (var d3 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _3 = u2;g3.cmp(c2) !== 0; ) {
          for (var A3 = g3, R2 = 0;A3.cmp(c2) !== 0; R2++)
            A3 = A3.redSqr();
          r(R2 < _3);
          var I4 = this.pow(d3, new f2(1).iushln(_3 - R2 - 1));
          w3 = w3.redMul(I4), d3 = I4.redSqr(), g3 = g3.redMul(d3), _3 = R2;
        }
        return w3;
      }, P2.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P2.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f2(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u2 = 2;u2 < s3.length; u2++)
          s3[u2] = this.mul(s3[u2 - 1], i);
        var c2 = s3[0], b5 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u2 = a3.length - 1;u2 >= 0; u2--) {
          for (var d3 = a3.words[u2], w3 = n - 1;w3 >= 0; w3--) {
            var g3 = d3 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b5 === 0) {
              l3 = 0;
              continue;
            }
            b5 <<= 1, b5 |= g3, l3++, !(l3 !== h3 && (u2 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b5]), l3 = 0, b5 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P2.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f2.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v2) {
        P2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P2), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Ll > "u" || Ll, h22);
  });
  Nl = T((d22) => {
    var js2 = d22;
    function uA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t != "string") {
        for (var o2 = 0;o2 < t.length; o2++)
          r[o2] = t[o2] | 0;
        return r;
      }
      if (e === "hex") {
        t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t);
        for (var o2 = 0;o2 < t.length; o2 += 2)
          r.push(parseInt(t[o2] + t[o2 + 1], 16));
      } else
        for (var o2 = 0;o2 < t.length; o2++) {
          var f2 = t.charCodeAt(o2), p3 = f2 >> 8, m4 = f2 & 255;
          p3 ? r.push(p3, m4) : r.push(m4);
        }
      return r;
    }
    js2.toArray = uA;
    function u2(t) {
      return t.length === 1 ? "0" + t : t;
    }
    js2.zero2 = u2;
    function l22(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += u2(t[r].toString(16));
      return e;
    }
    js2.toHex = l22;
    js2.encode = function(e, r) {
      return r === "hex" ? l22(e) : e;
    };
  });
  or = T((c2) => {
    var Pr = c2, lA = ri2(), dA = ar2(), Zs2 = Nl();
    Pr.assert = dA;
    Pr.toArray = Zs2.toArray;
    Pr.zero2 = Zs2.zero2;
    Pr.toHex = Zs2.toHex;
    Pr.encode = Zs2.encode;
    function cA(t, e, r) {
      var o2 = new Array(Math.max(t.bitLength(), r) + 1);
      o2.fill(0);
      for (var f2 = 1 << e + 1, p3 = t.clone(), m4 = 0;m4 < o2.length; m4++) {
        var y3, M4 = p3.andln(f2 - 1);
        p3.isOdd() ? (M4 > (f2 >> 1) - 1 ? y3 = (f2 >> 1) - M4 : y3 = M4, p3.isubn(y3)) : y3 = 0, o2[m4] = y3, p3.iushrn(1);
      }
      return o2;
    }
    Pr.getNAF = cA;
    function pA(t, e) {
      var r = [[], []];
      t = t.clone(), e = e.clone();
      for (var o2 = 0, f2 = 0, p3;t.cmpn(-o2) > 0 || e.cmpn(-f2) > 0; ) {
        var m4 = t.andln(3) + o2 & 3, y3 = e.andln(3) + f2 & 3;
        m4 === 3 && (m4 = -1), y3 === 3 && (y3 = -1);
        var M4;
        (m4 & 1) === 0 ? M4 = 0 : (p3 = t.andln(7) + o2 & 7, (p3 === 3 || p3 === 5) && y3 === 2 ? M4 = -m4 : M4 = m4), r[0].push(M4);
        var x3;
        (y3 & 1) === 0 ? x3 = 0 : (p3 = e.andln(7) + f2 & 7, (p3 === 3 || p3 === 5) && m4 === 2 ? x3 = -y3 : x3 = y3), r[1].push(x3), 2 * o2 === M4 + 1 && (o2 = 1 - o2), 2 * f2 === x3 + 1 && (f2 = 1 - f2), t.iushrn(1), e.iushrn(1);
      }
      return r;
    }
    Pr.getJSF = pA;
    function vA(t, e, r) {
      var o2 = "_" + e;
      t.prototype[e] = function() {
        return this[o2] !== undefined ? this[o2] : this[o2] = r.call(this);
      };
    }
    Pr.cachedProperty = vA;
    function bA(t) {
      return typeof t == "string" ? Pr.toArray(t, "hex") : t;
    }
    Pr.parseBytes = bA;
    function mA(t) {
      return new lA(t, "hex", "le");
    }
    Pr.intFromLE = mA;
  });
  Oa = T((xk, p22) => {
    var Cn = ri2(), Ca = or(), Vs2 = Ca.getNAF, gA = Ca.getJSF, $s2 = Ca.assert;
    function Xi2(t, e) {
      this.type = t, this.p = new Cn(e.p, 16), this.red = e.prime ? Cn.red(e.prime) : Cn.mont(this.p), this.zero = new Cn(0).toRed(this.red), this.one = new Cn(1).toRed(this.red), this.two = new Cn(2).toRed(this.red), this.n = e.n && new Cn(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
      var r = this.n && this.p.div(this.n);
      !r || r.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = true, this.redN = this.n.toRed(this.red));
    }
    p22.exports = Xi2;
    Xi2.prototype.point = function() {
      throw new Error("Not implemented");
    };
    Xi2.prototype.validate = function() {
      throw new Error("Not implemented");
    };
    Xi2.prototype._fixedNafMul = function(e, r) {
      $s2(e.precomputed);
      var o2 = e._getDoubles(), f2 = Vs2(r, 1, this._bitLength), p3 = (1 << o2.step + 1) - (o2.step % 2 === 0 ? 2 : 1);
      p3 /= 3;
      var m4 = [], y3, M4;
      for (y3 = 0;y3 < f2.length; y3 += o2.step) {
        M4 = 0;
        for (var x3 = y3 + o2.step - 1;x3 >= y3; x3--)
          M4 = (M4 << 1) + f2[x3];
        m4.push(M4);
      }
      for (var S2 = this.jpoint(null, null, null), E6 = this.jpoint(null, null, null), B3 = p3;B3 > 0; B3--) {
        for (y3 = 0;y3 < m4.length; y3++)
          M4 = m4[y3], M4 === B3 ? E6 = E6.mixedAdd(o2.points[y3]) : M4 === -B3 && (E6 = E6.mixedAdd(o2.points[y3].neg()));
        S2 = S2.add(E6);
      }
      return S2.toP();
    };
    Xi2.prototype._wnafMul = function(e, r) {
      var o2 = 4, f2 = e._getNAFPoints(o2);
      o2 = f2.wnd;
      for (var p3 = f2.points, m4 = Vs2(r, o2, this._bitLength), y3 = this.jpoint(null, null, null), M4 = m4.length - 1;M4 >= 0; M4--) {
        for (var x3 = 0;M4 >= 0 && m4[M4] === 0; M4--)
          x3++;
        if (M4 >= 0 && x3++, y3 = y3.dblp(x3), M4 < 0)
          break;
        var S2 = m4[M4];
        $s2(S2 !== 0), e.type === "affine" ? S2 > 0 ? y3 = y3.mixedAdd(p3[S2 - 1 >> 1]) : y3 = y3.mixedAdd(p3[-S2 - 1 >> 1].neg()) : S2 > 0 ? y3 = y3.add(p3[S2 - 1 >> 1]) : y3 = y3.add(p3[-S2 - 1 >> 1].neg());
      }
      return e.type === "affine" ? y3.toP() : y3;
    };
    Xi2.prototype._wnafMulAdd = function(e, r, o2, f2, p3) {
      var m4 = this._wnafT1, y3 = this._wnafT2, M4 = this._wnafT3, x3 = 0, S2, E6, B3;
      for (S2 = 0;S2 < f2; S2++) {
        B3 = r[S2];
        var q = B3._getNAFPoints(e);
        m4[S2] = q.wnd, y3[S2] = q.points;
      }
      for (S2 = f2 - 1;S2 >= 1; S2 -= 2) {
        var L3 = S2 - 1, ge = S2;
        if (m4[L3] !== 1 || m4[ge] !== 1) {
          M4[L3] = Vs2(o2[L3], m4[L3], this._bitLength), M4[ge] = Vs2(o2[ge], m4[ge], this._bitLength), x3 = Math.max(M4[L3].length, x3), x3 = Math.max(M4[ge].length, x3);
          continue;
        }
        var _e3 = [r[L3], null, null, r[ge]];
        r[L3].y.cmp(r[ge].y) === 0 ? (_e3[1] = r[L3].add(r[ge]), _e3[2] = r[L3].toJ().mixedAdd(r[ge].neg())) : r[L3].y.cmp(r[ge].y.redNeg()) === 0 ? (_e3[1] = r[L3].toJ().mixedAdd(r[ge]), _e3[2] = r[L3].add(r[ge].neg())) : (_e3[1] = r[L3].toJ().mixedAdd(r[ge]), _e3[2] = r[L3].toJ().mixedAdd(r[ge].neg()));
        var N5 = [-3, -1, -5, -7, 0, 7, 5, 1, 3], we = gA(o2[L3], o2[ge]);
        for (x3 = Math.max(we[0].length, x3), M4[L3] = new Array(x3), M4[ge] = new Array(x3), E6 = 0;E6 < x3; E6++) {
          var ye = we[0][E6] | 0, xe = we[1][E6] | 0;
          M4[L3][E6] = N5[(ye + 1) * 3 + (xe + 1)], M4[ge][E6] = 0, y3[L3] = _e3;
        }
      }
      var Re = this.jpoint(null, null, null), Ee = this._wnafT4;
      for (S2 = x3;S2 >= 0; S2--) {
        for (var Ae2 = 0;S2 >= 0; ) {
          var P2 = true;
          for (E6 = 0;E6 < f2; E6++)
            Ee[E6] = M4[E6][S2] | 0, Ee[E6] !== 0 && (P2 = false);
          if (!P2)
            break;
          Ae2++, S2--;
        }
        if (S2 >= 0 && Ae2++, Re = Re.dblp(Ae2), S2 < 0)
          break;
        for (E6 = 0;E6 < f2; E6++) {
          var Se3 = Ee[E6];
          Se3 !== 0 && (Se3 > 0 ? B3 = y3[E6][Se3 - 1 >> 1] : Se3 < 0 && (B3 = y3[E6][-Se3 - 1 >> 1].neg()), B3.type === "affine" ? Re = Re.mixedAdd(B3) : Re = Re.add(B3));
        }
      }
      for (S2 = 0;S2 < f2; S2++)
        y3[S2] = null;
      return p3 ? Re : Re.toP();
    };
    function _r3(t, e) {
      this.curve = t, this.type = e, this.precomputed = null;
    }
    Xi2.BasePoint = _r3;
    _r3.prototype.eq = function() {
      throw new Error("Not implemented");
    };
    _r3.prototype.validate = function() {
      return this.curve.validate(this);
    };
    Xi2.prototype.decodePoint = function(e, r) {
      e = Ca.toArray(e, r);
      var o2 = this.p.byteLength();
      if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o2) {
        e[0] === 6 ? $s2(e[e.length - 1] % 2 === 0) : e[0] === 7 && $s2(e[e.length - 1] % 2 === 1);
        var f2 = this.point(e.slice(1, 1 + o2), e.slice(1 + o2, 1 + 2 * o2));
        return f2;
      } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o2)
        return this.pointFromX(e.slice(1, 1 + o2), e[0] === 3);
      throw new Error("Unknown point format");
    };
    _r3.prototype.encodeCompressed = function(e) {
      return this.encode(e, true);
    };
    _r3.prototype._encode = function(e) {
      var r = this.curve.p.byteLength(), o2 = this.getX().toArray("be", r);
      return e ? [this.getY().isEven() ? 2 : 3].concat(o2) : [4].concat(o2, this.getY().toArray("be", r));
    };
    _r3.prototype.encode = function(e, r) {
      return Ca.encode(this._encode(r), e);
    };
    _r3.prototype.precompute = function(e) {
      if (this.precomputed)
        return this;
      var r = { doubles: null, naf: null, beta: null };
      return r.naf = this._getNAFPoints(8), r.doubles = this._getDoubles(4, e), r.beta = this._getBeta(), this.precomputed = r, this;
    };
    _r3.prototype._hasDoubles = function(e) {
      if (!this.precomputed)
        return false;
      var r = this.precomputed.doubles;
      return r ? r.points.length >= Math.ceil((e.bitLength() + 1) / r.step) : false;
    };
    _r3.prototype._getDoubles = function(e, r) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      for (var o2 = [this], f2 = this, p3 = 0;p3 < r; p3 += e) {
        for (var m4 = 0;m4 < e; m4++)
          f2 = f2.dbl();
        o2.push(f2);
      }
      return { step: e, points: o2 };
    };
    _r3.prototype._getNAFPoints = function(e) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      for (var r = [this], o2 = (1 << e) - 1, f2 = o2 === 1 ? null : this.dbl(), p3 = 1;p3 < o2; p3++)
        r[p3] = r[p3 - 1].add(f2);
      return { wnd: e, points: r };
    };
    _r3.prototype._getBeta = function() {
      return null;
    };
    _r3.prototype.dblp = function(e) {
      for (var r = this, o2 = 0;o2 < e; o2++)
        r = r.dbl();
      return r;
    };
  });
  b22 = T((Sk, v2) => {
    var yA = or(), lt2 = ri2(), Dl = Ie(), Bf = Oa(), wA = yA.assert;
    function xr2(t) {
      Bf.call(this, "short", t), this.a = new lt2(t.a, 16).toRed(this.red), this.b = new lt2(t.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(t), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
    }
    Dl(xr2, Bf);
    v2.exports = xr2;
    xr2.prototype._getEndomorphism = function(e) {
      if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
        var r, o2;
        if (e.beta)
          r = new lt2(e.beta, 16).toRed(this.red);
        else {
          var f2 = this._getEndoRoots(this.p);
          r = f2[0].cmp(f2[1]) < 0 ? f2[0] : f2[1], r = r.toRed(this.red);
        }
        if (e.lambda)
          o2 = new lt2(e.lambda, 16);
        else {
          var p3 = this._getEndoRoots(this.n);
          this.g.mul(p3[0]).x.cmp(this.g.x.redMul(r)) === 0 ? o2 = p3[0] : (o2 = p3[1], wA(this.g.mul(o2).x.cmp(this.g.x.redMul(r)) === 0));
        }
        var m4;
        return e.basis ? m4 = e.basis.map(function(y3) {
          return { a: new lt2(y3.a, 16), b: new lt2(y3.b, 16) };
        }) : m4 = this._getEndoBasis(o2), { beta: r, lambda: o2, basis: m4 };
      }
    };
    xr2.prototype._getEndoRoots = function(e) {
      var r = e === this.p ? this.red : lt2.mont(e), o2 = new lt2(2).toRed(r).redInvm(), f2 = o2.redNeg(), p3 = new lt2(3).toRed(r).redNeg().redSqrt().redMul(o2), m4 = f2.redAdd(p3).fromRed(), y3 = f2.redSub(p3).fromRed();
      return [m4, y3];
    };
    xr2.prototype._getEndoBasis = function(e) {
      for (var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o2 = e, f2 = this.n.clone(), p3 = new lt2(1), m4 = new lt2(0), y3 = new lt2(0), M4 = new lt2(1), x3, S2, E6, B3, q, L3, ge, _e3 = 0, N5, we;o2.cmpn(0) !== 0; ) {
        var ye = f2.div(o2);
        N5 = f2.sub(ye.mul(o2)), we = y3.sub(ye.mul(p3));
        var xe = M4.sub(ye.mul(m4));
        if (!E6 && N5.cmp(r) < 0)
          x3 = ge.neg(), S2 = p3, E6 = N5.neg(), B3 = we;
        else if (E6 && ++_e3 === 2)
          break;
        ge = N5, f2 = o2, o2 = N5, y3 = p3, p3 = we, M4 = m4, m4 = xe;
      }
      q = N5.neg(), L3 = we;
      var Re = E6.sqr().add(B3.sqr()), Ee = q.sqr().add(L3.sqr());
      return Ee.cmp(Re) >= 0 && (q = x3, L3 = S2), E6.negative && (E6 = E6.neg(), B3 = B3.neg()), q.negative && (q = q.neg(), L3 = L3.neg()), [{ a: E6, b: B3 }, { a: q, b: L3 }];
    };
    xr2.prototype._endoSplit = function(e) {
      var r = this.endo.basis, o2 = r[0], f2 = r[1], p3 = f2.b.mul(e).divRound(this.n), m4 = o2.b.neg().mul(e).divRound(this.n), y3 = p3.mul(o2.a), M4 = m4.mul(f2.a), x3 = p3.mul(o2.b), S2 = m4.mul(f2.b), E6 = e.sub(y3).sub(M4), B3 = x3.add(S2).neg();
      return { k1: E6, k2: B3 };
    };
    xr2.prototype.pointFromX = function(e, r) {
      e = new lt2(e, 16), e.red || (e = e.toRed(this.red));
      var o2 = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), f2 = o2.redSqrt();
      if (f2.redSqr().redSub(o2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var p3 = f2.fromRed().isOdd();
      return (r && !p3 || !r && p3) && (f2 = f2.redNeg()), this.point(e, f2);
    };
    xr2.prototype.validate = function(e) {
      if (e.inf)
        return true;
      var { x: r, y: o2 } = e, f2 = this.a.redMul(r), p3 = r.redSqr().redMul(r).redIAdd(f2).redIAdd(this.b);
      return o2.redSqr().redISub(p3).cmpn(0) === 0;
    };
    xr2.prototype._endoWnafMulAdd = function(e, r, o2) {
      for (var f2 = this._endoWnafT1, p3 = this._endoWnafT2, m4 = 0;m4 < e.length; m4++) {
        var y3 = this._endoSplit(r[m4]), M4 = e[m4], x3 = M4._getBeta();
        y3.k1.negative && (y3.k1.ineg(), M4 = M4.neg(true)), y3.k2.negative && (y3.k2.ineg(), x3 = x3.neg(true)), f2[m4 * 2] = M4, f2[m4 * 2 + 1] = x3, p3[m4 * 2] = y3.k1, p3[m4 * 2 + 1] = y3.k2;
      }
      for (var S2 = this._wnafMulAdd(1, f2, p3, m4 * 2, o2), E6 = 0;E6 < m4 * 2; E6++)
        f2[E6] = null, p3[E6] = null;
      return S2;
    };
    function Ct(t, e, r, o2) {
      Bf.BasePoint.call(this, t, "affine"), e === null && r === null ? (this.x = null, this.y = null, this.inf = true) : (this.x = new lt2(e, 16), this.y = new lt2(r, 16), o2 && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = false);
    }
    Dl(Ct, Bf.BasePoint);
    xr2.prototype.point = function(e, r, o2) {
      return new Ct(this, e, r, o2);
    };
    xr2.prototype.pointFromJSON = function(e, r) {
      return Ct.fromJSON(this, e, r);
    };
    Ct.prototype._getBeta = function() {
      if (!!this.curve.endo) {
        var e = this.precomputed;
        if (e && e.beta)
          return e.beta;
        var r = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (e) {
          var o2 = this.curve, f2 = function(p3) {
            return o2.point(p3.x.redMul(o2.endo.beta), p3.y);
          };
          e.beta = r, r.precomputed = { beta: null, naf: e.naf && { wnd: e.naf.wnd, points: e.naf.points.map(f2) }, doubles: e.doubles && { step: e.doubles.step, points: e.doubles.points.map(f2) } };
        }
        return r;
      }
    };
    Ct.prototype.toJSON = function() {
      return this.precomputed ? [this.x, this.y, this.precomputed && { doubles: this.precomputed.doubles && { step: this.precomputed.doubles.step, points: this.precomputed.doubles.points.slice(1) }, naf: this.precomputed.naf && { wnd: this.precomputed.naf.wnd, points: this.precomputed.naf.points.slice(1) } }] : [this.x, this.y];
    };
    Ct.fromJSON = function(e, r, o2) {
      typeof r == "string" && (r = JSON.parse(r));
      var f2 = e.point(r[0], r[1], o2);
      if (!r[2])
        return f2;
      function p3(y3) {
        return e.point(y3[0], y3[1], o2);
      }
      var m4 = r[2];
      return f2.precomputed = { beta: null, doubles: m4.doubles && { step: m4.doubles.step, points: [f2].concat(m4.doubles.points.map(p3)) }, naf: m4.naf && { wnd: m4.naf.wnd, points: [f2].concat(m4.naf.points.map(p3)) } }, f2;
    };
    Ct.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Ct.prototype.isInfinity = function() {
      return this.inf;
    };
    Ct.prototype.add = function(e) {
      if (this.inf)
        return e;
      if (e.inf)
        return this;
      if (this.eq(e))
        return this.dbl();
      if (this.neg().eq(e))
        return this.curve.point(null, null);
      if (this.x.cmp(e.x) === 0)
        return this.curve.point(null, null);
      var r = this.y.redSub(e.y);
      r.cmpn(0) !== 0 && (r = r.redMul(this.x.redSub(e.x).redInvm()));
      var o2 = r.redSqr().redISub(this.x).redISub(e.x), f2 = r.redMul(this.x.redSub(o2)).redISub(this.y);
      return this.curve.point(o2, f2);
    };
    Ct.prototype.dbl = function() {
      if (this.inf)
        return this;
      var e = this.y.redAdd(this.y);
      if (e.cmpn(0) === 0)
        return this.curve.point(null, null);
      var r = this.curve.a, o2 = this.x.redSqr(), f2 = e.redInvm(), p3 = o2.redAdd(o2).redIAdd(o2).redIAdd(r).redMul(f2), m4 = p3.redSqr().redISub(this.x.redAdd(this.x)), y3 = p3.redMul(this.x.redSub(m4)).redISub(this.y);
      return this.curve.point(m4, y3);
    };
    Ct.prototype.getX = function() {
      return this.x.fromRed();
    };
    Ct.prototype.getY = function() {
      return this.y.fromRed();
    };
    Ct.prototype.mul = function(e) {
      return e = new lt2(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
    };
    Ct.prototype.mulAdd = function(e, r, o2) {
      var f2 = [this, r], p3 = [e, o2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f2, p3) : this.curve._wnafMulAdd(1, f2, p3, 2);
    };
    Ct.prototype.jmulAdd = function(e, r, o2) {
      var f2 = [this, r], p3 = [e, o2];
      return this.curve.endo ? this.curve._endoWnafMulAdd(f2, p3, true) : this.curve._wnafMulAdd(1, f2, p3, 2, true);
    };
    Ct.prototype.eq = function(e) {
      return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
    };
    Ct.prototype.neg = function(e) {
      if (this.inf)
        return this;
      var r = this.curve.point(this.x, this.y.redNeg());
      if (e && this.precomputed) {
        var o2 = this.precomputed, f2 = function(p3) {
          return p3.neg();
        };
        r.precomputed = { naf: o2.naf && { wnd: o2.naf.wnd, points: o2.naf.points.map(f2) }, doubles: o2.doubles && { step: o2.doubles.step, points: o2.doubles.points.map(f2) } };
      }
      return r;
    };
    Ct.prototype.toJ = function() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var e = this.curve.jpoint(this.x, this.y, this.curve.one);
      return e;
    };
    function Wt2(t, e, r, o2) {
      Bf.BasePoint.call(this, t, "jacobian"), e === null && r === null && o2 === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new lt2(0)) : (this.x = new lt2(e, 16), this.y = new lt2(r, 16), this.z = new lt2(o2, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
    }
    Dl(Wt2, Bf.BasePoint);
    xr2.prototype.jpoint = function(e, r, o2) {
      return new Wt2(this, e, r, o2);
    };
    Wt2.prototype.toP = function() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var e = this.z.redInvm(), r = e.redSqr(), o2 = this.x.redMul(r), f2 = this.y.redMul(r).redMul(e);
      return this.curve.point(o2, f2);
    };
    Wt2.prototype.neg = function() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    Wt2.prototype.add = function(e) {
      if (this.isInfinity())
        return e;
      if (e.isInfinity())
        return this;
      var r = e.z.redSqr(), o2 = this.z.redSqr(), f2 = this.x.redMul(r), p3 = e.x.redMul(o2), m4 = this.y.redMul(r.redMul(e.z)), y3 = e.y.redMul(o2.redMul(this.z)), M4 = f2.redSub(p3), x3 = m4.redSub(y3);
      if (M4.cmpn(0) === 0)
        return x3.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var S2 = M4.redSqr(), E6 = S2.redMul(M4), B3 = f2.redMul(S2), q = x3.redSqr().redIAdd(E6).redISub(B3).redISub(B3), L3 = x3.redMul(B3.redISub(q)).redISub(m4.redMul(E6)), ge = this.z.redMul(e.z).redMul(M4);
      return this.curve.jpoint(q, L3, ge);
    };
    Wt2.prototype.mixedAdd = function(e) {
      if (this.isInfinity())
        return e.toJ();
      if (e.isInfinity())
        return this;
      var r = this.z.redSqr(), o2 = this.x, f2 = e.x.redMul(r), p3 = this.y, m4 = e.y.redMul(r).redMul(this.z), y3 = o2.redSub(f2), M4 = p3.redSub(m4);
      if (y3.cmpn(0) === 0)
        return M4.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
      var x3 = y3.redSqr(), S2 = x3.redMul(y3), E6 = o2.redMul(x3), B3 = M4.redSqr().redIAdd(S2).redISub(E6).redISub(E6), q = M4.redMul(E6.redISub(B3)).redISub(p3.redMul(S2)), L3 = this.z.redMul(y3);
      return this.curve.jpoint(B3, q, L3);
    };
    Wt2.prototype.dblp = function(e) {
      if (e === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!e)
        return this.dbl();
      var r;
      if (this.curve.zeroA || this.curve.threeA) {
        var o2 = this;
        for (r = 0;r < e; r++)
          o2 = o2.dbl();
        return o2;
      }
      var f2 = this.curve.a, p3 = this.curve.tinv, m4 = this.x, y3 = this.y, M4 = this.z, x3 = M4.redSqr().redSqr(), S2 = y3.redAdd(y3);
      for (r = 0;r < e; r++) {
        var E6 = m4.redSqr(), B3 = S2.redSqr(), q = B3.redSqr(), L3 = E6.redAdd(E6).redIAdd(E6).redIAdd(f2.redMul(x3)), ge = m4.redMul(B3), _e3 = L3.redSqr().redISub(ge.redAdd(ge)), N5 = ge.redISub(_e3), we = L3.redMul(N5);
        we = we.redIAdd(we).redISub(q);
        var ye = S2.redMul(M4);
        r + 1 < e && (x3 = x3.redMul(q)), m4 = _e3, M4 = ye, S2 = we;
      }
      return this.curve.jpoint(m4, S2.redMul(p3), M4);
    };
    Wt2.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
    };
    Wt2.prototype._zeroDbl = function() {
      var e, r, o2;
      if (this.zOne) {
        var f2 = this.x.redSqr(), p3 = this.y.redSqr(), m4 = p3.redSqr(), y3 = this.x.redAdd(p3).redSqr().redISub(f2).redISub(m4);
        y3 = y3.redIAdd(y3);
        var M4 = f2.redAdd(f2).redIAdd(f2), x3 = M4.redSqr().redISub(y3).redISub(y3), S2 = m4.redIAdd(m4);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), e = x3, r = M4.redMul(y3.redISub(x3)).redISub(S2), o2 = this.y.redAdd(this.y);
      } else {
        var E6 = this.x.redSqr(), B3 = this.y.redSqr(), q = B3.redSqr(), L3 = this.x.redAdd(B3).redSqr().redISub(E6).redISub(q);
        L3 = L3.redIAdd(L3);
        var ge = E6.redAdd(E6).redIAdd(E6), _e3 = ge.redSqr(), N5 = q.redIAdd(q);
        N5 = N5.redIAdd(N5), N5 = N5.redIAdd(N5), e = _e3.redISub(L3).redISub(L3), r = ge.redMul(L3.redISub(e)).redISub(N5), o2 = this.y.redMul(this.z), o2 = o2.redIAdd(o2);
      }
      return this.curve.jpoint(e, r, o2);
    };
    Wt2.prototype._threeDbl = function() {
      var e, r, o2;
      if (this.zOne) {
        var f2 = this.x.redSqr(), p3 = this.y.redSqr(), m4 = p3.redSqr(), y3 = this.x.redAdd(p3).redSqr().redISub(f2).redISub(m4);
        y3 = y3.redIAdd(y3);
        var M4 = f2.redAdd(f2).redIAdd(f2).redIAdd(this.curve.a), x3 = M4.redSqr().redISub(y3).redISub(y3);
        e = x3;
        var S2 = m4.redIAdd(m4);
        S2 = S2.redIAdd(S2), S2 = S2.redIAdd(S2), r = M4.redMul(y3.redISub(x3)).redISub(S2), o2 = this.y.redAdd(this.y);
      } else {
        var E6 = this.z.redSqr(), B3 = this.y.redSqr(), q = this.x.redMul(B3), L3 = this.x.redSub(E6).redMul(this.x.redAdd(E6));
        L3 = L3.redAdd(L3).redIAdd(L3);
        var ge = q.redIAdd(q);
        ge = ge.redIAdd(ge);
        var _e3 = ge.redAdd(ge);
        e = L3.redSqr().redISub(_e3), o2 = this.y.redAdd(this.z).redSqr().redISub(B3).redISub(E6);
        var N5 = B3.redSqr();
        N5 = N5.redIAdd(N5), N5 = N5.redIAdd(N5), N5 = N5.redIAdd(N5), r = L3.redMul(ge.redISub(e)).redISub(N5);
      }
      return this.curve.jpoint(e, r, o2);
    };
    Wt2.prototype._dbl = function() {
      var e = this.curve.a, r = this.x, o2 = this.y, f2 = this.z, p3 = f2.redSqr().redSqr(), m4 = r.redSqr(), y3 = o2.redSqr(), M4 = m4.redAdd(m4).redIAdd(m4).redIAdd(e.redMul(p3)), x3 = r.redAdd(r);
      x3 = x3.redIAdd(x3);
      var S2 = x3.redMul(y3), E6 = M4.redSqr().redISub(S2.redAdd(S2)), B3 = S2.redISub(E6), q = y3.redSqr();
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L3 = M4.redMul(B3).redISub(q), ge = o2.redAdd(o2).redMul(f2);
      return this.curve.jpoint(E6, L3, ge);
    };
    Wt2.prototype.trpl = function() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var e = this.x.redSqr(), r = this.y.redSqr(), o2 = this.z.redSqr(), f2 = r.redSqr(), p3 = e.redAdd(e).redIAdd(e), m4 = p3.redSqr(), y3 = this.x.redAdd(r).redSqr().redISub(e).redISub(f2);
      y3 = y3.redIAdd(y3), y3 = y3.redAdd(y3).redIAdd(y3), y3 = y3.redISub(m4);
      var M4 = y3.redSqr(), x3 = f2.redIAdd(f2);
      x3 = x3.redIAdd(x3), x3 = x3.redIAdd(x3), x3 = x3.redIAdd(x3);
      var S2 = p3.redIAdd(y3).redSqr().redISub(m4).redISub(M4).redISub(x3), E6 = r.redMul(S2);
      E6 = E6.redIAdd(E6), E6 = E6.redIAdd(E6);
      var B3 = this.x.redMul(M4).redISub(E6);
      B3 = B3.redIAdd(B3), B3 = B3.redIAdd(B3);
      var q = this.y.redMul(S2.redMul(x3.redISub(S2)).redISub(y3.redMul(M4)));
      q = q.redIAdd(q), q = q.redIAdd(q), q = q.redIAdd(q);
      var L3 = this.z.redAdd(y3).redSqr().redISub(o2).redISub(M4);
      return this.curve.jpoint(B3, q, L3);
    };
    Wt2.prototype.mul = function(e, r) {
      return e = new lt2(e, r), this.curve._wnafMul(this, e);
    };
    Wt2.prototype.eq = function(e) {
      if (e.type === "affine")
        return this.eq(e.toJ());
      if (this === e)
        return true;
      var r = this.z.redSqr(), o2 = e.z.redSqr();
      if (this.x.redMul(o2).redISub(e.x.redMul(r)).cmpn(0) !== 0)
        return false;
      var f2 = r.redMul(this.z), p3 = o2.redMul(e.z);
      return this.y.redMul(p3).redISub(e.y.redMul(f2)).cmpn(0) === 0;
    };
    Wt2.prototype.eqXToP = function(e) {
      var r = this.z.redSqr(), o2 = e.toRed(this.curve.red).redMul(r);
      if (this.x.cmp(o2) === 0)
        return true;
      for (var f2 = e.clone(), p3 = this.curve.redN.redMul(r);; ) {
        if (f2.iadd(this.curve.n), f2.cmp(this.curve.p) >= 0)
          return false;
        if (o2.redIAdd(p3), this.x.cmp(o2) === 0)
          return true;
      }
    };
    Wt2.prototype.inspect = function() {
      return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    Wt2.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
  });
  y22 = T((Ek, g22) => {
    var qf = ri2(), m22 = Ie(), Gs2 = Oa(), MA = or();
    function If(t) {
      Gs2.call(this, "mont", t), this.a = new qf(t.a, 16).toRed(this.red), this.b = new qf(t.b, 16).toRed(this.red), this.i4 = new qf(4).toRed(this.red).redInvm(), this.two = new qf(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    m22(If, Gs2);
    g22.exports = If;
    If.prototype.validate = function(e) {
      var r = e.normalize().x, o2 = r.redSqr(), f2 = o2.redMul(r).redAdd(o2.redMul(this.a)).redAdd(r), p3 = f2.redSqrt();
      return p3.redSqr().cmp(f2) === 0;
    };
    function Ot(t, e, r) {
      Gs2.BasePoint.call(this, t, "projective"), e === null && r === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new qf(e, 16), this.z = new qf(r, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
    }
    m22(Ot, Gs2.BasePoint);
    If.prototype.decodePoint = function(e, r) {
      return this.point(MA.toArray(e, r), 1);
    };
    If.prototype.point = function(e, r) {
      return new Ot(this, e, r);
    };
    If.prototype.pointFromJSON = function(e) {
      return Ot.fromJSON(this, e);
    };
    Ot.prototype.precompute = function() {};
    Ot.prototype._encode = function() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Ot.fromJSON = function(e, r) {
      return new Ot(e, r[0], r[1] || e.one);
    };
    Ot.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Ot.prototype.isInfinity = function() {
      return this.z.cmpn(0) === 0;
    };
    Ot.prototype.dbl = function() {
      var e = this.x.redAdd(this.z), r = e.redSqr(), o2 = this.x.redSub(this.z), f2 = o2.redSqr(), p3 = r.redSub(f2), m4 = r.redMul(f2), y3 = p3.redMul(f2.redAdd(this.curve.a24.redMul(p3)));
      return this.curve.point(m4, y3);
    };
    Ot.prototype.add = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.diffAdd = function(e, r) {
      var o2 = this.x.redAdd(this.z), f2 = this.x.redSub(this.z), p3 = e.x.redAdd(e.z), m4 = e.x.redSub(e.z), y3 = m4.redMul(o2), M4 = p3.redMul(f2), x3 = r.z.redMul(y3.redAdd(M4).redSqr()), S2 = r.x.redMul(y3.redISub(M4).redSqr());
      return this.curve.point(x3, S2);
    };
    Ot.prototype.mul = function(e) {
      for (var r = e.clone(), o2 = this, f2 = this.curve.point(null, null), p3 = this, m4 = [];r.cmpn(0) !== 0; r.iushrn(1))
        m4.push(r.andln(1));
      for (var y3 = m4.length - 1;y3 >= 0; y3--)
        m4[y3] === 0 ? (o2 = o2.diffAdd(f2, p3), f2 = f2.dbl()) : (f2 = o2.diffAdd(f2, p3), o2 = o2.dbl());
      return f2;
    };
    Ot.prototype.mulAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.jumlAdd = function() {
      throw new Error("Not supported on Montgomery curve");
    };
    Ot.prototype.eq = function(e) {
      return this.getX().cmp(e.getX()) === 0;
    };
    Ot.prototype.normalize = function() {
      return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
    };
    Ot.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
  });
  _22 = T((Ak, M22) => {
    var _A = or(), Ai2 = ri2(), w22 = Ie(), Ys3 = Oa(), xA = _A.assert;
    function ii(t) {
      this.twisted = (t.a | 0) !== 1, this.mOneA = this.twisted && (t.a | 0) === -1, this.extended = this.mOneA, Ys3.call(this, "edwards", t), this.a = new Ai2(t.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new Ai2(t.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new Ai2(t.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), xA(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (t.c | 0) === 1;
    }
    w22(ii, Ys3);
    M22.exports = ii;
    ii.prototype._mulA = function(e) {
      return this.mOneA ? e.redNeg() : this.a.redMul(e);
    };
    ii.prototype._mulC = function(e) {
      return this.oneC ? e : this.c.redMul(e);
    };
    ii.prototype.jpoint = function(e, r, o2, f2) {
      return this.point(e, r, o2, f2);
    };
    ii.prototype.pointFromX = function(e, r) {
      e = new Ai2(e, 16), e.red || (e = e.toRed(this.red));
      var o2 = e.redSqr(), f2 = this.c2.redSub(this.a.redMul(o2)), p3 = this.one.redSub(this.c2.redMul(this.d).redMul(o2)), m4 = f2.redMul(p3.redInvm()), y3 = m4.redSqrt();
      if (y3.redSqr().redSub(m4).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var M4 = y3.fromRed().isOdd();
      return (r && !M4 || !r && M4) && (y3 = y3.redNeg()), this.point(e, y3);
    };
    ii.prototype.pointFromY = function(e, r) {
      e = new Ai2(e, 16), e.red || (e = e.toRed(this.red));
      var o2 = e.redSqr(), f2 = o2.redSub(this.c2), p3 = o2.redMul(this.d).redMul(this.c2).redSub(this.a), m4 = f2.redMul(p3.redInvm());
      if (m4.cmp(this.zero) === 0) {
        if (r)
          throw new Error("invalid point");
        return this.point(this.zero, e);
      }
      var y3 = m4.redSqrt();
      if (y3.redSqr().redSub(m4).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      return y3.fromRed().isOdd() !== r && (y3 = y3.redNeg()), this.point(y3, e);
    };
    ii.prototype.validate = function(e) {
      if (e.isInfinity())
        return true;
      e.normalize();
      var r = e.x.redSqr(), o2 = e.y.redSqr(), f2 = r.redMul(this.a).redAdd(o2), p3 = this.c2.redMul(this.one.redAdd(this.d.redMul(r).redMul(o2)));
      return f2.cmp(p3) === 0;
    };
    function at2(t, e, r, o2, f2) {
      Ys3.BasePoint.call(this, t, "projective"), e === null && r === null && o2 === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = true) : (this.x = new Ai2(e, 16), this.y = new Ai2(r, 16), this.z = o2 ? new Ai2(o2, 16) : this.curve.one, this.t = f2 && new Ai2(f2, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
    }
    w22(at2, Ys3.BasePoint);
    ii.prototype.pointFromJSON = function(e) {
      return at2.fromJSON(this, e);
    };
    ii.prototype.point = function(e, r, o2, f2) {
      return new at2(this, e, r, o2, f2);
    };
    at2.fromJSON = function(e, r) {
      return new at2(e, r[0], r[1], r[2]);
    };
    at2.prototype.inspect = function() {
      return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    at2.prototype.isInfinity = function() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    at2.prototype._extDbl = function() {
      var e = this.x.redSqr(), r = this.y.redSqr(), o2 = this.z.redSqr();
      o2 = o2.redIAdd(o2);
      var f2 = this.curve._mulA(e), p3 = this.x.redAdd(this.y).redSqr().redISub(e).redISub(r), m4 = f2.redAdd(r), y3 = m4.redSub(o2), M4 = f2.redSub(r), x3 = p3.redMul(y3), S2 = m4.redMul(M4), E6 = p3.redMul(M4), B3 = y3.redMul(m4);
      return this.curve.point(x3, S2, B3, E6);
    };
    at2.prototype._projDbl = function() {
      var e = this.x.redAdd(this.y).redSqr(), r = this.x.redSqr(), o2 = this.y.redSqr(), f2, p3, m4, y3, M4, x3;
      if (this.curve.twisted) {
        y3 = this.curve._mulA(r);
        var S2 = y3.redAdd(o2);
        this.zOne ? (f2 = e.redSub(r).redSub(o2).redMul(S2.redSub(this.curve.two)), p3 = S2.redMul(y3.redSub(o2)), m4 = S2.redSqr().redSub(S2).redSub(S2)) : (M4 = this.z.redSqr(), x3 = S2.redSub(M4).redISub(M4), f2 = e.redSub(r).redISub(o2).redMul(x3), p3 = S2.redMul(y3.redSub(o2)), m4 = S2.redMul(x3));
      } else
        y3 = r.redAdd(o2), M4 = this.curve._mulC(this.z).redSqr(), x3 = y3.redSub(M4).redSub(M4), f2 = this.curve._mulC(e.redISub(y3)).redMul(x3), p3 = this.curve._mulC(y3).redMul(r.redISub(o2)), m4 = y3.redMul(x3);
      return this.curve.point(f2, p3, m4);
    };
    at2.prototype.dbl = function() {
      return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
    };
    at2.prototype._extAdd = function(e) {
      var r = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o2 = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), f2 = this.t.redMul(this.curve.dd).redMul(e.t), p3 = this.z.redMul(e.z.redAdd(e.z)), m4 = o2.redSub(r), y3 = p3.redSub(f2), M4 = p3.redAdd(f2), x3 = o2.redAdd(r), S2 = m4.redMul(y3), E6 = M4.redMul(x3), B3 = m4.redMul(x3), q = y3.redMul(M4);
      return this.curve.point(S2, E6, q, B3);
    };
    at2.prototype._projAdd = function(e) {
      var r = this.z.redMul(e.z), o2 = r.redSqr(), f2 = this.x.redMul(e.x), p3 = this.y.redMul(e.y), m4 = this.curve.d.redMul(f2).redMul(p3), y3 = o2.redSub(m4), M4 = o2.redAdd(m4), x3 = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(f2).redISub(p3), S2 = r.redMul(y3).redMul(x3), E6, B3;
      return this.curve.twisted ? (E6 = r.redMul(M4).redMul(p3.redSub(this.curve._mulA(f2))), B3 = y3.redMul(M4)) : (E6 = r.redMul(M4).redMul(p3.redSub(f2)), B3 = this.curve._mulC(y3).redMul(M4)), this.curve.point(S2, E6, B3);
    };
    at2.prototype.add = function(e) {
      return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
    };
    at2.prototype.mul = function(e) {
      return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
    };
    at2.prototype.mulAdd = function(e, r, o2) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o2], 2, false);
    };
    at2.prototype.jmulAdd = function(e, r, o2) {
      return this.curve._wnafMulAdd(1, [this, r], [e, o2], 2, true);
    };
    at2.prototype.normalize = function() {
      if (this.zOne)
        return this;
      var e = this.z.redInvm();
      return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = true, this;
    };
    at2.prototype.neg = function() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    at2.prototype.getX = function() {
      return this.normalize(), this.x.fromRed();
    };
    at2.prototype.getY = function() {
      return this.normalize(), this.y.fromRed();
    };
    at2.prototype.eq = function(e) {
      return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
    };
    at2.prototype.eqXToP = function(e) {
      var r = e.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(r) === 0)
        return true;
      for (var o2 = e.clone(), f2 = this.curve.redN.redMul(this.z);; ) {
        if (o2.iadd(this.curve.n), o2.cmp(this.curve.p) >= 0)
          return false;
        if (r.redIAdd(f2), this.x.cmp(r) === 0)
          return true;
      }
    };
    at2.prototype.toP = at2.prototype.normalize;
    at2.prototype.mixedAdd = at2.prototype.add;
  });
  Pl = T((x22) => {
    var Xs2 = x22;
    Xs2.base = Oa();
    Xs2.short = b22();
    Xs2.mont = y22();
    Xs2.edwards = _22();
  });
  Cr3 = T((it2) => {
    var SA = ar2(), EA = Ie();
    it2.inherits = EA;
    function AA(t, e) {
      return (t.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= t.length ? false : (t.charCodeAt(e + 1) & 64512) === 56320;
    }
    function RA(t, e) {
      if (Array.isArray(t))
        return t.slice();
      if (!t)
        return [];
      var r = [];
      if (typeof t == "string")
        if (e) {
          if (e === "hex")
            for (t = t.replace(/[^a-z0-9]+/ig, ""), t.length % 2 !== 0 && (t = "0" + t), f2 = 0;f2 < t.length; f2 += 2)
              r.push(parseInt(t[f2] + t[f2 + 1], 16));
        } else
          for (var o2 = 0, f2 = 0;f2 < t.length; f2++) {
            var p3 = t.charCodeAt(f2);
            p3 < 128 ? r[o2++] = p3 : p3 < 2048 ? (r[o2++] = p3 >> 6 | 192, r[o2++] = p3 & 63 | 128) : AA(t, f2) ? (p3 = 65536 + ((p3 & 1023) << 10) + (t.charCodeAt(++f2) & 1023), r[o2++] = p3 >> 18 | 240, r[o2++] = p3 >> 12 & 63 | 128, r[o2++] = p3 >> 6 & 63 | 128, r[o2++] = p3 & 63 | 128) : (r[o2++] = p3 >> 12 | 224, r[o2++] = p3 >> 6 & 63 | 128, r[o2++] = p3 & 63 | 128);
          }
      else
        for (f2 = 0;f2 < t.length; f2++)
          r[f2] = t[f2] | 0;
      return r;
    }
    it2.toArray = RA;
    function BA(t) {
      for (var e = "", r = 0;r < t.length; r++)
        e += E22(t[r].toString(16));
      return e;
    }
    it2.toHex = BA;
    function S2(t) {
      var e = t >>> 24 | t >>> 8 & 65280 | t << 8 & 16711680 | (t & 255) << 24;
      return e >>> 0;
    }
    it2.htonl = S2;
    function qA(t, e) {
      for (var r = "", o2 = 0;o2 < t.length; o2++) {
        var f2 = t[o2];
        e === "little" && (f2 = S2(f2)), r += A22(f2.toString(16));
      }
      return r;
    }
    it2.toHex32 = qA;
    function E22(t) {
      return t.length === 1 ? "0" + t : t;
    }
    it2.zero2 = E22;
    function A22(t) {
      return t.length === 7 ? "0" + t : t.length === 6 ? "00" + t : t.length === 5 ? "000" + t : t.length === 4 ? "0000" + t : t.length === 3 ? "00000" + t : t.length === 2 ? "000000" + t : t.length === 1 ? "0000000" + t : t;
    }
    it2.zero8 = A22;
    function IA(t, e, r, o2) {
      var f2 = r - e;
      SA(f2 % 4 === 0);
      for (var p3 = new Array(f2 / 4), m4 = 0, y3 = e;m4 < p3.length; m4++, y3 += 4) {
        var M4;
        o2 === "big" ? M4 = t[y3] << 24 | t[y3 + 1] << 16 | t[y3 + 2] << 8 | t[y3 + 3] : M4 = t[y3 + 3] << 24 | t[y3 + 2] << 16 | t[y3 + 1] << 8 | t[y3], p3[m4] = M4 >>> 0;
      }
      return p3;
    }
    it2.join32 = IA;
    function TA(t, e) {
      for (var r = new Array(t.length * 4), o2 = 0, f2 = 0;o2 < t.length; o2++, f2 += 4) {
        var p3 = t[o2];
        e === "big" ? (r[f2] = p3 >>> 24, r[f2 + 1] = p3 >>> 16 & 255, r[f2 + 2] = p3 >>> 8 & 255, r[f2 + 3] = p3 & 255) : (r[f2 + 3] = p3 >>> 24, r[f2 + 2] = p3 >>> 16 & 255, r[f2 + 1] = p3 >>> 8 & 255, r[f2] = p3 & 255);
      }
      return r;
    }
    it2.split32 = TA;
    function kA(t, e) {
      return t >>> e | t << 32 - e;
    }
    it2.rotr32 = kA;
    function LA(t, e) {
      return t << e | t >>> 32 - e;
    }
    it2.rotl32 = LA;
    function NA(t, e) {
      return t + e >>> 0;
    }
    it2.sum32 = NA;
    function DA(t, e, r) {
      return t + e + r >>> 0;
    }
    it2.sum32_3 = DA;
    function PA(t, e, r, o2) {
      return t + e + r + o2 >>> 0;
    }
    it2.sum32_4 = PA;
    function CA(t, e, r, o2, f2) {
      return t + e + r + o2 + f2 >>> 0;
    }
    it2.sum32_5 = CA;
    function OA(t, e, r, o2) {
      var f2 = t[e], p3 = t[e + 1], m4 = o2 + p3 >>> 0, y3 = (m4 < o2 ? 1 : 0) + r + f2;
      t[e] = y3 >>> 0, t[e + 1] = m4;
    }
    it2.sum64 = OA;
    function FA(t, e, r, o2) {
      var f2 = e + o2 >>> 0, p3 = (f2 < e ? 1 : 0) + t + r;
      return p3 >>> 0;
    }
    it2.sum64_hi = FA;
    function UA(t, e, r, o2) {
      var f2 = e + o2;
      return f2 >>> 0;
    }
    it2.sum64_lo = UA;
    function zA(t, e, r, o2, f2, p3, m4, y3) {
      var M4 = 0, x3 = e;
      x3 = x3 + o2 >>> 0, M4 += x3 < e ? 1 : 0, x3 = x3 + p3 >>> 0, M4 += x3 < p3 ? 1 : 0, x3 = x3 + y3 >>> 0, M4 += x3 < y3 ? 1 : 0;
      var S3 = t + r + f2 + m4 + M4;
      return S3 >>> 0;
    }
    it2.sum64_4_hi = zA;
    function HA(t, e, r, o2, f2, p3, m4, y3) {
      var M4 = e + o2 + p3 + y3;
      return M4 >>> 0;
    }
    it2.sum64_4_lo = HA;
    function WA(t, e, r, o2, f2, p3, m4, y3, M4, x3) {
      var S3 = 0, E6 = e;
      E6 = E6 + o2 >>> 0, S3 += E6 < e ? 1 : 0, E6 = E6 + p3 >>> 0, S3 += E6 < p3 ? 1 : 0, E6 = E6 + y3 >>> 0, S3 += E6 < y3 ? 1 : 0, E6 = E6 + x3 >>> 0, S3 += E6 < x3 ? 1 : 0;
      var B3 = t + r + f2 + m4 + M4 + S3;
      return B3 >>> 0;
    }
    it2.sum64_5_hi = WA;
    function KA(t, e, r, o2, f2, p3, m4, y3, M4, x3) {
      var S3 = e + o2 + p3 + y3 + x3;
      return S3 >>> 0;
    }
    it2.sum64_5_lo = KA;
    function jA(t, e, r) {
      var o2 = e << 32 - r | t >>> r;
      return o2 >>> 0;
    }
    it2.rotr64_hi = jA;
    function ZA(t, e, r) {
      var o2 = t << 32 - r | e >>> r;
      return o2 >>> 0;
    }
    it2.rotr64_lo = ZA;
    function VA(t, e, r) {
      return t >>> r;
    }
    it2.shr64_hi = VA;
    function $A(t, e, r) {
      var o2 = t << 32 - r | e >>> r;
      return o2 >>> 0;
    }
    it2.shr64_lo = $A;
  });
  Tf = T((B22) => {
    var R2 = Cr3(), GA = ar2();
    function Js2() {
      this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
    }
    B22.BlockHash = Js2;
    Js2.prototype.update = function(e, r) {
      if (e = R2.toArray(e, r), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
        e = this.pending;
        var o2 = e.length % this._delta8;
        this.pending = e.slice(e.length - o2, e.length), this.pending.length === 0 && (this.pending = null), e = R2.join32(e, 0, e.length - o2, this.endian);
        for (var f2 = 0;f2 < e.length; f2 += this._delta32)
          this._update(e, f2, f2 + this._delta32);
      }
      return this;
    };
    Js2.prototype.digest = function(e) {
      return this.update(this._pad()), GA(this.pending === null), this._digest(e);
    };
    Js2.prototype._pad = function() {
      var e = this.pendingTotal, r = this._delta8, o2 = r - (e + this.padLength) % r, f2 = new Array(o2 + this.padLength);
      f2[0] = 128;
      for (var p3 = 1;p3 < o2; p3++)
        f2[p3] = 0;
      if (e <<= 3, this.endian === "big") {
        for (var m4 = 8;m4 < this.padLength; m4++)
          f2[p3++] = 0;
        f2[p3++] = 0, f2[p3++] = 0, f2[p3++] = 0, f2[p3++] = 0, f2[p3++] = e >>> 24 & 255, f2[p3++] = e >>> 16 & 255, f2[p3++] = e >>> 8 & 255, f2[p3++] = e & 255;
      } else
        for (f2[p3++] = e & 255, f2[p3++] = e >>> 8 & 255, f2[p3++] = e >>> 16 & 255, f2[p3++] = e >>> 24 & 255, f2[p3++] = 0, f2[p3++] = 0, f2[p3++] = 0, f2[p3++] = 0, m4 = 8;m4 < this.padLength; m4++)
          f2[p3++] = 0;
      return f2;
    };
  });
  Cl = T((Ri2) => {
    var YA = Cr3(), ni = YA.rotr32;
    function XA(t, e, r, o2) {
      if (t === 0)
        return q2(e, r, o2);
      if (t === 1 || t === 3)
        return T2(e, r, o2);
      if (t === 2)
        return I22(e, r, o2);
    }
    Ri2.ft_1 = XA;
    function q2(t, e, r) {
      return t & e ^ ~t & r;
    }
    Ri2.ch32 = q2;
    function I22(t, e, r) {
      return t & e ^ t & r ^ e & r;
    }
    Ri2.maj32 = I22;
    function T2(t, e, r) {
      return t ^ e ^ r;
    }
    Ri2.p32 = T2;
    function JA(t) {
      return ni(t, 2) ^ ni(t, 13) ^ ni(t, 22);
    }
    Ri2.s0_256 = JA;
    function QA(t) {
      return ni(t, 6) ^ ni(t, 11) ^ ni(t, 25);
    }
    Ri2.s1_256 = QA;
    function eR(t) {
      return ni(t, 7) ^ ni(t, 18) ^ t >>> 3;
    }
    Ri2.g0_256 = eR;
    function tR(t) {
      return ni(t, 17) ^ ni(t, 19) ^ t >>> 10;
    }
    Ri2.g1_256 = tR;
  });
  N22 = T((Tk, L22) => {
    var kf = Cr3(), rR = Tf(), iR = Cl(), Ol = kf.rotl32, Fa = kf.sum32, nR = kf.sum32_5, fR = iR.ft_1, k22 = rR.BlockHash, aR = [1518500249, 1859775393, 2400959708, 3395469782];
    function fi2() {
      if (!(this instanceof fi2))
        return new fi2;
      k22.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
    }
    kf.inherits(fi2, k22);
    L22.exports = fi2;
    fi2.blockSize = 512;
    fi2.outSize = 160;
    fi2.hmacStrength = 80;
    fi2.padLength = 64;
    fi2.prototype._update = function(e, r) {
      for (var o2 = this.W, f2 = 0;f2 < 16; f2++)
        o2[f2] = e[r + f2];
      for (;f2 < o2.length; f2++)
        o2[f2] = Ol(o2[f2 - 3] ^ o2[f2 - 8] ^ o2[f2 - 14] ^ o2[f2 - 16], 1);
      var p3 = this.h[0], m4 = this.h[1], y3 = this.h[2], M4 = this.h[3], x3 = this.h[4];
      for (f2 = 0;f2 < o2.length; f2++) {
        var S2 = ~~(f2 / 20), E6 = nR(Ol(p3, 5), fR(S2, m4, y3, M4), x3, o2[f2], aR[S2]);
        x3 = M4, M4 = y3, y3 = Ol(m4, 30), m4 = p3, p3 = E6;
      }
      this.h[0] = Fa(this.h[0], p3), this.h[1] = Fa(this.h[1], m4), this.h[2] = Fa(this.h[2], y3), this.h[3] = Fa(this.h[3], M4), this.h[4] = Fa(this.h[4], x3);
    };
    fi2.prototype._digest = function(e) {
      return e === "hex" ? kf.toHex32(this.h, "big") : kf.split32(this.h, "big");
    };
  });
  Fl = T((kk, P2) => {
    var Lf = Cr3(), oR = Tf(), Nf = Cl(), sR = ar2(), Or = Lf.sum32, hR = Lf.sum32_4, uR = Lf.sum32_5, lR = Nf.ch32, dR = Nf.maj32, cR = Nf.s0_256, pR = Nf.s1_256, vR = Nf.g0_256, bR = Nf.g1_256, D2 = oR.BlockHash, mR = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
    function ai() {
      if (!(this instanceof ai))
        return new ai;
      D2.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = mR, this.W = new Array(64);
    }
    Lf.inherits(ai, D2);
    P2.exports = ai;
    ai.blockSize = 512;
    ai.outSize = 256;
    ai.hmacStrength = 192;
    ai.padLength = 64;
    ai.prototype._update = function(e, r) {
      for (var o2 = this.W, f2 = 0;f2 < 16; f2++)
        o2[f2] = e[r + f2];
      for (;f2 < o2.length; f2++)
        o2[f2] = hR(bR(o2[f2 - 2]), o2[f2 - 7], vR(o2[f2 - 15]), o2[f2 - 16]);
      var p3 = this.h[0], m4 = this.h[1], y3 = this.h[2], M4 = this.h[3], x3 = this.h[4], S2 = this.h[5], E6 = this.h[6], B3 = this.h[7];
      for (sR(this.k.length === o2.length), f2 = 0;f2 < o2.length; f2++) {
        var q = uR(B3, pR(x3), lR(x3, S2, E6), this.k[f2], o2[f2]), L3 = Or(cR(p3), dR(p3, m4, y3));
        B3 = E6, E6 = S2, S2 = x3, x3 = Or(M4, q), M4 = y3, y3 = m4, m4 = p3, p3 = Or(q, L3);
      }
      this.h[0] = Or(this.h[0], p3), this.h[1] = Or(this.h[1], m4), this.h[2] = Or(this.h[2], y3), this.h[3] = Or(this.h[3], M4), this.h[4] = Or(this.h[4], x3), this.h[5] = Or(this.h[5], S2), this.h[6] = Or(this.h[6], E6), this.h[7] = Or(this.h[7], B3);
    };
    ai.prototype._digest = function(e) {
      return e === "hex" ? Lf.toHex32(this.h, "big") : Lf.split32(this.h, "big");
    };
  });
  F22 = T((Lk, O2) => {
    var Ul = Cr3(), C22 = Fl();
    function Bi() {
      if (!(this instanceof Bi))
        return new Bi;
      C22.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
    }
    Ul.inherits(Bi, C22);
    O2.exports = Bi;
    Bi.blockSize = 512;
    Bi.outSize = 224;
    Bi.hmacStrength = 192;
    Bi.padLength = 64;
    Bi.prototype._digest = function(e) {
      return e === "hex" ? Ul.toHex32(this.h.slice(0, 7), "big") : Ul.split32(this.h.slice(0, 7), "big");
    };
  });
  Wl = T((Nk, W2) => {
    var ir3 = Cr3(), gR = Tf(), yR = ar2(), oi = ir3.rotr64_hi, si2 = ir3.rotr64_lo, U2 = ir3.shr64_hi, z2 = ir3.shr64_lo, Ji2 = ir3.sum64, zl = ir3.sum64_hi, Hl = ir3.sum64_lo, wR = ir3.sum64_4_hi, MR = ir3.sum64_4_lo, _R = ir3.sum64_5_hi, xR = ir3.sum64_5_lo, H22 = gR.BlockHash, SR = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
    function Fr2() {
      if (!(this instanceof Fr2))
        return new Fr2;
      H22.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = SR, this.W = new Array(160);
    }
    ir3.inherits(Fr2, H22);
    W2.exports = Fr2;
    Fr2.blockSize = 1024;
    Fr2.outSize = 512;
    Fr2.hmacStrength = 192;
    Fr2.padLength = 128;
    Fr2.prototype._prepareBlock = function(e, r) {
      for (var o2 = this.W, f2 = 0;f2 < 32; f2++)
        o2[f2] = e[r + f2];
      for (;f2 < o2.length; f2 += 2) {
        var p3 = DR(o2[f2 - 4], o2[f2 - 3]), m4 = PR(o2[f2 - 4], o2[f2 - 3]), y3 = o2[f2 - 14], M4 = o2[f2 - 13], x3 = LR(o2[f2 - 30], o2[f2 - 29]), S2 = NR(o2[f2 - 30], o2[f2 - 29]), E6 = o2[f2 - 32], B3 = o2[f2 - 31];
        o2[f2] = wR(p3, m4, y3, M4, x3, S2, E6, B3), o2[f2 + 1] = MR(p3, m4, y3, M4, x3, S2, E6, B3);
      }
    };
    Fr2.prototype._update = function(e, r) {
      this._prepareBlock(e, r);
      var o2 = this.W, f2 = this.h[0], p3 = this.h[1], m4 = this.h[2], y3 = this.h[3], M4 = this.h[4], x3 = this.h[5], S2 = this.h[6], E6 = this.h[7], B3 = this.h[8], q = this.h[9], L3 = this.h[10], ge = this.h[11], _e3 = this.h[12], N5 = this.h[13], we = this.h[14], ye = this.h[15];
      yR(this.k.length === o2.length);
      for (var xe = 0;xe < o2.length; xe += 2) {
        var Re = we, Ee = ye, Ae2 = TR(B3, q), P2 = kR(B3, q), Se3 = ER(B3, q, L3, ge, _e3, N5), v2 = AR(B3, q, L3, ge, _e3, N5), i = this.k[xe], a3 = this.k[xe + 1], h3 = o2[xe], s3 = o2[xe + 1], u2 = _R(Re, Ee, Ae2, P2, Se3, v2, i, a3, h3, s3), c2 = xR(Re, Ee, Ae2, P2, Se3, v2, i, a3, h3, s3);
        Re = qR(f2, p3), Ee = IR(f2, p3), Ae2 = RR(f2, p3, m4, y3, M4, x3), P2 = BR(f2, p3, m4, y3, M4, x3);
        var b5 = zl(Re, Ee, Ae2, P2), l3 = Hl(Re, Ee, Ae2, P2);
        we = _e3, ye = N5, _e3 = L3, N5 = ge, L3 = B3, ge = q, B3 = zl(S2, E6, u2, c2), q = Hl(E6, E6, u2, c2), S2 = M4, E6 = x3, M4 = m4, x3 = y3, m4 = f2, y3 = p3, f2 = zl(u2, c2, b5, l3), p3 = Hl(u2, c2, b5, l3);
      }
      Ji2(this.h, 0, f2, p3), Ji2(this.h, 2, m4, y3), Ji2(this.h, 4, M4, x3), Ji2(this.h, 6, S2, E6), Ji2(this.h, 8, B3, q), Ji2(this.h, 10, L3, ge), Ji2(this.h, 12, _e3, N5), Ji2(this.h, 14, we, ye);
    };
    Fr2.prototype._digest = function(e) {
      return e === "hex" ? ir3.toHex32(this.h, "big") : ir3.split32(this.h, "big");
    };
    function ER(t, e, r, o2, f2) {
      var p3 = t & r ^ ~t & f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function AR(t, e, r, o2, f2, p3) {
      var m4 = e & o2 ^ ~e & p3;
      return m4 < 0 && (m4 += 4294967296), m4;
    }
    function RR(t, e, r, o2, f2) {
      var p3 = t & r ^ t & f2 ^ r & f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function BR(t, e, r, o2, f2, p3) {
      var m4 = e & o2 ^ e & p3 ^ o2 & p3;
      return m4 < 0 && (m4 += 4294967296), m4;
    }
    function qR(t, e) {
      var r = oi(t, e, 28), o2 = oi(e, t, 2), f2 = oi(e, t, 7), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function IR(t, e) {
      var r = si2(t, e, 28), o2 = si2(e, t, 2), f2 = si2(e, t, 7), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function TR(t, e) {
      var r = oi(t, e, 14), o2 = oi(t, e, 18), f2 = oi(e, t, 9), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function kR(t, e) {
      var r = si2(t, e, 14), o2 = si2(t, e, 18), f2 = si2(e, t, 9), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function LR(t, e) {
      var r = oi(t, e, 1), o2 = oi(t, e, 8), f2 = U2(t, e, 7), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function NR(t, e) {
      var r = si2(t, e, 1), o2 = si2(t, e, 8), f2 = z2(t, e, 7), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function DR(t, e) {
      var r = oi(t, e, 19), o2 = oi(e, t, 29), f2 = U2(t, e, 6), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
    function PR(t, e) {
      var r = si2(t, e, 19), o2 = si2(e, t, 29), f2 = z2(t, e, 6), p3 = r ^ o2 ^ f2;
      return p3 < 0 && (p3 += 4294967296), p3;
    }
  });
  Z2 = T((Dk, j22) => {
    var Kl = Cr3(), K22 = Wl();
    function qi() {
      if (!(this instanceof qi))
        return new qi;
      K22.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
    }
    Kl.inherits(qi, K22);
    j22.exports = qi;
    qi.blockSize = 1024;
    qi.outSize = 384;
    qi.hmacStrength = 192;
    qi.padLength = 128;
    qi.prototype._digest = function(e) {
      return e === "hex" ? Kl.toHex32(this.h.slice(0, 12), "big") : Kl.split32(this.h.slice(0, 12), "big");
    };
  });
  V22 = T((Df) => {
    Df.sha1 = N22();
    Df.sha224 = F22();
    Df.sha256 = Fl();
    Df.sha384 = Z2();
    Df.sha512 = Wl();
  });
  Q22 = T((J22) => {
    var On2 = Cr3(), CR = Tf(), Qs2 = On2.rotl32, $2 = On2.sum32, Ua = On2.sum32_3, G2 = On2.sum32_4, X22 = CR.BlockHash;
    function hi() {
      if (!(this instanceof hi))
        return new hi;
      X22.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
    }
    On2.inherits(hi, X22);
    J22.ripemd160 = hi;
    hi.blockSize = 512;
    hi.outSize = 160;
    hi.hmacStrength = 192;
    hi.padLength = 64;
    hi.prototype._update = function(e, r) {
      for (var o2 = this.h[0], f2 = this.h[1], p3 = this.h[2], m4 = this.h[3], y3 = this.h[4], M4 = o2, x3 = f2, S2 = p3, E6 = m4, B3 = y3, q = 0;q < 80; q++) {
        var L3 = $2(Qs2(G2(o2, Y22(q, f2, p3, m4), e[UR[q] + r], OR(q)), HR[q]), y3);
        o2 = y3, y3 = m4, m4 = Qs2(p3, 10), p3 = f2, f2 = L3, L3 = $2(Qs2(G2(M4, Y22(79 - q, x3, S2, E6), e[zR[q] + r], FR(q)), WR[q]), B3), M4 = B3, B3 = E6, E6 = Qs2(S2, 10), S2 = x3, x3 = L3;
      }
      L3 = Ua(this.h[1], p3, E6), this.h[1] = Ua(this.h[2], m4, B3), this.h[2] = Ua(this.h[3], y3, M4), this.h[3] = Ua(this.h[4], o2, x3), this.h[4] = Ua(this.h[0], f2, S2), this.h[0] = L3;
    };
    hi.prototype._digest = function(e) {
      return e === "hex" ? On2.toHex32(this.h, "little") : On2.split32(this.h, "little");
    };
    function Y22(t, e, r, o2) {
      return t <= 15 ? e ^ r ^ o2 : t <= 31 ? e & r | ~e & o2 : t <= 47 ? (e | ~r) ^ o2 : t <= 63 ? e & o2 | r & ~o2 : e ^ (r | ~o2);
    }
    function OR(t) {
      return t <= 15 ? 0 : t <= 31 ? 1518500249 : t <= 47 ? 1859775393 : t <= 63 ? 2400959708 : 2840853838;
    }
    function FR(t) {
      return t <= 15 ? 1352829926 : t <= 31 ? 1548603684 : t <= 47 ? 1836072691 : t <= 63 ? 2053994217 : 0;
    }
    var UR = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13], zR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11], HR = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6], WR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  });
  ty = T((Ok, ey) => {
    var KR = Cr3(), jR = ar2();
    function Pf(t, e, r) {
      if (!(this instanceof Pf))
        return new Pf(t, e, r);
      this.Hash = t, this.blockSize = t.blockSize / 8, this.outSize = t.outSize / 8, this.inner = null, this.outer = null, this._init(KR.toArray(e, r));
    }
    ey.exports = Pf;
    Pf.prototype._init = function(e) {
      e.length > this.blockSize && (e = new this.Hash().update(e).digest()), jR(e.length <= this.blockSize);
      for (var r = e.length;r < this.blockSize; r++)
        e.push(0);
      for (r = 0;r < e.length; r++)
        e[r] ^= 54;
      for (this.inner = new this.Hash().update(e), r = 0;r < e.length; r++)
        e[r] ^= 106;
      this.outer = new this.Hash().update(e);
    };
    Pf.prototype.update = function(e, r) {
      return this.inner.update(e, r), this;
    };
    Pf.prototype.digest = function(e) {
      return this.outer.update(this.inner.digest()), this.outer.digest(e);
    };
  });
  e0 = T((ry) => {
    var Kt3 = ry;
    Kt3.utils = Cr3();
    Kt3.common = Tf();
    Kt3.sha = V22();
    Kt3.ripemd = Q22();
    Kt3.hmac = ty();
    Kt3.sha1 = Kt3.sha.sha1;
    Kt3.sha256 = Kt3.sha.sha256;
    Kt3.sha224 = Kt3.sha.sha224;
    Kt3.sha384 = Kt3.sha.sha384;
    Kt3.sha512 = Kt3.sha.sha512;
    Kt3.ripemd160 = Kt3.ripemd.ripemd160;
  });
  ny = T((Uk, iy) => {
    iy.exports = { doubles: { step: 4, points: [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]] }, naf: { wnd: 7, points: [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]] } };
  });
  t0 = T((oy) => {
    var Zl = oy, Qi2 = e0(), jl = Pl(), ZR = or(), fy = ZR.assert;
    function ay(t) {
      t.type === "short" ? this.curve = new jl.short(t) : t.type === "edwards" ? this.curve = new jl.edwards(t) : this.curve = new jl.mont(t), this.g = this.curve.g, this.n = this.curve.n, this.hash = t.hash, fy(this.g.validate(), "Invalid curve"), fy(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    Zl.PresetCurve = ay;
    function en(t, e) {
      Object.defineProperty(Zl, t, { configurable: true, enumerable: true, get: function() {
        var r = new ay(e);
        return Object.defineProperty(Zl, t, { configurable: true, enumerable: true, value: r }), r;
      } });
    }
    en("p192", { type: "short", prime: "p192", p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff", a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc", b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1", n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831", hash: Qi2.sha256, gRed: false, g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"] });
    en("p224", { type: "short", prime: "p224", p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001", a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe", b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4", n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d", hash: Qi2.sha256, gRed: false, g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"] });
    en("p256", { type: "short", prime: null, p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff", a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc", b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b", n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551", hash: Qi2.sha256, gRed: false, g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"] });
    en("p384", { type: "short", prime: null, p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff", a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc", b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef", n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973", hash: Qi2.sha384, gRed: false, g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"] });
    en("p521", { type: "short", prime: null, p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff", a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc", b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00", n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409", hash: Qi2.sha512, gRed: false, g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"] });
    en("curve25519", { type: "mont", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "76d06", b: "1", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi2.sha256, gRed: false, g: ["9"] });
    en("ed25519", { type: "edwards", prime: "p25519", p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed", a: "-1", c: "1", d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3", n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed", hash: Qi2.sha256, gRed: false, g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"] });
    var Vl;
    try {
      Vl = ny();
    } catch {
      Vl = undefined;
    }
    en("secp256k1", { type: "short", prime: "k256", p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f", a: "0", b: "7", n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141", h: "1", hash: Qi2.sha256, beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee", lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72", basis: [{ a: "3086d221a7d46bcde86c90e49284eb15", b: "-e4437ed6010e88286f547fa90abfe4c3" }, { a: "114ca50f7a8e2f3f657c1108d9d44cfd8", b: "3086d221a7d46bcde86c90e49284eb15" }], gRed: false, g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", Vl] });
  });
  uy = T((Hk, hy) => {
    var VR = e0(), Fn2 = Nl(), sy = ar2();
    function tn2(t) {
      if (!(this instanceof tn2))
        return new tn2(t);
      this.hash = t.hash, this.predResist = !!t.predResist, this.outLen = this.hash.outSize, this.minEntropy = t.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
      var e = Fn2.toArray(t.entropy, t.entropyEnc || "hex"), r = Fn2.toArray(t.nonce, t.nonceEnc || "hex"), o2 = Fn2.toArray(t.pers, t.persEnc || "hex");
      sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, r, o2);
    }
    hy.exports = tn2;
    tn2.prototype._init = function(e, r, o2) {
      var f2 = e.concat(r).concat(o2);
      this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
      for (var p3 = 0;p3 < this.V.length; p3++)
        this.K[p3] = 0, this.V[p3] = 1;
      this._update(f2), this._reseed = 1, this.reseedInterval = 281474976710656;
    };
    tn2.prototype._hmac = function() {
      return new VR.hmac(this.hash, this.K);
    };
    tn2.prototype._update = function(e) {
      var r = this._hmac().update(this.V).update([0]);
      e && (r = r.update(e)), this.K = r.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
    };
    tn2.prototype.reseed = function(e, r, o2, f2) {
      typeof r != "string" && (f2 = o2, o2 = r, r = null), e = Fn2.toArray(e, r), o2 = Fn2.toArray(o2, f2), sy(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(e.concat(o2 || [])), this._reseed = 1;
    };
    tn2.prototype.generate = function(e, r, o2, f2) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      typeof r != "string" && (f2 = o2, o2 = r, r = null), o2 && (o2 = Fn2.toArray(o2, f2 || "hex"), this._update(o2));
      for (var p3 = [];p3.length < e; )
        this.V = this._hmac().update(this.V).digest(), p3 = p3.concat(this.V);
      var m4 = p3.slice(0, e);
      return this._update(o2), this._reseed++, Fn2.encode(m4, r);
    };
  });
  dy = T((Wk, ly) => {
    var $R = ri2(), GR = or(), $l = GR.assert;
    function Gt(t, e) {
      this.ec = t, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
    }
    ly.exports = Gt;
    Gt.fromPublic = function(e, r, o2) {
      return r instanceof Gt ? r : new Gt(e, { pub: r, pubEnc: o2 });
    };
    Gt.fromPrivate = function(e, r, o2) {
      return r instanceof Gt ? r : new Gt(e, { priv: r, privEnc: o2 });
    };
    Gt.prototype.validate = function() {
      var e = this.getPublic();
      return e.isInfinity() ? { result: false, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: true, reason: null } : { result: false, reason: "Public key * N != O" } : { result: false, reason: "Public key is not a point" };
    };
    Gt.prototype.getPublic = function(e, r) {
      return typeof e == "string" && (r = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), r ? this.pub.encode(r, e) : this.pub;
    };
    Gt.prototype.getPrivate = function(e) {
      return e === "hex" ? this.priv.toString(16, 2) : this.priv;
    };
    Gt.prototype._importPrivate = function(e, r) {
      this.priv = new $R(e, r || 16), this.priv = this.priv.umod(this.ec.curve.n);
    };
    Gt.prototype._importPublic = function(e, r) {
      if (e.x || e.y) {
        this.ec.curve.type === "mont" ? $l(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && $l(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(e, r);
    };
    Gt.prototype.derive = function(e) {
      return e.validate() || $l(e.validate(), "public point not validated"), e.mul(this.priv).getX();
    };
    Gt.prototype.sign = function(e, r, o2) {
      return this.ec.sign(e, this, r, o2);
    };
    Gt.prototype.verify = function(e, r) {
      return this.ec.verify(e, r, this);
    };
    Gt.prototype.inspect = function() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  });
  vy = T((Kk, py) => {
    var r0 = ri2(), Xl = or(), YR = Xl.assert;
    function i0(t, e) {
      if (t instanceof i0)
        return t;
      this._importDER(t, e) || (YR(t.r && t.s, "Signature without r or s"), this.r = new r0(t.r, 16), this.s = new r0(t.s, 16), t.recoveryParam === undefined ? this.recoveryParam = null : this.recoveryParam = t.recoveryParam);
    }
    py.exports = i0;
    function XR() {
      this.place = 0;
    }
    function Gl(t, e) {
      var r = t[e.place++];
      if (!(r & 128))
        return r;
      var o2 = r & 15;
      if (o2 === 0 || o2 > 4)
        return false;
      for (var f2 = 0, p3 = 0, m4 = e.place;p3 < o2; p3++, m4++)
        f2 <<= 8, f2 |= t[m4], f2 >>>= 0;
      return f2 <= 127 ? false : (e.place = m4, f2);
    }
    function cy(t) {
      for (var e = 0, r = t.length - 1;!t[e] && !(t[e + 1] & 128) && e < r; )
        e++;
      return e === 0 ? t : t.slice(e);
    }
    i0.prototype._importDER = function(e, r) {
      e = Xl.toArray(e, r);
      var o2 = new XR;
      if (e[o2.place++] !== 48)
        return false;
      var f2 = Gl(e, o2);
      if (f2 === false || f2 + o2.place !== e.length || e[o2.place++] !== 2)
        return false;
      var p3 = Gl(e, o2);
      if (p3 === false)
        return false;
      var m4 = e.slice(o2.place, p3 + o2.place);
      if (o2.place += p3, e[o2.place++] !== 2)
        return false;
      var y3 = Gl(e, o2);
      if (y3 === false || e.length !== y3 + o2.place)
        return false;
      var M4 = e.slice(o2.place, y3 + o2.place);
      if (m4[0] === 0)
        if (m4[1] & 128)
          m4 = m4.slice(1);
        else
          return false;
      if (M4[0] === 0)
        if (M4[1] & 128)
          M4 = M4.slice(1);
        else
          return false;
      return this.r = new r0(m4), this.s = new r0(M4), this.recoveryParam = null, true;
    };
    function Yl(t, e) {
      if (e < 128) {
        t.push(e);
        return;
      }
      var r = 1 + (Math.log(e) / Math.LN2 >>> 3);
      for (t.push(r | 128);--r; )
        t.push(e >>> (r << 3) & 255);
      t.push(e);
    }
    i0.prototype.toDER = function(e) {
      var r = this.r.toArray(), o2 = this.s.toArray();
      for (r[0] & 128 && (r = [0].concat(r)), o2[0] & 128 && (o2 = [0].concat(o2)), r = cy(r), o2 = cy(o2);!o2[0] && !(o2[1] & 128); )
        o2 = o2.slice(1);
      var f2 = [2];
      Yl(f2, r.length), f2 = f2.concat(r), f2.push(2), Yl(f2, o2.length);
      var p3 = f2.concat(o2), m4 = [48];
      return Yl(m4, p3.length), m4 = m4.concat(p3), Xl.encode(m4, e);
    };
  });
  yy = T((jk, gy) => {
    var Un = ri2(), by = uy(), JR = or(), Jl = t0(), QR = As(), my = JR.assert, Ql = dy(), n0 = vy();
    function Sr(t) {
      if (!(this instanceof Sr))
        return new Sr(t);
      typeof t == "string" && (my(Object.prototype.hasOwnProperty.call(Jl, t), "Unknown curve " + t), t = Jl[t]), t instanceof Jl.PresetCurve && (t = { curve: t }), this.curve = t.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = t.curve.g, this.g.precompute(t.curve.n.bitLength() + 1), this.hash = t.hash || t.curve.hash;
    }
    gy.exports = Sr;
    Sr.prototype.keyPair = function(e) {
      return new Ql(this, e);
    };
    Sr.prototype.keyFromPrivate = function(e, r) {
      return Ql.fromPrivate(this, e, r);
    };
    Sr.prototype.keyFromPublic = function(e, r) {
      return Ql.fromPublic(this, e, r);
    };
    Sr.prototype.genKeyPair = function(e) {
      e || (e = {});
      for (var r = new by({ hash: this.hash, pers: e.pers, persEnc: e.persEnc || "utf8", entropy: e.entropy || QR(this.hash.hmacStrength), entropyEnc: e.entropy && e.entropyEnc || "utf8", nonce: this.n.toArray() }), o2 = this.n.byteLength(), f2 = this.n.sub(new Un(2));; ) {
        var p3 = new Un(r.generate(o2));
        if (!(p3.cmp(f2) > 0))
          return p3.iaddn(1), this.keyFromPrivate(p3);
      }
    };
    Sr.prototype._truncateToN = function(e, r) {
      var o2 = e.byteLength() * 8 - this.n.bitLength();
      return o2 > 0 && (e = e.ushrn(o2)), !r && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
    };
    Sr.prototype.sign = function(e, r, o2, f2) {
      typeof o2 == "object" && (f2 = o2, o2 = null), f2 || (f2 = {}), r = this.keyFromPrivate(r, o2), e = this._truncateToN(new Un(e, 16));
      for (var p3 = this.n.byteLength(), m4 = r.getPrivate().toArray("be", p3), y3 = e.toArray("be", p3), M4 = new by({ hash: this.hash, entropy: m4, nonce: y3, pers: f2.pers, persEnc: f2.persEnc || "utf8" }), x3 = this.n.sub(new Un(1)), S2 = 0;; S2++) {
        var E6 = f2.k ? f2.k(S2) : new Un(M4.generate(this.n.byteLength()));
        if (E6 = this._truncateToN(E6, true), !(E6.cmpn(1) <= 0 || E6.cmp(x3) >= 0)) {
          var B3 = this.g.mul(E6);
          if (!B3.isInfinity()) {
            var q = B3.getX(), L3 = q.umod(this.n);
            if (L3.cmpn(0) !== 0) {
              var ge = E6.invm(this.n).mul(L3.mul(r.getPrivate()).iadd(e));
              if (ge = ge.umod(this.n), ge.cmpn(0) !== 0) {
                var _e3 = (B3.getY().isOdd() ? 1 : 0) | (q.cmp(L3) !== 0 ? 2 : 0);
                return f2.canonical && ge.cmp(this.nh) > 0 && (ge = this.n.sub(ge), _e3 ^= 1), new n0({ r: L3, s: ge, recoveryParam: _e3 });
              }
            }
          }
        }
      }
    };
    Sr.prototype.verify = function(e, r, o2, f2) {
      e = this._truncateToN(new Un(e, 16)), o2 = this.keyFromPublic(o2, f2), r = new n0(r, "hex");
      var { r: p3, s: m4 } = r;
      if (p3.cmpn(1) < 0 || p3.cmp(this.n) >= 0 || m4.cmpn(1) < 0 || m4.cmp(this.n) >= 0)
        return false;
      var y3 = m4.invm(this.n), M4 = y3.mul(e).umod(this.n), x3 = y3.mul(p3).umod(this.n), S2;
      return this.curve._maxwellTrick ? (S2 = this.g.jmulAdd(M4, o2.getPublic(), x3), S2.isInfinity() ? false : S2.eqXToP(p3)) : (S2 = this.g.mulAdd(M4, o2.getPublic(), x3), S2.isInfinity() ? false : S2.getX().umod(this.n).cmp(p3) === 0);
    };
    Sr.prototype.recoverPubKey = function(t, e, r, o2) {
      my((3 & r) === r, "The recovery param is more than two bits"), e = new n0(e, o2);
      var f2 = this.n, p3 = new Un(t), m4 = e.r, y3 = e.s, M4 = r & 1, x3 = r >> 1;
      if (m4.cmp(this.curve.p.umod(this.curve.n)) >= 0 && x3)
        throw new Error("Unable to find sencond key candinate");
      x3 ? m4 = this.curve.pointFromX(m4.add(this.curve.n), M4) : m4 = this.curve.pointFromX(m4, M4);
      var S2 = e.r.invm(f2), E6 = f2.sub(p3).mul(S2).umod(f2), B3 = y3.mul(S2).umod(f2);
      return this.g.mulAdd(E6, m4, B3);
    };
    Sr.prototype.getKeyRecoveryParam = function(t, e, r, o2) {
      if (e = new n0(e, o2), e.recoveryParam !== null)
        return e.recoveryParam;
      for (var f2 = 0;f2 < 4; f2++) {
        var p3;
        try {
          p3 = this.recoverPubKey(t, e, f2);
        } catch {
          continue;
        }
        if (p3.eq(r))
          return f2;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  });
  xy = T((Zk, _y) => {
    var za = or(), My = za.assert, wy = za.parseBytes, Cf2 = za.cachedProperty;
    function Ft2(t, e) {
      this.eddsa = t, this._secret = wy(e.secret), t.isPoint(e.pub) ? this._pub = e.pub : this._pubBytes = wy(e.pub);
    }
    Ft2.fromPublic = function(e, r) {
      return r instanceof Ft2 ? r : new Ft2(e, { pub: r });
    };
    Ft2.fromSecret = function(e, r) {
      return r instanceof Ft2 ? r : new Ft2(e, { secret: r });
    };
    Ft2.prototype.secret = function() {
      return this._secret;
    };
    Cf2(Ft2, "pubBytes", function() {
      return this.eddsa.encodePoint(this.pub());
    });
    Cf2(Ft2, "pub", function() {
      return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
    });
    Cf2(Ft2, "privBytes", function() {
      var e = this.eddsa, r = this.hash(), o2 = e.encodingLength - 1, f2 = r.slice(0, e.encodingLength);
      return f2[0] &= 248, f2[o2] &= 127, f2[o2] |= 64, f2;
    });
    Cf2(Ft2, "priv", function() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    Cf2(Ft2, "hash", function() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    Cf2(Ft2, "messagePrefix", function() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    Ft2.prototype.sign = function(e) {
      return My(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
    };
    Ft2.prototype.verify = function(e, r) {
      return this.eddsa.verify(e, r, this);
    };
    Ft2.prototype.getSecret = function(e) {
      return My(this._secret, "KeyPair is public only"), za.encode(this.secret(), e);
    };
    Ft2.prototype.getPublic = function(e) {
      return za.encode(this.pubBytes(), e);
    };
    _y.exports = Ft2;
  });
  Ey = T((Vk, Sy) => {
    var eB = ri2(), f0 = or(), tB = f0.assert, a0 = f0.cachedProperty, rB = f0.parseBytes;
    function zn2(t, e) {
      this.eddsa = t, typeof e != "object" && (e = rB(e)), Array.isArray(e) && (e = { R: e.slice(0, t.encodingLength), S: e.slice(t.encodingLength) }), tB(e.R && e.S, "Signature without R or S"), t.isPoint(e.R) && (this._R = e.R), e.S instanceof eB && (this._S = e.S), this._Rencoded = Array.isArray(e.R) ? e.R : e.Rencoded, this._Sencoded = Array.isArray(e.S) ? e.S : e.Sencoded;
    }
    a0(zn2, "S", function() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    a0(zn2, "R", function() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    a0(zn2, "Rencoded", function() {
      return this.eddsa.encodePoint(this.R());
    });
    a0(zn2, "Sencoded", function() {
      return this.eddsa.encodeInt(this.S());
    });
    zn2.prototype.toBytes = function() {
      return this.Rencoded().concat(this.Sencoded());
    };
    zn2.prototype.toHex = function() {
      return f0.encode(this.toBytes(), "hex").toUpperCase();
    };
    Sy.exports = zn2;
  });
  Iy = T(($k, qy) => {
    var iB = e0(), nB = t0(), Of = or(), fB = Of.assert, Ry = Of.parseBytes, By = xy(), Ay = Ey();
    function nr(t) {
      if (fB(t === "ed25519", "only tested with ed25519 so far"), !(this instanceof nr))
        return new nr(t);
      t = nB[t].curve, this.curve = t, this.g = t.g, this.g.precompute(t.n.bitLength() + 1), this.pointClass = t.point().constructor, this.encodingLength = Math.ceil(t.n.bitLength() / 8), this.hash = iB.sha512;
    }
    qy.exports = nr;
    nr.prototype.sign = function(e, r) {
      e = Ry(e);
      var o2 = this.keyFromSecret(r), f2 = this.hashInt(o2.messagePrefix(), e), p3 = this.g.mul(f2), m4 = this.encodePoint(p3), y3 = this.hashInt(m4, o2.pubBytes(), e).mul(o2.priv()), M4 = f2.add(y3).umod(this.curve.n);
      return this.makeSignature({ R: p3, S: M4, Rencoded: m4 });
    };
    nr.prototype.verify = function(e, r, o2) {
      e = Ry(e), r = this.makeSignature(r);
      var f2 = this.keyFromPublic(o2), p3 = this.hashInt(r.Rencoded(), f2.pubBytes(), e), m4 = this.g.mul(r.S()), y3 = r.R().add(f2.pub().mul(p3));
      return y3.eq(m4);
    };
    nr.prototype.hashInt = function() {
      for (var e = this.hash(), r = 0;r < arguments.length; r++)
        e.update(arguments[r]);
      return Of.intFromLE(e.digest()).umod(this.curve.n);
    };
    nr.prototype.keyFromPublic = function(e) {
      return By.fromPublic(this, e);
    };
    nr.prototype.keyFromSecret = function(e) {
      return By.fromSecret(this, e);
    };
    nr.prototype.makeSignature = function(e) {
      return e instanceof Ay ? e : new Ay(this, e);
    };
    nr.prototype.encodePoint = function(e) {
      var r = e.getY().toArray("le", this.encodingLength);
      return r[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, r;
    };
    nr.prototype.decodePoint = function(e) {
      e = Of.parseBytes(e);
      var r = e.length - 1, o2 = e.slice(0, r).concat(e[r] & -129), f2 = (e[r] & 128) !== 0, p3 = Of.intFromLE(o2);
      return this.curve.pointFromY(p3, f2);
    };
    nr.prototype.encodeInt = function(e) {
      return e.toArray("le", this.encodingLength);
    };
    nr.prototype.decodeInt = function(e) {
      return Of.intFromLE(e);
    };
    nr.prototype.isPoint = function(e) {
      return e instanceof this.pointClass;
    };
  });
  o0 = T((Ty) => {
    var Hn = Ty;
    Hn.version = s2().version;
    Hn.utils = or();
    Hn.rand = As();
    Hn.curve = Pl();
    Hn.curves = t0();
    Hn.ec = yy();
    Hn.eddsa = Iy();
  });
  td = T((ky, ed) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o2(v2, i) {
        v2.super_ = i;
        var a3 = function() {};
        a3.prototype = i.prototype, v2.prototype = new a3, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a3) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v2 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p3;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p3 = window.Buffer : p3 = ji2().Buffer;
      } catch {}
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f2.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f2.prototype._init = function(i, a3, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h3);
        if (typeof i == "object")
          return this._initArray(i, a3, h3);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a3, s3), h3 === "le" && this._initArray(this.toArray(), a3, h3)));
      }, f2.prototype._initNumber = function(i, a3, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a3, h3);
      }, f2.prototype._initArray = function(i, a3, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2, c2, b5 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u2 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        else if (h3 === "le")
          for (s3 = 0, u2 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        return this.strip();
      };
      function m4(v2, i) {
        var a3 = v2.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y3(v2, i, a3) {
        var h3 = m4(v2, a3);
        return a3 - 1 >= i && (h3 |= m4(v2, a3 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a3, h3) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2 = 0, c2 = 0, b5;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        }
        this.strip();
      };
      function M4(v2, i, a3, h3) {
        for (var s3 = 0, u2 = Math.min(v2.length, a3), c2 = i;c2 < u2; c2++) {
          var b5 = v2.charCodeAt(c2) - 48;
          s3 *= h3, b5 >= 49 ? s3 += b5 - 49 + 10 : b5 >= 17 ? s3 += b5 - 17 + 10 : s3 += b5;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a3, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u2 = 1;u2 <= 67108863; u2 *= a3)
          s3++;
        s3--, u2 = u2 / a3 | 0;
        for (var c2 = i.length - h3, b5 = c2 % s3, l3 = Math.min(c2, c2 - b5) + h3, n = 0, d3 = h3;d3 < l3; d3 += s3)
          n = M4(i, d3, d3 + s3, a3), this.imuln(u2), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b5 !== 0) {
          var w3 = 1;
          for (n = M4(i, d3, i.length, a3), d3 = 0;d3 < b5; d3++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u2 = 0, c2 = 0;c2 < this.length; c2++) {
            var b5 = this.words[c2], l3 = ((b5 << s3 | u2) & 16777215).toString(16);
            u2 = b5 >>> 24 - s3 & 16777215, u2 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l3.length] + l3 + h3 : h3 = l3 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u2 !== 0 && (h3 = u2.toString(16) + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d3 = E6[i];
          h3 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g3 = w3.modn(d3).toString(i);
            w3 = w3.idivn(d3), w3.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a3) {
        return r(typeof p3 < "u"), this.toArrayLike(p3, i, a3);
      }, f2.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f2.prototype.toArrayLike = function(i, a3, h3) {
        var s3 = this.byteLength(), u2 = h3 || Math.max(1, s3);
        r(s3 <= u2, "byte array longer than desired length"), r(u2 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b5 = new i(u2), l3, n, d3 = this.clone();
        if (c2) {
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[n] = l3;
          for (;n < u2; n++)
            b5[n] = 0;
        } else {
          for (n = 0;n < u2 - s3; n++)
            b5[n] = 0;
          for (n = 0;!d3.isZero(); n++)
            l3 = d3.andln(255), d3.iushrn(8), b5[u2 - n - 1] = l3;
        }
        return b5;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a3 = i, h3 = 0;
        return a3 >= 4096 && (h3 += 13, a3 >>>= 13), a3 >= 64 && (h3 += 7, a3 >>>= 7), a3 >= 8 && (h3 += 4, a3 >>>= 4), a3 >= 2 && (h3 += 2, a3 >>>= 2), h3 + a3;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h3 = 0;
        return (a3 & 8191) === 0 && (h3 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h3 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h3 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h3 += 2, a3 >>>= 2), (a3 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v2) {
        for (var i = new Array(v2.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h3 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v2.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h3 = this._zeroBits(this.words[a3]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h3 = 0;h3 < a3.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a3, h3;
        this.length > i.length ? (a3 = this, h3 = i) : (a3 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a3.words[s3] ^ h3.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a3), h3 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a3 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u2 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        for (;u2 !== 0 && c2 < h3.length; c2++)
          a3 = (h3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        if (this.length = h3.length, u2 !== 0)
          this.words[this.length] = u2, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u2;
        h3 > 0 ? (s3 = this, u2 = i) : (s3 = i, u2 = this);
        for (var c2 = 0, b5 = 0;b5 < u2.length; b5++)
          a3 = (s3.words[b5] | 0) - (u2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        for (;c2 !== 0 && b5 < s3.length; b5++)
          a3 = (s3.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        if (c2 === 0 && b5 < s3.length && s3 !== this)
          for (;b5 < s3.length; b5++)
            this.words[b5] = s3.words[b5];
        return this.length = Math.max(this.length, b5), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative;
        var h3 = v2.length + i.length | 0;
        a3.length = h3, h3 = h3 - 1 | 0;
        var s3 = v2.words[0] | 0, u2 = i.words[0] | 0, c2 = s3 * u2, b5 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b5;
        for (var n = 1;n < h3; n++) {
          for (var d3 = l3 >>> 26, w3 = l3 & 67108863, g3 = Math.min(n, i.length - 1), _3 = Math.max(0, n - v2.length + 1);_3 <= g3; _3++) {
            var A3 = n - _3 | 0;
            s3 = v2.words[A3] | 0, u2 = i.words[_3] | 0, c2 = s3 * u2 + w3, d3 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d3 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L3 = function(i, a3, h3) {
        var s3 = i.words, u2 = a3.words, c2 = h3.words, b5 = 0, l3, n, d3, w3 = s3[0] | 0, g3 = w3 & 8191, _3 = w3 >>> 13, A3 = s3[1] | 0, R2 = A3 & 8191, I4 = A3 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt3 = s3[3] | 0, C3 = nt3 & 8191, O2 = nt3 >>> 13, vt = s3[4] | 0, F3 = vt & 8191, U2 = vt >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt3 = s3[6] | 0, W = mt3 & 8191, K4 = mt3 >>> 13, gt3 = s3[7] | 0, j4 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s3[8] | 0, V4 = yt2 & 8191, $ = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u2[0] | 0, X3 = Mt & 8191, J3 = Mt >>> 13, _t3 = u2[1] | 0, Q4 = _t3 & 8191, ee = _t3 >>> 13, xt3 = u2[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St = u2[3] | 0, ie = St & 8191, ne = St >>> 13, Et2 = u2[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At4 = u2[5] | 0, oe3 = At4 & 8191, se2 = At4 >>> 13, Rt = u2[6] | 0, he = Rt & 8191, ue4 = Rt >>> 13, Bt = u2[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt2 = u2[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u2[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a3.negative, h3.length = 19, l3 = Math.imul(g3, X3), n = Math.imul(g3, J3), n = n + Math.imul(_3, X3) | 0, d3 = Math.imul(_3, J3);
        var ft = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l3 = Math.imul(R2, X3), n = Math.imul(R2, J3), n = n + Math.imul(I4, X3) | 0, d3 = Math.imul(I4, J3), l3 = l3 + Math.imul(g3, Q4) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_3, Q4) | 0, d3 = d3 + Math.imul(_3, ee) | 0;
        var Be = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X3), n = Math.imul(k4, J3), n = n + Math.imul(D2, X3) | 0, d3 = Math.imul(D2, J3), l3 = l3 + Math.imul(R2, Q4) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I4, Q4) | 0, d3 = d3 + Math.imul(I4, ee) | 0, l3 = l3 + Math.imul(g3, te2) | 0, n = n + Math.imul(g3, re2) | 0, n = n + Math.imul(_3, te2) | 0, d3 = d3 + Math.imul(_3, re2) | 0;
        var qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C3, X3), n = Math.imul(C3, J3), n = n + Math.imul(O2, X3) | 0, d3 = Math.imul(O2, J3), l3 = l3 + Math.imul(k4, Q4) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q4) | 0, d3 = d3 + Math.imul(D2, ee) | 0, l3 = l3 + Math.imul(R2, te2) | 0, n = n + Math.imul(R2, re2) | 0, n = n + Math.imul(I4, te2) | 0, d3 = d3 + Math.imul(I4, re2) | 0, l3 = l3 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_3, ie) | 0, d3 = d3 + Math.imul(_3, ne) | 0;
        var ze = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F3, X3), n = Math.imul(F3, J3), n = n + Math.imul(U2, X3) | 0, d3 = Math.imul(U2, J3), l3 = l3 + Math.imul(C3, Q4) | 0, n = n + Math.imul(C3, ee) | 0, n = n + Math.imul(O2, Q4) | 0, d3 = d3 + Math.imul(O2, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D2, te2) | 0, d3 = d3 + Math.imul(D2, re2) | 0, l3 = l3 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I4, ie) | 0, d3 = d3 + Math.imul(I4, ne) | 0, l3 = l3 + Math.imul(g3, fe3) | 0, n = n + Math.imul(g3, ae2) | 0, n = n + Math.imul(_3, fe3) | 0, d3 = d3 + Math.imul(_3, ae2) | 0;
        var He3 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X3), n = Math.imul(z, J3), n = n + Math.imul(H3, X3) | 0, d3 = Math.imul(H3, J3), l3 = l3 + Math.imul(F3, Q4) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U2, Q4) | 0, d3 = d3 + Math.imul(U2, ee) | 0, l3 = l3 + Math.imul(C3, te2) | 0, n = n + Math.imul(C3, re2) | 0, n = n + Math.imul(O2, te2) | 0, d3 = d3 + Math.imul(O2, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d3 = d3 + Math.imul(D2, ne) | 0, l3 = l3 + Math.imul(R2, fe3) | 0, n = n + Math.imul(R2, ae2) | 0, n = n + Math.imul(I4, fe3) | 0, d3 = d3 + Math.imul(I4, ae2) | 0, l3 = l3 + Math.imul(g3, oe3) | 0, n = n + Math.imul(g3, se2) | 0, n = n + Math.imul(_3, oe3) | 0, d3 = d3 + Math.imul(_3, se2) | 0;
        var We2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X3), n = Math.imul(W, J3), n = n + Math.imul(K4, X3) | 0, d3 = Math.imul(K4, J3), l3 = l3 + Math.imul(z, Q4) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q4) | 0, d3 = d3 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F3, te2) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U2, te2) | 0, d3 = d3 + Math.imul(U2, re2) | 0, l3 = l3 + Math.imul(C3, ie) | 0, n = n + Math.imul(C3, ne) | 0, n = n + Math.imul(O2, ie) | 0, d3 = d3 + Math.imul(O2, ne) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D2, fe3) | 0, d3 = d3 + Math.imul(D2, ae2) | 0, l3 = l3 + Math.imul(R2, oe3) | 0, n = n + Math.imul(R2, se2) | 0, n = n + Math.imul(I4, oe3) | 0, d3 = d3 + Math.imul(I4, se2) | 0, l3 = l3 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue4) | 0, n = n + Math.imul(_3, he) | 0, d3 = d3 + Math.imul(_3, ue4) | 0;
        var Ke2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j4, X3), n = Math.imul(j4, J3), n = n + Math.imul(Z3, X3) | 0, d3 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q4) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K4, Q4) | 0, d3 = d3 + Math.imul(K4, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d3 = d3 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U2, ie) | 0, d3 = d3 + Math.imul(U2, ne) | 0, l3 = l3 + Math.imul(C3, fe3) | 0, n = n + Math.imul(C3, ae2) | 0, n = n + Math.imul(O2, fe3) | 0, d3 = d3 + Math.imul(O2, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se2) | 0, n = n + Math.imul(D2, oe3) | 0, d3 = d3 + Math.imul(D2, se2) | 0, l3 = l3 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue4) | 0, n = n + Math.imul(I4, he) | 0, d3 = d3 + Math.imul(I4, ue4) | 0, l3 = l3 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_3, le) | 0, d3 = d3 + Math.imul(_3, de) | 0;
        var je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V4, X3), n = Math.imul(V4, J3), n = n + Math.imul($, X3) | 0, d3 = Math.imul($, J3), l3 = l3 + Math.imul(j4, Q4) | 0, n = n + Math.imul(j4, ee) | 0, n = n + Math.imul(Z3, Q4) | 0, d3 = d3 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K4, te2) | 0, d3 = d3 + Math.imul(K4, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H3, ie) | 0, d3 = d3 + Math.imul(H3, ne) | 0, l3 = l3 + Math.imul(F3, fe3) | 0, n = n + Math.imul(F3, ae2) | 0, n = n + Math.imul(U2, fe3) | 0, d3 = d3 + Math.imul(U2, ae2) | 0, l3 = l3 + Math.imul(C3, oe3) | 0, n = n + Math.imul(C3, se2) | 0, n = n + Math.imul(O2, oe3) | 0, d3 = d3 + Math.imul(O2, se2) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D2, he) | 0, d3 = d3 + Math.imul(D2, ue4) | 0, l3 = l3 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I4, le) | 0, d3 = d3 + Math.imul(I4, de) | 0, l3 = l3 + Math.imul(g3, ce3) | 0, n = n + Math.imul(g3, pe2) | 0, n = n + Math.imul(_3, ce3) | 0, d3 = d3 + Math.imul(_3, pe2) | 0;
        var Ze2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X3), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X3) | 0, d3 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V4, Q4) | 0, n = n + Math.imul(V4, ee) | 0, n = n + Math.imul($, Q4) | 0, d3 = d3 + Math.imul($, ee) | 0, l3 = l3 + Math.imul(j4, te2) | 0, n = n + Math.imul(j4, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d3 = d3 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K4, ie) | 0, d3 = d3 + Math.imul(K4, ne) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d3 = d3 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F3, oe3) | 0, n = n + Math.imul(F3, se2) | 0, n = n + Math.imul(U2, oe3) | 0, d3 = d3 + Math.imul(U2, se2) | 0, l3 = l3 + Math.imul(C3, he) | 0, n = n + Math.imul(C3, ue4) | 0, n = n + Math.imul(O2, he) | 0, d3 = d3 + Math.imul(O2, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d3 = d3 + Math.imul(D2, de) | 0, l3 = l3 + Math.imul(R2, ce3) | 0, n = n + Math.imul(R2, pe2) | 0, n = n + Math.imul(I4, ce3) | 0, d3 = d3 + Math.imul(I4, pe2) | 0, l3 = l3 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_3, ve) | 0, d3 = d3 + Math.imul(_3, be) | 0;
        var Ve = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q4), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q4) | 0, d3 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V4, te2) | 0, n = n + Math.imul(V4, re2) | 0, n = n + Math.imul($, te2) | 0, d3 = d3 + Math.imul($, re2) | 0, l3 = l3 + Math.imul(j4, ie) | 0, n = n + Math.imul(j4, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d3 = d3 + Math.imul(Z3, ne) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K4, fe3) | 0, d3 = d3 + Math.imul(K4, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se2) | 0, n = n + Math.imul(H3, oe3) | 0, d3 = d3 + Math.imul(H3, se2) | 0, l3 = l3 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue4) | 0, n = n + Math.imul(U2, he) | 0, d3 = d3 + Math.imul(U2, ue4) | 0, l3 = l3 + Math.imul(C3, le) | 0, n = n + Math.imul(C3, de) | 0, n = n + Math.imul(O2, le) | 0, d3 = d3 + Math.imul(O2, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D2, ce3) | 0, d3 = d3 + Math.imul(D2, pe2) | 0, l3 = l3 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I4, ve) | 0, d3 = d3 + Math.imul(I4, be) | 0;
        var $e2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d3 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V4, ie) | 0, n = n + Math.imul(V4, ne) | 0, n = n + Math.imul($, ie) | 0, d3 = d3 + Math.imul($, ne) | 0, l3 = l3 + Math.imul(j4, fe3) | 0, n = n + Math.imul(j4, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d3 = d3 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se2) | 0, n = n + Math.imul(K4, oe3) | 0, d3 = d3 + Math.imul(K4, se2) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d3 = d3 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U2, le) | 0, d3 = d3 + Math.imul(U2, de) | 0, l3 = l3 + Math.imul(C3, ce3) | 0, n = n + Math.imul(C3, pe2) | 0, n = n + Math.imul(O2, ce3) | 0, d3 = d3 + Math.imul(O2, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d3 = d3 + Math.imul(D2, be) | 0;
        var Ge = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y3, ie) | 0, d3 = Math.imul(Y3, ne), l3 = l3 + Math.imul(V4, fe3) | 0, n = n + Math.imul(V4, ae2) | 0, n = n + Math.imul($, fe3) | 0, d3 = d3 + Math.imul($, ae2) | 0, l3 = l3 + Math.imul(j4, oe3) | 0, n = n + Math.imul(j4, se2) | 0, n = n + Math.imul(Z3, oe3) | 0, d3 = d3 + Math.imul(Z3, se2) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K4, he) | 0, d3 = d3 + Math.imul(K4, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d3 = d3 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F3, ce3) | 0, n = n + Math.imul(F3, pe2) | 0, n = n + Math.imul(U2, ce3) | 0, d3 = d3 + Math.imul(U2, pe2) | 0, l3 = l3 + Math.imul(C3, ve) | 0, n = n + Math.imul(C3, be) | 0, n = n + Math.imul(O2, ve) | 0, d3 = d3 + Math.imul(O2, be) | 0;
        var Ye = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d3 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V4, oe3) | 0, n = n + Math.imul(V4, se2) | 0, n = n + Math.imul($, oe3) | 0, d3 = d3 + Math.imul($, se2) | 0, l3 = l3 + Math.imul(j4, he) | 0, n = n + Math.imul(j4, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d3 = d3 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K4, le) | 0, d3 = d3 + Math.imul(K4, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d3 = d3 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U2, ve) | 0, d3 = d3 + Math.imul(U2, be) | 0;
        var Xe = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se2), n = n + Math.imul(Y3, oe3) | 0, d3 = Math.imul(Y3, se2), l3 = l3 + Math.imul(V4, he) | 0, n = n + Math.imul(V4, ue4) | 0, n = n + Math.imul($, he) | 0, d3 = d3 + Math.imul($, ue4) | 0, l3 = l3 + Math.imul(j4, le) | 0, n = n + Math.imul(j4, de) | 0, n = n + Math.imul(Z3, le) | 0, d3 = d3 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K4, ce3) | 0, d3 = d3 + Math.imul(K4, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H3, ve) | 0, d3 = d3 + Math.imul(H3, be) | 0;
        var Je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d3 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V4, le) | 0, n = n + Math.imul(V4, de) | 0, n = n + Math.imul($, le) | 0, d3 = d3 + Math.imul($, de) | 0, l3 = l3 + Math.imul(j4, ce3) | 0, n = n + Math.imul(j4, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d3 = d3 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K4, ve) | 0, d3 = d3 + Math.imul(K4, be) | 0;
        var Qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d3 = Math.imul(Y3, de), l3 = l3 + Math.imul(V4, ce3) | 0, n = n + Math.imul(V4, pe2) | 0, n = n + Math.imul($, ce3) | 0, d3 = d3 + Math.imul($, pe2) | 0, l3 = l3 + Math.imul(j4, ve) | 0, n = n + Math.imul(j4, be) | 0, n = n + Math.imul(Z3, ve) | 0, d3 = d3 + Math.imul(Z3, be) | 0;
        var et4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (et4 >>> 26) | 0, et4 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d3 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V4, ve) | 0, n = n + Math.imul(V4, be) | 0, n = n + Math.imul($, ve) | 0, d3 = d3 + Math.imul($, be) | 0;
        var tt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d3 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y3, ve) | 0, d3 = Math.imul(Y3, be);
        var rt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b5 = (d3 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et4, c2[17] = tt4, c2[18] = rt4, b5 !== 0 && (c2[19] = b5, h3.length++), h3;
      };
      Math.imul || (L3 = q);
      function ge(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative, a3.length = v2.length + i.length;
        for (var h3 = 0, s3 = 0, u2 = 0;u2 < a3.length - 1; u2++) {
          var c2 = s3;
          s3 = 0;
          for (var b5 = h3 & 67108863, l3 = Math.min(u2, i.length - 1), n = Math.max(0, u2 - v2.length + 1);n <= l3; n++) {
            var d3 = u2 - n, w3 = v2.words[d3] | 0, g3 = i.words[n] | 0, _3 = w3 * g3, A3 = _3 & 67108863;
            c2 = c2 + (_3 / 67108864 | 0) | 0, A3 = A3 + b5 | 0, b5 = A3 & 67108863, c2 = c2 + (A3 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u2] = b5, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a3.words[u2] = h3 : a3.length--, a3.strip();
      }
      function _e3(v2, i, a3) {
        var h3 = new N5;
        return h3.mulp(v2, i, a3);
      }
      f2.prototype.mulTo = function(i, a3) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a3) : s3 < 63 ? h3 = q(this, i, a3) : s3 < 1024 ? h3 = ge(this, i, a3) : h3 = _e3(this, i, a3), h3;
      };
      function N5(v2, i) {
        this.x = v2, this.y = i;
      }
      N5.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h3, i);
        return a3;
      }, N5.prototype.revBin = function(i, a3, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u2 = 0;u2 < a3; u2++)
          s3 |= (i & 1) << a3 - u2 - 1, i >>= 1;
        return s3;
      }, N5.prototype.permute = function(i, a3, h3, s3, u2, c2) {
        for (var b5 = 0;b5 < c2; b5++)
          s3[b5] = a3[i[b5]], u2[b5] = h3[i[b5]];
      }, N5.prototype.transform = function(i, a3, h3, s3, u2, c2) {
        this.permute(c2, i, a3, h3, s3, u2);
        for (var b5 = 1;b5 < u2; b5 <<= 1)
          for (var l3 = b5 << 1, n = Math.cos(2 * Math.PI / l3), d3 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u2; w3 += l3)
            for (var g3 = n, _3 = d3, A3 = 0;A3 < b5; A3++) {
              var R2 = h3[w3 + A3], I4 = s3[w3 + A3], Me = h3[w3 + A3 + b5], k4 = s3[w3 + A3 + b5], D2 = g3 * Me - _3 * k4;
              k4 = g3 * k4 + _3 * Me, Me = D2, h3[w3 + A3] = R2 + Me, s3[w3 + A3] = I4 + k4, h3[w3 + A3 + b5] = R2 - Me, s3[w3 + A3 + b5] = I4 - k4, A3 !== l3 && (D2 = n * g3 - d3 * _3, _3 = n * _3 + d3 * g3, g3 = D2);
            }
      }, N5.prototype.guessLen13b = function(i, a3) {
        var h3 = Math.max(a3, i) | 1, s3 = h3 & 1, u2 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u2++;
        return 1 << u2 + 1 + s3;
      }, N5.prototype.conjugate = function(i, a3, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u2 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u2, u2 = a3[s3], a3[s3] = -a3[h3 - s3 - 1], a3[h3 - s3 - 1] = -u2;
          }
      }, N5.prototype.normalize13b = function(i, a3) {
        for (var h3 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u2 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h3;
          i[s3] = u2 & 67108863, u2 < 67108864 ? h3 = 0 : h3 = u2 / 67108864 | 0;
        }
        return i;
      }, N5.prototype.convert13b = function(i, a3, h3, s3) {
        for (var u2 = 0, c2 = 0;c2 < a3; c2++)
          u2 = u2 + (i[c2] | 0), h3[2 * c2] = u2 & 8191, u2 = u2 >>> 13, h3[2 * c2 + 1] = u2 & 8191, u2 = u2 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u2 === 0), r((u2 & -8192) === 0);
      }, N5.prototype.stub = function(i) {
        for (var a3 = new Array(i), h3 = 0;h3 < i; h3++)
          a3[h3] = 0;
        return a3;
      }, N5.prototype.mulp = function(i, a3, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u2 = this.makeRBT(s3), c2 = this.stub(s3), b5 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d3 = new Array(s3), w3 = new Array(s3), g3 = new Array(s3), _3 = h3.words;
        _3.length = s3, this.convert13b(i.words, i.length, b5, s3), this.convert13b(a3.words, a3.length, d3, s3), this.transform(b5, c2, l3, n, s3, u2), this.transform(d3, c2, w3, g3, s3, u2);
        for (var A3 = 0;A3 < s3; A3++) {
          var R2 = l3[A3] * w3[A3] - n[A3] * g3[A3];
          n[A3] = l3[A3] * g3[A3] + n[A3] * w3[A3], l3[A3] = R2;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _3, c2, s3, u2), this.conjugate(_3, c2, s3), this.normalize13b(_3, s3), h3.negative = i.negative ^ a3.negative, h3.length = i.length + a3.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f2.prototype.mulf = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u2 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u2 >>> 26, this.words[h3] = u2 & 67108863;
        }
        return a3 !== 0 && (this.words[h3] = a3, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a3.length)
          for (var u2 = h3.sqr();s3 < a3.length; s3++, u2 = u2.sqr())
            a3[s3] !== 0 && (h3 = h3.mul(u2));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u2;
        if (a3 !== 0) {
          var c2 = 0;
          for (u2 = 0;u2 < this.length; u2++) {
            var b5 = this.words[u2] & s3, l3 = (this.words[u2] | 0) - b5 << a3;
            this.words[u2] = l3 | c2, c2 = b5 >>> 26 - a3;
          }
          c2 && (this.words[u2] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u2 = this.length - 1;u2 >= 0; u2--)
            this.words[u2 + h3] = this.words[u2];
          for (u2 = 0;u2 < h3; u2++)
            this.words[u2] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a3, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u2 = i % 26, c2 = Math.min((i - u2) / 26, this.length), b5 = 67108863 ^ 67108863 >>> u2 << u2, l3 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d3 = 0;
        for (n = this.length - 1;n >= 0 && (d3 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d3 << 26 - u2 | w3 >>> u2, d3 = w3 & b5;
        }
        return l3 && d3 !== 0 && (l3.words[l3.length++] = d3), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a3, h3) {
        return r(this.negative === 0), this.iushrn(i, a3, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return false;
        var u2 = this.words[h3];
        return !!(u2 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a3 !== 0 && h3++, this.length = Math.min(h3, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a3, h3) {
        var s3 = i.length + h3, u2;
        this._expand(s3);
        var c2, b5 = 0;
        for (u2 = 0;u2 < i.length; u2++) {
          c2 = (this.words[u2 + h3] | 0) + b5;
          var l3 = (i.words[u2] | 0) * a3;
          c2 -= l3 & 67108863, b5 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u2 + h3] = c2 & 67108863;
        }
        for (;u2 < this.length - h3; u2++)
          c2 = (this.words[u2 + h3] | 0) + b5, b5 = c2 >> 26, this.words[u2 + h3] = c2 & 67108863;
        if (b5 === 0)
          return this.strip();
        for (r(b5 === -1), b5 = 0, u2 = 0;u2 < this.length; u2++)
          c2 = -(this.words[u2] | 0) + b5, b5 = c2 >> 26, this.words[u2] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a3) {
        var h3 = this.length - i.length, s3 = this.clone(), u2 = i, c2 = u2.words[u2.length - 1] | 0, b5 = this._countBits(c2);
        h3 = 26 - b5, h3 !== 0 && (u2 = u2.ushln(h3), s3.iushln(h3), c2 = u2.words[u2.length - 1] | 0);
        var l3 = s3.length - u2.length, n;
        if (a3 !== "mod") {
          n = new f2(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d3 = 0;d3 < n.length; d3++)
            n.words[d3] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u2, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g3 = l3 - 1;g3 >= 0; g3--) {
          var _3 = (s3.words[u2.length + g3] | 0) * 67108864 + (s3.words[u2.length + g3 - 1] | 0);
          for (_3 = Math.min(_3 / c2 | 0, 67108863), s3._ishlnsubmul(u2, _3, g3);s3.negative !== 0; )
            _3--, s3.negative = 0, s3._ishlnsubmul(u2, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _3);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a3, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u2, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.iadd(i)), { div: s3, mod: u2 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.isub(i)), { div: c2.div, mod: u2 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h3 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u2 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u2 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a3 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a3 * 67108864;
          this.words[h3] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = new f2(0), b5 = new f2(1), l3 = 0;a3.isEven() && h3.isEven(); )
          a3.iushrn(1), h3.iushrn(1), ++l3;
        for (var n = h3.clone(), d3 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g3 = 1;(a3.words[0] & g3) === 0 && w3 < 26; ++w3, g3 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u2.isOdd()) && (s3.iadd(n), u2.isub(d3)), s3.iushrn(1), u2.iushrn(1);
          for (var _3 = 0, A3 = 1;(h3.words[0] & A3) === 0 && _3 < 26; ++_3, A3 <<= 1)
            ;
          if (_3 > 0)
            for (h3.iushrn(_3);_3-- > 0; )
              (c2.isOdd() || b5.isOdd()) && (c2.iadd(n), b5.isub(d3)), c2.iushrn(1), b5.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(c2), u2.isub(b5)) : (h3.isub(a3), c2.isub(s3), b5.isub(u2));
        }
        return { a: c2, b: b5, gcd: h3.iushln(l3) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = h3.clone();a3.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b5 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b5 < 26; ++b5, l3 <<= 1)
            ;
          if (b5 > 0)
            for (a3.iushrn(b5);b5-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d3 = 1;(h3.words[0] & d3) === 0 && n < 26; ++n, d3 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u2.isOdd() && u2.iadd(c2), u2.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(u2)) : (h3.isub(a3), u2.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u2, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h3 = i.clone();
        a3.negative = 0, h3.negative = 0;
        for (var s3 = 0;a3.isEven() && h3.isEven(); s3++)
          a3.iushrn(1), h3.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u2 = a3.cmp(h3);
          if (u2 < 0) {
            var c2 = a3;
            a3 = h3, h3 = c2;
          } else if (u2 === 0 || h3.cmpn(1) === 0)
            break;
          a3.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u2 = s3, c2 = h3;u2 !== 0 && c2 < this.length; c2++) {
          var b5 = this.words[c2] | 0;
          b5 += u2, u2 = b5 >>> 26, b5 &= 67108863, this.words[c2] = b5;
        }
        return u2 !== 0 && (this.words[c2] = u2, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u2 = i.words[h3] | 0;
          if (s3 !== u2) {
            s3 < u2 ? a3 = -1 : s3 > u2 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a3 = i, h3;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h3 = a3.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe, ye), xe.prototype.split = function(i, a3) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u2 = 0;u2 < s3; u2++)
          a3.words[u2] = i.words[u2];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h3, u2 = 10;u2 < i.length; u2++) {
          var b5 = i.words[u2] | 0;
          i.words[u2 - 10] = (b5 & h3) << 4 | c2 >>> 22, c2 = b5;
        }
        c2 >>>= 22, i.words[u2 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a3 += s3 * 977, i.words[h3] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a3, u2 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u2, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.add(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.iadd(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.sub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.isub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P2.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P2.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u2 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u2++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b5 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l3).cmp(b5) !== 0; )
          n.redIAdd(b5);
        for (var d3 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _3 = u2;g3.cmp(c2) !== 0; ) {
          for (var A3 = g3, R2 = 0;A3.cmp(c2) !== 0; R2++)
            A3 = A3.redSqr();
          r(R2 < _3);
          var I4 = this.pow(d3, new f2(1).iushln(_3 - R2 - 1));
          w3 = w3.redMul(I4), d3 = I4.redSqr(), g3 = g3.redMul(d3), _3 = R2;
        }
        return w3;
      }, P2.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P2.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f2(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u2 = 2;u2 < s3.length; u2++)
          s3[u2] = this.mul(s3[u2 - 1], i);
        var c2 = s3[0], b5 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u2 = a3.length - 1;u2 >= 0; u2--) {
          for (var d3 = a3.words[u2], w3 = n - 1;w3 >= 0; w3--) {
            var g3 = d3 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b5 === 0) {
              l3 = 0;
              continue;
            }
            b5 <<= 1, b5 |= g3, l3++, !(l3 !== h3 && (u2 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b5]), l3 = 0, b5 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P2.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f2.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v2) {
        P2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P2), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof ed > "u" || ed, ky);
  });
  h0 = T((Yk, Ly) => {
    var s0 = Ut2(), Ff = s0.Buffer, Er4 = {}, Ar2;
    for (Ar2 in s0)
      !s0.hasOwnProperty(Ar2) || Ar2 === "SlowBuffer" || Ar2 === "Buffer" || (Er4[Ar2] = s0[Ar2]);
    var Uf = Er4.Buffer = {};
    for (Ar2 in Ff)
      !Ff.hasOwnProperty(Ar2) || Ar2 === "allocUnsafe" || Ar2 === "allocUnsafeSlow" || (Uf[Ar2] = Ff[Ar2]);
    Er4.Buffer.prototype = Ff.prototype;
    (!Uf.from || Uf.from === Uint8Array.from) && (Uf.from = function(t, e, r) {
      if (typeof t == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof t);
      if (t && typeof t.length > "u")
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
      return Ff(t, e, r);
    });
    Uf.alloc || (Uf.alloc = function(t, e, r) {
      if (typeof t != "number")
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof t);
      if (t < 0 || t >= 2 * (1 << 30))
        throw new RangeError('The value "' + t + '" is invalid for option "size"');
      var o2 = Ff(t);
      return !e || e.length === 0 ? o2.fill(0) : typeof r == "string" ? o2.fill(e, r) : o2.fill(e), o2;
    });
    if (!Er4.kStringMaxLength)
      try {
        Er4.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch {}
    Er4.constants || (Er4.constants = { MAX_LENGTH: Er4.kMaxLength }, Er4.kStringMaxLength && (Er4.constants.MAX_STRING_LENGTH = Er4.kStringMaxLength));
    Ly.exports = Er4;
  });
  u0 = T((Ny) => {
    var aB = Ie();
    function Rr3(t) {
      this._reporterState = { obj: null, path: [], options: t || {}, errors: [] };
    }
    Ny.Reporter = Rr3;
    Rr3.prototype.isError = function(e) {
      return e instanceof zf;
    };
    Rr3.prototype.save = function() {
      let e = this._reporterState;
      return { obj: e.obj, pathLen: e.path.length };
    };
    Rr3.prototype.restore = function(e) {
      let r = this._reporterState;
      r.obj = e.obj, r.path = r.path.slice(0, e.pathLen);
    };
    Rr3.prototype.enterKey = function(e) {
      return this._reporterState.path.push(e);
    };
    Rr3.prototype.exitKey = function(e) {
      let r = this._reporterState;
      r.path = r.path.slice(0, e - 1);
    };
    Rr3.prototype.leaveKey = function(e, r, o2) {
      let f2 = this._reporterState;
      this.exitKey(e), f2.obj !== null && (f2.obj[r] = o2);
    };
    Rr3.prototype.path = function() {
      return this._reporterState.path.join("/");
    };
    Rr3.prototype.enterObject = function() {
      let e = this._reporterState, r = e.obj;
      return e.obj = {}, r;
    };
    Rr3.prototype.leaveObject = function(e) {
      let r = this._reporterState, o2 = r.obj;
      return r.obj = e, o2;
    };
    Rr3.prototype.error = function(e) {
      let r, o2 = this._reporterState, f2 = e instanceof zf;
      if (f2 ? r = e : r = new zf(o2.path.map(function(p3) {
        return "[" + JSON.stringify(p3) + "]";
      }).join(""), e.message || e, e.stack), !o2.options.partial)
        throw r;
      return f2 || o2.errors.push(r), r;
    };
    Rr3.prototype.wrapResult = function(e) {
      let r = this._reporterState;
      return r.options.partial ? { result: this.isError(e) ? null : e, errors: r.errors } : e;
    };
    function zf(t, e) {
      this.path = t, this.rethrow(e);
    }
    aB(zf, Error);
    zf.prototype.rethrow = function(e) {
      if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, zf), !this.stack)
        try {
          throw new Error(this.message);
        } catch (r) {
          this.stack = r.stack;
        }
      return this;
    };
  });
  Kf = T((rd) => {
    var oB = Ie(), l0 = u0().Reporter, Hf = h0().Buffer;
    function Br2(t, e) {
      if (l0.call(this, e), !Hf.isBuffer(t)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = t, this.offset = 0, this.length = t.length;
    }
    oB(Br2, l0);
    rd.DecoderBuffer = Br2;
    Br2.isDecoderBuffer = function(e) {
      return e instanceof Br2 ? true : typeof e == "object" && Hf.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
    };
    Br2.prototype.save = function() {
      return { offset: this.offset, reporter: l0.prototype.save.call(this) };
    };
    Br2.prototype.restore = function(e) {
      let r = new Br2(this.base);
      return r.offset = e.offset, r.length = this.offset, this.offset = e.offset, l0.prototype.restore.call(this, e.reporter), r;
    };
    Br2.prototype.isEmpty = function() {
      return this.offset === this.length;
    };
    Br2.prototype.readUInt8 = function(e) {
      return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(e || "DecoderBuffer overrun");
    };
    Br2.prototype.skip = function(e, r) {
      if (!(this.offset + e <= this.length))
        return this.error(r || "DecoderBuffer overrun");
      let o2 = new Br2(this.base);
      return o2._reporterState = this._reporterState, o2.offset = this.offset, o2.length = this.offset + e, this.offset += e, o2;
    };
    Br2.prototype.raw = function(e) {
      return this.base.slice(e ? e.offset : this.offset, this.length);
    };
    function Wf(t, e) {
      if (Array.isArray(t))
        this.length = 0, this.value = t.map(function(r) {
          return Wf.isEncoderBuffer(r) || (r = new Wf(r, e)), this.length += r.length, r;
        }, this);
      else if (typeof t == "number") {
        if (!(0 <= t && t <= 255))
          return e.error("non-byte EncoderBuffer value");
        this.value = t, this.length = 1;
      } else if (typeof t == "string")
        this.value = t, this.length = Hf.byteLength(t);
      else if (Hf.isBuffer(t))
        this.value = t, this.length = t.length;
      else
        return e.error("Unsupported type: " + typeof t);
    }
    rd.EncoderBuffer = Wf;
    Wf.isEncoderBuffer = function(e) {
      return e instanceof Wf ? true : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
    };
    Wf.prototype.join = function(e, r) {
      return e || (e = Hf.alloc(this.length)), r || (r = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o2) {
        o2.join(e, r), r += o2.length;
      }) : (typeof this.value == "number" ? e[r] = this.value : typeof this.value == "string" ? e.write(this.value, r) : Hf.isBuffer(this.value) && this.value.copy(e, r), r += this.length)), e;
    };
  });
  d0 = T((Qk, Py) => {
    var sB = u0().Reporter, hB = Kf().EncoderBuffer, uB = Kf().DecoderBuffer, Qt2 = ar2(), Dy = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"], lB = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(Dy), dB = ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"];
    function Ue(t, e, r) {
      let o2 = {};
      this._baseState = o2, o2.name = r, o2.enc = t, o2.parent = e || null, o2.children = null, o2.tag = null, o2.args = null, o2.reverseArgs = null, o2.choice = null, o2.optional = false, o2.any = false, o2.obj = false, o2.use = null, o2.useDecoder = null, o2.key = null, o2.default = null, o2.explicit = null, o2.implicit = null, o2.contains = null, o2.parent || (o2.children = [], this._wrap());
    }
    Py.exports = Ue;
    var cB = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
    Ue.prototype.clone = function() {
      let e = this._baseState, r = {};
      cB.forEach(function(f2) {
        r[f2] = e[f2];
      });
      let o2 = new this.constructor(r.parent);
      return o2._baseState = r, o2;
    };
    Ue.prototype._wrap = function() {
      let e = this._baseState;
      lB.forEach(function(r) {
        this[r] = function() {
          let f2 = new this.constructor(this);
          return e.children.push(f2), f2[r].apply(f2, arguments);
        };
      }, this);
    };
    Ue.prototype._init = function(e) {
      let r = this._baseState;
      Qt2(r.parent === null), e.call(this), r.children = r.children.filter(function(o2) {
        return o2._baseState.parent === this;
      }, this), Qt2.equal(r.children.length, 1, "Root node can have only one child");
    };
    Ue.prototype._useArgs = function(e) {
      let r = this._baseState, o2 = e.filter(function(f2) {
        return f2 instanceof this.constructor;
      }, this);
      e = e.filter(function(f2) {
        return !(f2 instanceof this.constructor);
      }, this), o2.length !== 0 && (Qt2(r.children === null), r.children = o2, o2.forEach(function(f2) {
        f2._baseState.parent = this;
      }, this)), e.length !== 0 && (Qt2(r.args === null), r.args = e, r.reverseArgs = e.map(function(f2) {
        if (typeof f2 != "object" || f2.constructor !== Object)
          return f2;
        let p3 = {};
        return Object.keys(f2).forEach(function(m4) {
          m4 == (m4 | 0) && (m4 |= 0);
          let y3 = f2[m4];
          p3[y3] = m4;
        }), p3;
      }));
    };
    dB.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState;
        throw new Error(t + " not implemented for encoding: " + r.enc);
      };
    });
    Dy.forEach(function(t) {
      Ue.prototype[t] = function() {
        let r = this._baseState, o2 = Array.prototype.slice.call(arguments);
        return Qt2(r.tag === null), r.tag = t, this._useArgs(o2), this;
      };
    });
    Ue.prototype.use = function(e) {
      Qt2(e);
      let r = this._baseState;
      return Qt2(r.use === null), r.use = e, this;
    };
    Ue.prototype.optional = function() {
      let e = this._baseState;
      return e.optional = true, this;
    };
    Ue.prototype.def = function(e) {
      let r = this._baseState;
      return Qt2(r.default === null), r.default = e, r.optional = true, this;
    };
    Ue.prototype.explicit = function(e) {
      let r = this._baseState;
      return Qt2(r.explicit === null && r.implicit === null), r.explicit = e, this;
    };
    Ue.prototype.implicit = function(e) {
      let r = this._baseState;
      return Qt2(r.explicit === null && r.implicit === null), r.implicit = e, this;
    };
    Ue.prototype.obj = function() {
      let e = this._baseState, r = Array.prototype.slice.call(arguments);
      return e.obj = true, r.length !== 0 && this._useArgs(r), this;
    };
    Ue.prototype.key = function(e) {
      let r = this._baseState;
      return Qt2(r.key === null), r.key = e, this;
    };
    Ue.prototype.any = function() {
      let e = this._baseState;
      return e.any = true, this;
    };
    Ue.prototype.choice = function(e) {
      let r = this._baseState;
      return Qt2(r.choice === null), r.choice = e, this._useArgs(Object.keys(e).map(function(o2) {
        return e[o2];
      })), this;
    };
    Ue.prototype.contains = function(e) {
      let r = this._baseState;
      return Qt2(r.use === null), r.contains = e, this;
    };
    Ue.prototype._decode = function(e, r) {
      let o2 = this._baseState;
      if (o2.parent === null)
        return e.wrapResult(o2.children[0]._decode(e, r));
      let f2 = o2.default, p3 = true, m4 = null;
      if (o2.key !== null && (m4 = e.enterKey(o2.key)), o2.optional) {
        let M4 = null;
        if (o2.explicit !== null ? M4 = o2.explicit : o2.implicit !== null ? M4 = o2.implicit : o2.tag !== null && (M4 = o2.tag), M4 === null && !o2.any) {
          let x3 = e.save();
          try {
            o2.choice === null ? this._decodeGeneric(o2.tag, e, r) : this._decodeChoice(e, r), p3 = true;
          } catch {
            p3 = false;
          }
          e.restore(x3);
        } else if (p3 = this._peekTag(e, M4, o2.any), e.isError(p3))
          return p3;
      }
      let y3;
      if (o2.obj && p3 && (y3 = e.enterObject()), p3) {
        if (o2.explicit !== null) {
          let x3 = this._decodeTag(e, o2.explicit);
          if (e.isError(x3))
            return x3;
          e = x3;
        }
        let M4 = e.offset;
        if (o2.use === null && o2.choice === null) {
          let x3;
          o2.any && (x3 = e.save());
          let S2 = this._decodeTag(e, o2.implicit !== null ? o2.implicit : o2.tag, o2.any);
          if (e.isError(S2))
            return S2;
          o2.any ? f2 = e.raw(x3) : e = S2;
        }
        if (r && r.track && o2.tag !== null && r.track(e.path(), M4, e.length, "tagged"), r && r.track && o2.tag !== null && r.track(e.path(), e.offset, e.length, "content"), o2.any || (o2.choice === null ? f2 = this._decodeGeneric(o2.tag, e, r) : f2 = this._decodeChoice(e, r)), e.isError(f2))
          return f2;
        if (!o2.any && o2.choice === null && o2.children !== null && o2.children.forEach(function(S2) {
          S2._decode(e, r);
        }), o2.contains && (o2.tag === "octstr" || o2.tag === "bitstr")) {
          let x3 = new uB(f2);
          f2 = this._getUse(o2.contains, e._reporterState.obj)._decode(x3, r);
        }
      }
      return o2.obj && p3 && (f2 = e.leaveObject(y3)), o2.key !== null && (f2 !== null || p3 === true) ? e.leaveKey(m4, o2.key, f2) : m4 !== null && e.exitKey(m4), f2;
    };
    Ue.prototype._decodeGeneric = function(e, r, o2) {
      let f2 = this._baseState;
      return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(r, e, f2.args[0], o2) : /str$/.test(e) ? this._decodeStr(r, e, o2) : e === "objid" && f2.args ? this._decodeObjid(r, f2.args[0], f2.args[1], o2) : e === "objid" ? this._decodeObjid(r, null, null, o2) : e === "gentime" || e === "utctime" ? this._decodeTime(r, e, o2) : e === "null_" ? this._decodeNull(r, o2) : e === "bool" ? this._decodeBool(r, o2) : e === "objDesc" ? this._decodeStr(r, e, o2) : e === "int" || e === "enum" ? this._decodeInt(r, f2.args && f2.args[0], o2) : f2.use !== null ? this._getUse(f2.use, r._reporterState.obj)._decode(r, o2) : r.error("unknown tag: " + e);
    };
    Ue.prototype._getUse = function(e, r) {
      let o2 = this._baseState;
      return o2.useDecoder = this._use(e, r), Qt2(o2.useDecoder._baseState.parent === null), o2.useDecoder = o2.useDecoder._baseState.children[0], o2.implicit !== o2.useDecoder._baseState.implicit && (o2.useDecoder = o2.useDecoder.clone(), o2.useDecoder._baseState.implicit = o2.implicit), o2.useDecoder;
    };
    Ue.prototype._decodeChoice = function(e, r) {
      let o2 = this._baseState, f2 = null, p3 = false;
      return Object.keys(o2.choice).some(function(m4) {
        let y3 = e.save(), M4 = o2.choice[m4];
        try {
          let x3 = M4._decode(e, r);
          if (e.isError(x3))
            return false;
          f2 = { type: m4, value: x3 }, p3 = true;
        } catch {
          return e.restore(y3), false;
        }
        return true;
      }, this), p3 ? f2 : e.error("Choice not matched");
    };
    Ue.prototype._createEncoderBuffer = function(e) {
      return new hB(e, this.reporter);
    };
    Ue.prototype._encode = function(e, r, o2) {
      let f2 = this._baseState;
      if (f2.default !== null && f2.default === e)
        return;
      let p3 = this._encodeValue(e, r, o2);
      if (p3 !== undefined && !this._skipDefault(p3, r, o2))
        return p3;
    };
    Ue.prototype._encodeValue = function(e, r, o2) {
      let f2 = this._baseState;
      if (f2.parent === null)
        return f2.children[0]._encode(e, r || new sB);
      let p3 = null;
      if (this.reporter = r, f2.optional && e === undefined)
        if (f2.default !== null)
          e = f2.default;
        else
          return;
      let m4 = null, y3 = false;
      if (f2.any)
        p3 = this._createEncoderBuffer(e);
      else if (f2.choice)
        p3 = this._encodeChoice(e, r);
      else if (f2.contains)
        m4 = this._getUse(f2.contains, o2)._encode(e, r), y3 = true;
      else if (f2.children)
        m4 = f2.children.map(function(M4) {
          if (M4._baseState.tag === "null_")
            return M4._encode(null, r, e);
          if (M4._baseState.key === null)
            return r.error("Child should have a key");
          let x3 = r.enterKey(M4._baseState.key);
          if (typeof e != "object")
            return r.error("Child expected, but input is not object");
          let S2 = M4._encode(e[M4._baseState.key], r, e);
          return r.leaveKey(x3), S2;
        }, this).filter(function(M4) {
          return M4;
        }), m4 = this._createEncoderBuffer(m4);
      else if (f2.tag === "seqof" || f2.tag === "setof") {
        if (!(f2.args && f2.args.length === 1))
          return r.error("Too many args for : " + f2.tag);
        if (!Array.isArray(e))
          return r.error("seqof/setof, but data is not Array");
        let M4 = this.clone();
        M4._baseState.implicit = null, m4 = this._createEncoderBuffer(e.map(function(x3) {
          let S2 = this._baseState;
          return this._getUse(S2.args[0], e)._encode(x3, r);
        }, M4));
      } else
        f2.use !== null ? p3 = this._getUse(f2.use, o2)._encode(e, r) : (m4 = this._encodePrimitive(f2.tag, e), y3 = true);
      if (!f2.any && f2.choice === null) {
        let M4 = f2.implicit !== null ? f2.implicit : f2.tag, x3 = f2.implicit === null ? "universal" : "context";
        M4 === null ? f2.use === null && r.error("Tag could be omitted only for .use()") : f2.use === null && (p3 = this._encodeComposite(M4, y3, x3, m4));
      }
      return f2.explicit !== null && (p3 = this._encodeComposite(f2.explicit, false, "context", p3)), p3;
    };
    Ue.prototype._encodeChoice = function(e, r) {
      let o2 = this._baseState, f2 = o2.choice[e.type];
      return f2 || Qt2(false, e.type + " not found in " + JSON.stringify(Object.keys(o2.choice))), f2._encode(e.value, r);
    };
    Ue.prototype._encodePrimitive = function(e, r) {
      let o2 = this._baseState;
      if (/str$/.test(e))
        return this._encodeStr(r, e);
      if (e === "objid" && o2.args)
        return this._encodeObjid(r, o2.reverseArgs[0], o2.args[1]);
      if (e === "objid")
        return this._encodeObjid(r, null, null);
      if (e === "gentime" || e === "utctime")
        return this._encodeTime(r, e);
      if (e === "null_")
        return this._encodeNull();
      if (e === "int" || e === "enum")
        return this._encodeInt(r, o2.args && o2.reverseArgs[0]);
      if (e === "bool")
        return this._encodeBool(r);
      if (e === "objDesc")
        return this._encodeStr(r, e);
      throw new Error("Unsupported tag: " + e);
    };
    Ue.prototype._isNumstr = function(e) {
      return /^[0-9 ]*$/.test(e);
    };
    Ue.prototype._isPrintstr = function(e) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
    };
  });
  c0 = T((Wn) => {
    function Cy(t) {
      let e = {};
      return Object.keys(t).forEach(function(r) {
        (r | 0) == r && (r = r | 0);
        let o2 = t[r];
        e[o2] = r;
      }), e;
    }
    Wn.tagClass = { 0: "universal", 1: "application", 2: "context", 3: "private" };
    Wn.tagClassByName = Cy(Wn.tagClass);
    Wn.tag = { 0: "end", 1: "bool", 2: "int", 3: "bitstr", 4: "octstr", 5: "null_", 6: "objid", 7: "objDesc", 8: "external", 9: "real", 10: "enum", 11: "embed", 12: "utf8str", 13: "relativeOid", 16: "seq", 17: "set", 18: "numstr", 19: "printstr", 20: "t61str", 21: "videostr", 22: "ia5str", 23: "utctime", 24: "gentime", 25: "graphstr", 26: "iso646str", 27: "genstr", 28: "unistr", 29: "charstr", 30: "bmpstr" };
    Wn.tagByName = Cy(Wn.tag);
  });
  nd = T((tL, Uy) => {
    var pB = Ie(), Ii2 = h0().Buffer, Oy = d0(), id = c0();
    function Fy(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new Ur2, this.tree._init(t.body);
    }
    Uy.exports = Fy;
    Fy.prototype.encode = function(e, r) {
      return this.tree._encode(e, r).join();
    };
    function Ur2(t) {
      Oy.call(this, "der", t);
    }
    pB(Ur2, Oy);
    Ur2.prototype._encodeComposite = function(e, r, o2, f2) {
      let p3 = vB(e, r, o2, this.reporter);
      if (f2.length < 128) {
        let M4 = Ii2.alloc(2);
        return M4[0] = p3, M4[1] = f2.length, this._createEncoderBuffer([M4, f2]);
      }
      let m4 = 1;
      for (let M4 = f2.length;M4 >= 256; M4 >>= 8)
        m4++;
      let y3 = Ii2.alloc(1 + 1 + m4);
      y3[0] = p3, y3[1] = 128 | m4;
      for (let M4 = 1 + m4, x3 = f2.length;x3 > 0; M4--, x3 >>= 8)
        y3[M4] = x3 & 255;
      return this._createEncoderBuffer([y3, f2]);
    };
    Ur2.prototype._encodeStr = function(e, r) {
      if (r === "bitstr")
        return this._createEncoderBuffer([e.unused | 0, e.data]);
      if (r === "bmpstr") {
        let o2 = Ii2.alloc(e.length * 2);
        for (let f2 = 0;f2 < e.length; f2++)
          o2.writeUInt16BE(e.charCodeAt(f2), f2 * 2);
        return this._createEncoderBuffer(o2);
      } else
        return r === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : r === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(r) ? this._createEncoderBuffer(e) : r === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + r + " unsupported");
    };
    Ur2.prototype._encodeObjid = function(e, r, o2) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("string objid given, but no values map found");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("objid not found in values map");
        e = r[e].split(/[\s.]+/g);
        for (let y3 = 0;y3 < e.length; y3++)
          e[y3] |= 0;
      } else if (Array.isArray(e)) {
        e = e.slice();
        for (let y3 = 0;y3 < e.length; y3++)
          e[y3] |= 0;
      }
      if (!Array.isArray(e))
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
      if (!o2) {
        if (e[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        e.splice(0, 2, e[0] * 40 + e[1]);
      }
      let f2 = 0;
      for (let y3 = 0;y3 < e.length; y3++) {
        let M4 = e[y3];
        for (f2++;M4 >= 128; M4 >>= 7)
          f2++;
      }
      let p3 = Ii2.alloc(f2), m4 = p3.length - 1;
      for (let y3 = e.length - 1;y3 >= 0; y3--) {
        let M4 = e[y3];
        for (p3[m4--] = M4 & 127;(M4 >>= 7) > 0; )
          p3[m4--] = 128 | M4 & 127;
      }
      return this._createEncoderBuffer(p3);
    };
    function qr3(t) {
      return t < 10 ? "0" + t : t;
    }
    Ur2.prototype._encodeTime = function(e, r) {
      let o2, f2 = new Date(e);
      return r === "gentime" ? o2 = [qr3(f2.getUTCFullYear()), qr3(f2.getUTCMonth() + 1), qr3(f2.getUTCDate()), qr3(f2.getUTCHours()), qr3(f2.getUTCMinutes()), qr3(f2.getUTCSeconds()), "Z"].join("") : r === "utctime" ? o2 = [qr3(f2.getUTCFullYear() % 100), qr3(f2.getUTCMonth() + 1), qr3(f2.getUTCDate()), qr3(f2.getUTCHours()), qr3(f2.getUTCMinutes()), qr3(f2.getUTCSeconds()), "Z"].join("") : this.reporter.error("Encoding " + r + " time is not supported yet"), this._encodeStr(o2, "octstr");
    };
    Ur2.prototype._encodeNull = function() {
      return this._createEncoderBuffer("");
    };
    Ur2.prototype._encodeInt = function(e, r) {
      if (typeof e == "string") {
        if (!r)
          return this.reporter.error("String int or enum given, but no values map");
        if (!r.hasOwnProperty(e))
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
        e = r[e];
      }
      if (typeof e != "number" && !Ii2.isBuffer(e)) {
        let p3 = e.toArray();
        !e.sign && p3[0] & 128 && p3.unshift(0), e = Ii2.from(p3);
      }
      if (Ii2.isBuffer(e)) {
        let p3 = e.length;
        e.length === 0 && p3++;
        let m4 = Ii2.alloc(p3);
        return e.copy(m4), e.length === 0 && (m4[0] = 0), this._createEncoderBuffer(m4);
      }
      if (e < 128)
        return this._createEncoderBuffer(e);
      if (e < 256)
        return this._createEncoderBuffer([0, e]);
      let o2 = 1;
      for (let p3 = e;p3 >= 256; p3 >>= 8)
        o2++;
      let f2 = new Array(o2);
      for (let p3 = f2.length - 1;p3 >= 0; p3--)
        f2[p3] = e & 255, e >>= 8;
      return f2[0] & 128 && f2.unshift(0), this._createEncoderBuffer(Ii2.from(f2));
    };
    Ur2.prototype._encodeBool = function(e) {
      return this._createEncoderBuffer(e ? 255 : 0);
    };
    Ur2.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getEncoder("der").tree;
    };
    Ur2.prototype._skipDefault = function(e, r, o2) {
      let f2 = this._baseState, p3;
      if (f2.default === null)
        return false;
      let m4 = e.join();
      if (f2.defaultBuffer === undefined && (f2.defaultBuffer = this._encodeValue(f2.default, r, o2).join()), m4.length !== f2.defaultBuffer.length)
        return false;
      for (p3 = 0;p3 < m4.length; p3++)
        if (m4[p3] !== f2.defaultBuffer[p3])
          return false;
      return true;
    };
    function vB(t, e, r, o2) {
      let f2;
      if (t === "seqof" ? t = "seq" : t === "setof" && (t = "set"), id.tagByName.hasOwnProperty(t))
        f2 = id.tagByName[t];
      else if (typeof t == "number" && (t | 0) === t)
        f2 = t;
      else
        return o2.error("Unknown tag: " + t);
      return f2 >= 31 ? o2.error("Multi-octet tag encoding unsupported") : (e || (f2 |= 32), f2 |= id.tagClassByName[r || "universal"] << 6, f2);
    }
  });
  Hy = T((rL, zy) => {
    var bB = Ie(), fd = nd();
    function ad(t) {
      fd.call(this, t), this.enc = "pem";
    }
    bB(ad, fd);
    zy.exports = ad;
    ad.prototype.encode = function(e, r) {
      let f2 = fd.prototype.encode.call(this, e).toString("base64"), p3 = ["-----BEGIN " + r.label + "-----"];
      for (let m4 = 0;m4 < f2.length; m4 += 64)
        p3.push(f2.slice(m4, m4 + 64));
      return p3.push("-----END " + r.label + "-----"), p3.join(`
`);
    };
  });
  od = T((Ky) => {
    var Wy = Ky;
    Wy.der = nd();
    Wy.pem = Hy();
  });
  hd = T((nL, Yy) => {
    var mB = Ie(), gB = td(), jy = Kf().DecoderBuffer, Vy = d0(), Zy = c0();
    function $y(t) {
      this.enc = "der", this.name = t.name, this.entity = t, this.tree = new sr, this.tree._init(t.body);
    }
    Yy.exports = $y;
    $y.prototype.decode = function(e, r) {
      return jy.isDecoderBuffer(e) || (e = new jy(e, r)), this.tree._decode(e, r);
    };
    function sr(t) {
      Vy.call(this, "der", t);
    }
    mB(sr, Vy);
    sr.prototype._peekTag = function(e, r, o2) {
      if (e.isEmpty())
        return false;
      let f2 = e.save(), p3 = sd(e, 'Failed to peek tag: "' + r + '"');
      return e.isError(p3) ? p3 : (e.restore(f2), p3.tag === r || p3.tagStr === r || p3.tagStr + "of" === r || o2);
    };
    sr.prototype._decodeTag = function(e, r, o2) {
      let f2 = sd(e, 'Failed to decode tag of "' + r + '"');
      if (e.isError(f2))
        return f2;
      let p3 = Gy(e, f2.primitive, 'Failed to get length of "' + r + '"');
      if (e.isError(p3))
        return p3;
      if (!o2 && f2.tag !== r && f2.tagStr !== r && f2.tagStr + "of" !== r)
        return e.error('Failed to match tag: "' + r + '"');
      if (f2.primitive || p3 !== null)
        return e.skip(p3, 'Failed to match body of: "' + r + '"');
      let m4 = e.save(), y3 = this._skipUntilEnd(e, 'Failed to skip indefinite length body: "' + this.tag + '"');
      return e.isError(y3) ? y3 : (p3 = e.offset - m4.offset, e.restore(m4), e.skip(p3, 'Failed to match body of: "' + r + '"'));
    };
    sr.prototype._skipUntilEnd = function(e, r) {
      for (;; ) {
        let o2 = sd(e, r);
        if (e.isError(o2))
          return o2;
        let f2 = Gy(e, o2.primitive, r);
        if (e.isError(f2))
          return f2;
        let p3;
        if (o2.primitive || f2 !== null ? p3 = e.skip(f2) : p3 = this._skipUntilEnd(e, r), e.isError(p3))
          return p3;
        if (o2.tagStr === "end")
          break;
      }
    };
    sr.prototype._decodeList = function(e, r, o2, f2) {
      let p3 = [];
      for (;!e.isEmpty(); ) {
        let m4 = this._peekTag(e, "end");
        if (e.isError(m4))
          return m4;
        let y3 = o2.decode(e, "der", f2);
        if (e.isError(y3) && m4)
          break;
        p3.push(y3);
      }
      return p3;
    };
    sr.prototype._decodeStr = function(e, r) {
      if (r === "bitstr") {
        let o2 = e.readUInt8();
        return e.isError(o2) ? o2 : { unused: o2, data: e.raw() };
      } else if (r === "bmpstr") {
        let o2 = e.raw();
        if (o2.length % 2 === 1)
          return e.error("Decoding of string type: bmpstr length mismatch");
        let f2 = "";
        for (let p3 = 0;p3 < o2.length / 2; p3++)
          f2 += String.fromCharCode(o2.readUInt16BE(p3 * 2));
        return f2;
      } else if (r === "numstr") {
        let o2 = e.raw().toString("ascii");
        return this._isNumstr(o2) ? o2 : e.error("Decoding of string type: numstr unsupported characters");
      } else {
        if (r === "octstr")
          return e.raw();
        if (r === "objDesc")
          return e.raw();
        if (r === "printstr") {
          let o2 = e.raw().toString("ascii");
          return this._isPrintstr(o2) ? o2 : e.error("Decoding of string type: printstr unsupported characters");
        } else
          return /str$/.test(r) ? e.raw().toString() : e.error("Decoding of string type: " + r + " unsupported");
      }
    };
    sr.prototype._decodeObjid = function(e, r, o2) {
      let f2, p3 = [], m4 = 0, y3 = 0;
      for (;!e.isEmpty(); )
        y3 = e.readUInt8(), m4 <<= 7, m4 |= y3 & 127, (y3 & 128) === 0 && (p3.push(m4), m4 = 0);
      y3 & 128 && p3.push(m4);
      let M4 = p3[0] / 40 | 0, x3 = p3[0] % 40;
      if (o2 ? f2 = p3 : f2 = [M4, x3].concat(p3.slice(1)), r) {
        let S2 = r[f2.join(" ")];
        S2 === undefined && (S2 = r[f2.join(".")]), S2 !== undefined && (f2 = S2);
      }
      return f2;
    };
    sr.prototype._decodeTime = function(e, r) {
      let o2 = e.raw().toString(), f2, p3, m4, y3, M4, x3;
      if (r === "gentime")
        f2 = o2.slice(0, 4) | 0, p3 = o2.slice(4, 6) | 0, m4 = o2.slice(6, 8) | 0, y3 = o2.slice(8, 10) | 0, M4 = o2.slice(10, 12) | 0, x3 = o2.slice(12, 14) | 0;
      else if (r === "utctime")
        f2 = o2.slice(0, 2) | 0, p3 = o2.slice(2, 4) | 0, m4 = o2.slice(4, 6) | 0, y3 = o2.slice(6, 8) | 0, M4 = o2.slice(8, 10) | 0, x3 = o2.slice(10, 12) | 0, f2 < 70 ? f2 = 2000 + f2 : f2 = 1900 + f2;
      else
        return e.error("Decoding " + r + " time is not supported yet");
      return Date.UTC(f2, p3 - 1, m4, y3, M4, x3, 0);
    };
    sr.prototype._decodeNull = function() {
      return null;
    };
    sr.prototype._decodeBool = function(e) {
      let r = e.readUInt8();
      return e.isError(r) ? r : r !== 0;
    };
    sr.prototype._decodeInt = function(e, r) {
      let o2 = e.raw(), f2 = new gB(o2);
      return r && (f2 = r[f2.toString(10)] || f2), f2;
    };
    sr.prototype._use = function(e, r) {
      return typeof e == "function" && (e = e(r)), e._getDecoder("der").tree;
    };
    function sd(t, e) {
      let r = t.readUInt8(e);
      if (t.isError(r))
        return r;
      let o2 = Zy.tagClass[r >> 6], f2 = (r & 32) === 0;
      if ((r & 31) === 31) {
        let m4 = r;
        for (r = 0;(m4 & 128) === 128; ) {
          if (m4 = t.readUInt8(e), t.isError(m4))
            return m4;
          r <<= 7, r |= m4 & 127;
        }
      } else
        r &= 31;
      let p3 = Zy.tag[r];
      return { cls: o2, primitive: f2, tag: r, tagStr: p3 };
    }
    function Gy(t, e, r) {
      let o2 = t.readUInt8(r);
      if (t.isError(o2))
        return o2;
      if (!e && o2 === 128)
        return null;
      if ((o2 & 128) === 0)
        return o2;
      let f2 = o2 & 127;
      if (f2 > 4)
        return t.error("length octect is too long");
      o2 = 0;
      for (let p3 = 0;p3 < f2; p3++) {
        o2 <<= 8;
        let m4 = t.readUInt8(r);
        if (t.isError(m4))
          return m4;
        o2 |= m4;
      }
      return o2;
    }
  });
  Jy = T((fL, Xy) => {
    var yB = Ie(), wB = h0().Buffer, ud = hd();
    function ld(t) {
      ud.call(this, t), this.enc = "pem";
    }
    yB(ld, ud);
    Xy.exports = ld;
    ld.prototype.decode = function(e, r) {
      let o2 = e.toString().split(/[\r\n]+/g), f2 = r.label.toUpperCase(), p3 = /^-----(BEGIN|END) ([^-]+)-----$/, m4 = -1, y3 = -1;
      for (let S2 = 0;S2 < o2.length; S2++) {
        let E6 = o2[S2].match(p3);
        if (E6 !== null && E6[2] === f2)
          if (m4 === -1) {
            if (E6[1] !== "BEGIN")
              break;
            m4 = S2;
          } else {
            if (E6[1] !== "END")
              break;
            y3 = S2;
            break;
          }
      }
      if (m4 === -1 || y3 === -1)
        throw new Error("PEM section not found for: " + f2);
      let M4 = o2.slice(m4 + 1, y3).join("");
      M4.replace(/[^a-z0-9+/=]+/gi, "");
      let x3 = wB.from(M4, "base64");
      return ud.prototype.decode.call(this, x3, r);
    };
  });
  dd = T((e3) => {
    var Qy = e3;
    Qy.der = hd();
    Qy.pem = Jy();
  });
  r3 = T((t3) => {
    var MB = od(), _B = dd(), xB = Ie(), SB = t3;
    SB.define = function(e, r) {
      return new jf(e, r);
    };
    function jf(t, e) {
      this.name = t, this.body = e, this.decoders = {}, this.encoders = {};
    }
    jf.prototype._createNamed = function(e) {
      let r = this.name;
      function o2(f2) {
        this._initNamed(f2, r);
      }
      return xB(o2, e), o2.prototype._initNamed = function(p3, m4) {
        e.call(this, p3, m4);
      }, new o2(this);
    };
    jf.prototype._getDecoder = function(e) {
      return e = e || "der", this.decoders.hasOwnProperty(e) || (this.decoders[e] = this._createNamed(_B[e])), this.decoders[e];
    };
    jf.prototype.decode = function(e, r, o2) {
      return this._getDecoder(r).decode(e, o2);
    };
    jf.prototype._getEncoder = function(e) {
      return e = e || "der", this.encoders.hasOwnProperty(e) || (this.encoders[e] = this._createNamed(MB[e])), this.encoders[e];
    };
    jf.prototype.encode = function(e, r, o2) {
      return this._getEncoder(r).encode(e, o2);
    };
  });
  n3 = T((i3) => {
    var p0 = i3;
    p0.Reporter = u0().Reporter;
    p0.DecoderBuffer = Kf().DecoderBuffer;
    p0.EncoderBuffer = Kf().EncoderBuffer;
    p0.Node = d0();
  });
  o3 = T((a3) => {
    var f3 = a3;
    f3._reverse = function(e) {
      let r = {};
      return Object.keys(e).forEach(function(o2) {
        (o2 | 0) == o2 && (o2 = o2 | 0);
        let f2 = e[o2];
        r[f2] = o2;
      }), r;
    };
    f3.der = c0();
  });
  cd = T((s3) => {
    var Zf = s3;
    Zf.bignum = td();
    Zf.define = r3().define;
    Zf.base = n3();
    Zf.constants = o3();
    Zf.decoders = dd();
    Zf.encoders = od();
  });
  d3 = T((lL, l3) => {
    var zr = cd(), h3 = zr.define("Time", function() {
      this.choice({ utcTime: this.utctime(), generalTime: this.gentime() });
    }), EB = zr.define("AttributeTypeValue", function() {
      this.seq().obj(this.key("type").objid(), this.key("value").any());
    }), pd = zr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
    }), AB = zr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(pd), this.key("subjectPublicKey").bitstr());
    }), RB = zr.define("RelativeDistinguishedName", function() {
      this.setof(EB);
    }), BB = zr.define("RDNSequence", function() {
      this.seqof(RB);
    }), u3 = zr.define("Name", function() {
      this.choice({ rdnSequence: this.use(BB) });
    }), qB = zr.define("Validity", function() {
      this.seq().obj(this.key("notBefore").use(h3), this.key("notAfter").use(h3));
    }), IB = zr.define("Extension", function() {
      this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
    }), TB = zr.define("TBSCertificate", function() {
      this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(pd), this.key("issuer").use(u3), this.key("validity").use(qB), this.key("subject").use(u3), this.key("subjectPublicKeyInfo").use(AB), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(IB).optional());
    }), kB = zr.define("X509Certificate", function() {
      this.seq().obj(this.key("tbsCertificate").use(TB), this.key("signatureAlgorithm").use(pd), this.key("signatureValue").bitstr());
    });
    l3.exports = kB;
  });
  p3 = T((Wr) => {
    var Hr = cd();
    Wr.certificate = d3();
    var LB = Hr.define("RSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
    });
    Wr.RSAPrivateKey = LB;
    var NB = Hr.define("RSAPublicKey", function() {
      this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
    });
    Wr.RSAPublicKey = NB;
    var DB = Hr.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(this.key("algorithm").use(c3), this.key("subjectPublicKey").bitstr());
    });
    Wr.PublicKey = DB;
    var c3 = Hr.define("AlgorithmIdentifier", function() {
      this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
    }), PB = Hr.define("PrivateKeyInfo", function() {
      this.seq().obj(this.key("version").int(), this.key("algorithm").use(c3), this.key("subjectPrivateKey").octstr());
    });
    Wr.PrivateKey = PB;
    var CB = Hr.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
    });
    Wr.EncryptedPrivateKey = CB;
    var OB = Hr.define("DSAPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
    });
    Wr.DSAPrivateKey = OB;
    Wr.DSAparam = Hr.define("DSAparam", function() {
      this.int();
    });
    var FB = Hr.define("ECPrivateKey", function() {
      this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(UB), this.key("publicKey").optional().explicit(1).bitstr());
    });
    Wr.ECPrivateKey = FB;
    var UB = Hr.define("ECParameters", function() {
      this.choice({ namedCurve: this.objid() });
    });
    Wr.signature = Hr.define("signature", function() {
      this.seq().obj(this.key("r").int(), this.key("s").int());
    });
  });
  v3 = T((cL, zB) => {
    zB.exports = { "2.16.840.1.101.3.4.1.1": "aes-128-ecb", "2.16.840.1.101.3.4.1.2": "aes-128-cbc", "2.16.840.1.101.3.4.1.3": "aes-128-ofb", "2.16.840.1.101.3.4.1.4": "aes-128-cfb", "2.16.840.1.101.3.4.1.21": "aes-192-ecb", "2.16.840.1.101.3.4.1.22": "aes-192-cbc", "2.16.840.1.101.3.4.1.23": "aes-192-ofb", "2.16.840.1.101.3.4.1.24": "aes-192-cfb", "2.16.840.1.101.3.4.1.41": "aes-256-ecb", "2.16.840.1.101.3.4.1.42": "aes-256-cbc", "2.16.840.1.101.3.4.1.43": "aes-256-ofb", "2.16.840.1.101.3.4.1.44": "aes-256-cfb" };
  });
  m32 = T((pL, b32) => {
    var HB = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, WB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, KB = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, jB = Ba(), ZB = Es(), v0 = Te().Buffer;
    b32.exports = function(t, e) {
      var r = t.toString(), o2 = r.match(HB), f2;
      if (o2) {
        var m4 = "aes" + o2[1], y3 = v0.from(o2[2], "hex"), M4 = v0.from(o2[3].replace(/[\r\n]/g, ""), "base64"), x3 = jB(e, y3.slice(0, 8), parseInt(o2[1], 10)).key, S2 = [], E6 = ZB.createDecipheriv(m4, x3, y3);
        S2.push(E6.update(M4)), S2.push(E6.final()), f2 = v0.concat(S2);
      } else {
        var p4 = r.match(KB);
        f2 = v0.from(p4[2].replace(/[\r\n]/g, ""), "base64");
      }
      var B3 = r.match(WB)[1];
      return { tag: B3, data: f2 };
    };
  });
  Ha = T((vL, y3) => {
    var fr = p3(), VB = v3(), $B = m32(), GB = Es(), YB = Iu(), vd = Te().Buffer;
    y3.exports = g3;
    function g3(t) {
      var e;
      typeof t == "object" && !vd.isBuffer(t) && (e = t.passphrase, t = t.key), typeof t == "string" && (t = vd.from(t));
      var r = $B(t, e), o2 = r.tag, f2 = r.data, p4, m4;
      switch (o2) {
        case "CERTIFICATE":
          m4 = fr.certificate.decode(f2, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
          switch (m4 || (m4 = fr.PublicKey.decode(f2, "der")), p4 = m4.algorithm.algorithm.join("."), p4) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPublicKey.decode(m4.subjectPublicKey.data, "der");
            case "1.2.840.10045.2.1":
              return m4.subjectPrivateKey = m4.subjectPublicKey, { type: "ec", data: m4 };
            case "1.2.840.10040.4.1":
              return m4.algorithm.params.pub_key = fr.DSAparam.decode(m4.subjectPublicKey.data, "der"), { type: "dsa", data: m4.algorithm.params };
            default:
              throw new Error("unknown key id " + p4);
          }
        case "ENCRYPTED PRIVATE KEY":
          f2 = fr.EncryptedPrivateKey.decode(f2, "der"), f2 = XB(f2, e);
        case "PRIVATE KEY":
          switch (m4 = fr.PrivateKey.decode(f2, "der"), p4 = m4.algorithm.algorithm.join("."), p4) {
            case "1.2.840.113549.1.1.1":
              return fr.RSAPrivateKey.decode(m4.subjectPrivateKey, "der");
            case "1.2.840.10045.2.1":
              return { curve: m4.algorithm.curve, privateKey: fr.ECPrivateKey.decode(m4.subjectPrivateKey, "der").privateKey };
            case "1.2.840.10040.4.1":
              return m4.algorithm.params.priv_key = fr.DSAparam.decode(m4.subjectPrivateKey, "der"), { type: "dsa", params: m4.algorithm.params };
            default:
              throw new Error("unknown key id " + p4);
          }
        case "RSA PUBLIC KEY":
          return fr.RSAPublicKey.decode(f2, "der");
        case "RSA PRIVATE KEY":
          return fr.RSAPrivateKey.decode(f2, "der");
        case "DSA PRIVATE KEY":
          return { type: "dsa", params: fr.DSAPrivateKey.decode(f2, "der") };
        case "EC PRIVATE KEY":
          return f2 = fr.ECPrivateKey.decode(f2, "der"), { curve: f2.parameters.value, privateKey: f2.privateKey };
        default:
          throw new Error("unknown key type " + o2);
      }
    }
    g3.signature = fr.signature;
    function XB(t, e) {
      var r = t.algorithm.decrypt.kde.kdeparams.salt, o2 = parseInt(t.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), f2 = VB[t.algorithm.decrypt.cipher.algo.join(".")], p4 = t.algorithm.decrypt.cipher.iv, m4 = t.subjectPrivateKey, y4 = parseInt(f2.split("-")[1], 10) / 8, M4 = YB.pbkdf2Sync(e, r, o2, y4, "sha1"), x3 = GB.createDecipheriv(f2, M4, p4), S2 = [];
      return S2.push(x3.update(m4)), S2.push(x3.final()), vd.concat(S2);
    }
  });
  bd = T((bL, JB) => {
    JB.exports = { "1.3.132.0.10": "secp256k1", "1.3.132.0.33": "p224", "1.2.840.10045.3.1.1": "p192", "1.2.840.10045.3.1.7": "p256", "1.3.132.0.34": "p384", "1.3.132.0.35": "p521" };
  });
  _3 = T((mL, m0) => {
    var Yt = Te().Buffer, Kn = wu(), QB = Ks2(), eq = o0().ec, b0 = Ws2(), tq = Ha(), rq = bd();
    function iq(t, e, r, o2, f2) {
      var p4 = tq(e);
      if (p4.curve) {
        if (o2 !== "ecdsa" && o2 !== "ecdsa/rsa")
          throw new Error("wrong private key type");
        return nq(t, p4);
      } else if (p4.type === "dsa") {
        if (o2 !== "dsa")
          throw new Error("wrong private key type");
        return fq(t, p4, r);
      } else if (o2 !== "rsa" && o2 !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      t = Yt.concat([f2, t]);
      for (var m4 = p4.modulus.byteLength(), y3 = [0, 1];t.length + y3.length + 1 < m4; )
        y3.push(255);
      y3.push(0);
      for (var M4 = -1;++M4 < t.length; )
        y3.push(t[M4]);
      var x3 = QB(y3, p4);
      return x3;
    }
    function nq(t, e) {
      var r = rq[e.curve.join(".")];
      if (!r)
        throw new Error("unknown curve " + e.curve.join("."));
      var o2 = new eq(r), f2 = o2.keyFromPrivate(e.privateKey), p4 = f2.sign(t);
      return Yt.from(p4.toDER());
    }
    function fq(t, e, r) {
      for (var o2 = e.params.priv_key, f2 = e.params.p, p4 = e.params.q, m4 = e.params.g, y3 = new b0(0), M4, x3 = md(t, p4).mod(p4), S2 = false, E6 = w3(o2, p4, t, r);S2 === false; )
        M4 = M32(p4, E6, r), y3 = sq(m4, M4, f2, p4), S2 = M4.invm(p4).imul(x3.add(o2.mul(y3))).mod(p4), S2.cmpn(0) === 0 && (S2 = false, y3 = new b0(0));
      return aq(y3, S2);
    }
    function aq(t, e) {
      t = t.toArray(), e = e.toArray(), t[0] & 128 && (t = [0].concat(t)), e[0] & 128 && (e = [0].concat(e));
      var r = t.length + e.length + 4, o2 = [48, r, 2, t.length];
      return o2 = o2.concat(t, [2, e.length], e), Yt.from(o2);
    }
    function w3(t, e, r, o2) {
      if (t = Yt.from(t.toArray()), t.length < e.byteLength()) {
        var f2 = Yt.alloc(e.byteLength() - t.length);
        t = Yt.concat([f2, t]);
      }
      var p4 = r.length, m4 = oq(r, e), y3 = Yt.alloc(p4);
      y3.fill(1);
      var M4 = Yt.alloc(p4);
      return M4 = Kn(o2, M4).update(y3).update(Yt.from([0])).update(t).update(m4).digest(), y3 = Kn(o2, M4).update(y3).digest(), M4 = Kn(o2, M4).update(y3).update(Yt.from([1])).update(t).update(m4).digest(), y3 = Kn(o2, M4).update(y3).digest(), { k: M4, v: y3 };
    }
    function md(t, e) {
      var r = new b0(t), o2 = (t.length << 3) - e.bitLength();
      return o2 > 0 && r.ishrn(o2), r;
    }
    function oq(t, e) {
      t = md(t, e), t = t.mod(e);
      var r = Yt.from(t.toArray());
      if (r.length < e.byteLength()) {
        var o2 = Yt.alloc(e.byteLength() - r.length);
        r = Yt.concat([o2, r]);
      }
      return r;
    }
    function M32(t, e, r) {
      var o2, f2;
      do {
        for (o2 = Yt.alloc(0);o2.length * 8 < t.bitLength(); )
          e.v = Kn(r, e.k).update(e.v).digest(), o2 = Yt.concat([o2, e.v]);
        f2 = md(o2, t), e.k = Kn(r, e.k).update(e.v).update(Yt.from([0])).digest(), e.v = Kn(r, e.k).update(e.v).digest();
      } while (f2.cmp(t) !== -1);
      return f2;
    }
    function sq(t, e, r, o2) {
      return t.toRed(b0.mont(r)).redPow(e).fromRed().mod(o2);
    }
    m0.exports = iq;
    m0.exports.getKey = w3;
    m0.exports.makeKey = M32;
  });
  A3 = T((gL, E32) => {
    var gd = Te().Buffer, Wa = Ws2(), hq = o0().ec, S3 = Ha(), uq = bd();
    function lq(t, e, r, o2, f2) {
      var p4 = S3(r);
      if (p4.type === "ec") {
        if (o2 !== "ecdsa" && o2 !== "ecdsa/rsa")
          throw new Error("wrong public key type");
        return dq(t, e, p4);
      } else if (p4.type === "dsa") {
        if (o2 !== "dsa")
          throw new Error("wrong public key type");
        return cq(t, e, p4);
      } else if (o2 !== "rsa" && o2 !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      e = gd.concat([f2, e]);
      for (var m4 = p4.modulus.byteLength(), y3 = [1], M4 = 0;e.length + y3.length + 2 < m4; )
        y3.push(255), M4++;
      y3.push(0);
      for (var x4 = -1;++x4 < e.length; )
        y3.push(e[x4]);
      y3 = gd.from(y3);
      var S2 = Wa.mont(p4.modulus);
      t = new Wa(t).toRed(S2), t = t.redPow(new Wa(p4.publicExponent)), t = gd.from(t.fromRed().toArray());
      var E6 = M4 < 8 ? 1 : 0;
      for (m4 = Math.min(t.length, y3.length), t.length !== y3.length && (E6 = 1), x4 = -1;++x4 < m4; )
        E6 |= t[x4] ^ y3[x4];
      return E6 === 0;
    }
    function dq(t, e, r) {
      var o2 = uq[r.data.algorithm.curve.join(".")];
      if (!o2)
        throw new Error("unknown curve " + r.data.algorithm.curve.join("."));
      var f2 = new hq(o2), p4 = r.data.subjectPrivateKey.data;
      return f2.verify(e, t, p4);
    }
    function cq(t, e, r) {
      var o2 = r.data.p, f2 = r.data.q, p4 = r.data.g, m4 = r.data.pub_key, y3 = S3.signature.decode(t, "der"), M4 = y3.s, x4 = y3.r;
      x3(M4, f2), x3(x4, f2);
      var S2 = Wa.mont(o2), E6 = M4.invm(f2), B3 = p4.toRed(S2).redPow(new Wa(e).mul(E6).mod(f2)).fromRed().mul(m4.toRed(S2).redPow(x4.mul(E6).mod(f2)).fromRed()).mod(o2).mod(f2);
      return B3.cmp(x4) === 0;
    }
    function x3(t, e) {
      if (t.cmpn(0) <= 0)
        throw new Error("invalid sig");
      if (t.cmp(e) >= e)
        throw new Error("invalid sig");
    }
    E32.exports = lq;
  });
  k32 = T((yL, T3) => {
    var g0 = Te().Buffer, q3 = bf(), y0 = i2(), I32 = Ie(), pq = _3(), vq = A3(), jn2 = Mu();
    Object.keys(jn2).forEach(function(t) {
      jn2[t].id = g0.from(jn2[t].id, "hex"), jn2[t.toLowerCase()] = jn2[t];
    });
    function Ka(t) {
      y0.Writable.call(this);
      var e = jn2[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hashType = e.hash, this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I32(Ka, y0.Writable);
    Ka.prototype._write = function(e, r, o2) {
      this._hash.update(e), o2();
    };
    Ka.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    Ka.prototype.sign = function(e, r) {
      this.end();
      var o2 = this._hash.digest(), f2 = pq(o2, e, this._hashType, this._signType, this._tag);
      return r ? f2.toString(r) : f2;
    };
    function ja(t) {
      y0.Writable.call(this);
      var e = jn2[t];
      if (!e)
        throw new Error("Unknown message digest");
      this._hash = q3(e.hash), this._tag = e.id, this._signType = e.sign;
    }
    I32(ja, y0.Writable);
    ja.prototype._write = function(e, r, o2) {
      this._hash.update(e), o2();
    };
    ja.prototype.update = function(e, r) {
      return typeof e == "string" && (e = g0.from(e, r)), this._hash.update(e), this;
    };
    ja.prototype.verify = function(e, r, o2) {
      typeof r == "string" && (r = g0.from(r, o2)), this.end();
      var f2 = this._hash.digest();
      return vq(r, f2, e, this._signType, this._tag);
    };
    function R3(t) {
      return new Ka(t);
    }
    function B3(t) {
      return new ja(t);
    }
    T3.exports = { Sign: R3, Verify: B3, createSign: R3, createVerify: B3 };
  });
  N32 = T((L3, yd) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o2(v2, i) {
        v2.super_ = i;
        var a3 = function() {};
        a3.prototype = i.prototype, v2.prototype = new a3, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a3) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v2 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p4;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p4 = window.Buffer : p4 = ji2().Buffer;
      } catch {}
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f2.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f2.prototype._init = function(i, a3, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h3);
        if (typeof i == "object")
          return this._initArray(i, a3, h3);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a3, s3), h3 === "le" && this._initArray(this.toArray(), a3, h3)));
      }, f2.prototype._initNumber = function(i, a3, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a3, h3);
      }, f2.prototype._initArray = function(i, a3, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2, c2, b5 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u2 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        else if (h3 === "le")
          for (s3 = 0, u2 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        return this.strip();
      };
      function m4(v2, i) {
        var a3 = v2.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y3(v2, i, a3) {
        var h3 = m4(v2, a3);
        return a3 - 1 >= i && (h3 |= m4(v2, a3 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a3, h3) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2 = 0, c2 = 0, b5;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        }
        this.strip();
      };
      function M4(v2, i, a3, h3) {
        for (var s3 = 0, u2 = Math.min(v2.length, a3), c2 = i;c2 < u2; c2++) {
          var b5 = v2.charCodeAt(c2) - 48;
          s3 *= h3, b5 >= 49 ? s3 += b5 - 49 + 10 : b5 >= 17 ? s3 += b5 - 17 + 10 : s3 += b5;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a3, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u2 = 1;u2 <= 67108863; u2 *= a3)
          s3++;
        s3--, u2 = u2 / a3 | 0;
        for (var c2 = i.length - h3, b5 = c2 % s3, l3 = Math.min(c2, c2 - b5) + h3, n = 0, d4 = h3;d4 < l3; d4 += s3)
          n = M4(i, d4, d4 + s3, a3), this.imuln(u2), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b5 !== 0) {
          var w3 = 1;
          for (n = M4(i, d4, i.length, a3), d4 = 0;d4 < b5; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u2 = 0, c2 = 0;c2 < this.length; c2++) {
            var b5 = this.words[c2], l3 = ((b5 << s3 | u2) & 16777215).toString(16);
            u2 = b5 >>> 24 - s3 & 16777215, u2 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l3.length] + l3 + h3 : h3 = l3 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u2 !== 0 && (h3 = u2.toString(16) + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d4 = E6[i];
          h3 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g3 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a3) {
        return r(typeof p4 < "u"), this.toArrayLike(p4, i, a3);
      }, f2.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f2.prototype.toArrayLike = function(i, a3, h3) {
        var s3 = this.byteLength(), u2 = h3 || Math.max(1, s3);
        r(s3 <= u2, "byte array longer than desired length"), r(u2 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b5 = new i(u2), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b5[n] = l3;
          for (;n < u2; n++)
            b5[n] = 0;
        } else {
          for (n = 0;n < u2 - s3; n++)
            b5[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b5[u2 - n - 1] = l3;
        }
        return b5;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a3 = i, h3 = 0;
        return a3 >= 4096 && (h3 += 13, a3 >>>= 13), a3 >= 64 && (h3 += 7, a3 >>>= 7), a3 >= 8 && (h3 += 4, a3 >>>= 4), a3 >= 2 && (h3 += 2, a3 >>>= 2), h3 + a3;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h3 = 0;
        return (a3 & 8191) === 0 && (h3 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h3 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h3 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h3 += 2, a3 >>>= 2), (a3 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v2) {
        for (var i = new Array(v2.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h3 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v2.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h3 = this._zeroBits(this.words[a3]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h3 = 0;h3 < a3.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a3, h3;
        this.length > i.length ? (a3 = this, h3 = i) : (a3 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a3.words[s3] ^ h3.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a3), h3 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a3 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u2 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        for (;u2 !== 0 && c2 < h3.length; c2++)
          a3 = (h3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        if (this.length = h3.length, u2 !== 0)
          this.words[this.length] = u2, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u2;
        h3 > 0 ? (s3 = this, u2 = i) : (s3 = i, u2 = this);
        for (var c2 = 0, b5 = 0;b5 < u2.length; b5++)
          a3 = (s3.words[b5] | 0) - (u2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        for (;c2 !== 0 && b5 < s3.length; b5++)
          a3 = (s3.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        if (c2 === 0 && b5 < s3.length && s3 !== this)
          for (;b5 < s3.length; b5++)
            this.words[b5] = s3.words[b5];
        return this.length = Math.max(this.length, b5), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative;
        var h3 = v2.length + i.length | 0;
        a3.length = h3, h3 = h3 - 1 | 0;
        var s3 = v2.words[0] | 0, u2 = i.words[0] | 0, c2 = s3 * u2, b5 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b5;
        for (var n = 1;n < h3; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g3 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v2.length + 1);_4 <= g3; _4++) {
            var A4 = n - _4 | 0;
            s3 = v2.words[A4] | 0, u2 = i.words[_4] | 0, c2 = s3 * u2 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L4 = function(i, a3, h3) {
        var s3 = i.words, u2 = a3.words, c2 = h3.words, b5 = 0, l3, n, d4, w3 = s3[0] | 0, g3 = w3 & 8191, _4 = w3 >>> 13, A4 = s3[1] | 0, R2 = A4 & 8191, I4 = A4 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt3 = s3[3] | 0, C3 = nt3 & 8191, O2 = nt3 >>> 13, vt = s3[4] | 0, F3 = vt & 8191, U2 = vt >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt3 = s3[6] | 0, W = mt3 & 8191, K4 = mt3 >>> 13, gt3 = s3[7] | 0, j4 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s3[8] | 0, V4 = yt2 & 8191, $ = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u2[0] | 0, X3 = Mt & 8191, J3 = Mt >>> 13, _t3 = u2[1] | 0, Q4 = _t3 & 8191, ee = _t3 >>> 13, xt3 = u2[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St = u2[3] | 0, ie = St & 8191, ne = St >>> 13, Et2 = u2[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At4 = u2[5] | 0, oe3 = At4 & 8191, se2 = At4 >>> 13, Rt = u2[6] | 0, he = Rt & 8191, ue4 = Rt >>> 13, Bt = u2[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt2 = u2[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u2[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a3.negative, h3.length = 19, l3 = Math.imul(g3, X3), n = Math.imul(g3, J3), n = n + Math.imul(_4, X3) | 0, d4 = Math.imul(_4, J3);
        var ft = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l3 = Math.imul(R2, X3), n = Math.imul(R2, J3), n = n + Math.imul(I4, X3) | 0, d4 = Math.imul(I4, J3), l3 = l3 + Math.imul(g3, Q4) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_4, Q4) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X3), n = Math.imul(k4, J3), n = n + Math.imul(D2, X3) | 0, d4 = Math.imul(D2, J3), l3 = l3 + Math.imul(R2, Q4) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I4, Q4) | 0, d4 = d4 + Math.imul(I4, ee) | 0, l3 = l3 + Math.imul(g3, te2) | 0, n = n + Math.imul(g3, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C3, X3), n = Math.imul(C3, J3), n = n + Math.imul(O2, X3) | 0, d4 = Math.imul(O2, J3), l3 = l3 + Math.imul(k4, Q4) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q4) | 0, d4 = d4 + Math.imul(D2, ee) | 0, l3 = l3 + Math.imul(R2, te2) | 0, n = n + Math.imul(R2, re2) | 0, n = n + Math.imul(I4, te2) | 0, d4 = d4 + Math.imul(I4, re2) | 0, l3 = l3 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne) | 0;
        var ze = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F3, X3), n = Math.imul(F3, J3), n = n + Math.imul(U2, X3) | 0, d4 = Math.imul(U2, J3), l3 = l3 + Math.imul(C3, Q4) | 0, n = n + Math.imul(C3, ee) | 0, n = n + Math.imul(O2, Q4) | 0, d4 = d4 + Math.imul(O2, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D2, te2) | 0, d4 = d4 + Math.imul(D2, re2) | 0, l3 = l3 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I4, ie) | 0, d4 = d4 + Math.imul(I4, ne) | 0, l3 = l3 + Math.imul(g3, fe3) | 0, n = n + Math.imul(g3, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X3), n = Math.imul(z, J3), n = n + Math.imul(H3, X3) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F3, Q4) | 0, n = n + Math.imul(F3, ee) | 0, n = n + Math.imul(U2, Q4) | 0, d4 = d4 + Math.imul(U2, ee) | 0, l3 = l3 + Math.imul(C3, te2) | 0, n = n + Math.imul(C3, re2) | 0, n = n + Math.imul(O2, te2) | 0, d4 = d4 + Math.imul(O2, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d4 = d4 + Math.imul(D2, ne) | 0, l3 = l3 + Math.imul(R2, fe3) | 0, n = n + Math.imul(R2, ae2) | 0, n = n + Math.imul(I4, fe3) | 0, d4 = d4 + Math.imul(I4, ae2) | 0, l3 = l3 + Math.imul(g3, oe3) | 0, n = n + Math.imul(g3, se2) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se2) | 0;
        var We2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X3), n = Math.imul(W, J3), n = n + Math.imul(K4, X3) | 0, d4 = Math.imul(K4, J3), l3 = l3 + Math.imul(z, Q4) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q4) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F3, te2) | 0, n = n + Math.imul(F3, re2) | 0, n = n + Math.imul(U2, te2) | 0, d4 = d4 + Math.imul(U2, re2) | 0, l3 = l3 + Math.imul(C3, ie) | 0, n = n + Math.imul(C3, ne) | 0, n = n + Math.imul(O2, ie) | 0, d4 = d4 + Math.imul(O2, ne) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D2, fe3) | 0, d4 = d4 + Math.imul(D2, ae2) | 0, l3 = l3 + Math.imul(R2, oe3) | 0, n = n + Math.imul(R2, se2) | 0, n = n + Math.imul(I4, oe3) | 0, d4 = d4 + Math.imul(I4, se2) | 0, l3 = l3 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j4, X3), n = Math.imul(j4, J3), n = n + Math.imul(Z3, X3) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q4) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K4, Q4) | 0, d4 = d4 + Math.imul(K4, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F3, ie) | 0, n = n + Math.imul(F3, ne) | 0, n = n + Math.imul(U2, ie) | 0, d4 = d4 + Math.imul(U2, ne) | 0, l3 = l3 + Math.imul(C3, fe3) | 0, n = n + Math.imul(C3, ae2) | 0, n = n + Math.imul(O2, fe3) | 0, d4 = d4 + Math.imul(O2, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se2) | 0, n = n + Math.imul(D2, oe3) | 0, d4 = d4 + Math.imul(D2, se2) | 0, l3 = l3 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue4) | 0, n = n + Math.imul(I4, he) | 0, d4 = d4 + Math.imul(I4, ue4) | 0, l3 = l3 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V4, X3), n = Math.imul(V4, J3), n = n + Math.imul($, X3) | 0, d4 = Math.imul($, J3), l3 = l3 + Math.imul(j4, Q4) | 0, n = n + Math.imul(j4, ee) | 0, n = n + Math.imul(Z3, Q4) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K4, te2) | 0, d4 = d4 + Math.imul(K4, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne) | 0, l3 = l3 + Math.imul(F3, fe3) | 0, n = n + Math.imul(F3, ae2) | 0, n = n + Math.imul(U2, fe3) | 0, d4 = d4 + Math.imul(U2, ae2) | 0, l3 = l3 + Math.imul(C3, oe3) | 0, n = n + Math.imul(C3, se2) | 0, n = n + Math.imul(O2, oe3) | 0, d4 = d4 + Math.imul(O2, se2) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D2, he) | 0, d4 = d4 + Math.imul(D2, ue4) | 0, l3 = l3 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I4, le) | 0, d4 = d4 + Math.imul(I4, de) | 0, l3 = l3 + Math.imul(g3, ce3) | 0, n = n + Math.imul(g3, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X3), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X3) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V4, Q4) | 0, n = n + Math.imul(V4, ee) | 0, n = n + Math.imul($, Q4) | 0, d4 = d4 + Math.imul($, ee) | 0, l3 = l3 + Math.imul(j4, te2) | 0, n = n + Math.imul(j4, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K4, ie) | 0, d4 = d4 + Math.imul(K4, ne) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F3, oe3) | 0, n = n + Math.imul(F3, se2) | 0, n = n + Math.imul(U2, oe3) | 0, d4 = d4 + Math.imul(U2, se2) | 0, l3 = l3 + Math.imul(C3, he) | 0, n = n + Math.imul(C3, ue4) | 0, n = n + Math.imul(O2, he) | 0, d4 = d4 + Math.imul(O2, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d4 = d4 + Math.imul(D2, de) | 0, l3 = l3 + Math.imul(R2, ce3) | 0, n = n + Math.imul(R2, pe2) | 0, n = n + Math.imul(I4, ce3) | 0, d4 = d4 + Math.imul(I4, pe2) | 0, l3 = l3 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be) | 0;
        var Ve = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q4), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q4) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V4, te2) | 0, n = n + Math.imul(V4, re2) | 0, n = n + Math.imul($, te2) | 0, d4 = d4 + Math.imul($, re2) | 0, l3 = l3 + Math.imul(j4, ie) | 0, n = n + Math.imul(j4, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K4, fe3) | 0, d4 = d4 + Math.imul(K4, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se2) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se2) | 0, l3 = l3 + Math.imul(F3, he) | 0, n = n + Math.imul(F3, ue4) | 0, n = n + Math.imul(U2, he) | 0, d4 = d4 + Math.imul(U2, ue4) | 0, l3 = l3 + Math.imul(C3, le) | 0, n = n + Math.imul(C3, de) | 0, n = n + Math.imul(O2, le) | 0, d4 = d4 + Math.imul(O2, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D2, ce3) | 0, d4 = d4 + Math.imul(D2, pe2) | 0, l3 = l3 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I4, ve) | 0, d4 = d4 + Math.imul(I4, be) | 0;
        var $e2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V4, ie) | 0, n = n + Math.imul(V4, ne) | 0, n = n + Math.imul($, ie) | 0, d4 = d4 + Math.imul($, ne) | 0, l3 = l3 + Math.imul(j4, fe3) | 0, n = n + Math.imul(j4, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se2) | 0, n = n + Math.imul(K4, oe3) | 0, d4 = d4 + Math.imul(K4, se2) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F3, le) | 0, n = n + Math.imul(F3, de) | 0, n = n + Math.imul(U2, le) | 0, d4 = d4 + Math.imul(U2, de) | 0, l3 = l3 + Math.imul(C3, ce3) | 0, n = n + Math.imul(C3, pe2) | 0, n = n + Math.imul(O2, ce3) | 0, d4 = d4 + Math.imul(O2, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d4 = d4 + Math.imul(D2, be) | 0;
        var Ge = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne), l3 = l3 + Math.imul(V4, fe3) | 0, n = n + Math.imul(V4, ae2) | 0, n = n + Math.imul($, fe3) | 0, d4 = d4 + Math.imul($, ae2) | 0, l3 = l3 + Math.imul(j4, oe3) | 0, n = n + Math.imul(j4, se2) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se2) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K4, he) | 0, d4 = d4 + Math.imul(K4, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F3, ce3) | 0, n = n + Math.imul(F3, pe2) | 0, n = n + Math.imul(U2, ce3) | 0, d4 = d4 + Math.imul(U2, pe2) | 0, l3 = l3 + Math.imul(C3, ve) | 0, n = n + Math.imul(C3, be) | 0, n = n + Math.imul(O2, ve) | 0, d4 = d4 + Math.imul(O2, be) | 0;
        var Ye = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V4, oe3) | 0, n = n + Math.imul(V4, se2) | 0, n = n + Math.imul($, oe3) | 0, d4 = d4 + Math.imul($, se2) | 0, l3 = l3 + Math.imul(j4, he) | 0, n = n + Math.imul(j4, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K4, le) | 0, d4 = d4 + Math.imul(K4, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F3, ve) | 0, n = n + Math.imul(F3, be) | 0, n = n + Math.imul(U2, ve) | 0, d4 = d4 + Math.imul(U2, be) | 0;
        var Xe = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se2), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se2), l3 = l3 + Math.imul(V4, he) | 0, n = n + Math.imul(V4, ue4) | 0, n = n + Math.imul($, he) | 0, d4 = d4 + Math.imul($, ue4) | 0, l3 = l3 + Math.imul(j4, le) | 0, n = n + Math.imul(j4, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K4, ce3) | 0, d4 = d4 + Math.imul(K4, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be) | 0;
        var Je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V4, le) | 0, n = n + Math.imul(V4, de) | 0, n = n + Math.imul($, le) | 0, d4 = d4 + Math.imul($, de) | 0, l3 = l3 + Math.imul(j4, ce3) | 0, n = n + Math.imul(j4, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K4, ve) | 0, d4 = d4 + Math.imul(K4, be) | 0;
        var Qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V4, ce3) | 0, n = n + Math.imul(V4, pe2) | 0, n = n + Math.imul($, ce3) | 0, d4 = d4 + Math.imul($, pe2) | 0, l3 = l3 + Math.imul(j4, ve) | 0, n = n + Math.imul(j4, be) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be) | 0;
        var et4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (et4 >>> 26) | 0, et4 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V4, ve) | 0, n = n + Math.imul(V4, be) | 0, n = n + Math.imul($, ve) | 0, d4 = d4 + Math.imul($, be) | 0;
        var tt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be);
        var rt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b5 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et4, c2[17] = tt4, c2[18] = rt4, b5 !== 0 && (c2[19] = b5, h3.length++), h3;
      };
      Math.imul || (L4 = q);
      function ge(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative, a3.length = v2.length + i.length;
        for (var h3 = 0, s3 = 0, u2 = 0;u2 < a3.length - 1; u2++) {
          var c2 = s3;
          s3 = 0;
          for (var b5 = h3 & 67108863, l3 = Math.min(u2, i.length - 1), n = Math.max(0, u2 - v2.length + 1);n <= l3; n++) {
            var d4 = u2 - n, w3 = v2.words[d4] | 0, g3 = i.words[n] | 0, _4 = w3 * g3, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b5 | 0, b5 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u2] = b5, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a3.words[u2] = h3 : a3.length--, a3.strip();
      }
      function _e3(v2, i, a3) {
        var h3 = new N5;
        return h3.mulp(v2, i, a3);
      }
      f2.prototype.mulTo = function(i, a3) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L4(this, i, a3) : s3 < 63 ? h3 = q(this, i, a3) : s3 < 1024 ? h3 = ge(this, i, a3) : h3 = _e3(this, i, a3), h3;
      };
      function N5(v2, i) {
        this.x = v2, this.y = i;
      }
      N5.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h3, i);
        return a3;
      }, N5.prototype.revBin = function(i, a3, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u2 = 0;u2 < a3; u2++)
          s3 |= (i & 1) << a3 - u2 - 1, i >>= 1;
        return s3;
      }, N5.prototype.permute = function(i, a3, h3, s3, u2, c2) {
        for (var b5 = 0;b5 < c2; b5++)
          s3[b5] = a3[i[b5]], u2[b5] = h3[i[b5]];
      }, N5.prototype.transform = function(i, a3, h3, s3, u2, c2) {
        this.permute(c2, i, a3, h3, s3, u2);
        for (var b5 = 1;b5 < u2; b5 <<= 1)
          for (var l3 = b5 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u2; w3 += l3)
            for (var g3 = n, _4 = d4, A4 = 0;A4 < b5; A4++) {
              var R2 = h3[w3 + A4], I4 = s3[w3 + A4], Me = h3[w3 + A4 + b5], k4 = s3[w3 + A4 + b5], D2 = g3 * Me - _4 * k4;
              k4 = g3 * k4 + _4 * Me, Me = D2, h3[w3 + A4] = R2 + Me, s3[w3 + A4] = I4 + k4, h3[w3 + A4 + b5] = R2 - Me, s3[w3 + A4 + b5] = I4 - k4, A4 !== l3 && (D2 = n * g3 - d4 * _4, _4 = n * _4 + d4 * g3, g3 = D2);
            }
      }, N5.prototype.guessLen13b = function(i, a3) {
        var h3 = Math.max(a3, i) | 1, s3 = h3 & 1, u2 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u2++;
        return 1 << u2 + 1 + s3;
      }, N5.prototype.conjugate = function(i, a3, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u2 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u2, u2 = a3[s3], a3[s3] = -a3[h3 - s3 - 1], a3[h3 - s3 - 1] = -u2;
          }
      }, N5.prototype.normalize13b = function(i, a3) {
        for (var h3 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u2 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h3;
          i[s3] = u2 & 67108863, u2 < 67108864 ? h3 = 0 : h3 = u2 / 67108864 | 0;
        }
        return i;
      }, N5.prototype.convert13b = function(i, a3, h3, s3) {
        for (var u2 = 0, c2 = 0;c2 < a3; c2++)
          u2 = u2 + (i[c2] | 0), h3[2 * c2] = u2 & 8191, u2 = u2 >>> 13, h3[2 * c2 + 1] = u2 & 8191, u2 = u2 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u2 === 0), r((u2 & -8192) === 0);
      }, N5.prototype.stub = function(i) {
        for (var a3 = new Array(i), h3 = 0;h3 < i; h3++)
          a3[h3] = 0;
        return a3;
      }, N5.prototype.mulp = function(i, a3, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u2 = this.makeRBT(s3), c2 = this.stub(s3), b5 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d4 = new Array(s3), w3 = new Array(s3), g3 = new Array(s3), _4 = h3.words;
        _4.length = s3, this.convert13b(i.words, i.length, b5, s3), this.convert13b(a3.words, a3.length, d4, s3), this.transform(b5, c2, l3, n, s3, u2), this.transform(d4, c2, w3, g3, s3, u2);
        for (var A4 = 0;A4 < s3; A4++) {
          var R2 = l3[A4] * w3[A4] - n[A4] * g3[A4];
          n[A4] = l3[A4] * g3[A4] + n[A4] * w3[A4], l3[A4] = R2;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _4, c2, s3, u2), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h3.negative = i.negative ^ a3.negative, h3.length = i.length + a3.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f2.prototype.mulf = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u2 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u2 >>> 26, this.words[h3] = u2 & 67108863;
        }
        return a3 !== 0 && (this.words[h3] = a3, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a3.length)
          for (var u2 = h3.sqr();s3 < a3.length; s3++, u2 = u2.sqr())
            a3[s3] !== 0 && (h3 = h3.mul(u2));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u2;
        if (a3 !== 0) {
          var c2 = 0;
          for (u2 = 0;u2 < this.length; u2++) {
            var b5 = this.words[u2] & s3, l3 = (this.words[u2] | 0) - b5 << a3;
            this.words[u2] = l3 | c2, c2 = b5 >>> 26 - a3;
          }
          c2 && (this.words[u2] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u2 = this.length - 1;u2 >= 0; u2--)
            this.words[u2 + h3] = this.words[u2];
          for (u2 = 0;u2 < h3; u2++)
            this.words[u2] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a3, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u2 = i % 26, c2 = Math.min((i - u2) / 26, this.length), b5 = 67108863 ^ 67108863 >>> u2 << u2, l3 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u2 | w3 >>> u2, d4 = w3 & b5;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a3, h3) {
        return r(this.negative === 0), this.iushrn(i, a3, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return false;
        var u2 = this.words[h3];
        return !!(u2 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a3 !== 0 && h3++, this.length = Math.min(h3, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a3, h3) {
        var s3 = i.length + h3, u2;
        this._expand(s3);
        var c2, b5 = 0;
        for (u2 = 0;u2 < i.length; u2++) {
          c2 = (this.words[u2 + h3] | 0) + b5;
          var l3 = (i.words[u2] | 0) * a3;
          c2 -= l3 & 67108863, b5 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u2 + h3] = c2 & 67108863;
        }
        for (;u2 < this.length - h3; u2++)
          c2 = (this.words[u2 + h3] | 0) + b5, b5 = c2 >> 26, this.words[u2 + h3] = c2 & 67108863;
        if (b5 === 0)
          return this.strip();
        for (r(b5 === -1), b5 = 0, u2 = 0;u2 < this.length; u2++)
          c2 = -(this.words[u2] | 0) + b5, b5 = c2 >> 26, this.words[u2] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a3) {
        var h3 = this.length - i.length, s3 = this.clone(), u2 = i, c2 = u2.words[u2.length - 1] | 0, b5 = this._countBits(c2);
        h3 = 26 - b5, h3 !== 0 && (u2 = u2.ushln(h3), s3.iushln(h3), c2 = u2.words[u2.length - 1] | 0);
        var l3 = s3.length - u2.length, n;
        if (a3 !== "mod") {
          n = new f2(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u2, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g3 = l3 - 1;g3 >= 0; g3--) {
          var _4 = (s3.words[u2.length + g3] | 0) * 67108864 + (s3.words[u2.length + g3 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u2, _4, g3);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u2, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _4);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a3, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u2, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.iadd(i)), { div: s3, mod: u2 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.isub(i)), { div: c2.div, mod: u2 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h3 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u2 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u2 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a3 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a3 * 67108864;
          this.words[h3] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = new f2(0), b5 = new f2(1), l3 = 0;a3.isEven() && h3.isEven(); )
          a3.iushrn(1), h3.iushrn(1), ++l3;
        for (var n = h3.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g3 = 1;(a3.words[0] & g3) === 0 && w3 < 26; ++w3, g3 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u2.isOdd()) && (s3.iadd(n), u2.isub(d4)), s3.iushrn(1), u2.iushrn(1);
          for (var _4 = 0, A4 = 1;(h3.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h3.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b5.isOdd()) && (c2.iadd(n), b5.isub(d4)), c2.iushrn(1), b5.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(c2), u2.isub(b5)) : (h3.isub(a3), c2.isub(s3), b5.isub(u2));
        }
        return { a: c2, b: b5, gcd: h3.iushln(l3) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = h3.clone();a3.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b5 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b5 < 26; ++b5, l3 <<= 1)
            ;
          if (b5 > 0)
            for (a3.iushrn(b5);b5-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d4 = 1;(h3.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u2.isOdd() && u2.iadd(c2), u2.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(u2)) : (h3.isub(a3), u2.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u2, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h3 = i.clone();
        a3.negative = 0, h3.negative = 0;
        for (var s3 = 0;a3.isEven() && h3.isEven(); s3++)
          a3.iushrn(1), h3.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u2 = a3.cmp(h3);
          if (u2 < 0) {
            var c2 = a3;
            a3 = h3, h3 = c2;
          } else if (u2 === 0 || h3.cmpn(1) === 0)
            break;
          a3.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u2 = s3, c2 = h3;u2 !== 0 && c2 < this.length; c2++) {
          var b5 = this.words[c2] | 0;
          b5 += u2, u2 = b5 >>> 26, b5 &= 67108863, this.words[c2] = b5;
        }
        return u2 !== 0 && (this.words[c2] = u2, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u2 = i.words[h3] | 0;
          if (s3 !== u2) {
            s3 < u2 ? a3 = -1 : s3 > u2 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a3 = i, h3;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h3 = a3.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe, ye), xe.prototype.split = function(i, a3) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u2 = 0;u2 < s3; u2++)
          a3.words[u2] = i.words[u2];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h3, u2 = 10;u2 < i.length; u2++) {
          var b5 = i.words[u2] | 0;
          i.words[u2 - 10] = (b5 & h3) << 4 | c2 >>> 22, c2 = b5;
        }
        c2 >>>= 22, i.words[u2 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a3 += s3 * 977, i.words[h3] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a3, u2 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u2, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.add(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.iadd(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.sub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.isub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P2.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P2.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u2 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u2++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b5 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l3).cmp(b5) !== 0; )
          n.redIAdd(b5);
        for (var d4 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _4 = u2;g3.cmp(c2) !== 0; ) {
          for (var A4 = g3, R2 = 0;A4.cmp(c2) !== 0; R2++)
            A4 = A4.redSqr();
          r(R2 < _4);
          var I4 = this.pow(d4, new f2(1).iushln(_4 - R2 - 1));
          w3 = w3.redMul(I4), d4 = I4.redSqr(), g3 = g3.redMul(d4), _4 = R2;
        }
        return w3;
      }, P2.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P2.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f2(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u2 = 2;u2 < s3.length; u2++)
          s3[u2] = this.mul(s3[u2 - 1], i);
        var c2 = s3[0], b5 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u2 = a3.length - 1;u2 >= 0; u2--) {
          for (var d4 = a3.words[u2], w3 = n - 1;w3 >= 0; w3--) {
            var g3 = d4 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b5 === 0) {
              l3 = 0;
              continue;
            }
            b5 <<= 1, b5 |= g3, l3++, !(l3 !== h3 && (u2 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b5]), l3 = 0, b5 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P2.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f2.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v2) {
        P2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P2), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof yd > "u" || yd, L3);
  });
  P3 = T((wL, D3) => {
    var bq = o0(), mq = N32();
    D3.exports = function(e) {
      return new Zn(e);
    };
    var hr3 = { secp256k1: { name: "secp256k1", byteLength: 32 }, secp224r1: { name: "p224", byteLength: 28 }, prime256v1: { name: "p256", byteLength: 32 }, prime192v1: { name: "p192", byteLength: 24 }, ed25519: { name: "ed25519", byteLength: 32 }, secp384r1: { name: "p384", byteLength: 48 }, secp521r1: { name: "p521", byteLength: 66 } };
    hr3.p224 = hr3.secp224r1;
    hr3.p256 = hr3.secp256r1 = hr3.prime256v1;
    hr3.p192 = hr3.secp192r1 = hr3.prime192v1;
    hr3.p384 = hr3.secp384r1;
    hr3.p521 = hr3.secp521r1;
    function Zn(t) {
      this.curveType = hr3[t], this.curveType || (this.curveType = { name: t }), this.curve = new bq.ec(this.curveType.name), this.keys = undefined;
    }
    Zn.prototype.generateKeys = function(t, e) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(t, e);
    };
    Zn.prototype.computeSecret = function(t, e, r) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var o2 = this.curve.keyFromPublic(t).getPublic(), f2 = o2.mul(this.keys.getPrivate()).getX();
      return wd(f2, r, this.curveType.byteLength);
    };
    Zn.prototype.getPublicKey = function(t, e) {
      var r = this.keys.getPublic(e === "compressed", true);
      return e === "hybrid" && (r[r.length - 1] % 2 ? r[0] = 7 : r[0] = 6), wd(r, t);
    };
    Zn.prototype.getPrivateKey = function(t) {
      return wd(this.keys.getPrivate(), t);
    };
    Zn.prototype.setPublicKey = function(t, e) {
      return e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e)), this.keys._importPublic(t), this;
    };
    Zn.prototype.setPrivateKey = function(t, e) {
      e = e || "utf8", Buffer.isBuffer(t) || (t = new Buffer(t, e));
      var r = new mq(t);
      return r = r.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(r), this;
    };
    function wd(t, e, r) {
      Array.isArray(t) || (t = t.toArray());
      var o2 = new Buffer(t);
      if (r && o2.length < r) {
        var f2 = new Buffer(r - o2.length);
        f2.fill(0), o2 = Buffer.concat([f2, o2]);
      }
      return e ? o2.toString(e) : o2;
    }
  });
  _d = T((ML, C3) => {
    var gq = bf(), Md = Te().Buffer;
    C3.exports = function(t, e) {
      for (var r = Md.alloc(0), o2 = 0, f2;r.length < e; )
        f2 = yq(o2++), r = Md.concat([r, gq("sha1").update(t).update(f2).digest()]);
      return r.slice(0, e);
    };
    function yq(t) {
      var e = Md.allocUnsafe(4);
      return e.writeUInt32BE(t, 0), e;
    }
  });
  xd = T((_L, O3) => {
    O3.exports = function(e, r) {
      for (var o2 = e.length, f2 = -1;++f2 < o2; )
        e[f2] ^= r[f2];
      return e;
    };
  });
  w0 = T((F3, Sd) => {
    (function(t, e) {
      function r(v2, i) {
        if (!v2)
          throw new Error(i || "Assertion failed");
      }
      function o2(v2, i) {
        v2.super_ = i;
        var a3 = function() {};
        a3.prototype = i.prototype, v2.prototype = new a3, v2.prototype.constructor = v2;
      }
      function f2(v2, i, a3) {
        if (f2.isBN(v2))
          return v2;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, v2 !== null && ((i === "le" || i === "be") && (a3 = i, i = 10), this._init(v2 || 0, i || 10, a3 || "be"));
      }
      typeof t == "object" ? t.exports = f2 : e.BN = f2, f2.BN = f2, f2.wordSize = 26;
      var p4;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p4 = window.Buffer : p4 = ji2().Buffer;
      } catch {}
      f2.isBN = function(i) {
        return i instanceof f2 ? true : i !== null && typeof i == "object" && i.constructor.wordSize === f2.wordSize && Array.isArray(i.words);
      }, f2.max = function(i, a3) {
        return i.cmp(a3) > 0 ? i : a3;
      }, f2.min = function(i, a3) {
        return i.cmp(a3) < 0 ? i : a3;
      }, f2.prototype._init = function(i, a3, h3) {
        if (typeof i == "number")
          return this._initNumber(i, a3, h3);
        if (typeof i == "object")
          return this._initArray(i, a3, h3);
        a3 === "hex" && (a3 = 16), r(a3 === (a3 | 0) && a3 >= 2 && a3 <= 36), i = i.toString().replace(/\s+/g, "");
        var s3 = 0;
        i[0] === "-" && (s3++, this.negative = 1), s3 < i.length && (a3 === 16 ? this._parseHex(i, s3, h3) : (this._parseBase(i, a3, s3), h3 === "le" && this._initArray(this.toArray(), a3, h3)));
      }, f2.prototype._initNumber = function(i, a3, h3) {
        i < 0 && (this.negative = 1, i = -i), i < 67108864 ? (this.words = [i & 67108863], this.length = 1) : i < 4503599627370496 ? (this.words = [i & 67108863, i / 67108864 & 67108863], this.length = 2) : (r(i < 9007199254740992), this.words = [i & 67108863, i / 67108864 & 67108863, 1], this.length = 3), h3 === "le" && this._initArray(this.toArray(), a3, h3);
      }, f2.prototype._initArray = function(i, a3, h3) {
        if (r(typeof i.length == "number"), i.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(i.length / 3), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2, c2, b5 = 0;
        if (h3 === "be")
          for (s3 = i.length - 1, u2 = 0;s3 >= 0; s3 -= 3)
            c2 = i[s3] | i[s3 - 1] << 8 | i[s3 - 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        else if (h3 === "le")
          for (s3 = 0, u2 = 0;s3 < i.length; s3 += 3)
            c2 = i[s3] | i[s3 + 1] << 8 | i[s3 + 2] << 16, this.words[u2] |= c2 << b5 & 67108863, this.words[u2 + 1] = c2 >>> 26 - b5 & 67108863, b5 += 24, b5 >= 26 && (b5 -= 26, u2++);
        return this.strip();
      };
      function m4(v2, i) {
        var a3 = v2.charCodeAt(i);
        return a3 >= 65 && a3 <= 70 ? a3 - 55 : a3 >= 97 && a3 <= 102 ? a3 - 87 : a3 - 48 & 15;
      }
      function y3(v2, i, a3) {
        var h3 = m4(v2, a3);
        return a3 - 1 >= i && (h3 |= m4(v2, a3 - 1) << 4), h3;
      }
      f2.prototype._parseHex = function(i, a3, h3) {
        this.length = Math.ceil((i.length - a3) / 6), this.words = new Array(this.length);
        for (var s3 = 0;s3 < this.length; s3++)
          this.words[s3] = 0;
        var u2 = 0, c2 = 0, b5;
        if (h3 === "be")
          for (s3 = i.length - 1;s3 >= a3; s3 -= 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        else {
          var l3 = i.length - a3;
          for (s3 = l3 % 2 === 0 ? a3 + 1 : a3;s3 < i.length; s3 += 2)
            b5 = y3(i, a3, s3) << u2, this.words[c2] |= b5 & 67108863, u2 >= 18 ? (u2 -= 18, c2 += 1, this.words[c2] |= b5 >>> 26) : u2 += 8;
        }
        this.strip();
      };
      function M4(v2, i, a3, h3) {
        for (var s3 = 0, u2 = Math.min(v2.length, a3), c2 = i;c2 < u2; c2++) {
          var b5 = v2.charCodeAt(c2) - 48;
          s3 *= h3, b5 >= 49 ? s3 += b5 - 49 + 10 : b5 >= 17 ? s3 += b5 - 17 + 10 : s3 += b5;
        }
        return s3;
      }
      f2.prototype._parseBase = function(i, a3, h3) {
        this.words = [0], this.length = 1;
        for (var s3 = 0, u2 = 1;u2 <= 67108863; u2 *= a3)
          s3++;
        s3--, u2 = u2 / a3 | 0;
        for (var c2 = i.length - h3, b5 = c2 % s3, l3 = Math.min(c2, c2 - b5) + h3, n = 0, d4 = h3;d4 < l3; d4 += s3)
          n = M4(i, d4, d4 + s3, a3), this.imuln(u2), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        if (b5 !== 0) {
          var w3 = 1;
          for (n = M4(i, d4, i.length, a3), d4 = 0;d4 < b5; d4++)
            w3 *= a3;
          this.imuln(w3), this.words[0] + n < 67108864 ? this.words[0] += n : this._iaddn(n);
        }
        this.strip();
      }, f2.prototype.copy = function(i) {
        i.words = new Array(this.length);
        for (var a3 = 0;a3 < this.length; a3++)
          i.words[a3] = this.words[a3];
        i.length = this.length, i.negative = this.negative, i.red = this.red;
      }, f2.prototype.clone = function() {
        var i = new f2(null);
        return this.copy(i), i;
      }, f2.prototype._expand = function(i) {
        for (;this.length < i; )
          this.words[this.length++] = 0;
        return this;
      }, f2.prototype.strip = function() {
        for (;this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, f2.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, f2.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var x3 = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"], S2 = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5], E6 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      f2.prototype.toString = function(i, a3) {
        i = i || 10, a3 = a3 | 0 || 1;
        var h3;
        if (i === 16 || i === "hex") {
          h3 = "";
          for (var s3 = 0, u2 = 0, c2 = 0;c2 < this.length; c2++) {
            var b5 = this.words[c2], l3 = ((b5 << s3 | u2) & 16777215).toString(16);
            u2 = b5 >>> 24 - s3 & 16777215, u2 !== 0 || c2 !== this.length - 1 ? h3 = x3[6 - l3.length] + l3 + h3 : h3 = l3 + h3, s3 += 2, s3 >= 26 && (s3 -= 26, c2--);
          }
          for (u2 !== 0 && (h3 = u2.toString(16) + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        if (i === (i | 0) && i >= 2 && i <= 36) {
          var n = S2[i], d4 = E6[i];
          h3 = "";
          var w3 = this.clone();
          for (w3.negative = 0;!w3.isZero(); ) {
            var g3 = w3.modn(d4).toString(i);
            w3 = w3.idivn(d4), w3.isZero() ? h3 = g3 + h3 : h3 = x3[n - g3.length] + g3 + h3;
          }
          for (this.isZero() && (h3 = "0" + h3);h3.length % a3 !== 0; )
            h3 = "0" + h3;
          return this.negative !== 0 && (h3 = "-" + h3), h3;
        }
        r(false, "Base should be between 2 and 36");
      }, f2.prototype.toNumber = function() {
        var i = this.words[0];
        return this.length === 2 ? i += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? i += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(false, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -i : i;
      }, f2.prototype.toJSON = function() {
        return this.toString(16);
      }, f2.prototype.toBuffer = function(i, a3) {
        return r(typeof p4 < "u"), this.toArrayLike(p4, i, a3);
      }, f2.prototype.toArray = function(i, a3) {
        return this.toArrayLike(Array, i, a3);
      }, f2.prototype.toArrayLike = function(i, a3, h3) {
        var s3 = this.byteLength(), u2 = h3 || Math.max(1, s3);
        r(s3 <= u2, "byte array longer than desired length"), r(u2 > 0, "Requested array length <= 0"), this.strip();
        var c2 = a3 === "le", b5 = new i(u2), l3, n, d4 = this.clone();
        if (c2) {
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b5[n] = l3;
          for (;n < u2; n++)
            b5[n] = 0;
        } else {
          for (n = 0;n < u2 - s3; n++)
            b5[n] = 0;
          for (n = 0;!d4.isZero(); n++)
            l3 = d4.andln(255), d4.iushrn(8), b5[u2 - n - 1] = l3;
        }
        return b5;
      }, Math.clz32 ? f2.prototype._countBits = function(i) {
        return 32 - Math.clz32(i);
      } : f2.prototype._countBits = function(i) {
        var a3 = i, h3 = 0;
        return a3 >= 4096 && (h3 += 13, a3 >>>= 13), a3 >= 64 && (h3 += 7, a3 >>>= 7), a3 >= 8 && (h3 += 4, a3 >>>= 4), a3 >= 2 && (h3 += 2, a3 >>>= 2), h3 + a3;
      }, f2.prototype._zeroBits = function(i) {
        if (i === 0)
          return 26;
        var a3 = i, h3 = 0;
        return (a3 & 8191) === 0 && (h3 += 13, a3 >>>= 13), (a3 & 127) === 0 && (h3 += 7, a3 >>>= 7), (a3 & 15) === 0 && (h3 += 4, a3 >>>= 4), (a3 & 3) === 0 && (h3 += 2, a3 >>>= 2), (a3 & 1) === 0 && h3++, h3;
      }, f2.prototype.bitLength = function() {
        var i = this.words[this.length - 1], a3 = this._countBits(i);
        return (this.length - 1) * 26 + a3;
      };
      function B3(v2) {
        for (var i = new Array(v2.bitLength()), a3 = 0;a3 < i.length; a3++) {
          var h3 = a3 / 26 | 0, s3 = a3 % 26;
          i[a3] = (v2.words[h3] & 1 << s3) >>> s3;
        }
        return i;
      }
      f2.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var i = 0, a3 = 0;a3 < this.length; a3++) {
          var h3 = this._zeroBits(this.words[a3]);
          if (i += h3, h3 !== 26)
            break;
        }
        return i;
      }, f2.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, f2.prototype.toTwos = function(i) {
        return this.negative !== 0 ? this.abs().inotn(i).iaddn(1) : this.clone();
      }, f2.prototype.fromTwos = function(i) {
        return this.testn(i - 1) ? this.notn(i).iaddn(1).ineg() : this.clone();
      }, f2.prototype.isNeg = function() {
        return this.negative !== 0;
      }, f2.prototype.neg = function() {
        return this.clone().ineg();
      }, f2.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, f2.prototype.iuor = function(i) {
        for (;this.length < i.length; )
          this.words[this.length++] = 0;
        for (var a3 = 0;a3 < i.length; a3++)
          this.words[a3] = this.words[a3] | i.words[a3];
        return this.strip();
      }, f2.prototype.ior = function(i) {
        return r((this.negative | i.negative) === 0), this.iuor(i);
      }, f2.prototype.or = function(i) {
        return this.length > i.length ? this.clone().ior(i) : i.clone().ior(this);
      }, f2.prototype.uor = function(i) {
        return this.length > i.length ? this.clone().iuor(i) : i.clone().iuor(this);
      }, f2.prototype.iuand = function(i) {
        var a3;
        this.length > i.length ? a3 = i : a3 = this;
        for (var h3 = 0;h3 < a3.length; h3++)
          this.words[h3] = this.words[h3] & i.words[h3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.iand = function(i) {
        return r((this.negative | i.negative) === 0), this.iuand(i);
      }, f2.prototype.and = function(i) {
        return this.length > i.length ? this.clone().iand(i) : i.clone().iand(this);
      }, f2.prototype.uand = function(i) {
        return this.length > i.length ? this.clone().iuand(i) : i.clone().iuand(this);
      }, f2.prototype.iuxor = function(i) {
        var a3, h3;
        this.length > i.length ? (a3 = this, h3 = i) : (a3 = i, h3 = this);
        for (var s3 = 0;s3 < h3.length; s3++)
          this.words[s3] = a3.words[s3] ^ h3.words[s3];
        if (this !== a3)
          for (;s3 < a3.length; s3++)
            this.words[s3] = a3.words[s3];
        return this.length = a3.length, this.strip();
      }, f2.prototype.ixor = function(i) {
        return r((this.negative | i.negative) === 0), this.iuxor(i);
      }, f2.prototype.xor = function(i) {
        return this.length > i.length ? this.clone().ixor(i) : i.clone().ixor(this);
      }, f2.prototype.uxor = function(i) {
        return this.length > i.length ? this.clone().iuxor(i) : i.clone().iuxor(this);
      }, f2.prototype.inotn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = Math.ceil(i / 26) | 0, h3 = i % 26;
        this._expand(a3), h3 > 0 && a3--;
        for (var s3 = 0;s3 < a3; s3++)
          this.words[s3] = ~this.words[s3] & 67108863;
        return h3 > 0 && (this.words[s3] = ~this.words[s3] & 67108863 >> 26 - h3), this.strip();
      }, f2.prototype.notn = function(i) {
        return this.clone().inotn(i);
      }, f2.prototype.setn = function(i, a3) {
        r(typeof i == "number" && i >= 0);
        var h3 = i / 26 | 0, s3 = i % 26;
        return this._expand(h3 + 1), a3 ? this.words[h3] = this.words[h3] | 1 << s3 : this.words[h3] = this.words[h3] & ~(1 << s3), this.strip();
      }, f2.prototype.iadd = function(i) {
        var a3;
        if (this.negative !== 0 && i.negative === 0)
          return this.negative = 0, a3 = this.isub(i), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && i.negative !== 0)
          return i.negative = 0, a3 = this.isub(i), i.negative = 1, a3._normSign();
        var h3, s3;
        this.length > i.length ? (h3 = this, s3 = i) : (h3 = i, s3 = this);
        for (var u2 = 0, c2 = 0;c2 < s3.length; c2++)
          a3 = (h3.words[c2] | 0) + (s3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        for (;u2 !== 0 && c2 < h3.length; c2++)
          a3 = (h3.words[c2] | 0) + u2, this.words[c2] = a3 & 67108863, u2 = a3 >>> 26;
        if (this.length = h3.length, u2 !== 0)
          this.words[this.length] = u2, this.length++;
        else if (h3 !== this)
          for (;c2 < h3.length; c2++)
            this.words[c2] = h3.words[c2];
        return this;
      }, f2.prototype.add = function(i) {
        var a3;
        return i.negative !== 0 && this.negative === 0 ? (i.negative = 0, a3 = this.sub(i), i.negative ^= 1, a3) : i.negative === 0 && this.negative !== 0 ? (this.negative = 0, a3 = i.sub(this), this.negative = 1, a3) : this.length > i.length ? this.clone().iadd(i) : i.clone().iadd(this);
      }, f2.prototype.isub = function(i) {
        if (i.negative !== 0) {
          i.negative = 0;
          var a3 = this.iadd(i);
          return i.negative = 1, a3._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(i), this.negative = 1, this._normSign();
        var h3 = this.cmp(i);
        if (h3 === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var s3, u2;
        h3 > 0 ? (s3 = this, u2 = i) : (s3 = i, u2 = this);
        for (var c2 = 0, b5 = 0;b5 < u2.length; b5++)
          a3 = (s3.words[b5] | 0) - (u2.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        for (;c2 !== 0 && b5 < s3.length; b5++)
          a3 = (s3.words[b5] | 0) + c2, c2 = a3 >> 26, this.words[b5] = a3 & 67108863;
        if (c2 === 0 && b5 < s3.length && s3 !== this)
          for (;b5 < s3.length; b5++)
            this.words[b5] = s3.words[b5];
        return this.length = Math.max(this.length, b5), s3 !== this && (this.negative = 1), this.strip();
      }, f2.prototype.sub = function(i) {
        return this.clone().isub(i);
      };
      function q(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative;
        var h3 = v2.length + i.length | 0;
        a3.length = h3, h3 = h3 - 1 | 0;
        var s3 = v2.words[0] | 0, u2 = i.words[0] | 0, c2 = s3 * u2, b5 = c2 & 67108863, l3 = c2 / 67108864 | 0;
        a3.words[0] = b5;
        for (var n = 1;n < h3; n++) {
          for (var d4 = l3 >>> 26, w3 = l3 & 67108863, g3 = Math.min(n, i.length - 1), _4 = Math.max(0, n - v2.length + 1);_4 <= g3; _4++) {
            var A4 = n - _4 | 0;
            s3 = v2.words[A4] | 0, u2 = i.words[_4] | 0, c2 = s3 * u2 + w3, d4 += c2 / 67108864 | 0, w3 = c2 & 67108863;
          }
          a3.words[n] = w3 | 0, l3 = d4 | 0;
        }
        return l3 !== 0 ? a3.words[n] = l3 | 0 : a3.length--, a3.strip();
      }
      var L3 = function(i, a3, h3) {
        var s3 = i.words, u2 = a3.words, c2 = h3.words, b5 = 0, l3, n, d4, w3 = s3[0] | 0, g3 = w3 & 8191, _4 = w3 >>> 13, A4 = s3[1] | 0, R2 = A4 & 8191, I4 = A4 >>> 13, Me = s3[2] | 0, k4 = Me & 8191, D2 = Me >>> 13, nt3 = s3[3] | 0, C3 = nt3 & 8191, O2 = nt3 >>> 13, vt = s3[4] | 0, F4 = vt & 8191, U2 = vt >>> 13, bt4 = s3[5] | 0, z = bt4 & 8191, H3 = bt4 >>> 13, mt3 = s3[6] | 0, W = mt3 & 8191, K4 = mt3 >>> 13, gt3 = s3[7] | 0, j4 = gt3 & 8191, Z3 = gt3 >>> 13, yt2 = s3[8] | 0, V4 = yt2 & 8191, $ = yt2 >>> 13, wt = s3[9] | 0, G2 = wt & 8191, Y3 = wt >>> 13, Mt = u2[0] | 0, X3 = Mt & 8191, J3 = Mt >>> 13, _t3 = u2[1] | 0, Q4 = _t3 & 8191, ee = _t3 >>> 13, xt3 = u2[2] | 0, te2 = xt3 & 8191, re2 = xt3 >>> 13, St = u2[3] | 0, ie = St & 8191, ne = St >>> 13, Et2 = u2[4] | 0, fe3 = Et2 & 8191, ae2 = Et2 >>> 13, At4 = u2[5] | 0, oe3 = At4 & 8191, se2 = At4 >>> 13, Rt = u2[6] | 0, he = Rt & 8191, ue4 = Rt >>> 13, Bt = u2[7] | 0, le = Bt & 8191, de = Bt >>> 13, qt2 = u2[8] | 0, ce3 = qt2 & 8191, pe2 = qt2 >>> 13, It = u2[9] | 0, ve = It & 8191, be = It >>> 13;
        h3.negative = i.negative ^ a3.negative, h3.length = 19, l3 = Math.imul(g3, X3), n = Math.imul(g3, J3), n = n + Math.imul(_4, X3) | 0, d4 = Math.imul(_4, J3);
        var ft = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, l3 = Math.imul(R2, X3), n = Math.imul(R2, J3), n = n + Math.imul(I4, X3) | 0, d4 = Math.imul(I4, J3), l3 = l3 + Math.imul(g3, Q4) | 0, n = n + Math.imul(g3, ee) | 0, n = n + Math.imul(_4, Q4) | 0, d4 = d4 + Math.imul(_4, ee) | 0;
        var Be = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Be >>> 26) | 0, Be &= 67108863, l3 = Math.imul(k4, X3), n = Math.imul(k4, J3), n = n + Math.imul(D2, X3) | 0, d4 = Math.imul(D2, J3), l3 = l3 + Math.imul(R2, Q4) | 0, n = n + Math.imul(R2, ee) | 0, n = n + Math.imul(I4, Q4) | 0, d4 = d4 + Math.imul(I4, ee) | 0, l3 = l3 + Math.imul(g3, te2) | 0, n = n + Math.imul(g3, re2) | 0, n = n + Math.imul(_4, te2) | 0, d4 = d4 + Math.imul(_4, re2) | 0;
        var qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (qe2 >>> 26) | 0, qe2 &= 67108863, l3 = Math.imul(C3, X3), n = Math.imul(C3, J3), n = n + Math.imul(O2, X3) | 0, d4 = Math.imul(O2, J3), l3 = l3 + Math.imul(k4, Q4) | 0, n = n + Math.imul(k4, ee) | 0, n = n + Math.imul(D2, Q4) | 0, d4 = d4 + Math.imul(D2, ee) | 0, l3 = l3 + Math.imul(R2, te2) | 0, n = n + Math.imul(R2, re2) | 0, n = n + Math.imul(I4, te2) | 0, d4 = d4 + Math.imul(I4, re2) | 0, l3 = l3 + Math.imul(g3, ie) | 0, n = n + Math.imul(g3, ne) | 0, n = n + Math.imul(_4, ie) | 0, d4 = d4 + Math.imul(_4, ne) | 0;
        var ze = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (ze >>> 26) | 0, ze &= 67108863, l3 = Math.imul(F4, X3), n = Math.imul(F4, J3), n = n + Math.imul(U2, X3) | 0, d4 = Math.imul(U2, J3), l3 = l3 + Math.imul(C3, Q4) | 0, n = n + Math.imul(C3, ee) | 0, n = n + Math.imul(O2, Q4) | 0, d4 = d4 + Math.imul(O2, ee) | 0, l3 = l3 + Math.imul(k4, te2) | 0, n = n + Math.imul(k4, re2) | 0, n = n + Math.imul(D2, te2) | 0, d4 = d4 + Math.imul(D2, re2) | 0, l3 = l3 + Math.imul(R2, ie) | 0, n = n + Math.imul(R2, ne) | 0, n = n + Math.imul(I4, ie) | 0, d4 = d4 + Math.imul(I4, ne) | 0, l3 = l3 + Math.imul(g3, fe3) | 0, n = n + Math.imul(g3, ae2) | 0, n = n + Math.imul(_4, fe3) | 0, d4 = d4 + Math.imul(_4, ae2) | 0;
        var He3 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (He3 >>> 26) | 0, He3 &= 67108863, l3 = Math.imul(z, X3), n = Math.imul(z, J3), n = n + Math.imul(H3, X3) | 0, d4 = Math.imul(H3, J3), l3 = l3 + Math.imul(F4, Q4) | 0, n = n + Math.imul(F4, ee) | 0, n = n + Math.imul(U2, Q4) | 0, d4 = d4 + Math.imul(U2, ee) | 0, l3 = l3 + Math.imul(C3, te2) | 0, n = n + Math.imul(C3, re2) | 0, n = n + Math.imul(O2, te2) | 0, d4 = d4 + Math.imul(O2, re2) | 0, l3 = l3 + Math.imul(k4, ie) | 0, n = n + Math.imul(k4, ne) | 0, n = n + Math.imul(D2, ie) | 0, d4 = d4 + Math.imul(D2, ne) | 0, l3 = l3 + Math.imul(R2, fe3) | 0, n = n + Math.imul(R2, ae2) | 0, n = n + Math.imul(I4, fe3) | 0, d4 = d4 + Math.imul(I4, ae2) | 0, l3 = l3 + Math.imul(g3, oe3) | 0, n = n + Math.imul(g3, se2) | 0, n = n + Math.imul(_4, oe3) | 0, d4 = d4 + Math.imul(_4, se2) | 0;
        var We2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (We2 >>> 26) | 0, We2 &= 67108863, l3 = Math.imul(W, X3), n = Math.imul(W, J3), n = n + Math.imul(K4, X3) | 0, d4 = Math.imul(K4, J3), l3 = l3 + Math.imul(z, Q4) | 0, n = n + Math.imul(z, ee) | 0, n = n + Math.imul(H3, Q4) | 0, d4 = d4 + Math.imul(H3, ee) | 0, l3 = l3 + Math.imul(F4, te2) | 0, n = n + Math.imul(F4, re2) | 0, n = n + Math.imul(U2, te2) | 0, d4 = d4 + Math.imul(U2, re2) | 0, l3 = l3 + Math.imul(C3, ie) | 0, n = n + Math.imul(C3, ne) | 0, n = n + Math.imul(O2, ie) | 0, d4 = d4 + Math.imul(O2, ne) | 0, l3 = l3 + Math.imul(k4, fe3) | 0, n = n + Math.imul(k4, ae2) | 0, n = n + Math.imul(D2, fe3) | 0, d4 = d4 + Math.imul(D2, ae2) | 0, l3 = l3 + Math.imul(R2, oe3) | 0, n = n + Math.imul(R2, se2) | 0, n = n + Math.imul(I4, oe3) | 0, d4 = d4 + Math.imul(I4, se2) | 0, l3 = l3 + Math.imul(g3, he) | 0, n = n + Math.imul(g3, ue4) | 0, n = n + Math.imul(_4, he) | 0, d4 = d4 + Math.imul(_4, ue4) | 0;
        var Ke2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ke2 >>> 26) | 0, Ke2 &= 67108863, l3 = Math.imul(j4, X3), n = Math.imul(j4, J3), n = n + Math.imul(Z3, X3) | 0, d4 = Math.imul(Z3, J3), l3 = l3 + Math.imul(W, Q4) | 0, n = n + Math.imul(W, ee) | 0, n = n + Math.imul(K4, Q4) | 0, d4 = d4 + Math.imul(K4, ee) | 0, l3 = l3 + Math.imul(z, te2) | 0, n = n + Math.imul(z, re2) | 0, n = n + Math.imul(H3, te2) | 0, d4 = d4 + Math.imul(H3, re2) | 0, l3 = l3 + Math.imul(F4, ie) | 0, n = n + Math.imul(F4, ne) | 0, n = n + Math.imul(U2, ie) | 0, d4 = d4 + Math.imul(U2, ne) | 0, l3 = l3 + Math.imul(C3, fe3) | 0, n = n + Math.imul(C3, ae2) | 0, n = n + Math.imul(O2, fe3) | 0, d4 = d4 + Math.imul(O2, ae2) | 0, l3 = l3 + Math.imul(k4, oe3) | 0, n = n + Math.imul(k4, se2) | 0, n = n + Math.imul(D2, oe3) | 0, d4 = d4 + Math.imul(D2, se2) | 0, l3 = l3 + Math.imul(R2, he) | 0, n = n + Math.imul(R2, ue4) | 0, n = n + Math.imul(I4, he) | 0, d4 = d4 + Math.imul(I4, ue4) | 0, l3 = l3 + Math.imul(g3, le) | 0, n = n + Math.imul(g3, de) | 0, n = n + Math.imul(_4, le) | 0, d4 = d4 + Math.imul(_4, de) | 0;
        var je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (je >>> 26) | 0, je &= 67108863, l3 = Math.imul(V4, X3), n = Math.imul(V4, J3), n = n + Math.imul($, X3) | 0, d4 = Math.imul($, J3), l3 = l3 + Math.imul(j4, Q4) | 0, n = n + Math.imul(j4, ee) | 0, n = n + Math.imul(Z3, Q4) | 0, d4 = d4 + Math.imul(Z3, ee) | 0, l3 = l3 + Math.imul(W, te2) | 0, n = n + Math.imul(W, re2) | 0, n = n + Math.imul(K4, te2) | 0, d4 = d4 + Math.imul(K4, re2) | 0, l3 = l3 + Math.imul(z, ie) | 0, n = n + Math.imul(z, ne) | 0, n = n + Math.imul(H3, ie) | 0, d4 = d4 + Math.imul(H3, ne) | 0, l3 = l3 + Math.imul(F4, fe3) | 0, n = n + Math.imul(F4, ae2) | 0, n = n + Math.imul(U2, fe3) | 0, d4 = d4 + Math.imul(U2, ae2) | 0, l3 = l3 + Math.imul(C3, oe3) | 0, n = n + Math.imul(C3, se2) | 0, n = n + Math.imul(O2, oe3) | 0, d4 = d4 + Math.imul(O2, se2) | 0, l3 = l3 + Math.imul(k4, he) | 0, n = n + Math.imul(k4, ue4) | 0, n = n + Math.imul(D2, he) | 0, d4 = d4 + Math.imul(D2, ue4) | 0, l3 = l3 + Math.imul(R2, le) | 0, n = n + Math.imul(R2, de) | 0, n = n + Math.imul(I4, le) | 0, d4 = d4 + Math.imul(I4, de) | 0, l3 = l3 + Math.imul(g3, ce3) | 0, n = n + Math.imul(g3, pe2) | 0, n = n + Math.imul(_4, ce3) | 0, d4 = d4 + Math.imul(_4, pe2) | 0;
        var Ze2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ze2 >>> 26) | 0, Ze2 &= 67108863, l3 = Math.imul(G2, X3), n = Math.imul(G2, J3), n = n + Math.imul(Y3, X3) | 0, d4 = Math.imul(Y3, J3), l3 = l3 + Math.imul(V4, Q4) | 0, n = n + Math.imul(V4, ee) | 0, n = n + Math.imul($, Q4) | 0, d4 = d4 + Math.imul($, ee) | 0, l3 = l3 + Math.imul(j4, te2) | 0, n = n + Math.imul(j4, re2) | 0, n = n + Math.imul(Z3, te2) | 0, d4 = d4 + Math.imul(Z3, re2) | 0, l3 = l3 + Math.imul(W, ie) | 0, n = n + Math.imul(W, ne) | 0, n = n + Math.imul(K4, ie) | 0, d4 = d4 + Math.imul(K4, ne) | 0, l3 = l3 + Math.imul(z, fe3) | 0, n = n + Math.imul(z, ae2) | 0, n = n + Math.imul(H3, fe3) | 0, d4 = d4 + Math.imul(H3, ae2) | 0, l3 = l3 + Math.imul(F4, oe3) | 0, n = n + Math.imul(F4, se2) | 0, n = n + Math.imul(U2, oe3) | 0, d4 = d4 + Math.imul(U2, se2) | 0, l3 = l3 + Math.imul(C3, he) | 0, n = n + Math.imul(C3, ue4) | 0, n = n + Math.imul(O2, he) | 0, d4 = d4 + Math.imul(O2, ue4) | 0, l3 = l3 + Math.imul(k4, le) | 0, n = n + Math.imul(k4, de) | 0, n = n + Math.imul(D2, le) | 0, d4 = d4 + Math.imul(D2, de) | 0, l3 = l3 + Math.imul(R2, ce3) | 0, n = n + Math.imul(R2, pe2) | 0, n = n + Math.imul(I4, ce3) | 0, d4 = d4 + Math.imul(I4, pe2) | 0, l3 = l3 + Math.imul(g3, ve) | 0, n = n + Math.imul(g3, be) | 0, n = n + Math.imul(_4, ve) | 0, d4 = d4 + Math.imul(_4, be) | 0;
        var Ve = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ve >>> 26) | 0, Ve &= 67108863, l3 = Math.imul(G2, Q4), n = Math.imul(G2, ee), n = n + Math.imul(Y3, Q4) | 0, d4 = Math.imul(Y3, ee), l3 = l3 + Math.imul(V4, te2) | 0, n = n + Math.imul(V4, re2) | 0, n = n + Math.imul($, te2) | 0, d4 = d4 + Math.imul($, re2) | 0, l3 = l3 + Math.imul(j4, ie) | 0, n = n + Math.imul(j4, ne) | 0, n = n + Math.imul(Z3, ie) | 0, d4 = d4 + Math.imul(Z3, ne) | 0, l3 = l3 + Math.imul(W, fe3) | 0, n = n + Math.imul(W, ae2) | 0, n = n + Math.imul(K4, fe3) | 0, d4 = d4 + Math.imul(K4, ae2) | 0, l3 = l3 + Math.imul(z, oe3) | 0, n = n + Math.imul(z, se2) | 0, n = n + Math.imul(H3, oe3) | 0, d4 = d4 + Math.imul(H3, se2) | 0, l3 = l3 + Math.imul(F4, he) | 0, n = n + Math.imul(F4, ue4) | 0, n = n + Math.imul(U2, he) | 0, d4 = d4 + Math.imul(U2, ue4) | 0, l3 = l3 + Math.imul(C3, le) | 0, n = n + Math.imul(C3, de) | 0, n = n + Math.imul(O2, le) | 0, d4 = d4 + Math.imul(O2, de) | 0, l3 = l3 + Math.imul(k4, ce3) | 0, n = n + Math.imul(k4, pe2) | 0, n = n + Math.imul(D2, ce3) | 0, d4 = d4 + Math.imul(D2, pe2) | 0, l3 = l3 + Math.imul(R2, ve) | 0, n = n + Math.imul(R2, be) | 0, n = n + Math.imul(I4, ve) | 0, d4 = d4 + Math.imul(I4, be) | 0;
        var $e2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + ($e2 >>> 26) | 0, $e2 &= 67108863, l3 = Math.imul(G2, te2), n = Math.imul(G2, re2), n = n + Math.imul(Y3, te2) | 0, d4 = Math.imul(Y3, re2), l3 = l3 + Math.imul(V4, ie) | 0, n = n + Math.imul(V4, ne) | 0, n = n + Math.imul($, ie) | 0, d4 = d4 + Math.imul($, ne) | 0, l3 = l3 + Math.imul(j4, fe3) | 0, n = n + Math.imul(j4, ae2) | 0, n = n + Math.imul(Z3, fe3) | 0, d4 = d4 + Math.imul(Z3, ae2) | 0, l3 = l3 + Math.imul(W, oe3) | 0, n = n + Math.imul(W, se2) | 0, n = n + Math.imul(K4, oe3) | 0, d4 = d4 + Math.imul(K4, se2) | 0, l3 = l3 + Math.imul(z, he) | 0, n = n + Math.imul(z, ue4) | 0, n = n + Math.imul(H3, he) | 0, d4 = d4 + Math.imul(H3, ue4) | 0, l3 = l3 + Math.imul(F4, le) | 0, n = n + Math.imul(F4, de) | 0, n = n + Math.imul(U2, le) | 0, d4 = d4 + Math.imul(U2, de) | 0, l3 = l3 + Math.imul(C3, ce3) | 0, n = n + Math.imul(C3, pe2) | 0, n = n + Math.imul(O2, ce3) | 0, d4 = d4 + Math.imul(O2, pe2) | 0, l3 = l3 + Math.imul(k4, ve) | 0, n = n + Math.imul(k4, be) | 0, n = n + Math.imul(D2, ve) | 0, d4 = d4 + Math.imul(D2, be) | 0;
        var Ge = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ge >>> 26) | 0, Ge &= 67108863, l3 = Math.imul(G2, ie), n = Math.imul(G2, ne), n = n + Math.imul(Y3, ie) | 0, d4 = Math.imul(Y3, ne), l3 = l3 + Math.imul(V4, fe3) | 0, n = n + Math.imul(V4, ae2) | 0, n = n + Math.imul($, fe3) | 0, d4 = d4 + Math.imul($, ae2) | 0, l3 = l3 + Math.imul(j4, oe3) | 0, n = n + Math.imul(j4, se2) | 0, n = n + Math.imul(Z3, oe3) | 0, d4 = d4 + Math.imul(Z3, se2) | 0, l3 = l3 + Math.imul(W, he) | 0, n = n + Math.imul(W, ue4) | 0, n = n + Math.imul(K4, he) | 0, d4 = d4 + Math.imul(K4, ue4) | 0, l3 = l3 + Math.imul(z, le) | 0, n = n + Math.imul(z, de) | 0, n = n + Math.imul(H3, le) | 0, d4 = d4 + Math.imul(H3, de) | 0, l3 = l3 + Math.imul(F4, ce3) | 0, n = n + Math.imul(F4, pe2) | 0, n = n + Math.imul(U2, ce3) | 0, d4 = d4 + Math.imul(U2, pe2) | 0, l3 = l3 + Math.imul(C3, ve) | 0, n = n + Math.imul(C3, be) | 0, n = n + Math.imul(O2, ve) | 0, d4 = d4 + Math.imul(O2, be) | 0;
        var Ye = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Ye >>> 26) | 0, Ye &= 67108863, l3 = Math.imul(G2, fe3), n = Math.imul(G2, ae2), n = n + Math.imul(Y3, fe3) | 0, d4 = Math.imul(Y3, ae2), l3 = l3 + Math.imul(V4, oe3) | 0, n = n + Math.imul(V4, se2) | 0, n = n + Math.imul($, oe3) | 0, d4 = d4 + Math.imul($, se2) | 0, l3 = l3 + Math.imul(j4, he) | 0, n = n + Math.imul(j4, ue4) | 0, n = n + Math.imul(Z3, he) | 0, d4 = d4 + Math.imul(Z3, ue4) | 0, l3 = l3 + Math.imul(W, le) | 0, n = n + Math.imul(W, de) | 0, n = n + Math.imul(K4, le) | 0, d4 = d4 + Math.imul(K4, de) | 0, l3 = l3 + Math.imul(z, ce3) | 0, n = n + Math.imul(z, pe2) | 0, n = n + Math.imul(H3, ce3) | 0, d4 = d4 + Math.imul(H3, pe2) | 0, l3 = l3 + Math.imul(F4, ve) | 0, n = n + Math.imul(F4, be) | 0, n = n + Math.imul(U2, ve) | 0, d4 = d4 + Math.imul(U2, be) | 0;
        var Xe = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Xe >>> 26) | 0, Xe &= 67108863, l3 = Math.imul(G2, oe3), n = Math.imul(G2, se2), n = n + Math.imul(Y3, oe3) | 0, d4 = Math.imul(Y3, se2), l3 = l3 + Math.imul(V4, he) | 0, n = n + Math.imul(V4, ue4) | 0, n = n + Math.imul($, he) | 0, d4 = d4 + Math.imul($, ue4) | 0, l3 = l3 + Math.imul(j4, le) | 0, n = n + Math.imul(j4, de) | 0, n = n + Math.imul(Z3, le) | 0, d4 = d4 + Math.imul(Z3, de) | 0, l3 = l3 + Math.imul(W, ce3) | 0, n = n + Math.imul(W, pe2) | 0, n = n + Math.imul(K4, ce3) | 0, d4 = d4 + Math.imul(K4, pe2) | 0, l3 = l3 + Math.imul(z, ve) | 0, n = n + Math.imul(z, be) | 0, n = n + Math.imul(H3, ve) | 0, d4 = d4 + Math.imul(H3, be) | 0;
        var Je = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Je >>> 26) | 0, Je &= 67108863, l3 = Math.imul(G2, he), n = Math.imul(G2, ue4), n = n + Math.imul(Y3, he) | 0, d4 = Math.imul(Y3, ue4), l3 = l3 + Math.imul(V4, le) | 0, n = n + Math.imul(V4, de) | 0, n = n + Math.imul($, le) | 0, d4 = d4 + Math.imul($, de) | 0, l3 = l3 + Math.imul(j4, ce3) | 0, n = n + Math.imul(j4, pe2) | 0, n = n + Math.imul(Z3, ce3) | 0, d4 = d4 + Math.imul(Z3, pe2) | 0, l3 = l3 + Math.imul(W, ve) | 0, n = n + Math.imul(W, be) | 0, n = n + Math.imul(K4, ve) | 0, d4 = d4 + Math.imul(K4, be) | 0;
        var Qe2 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (Qe2 >>> 26) | 0, Qe2 &= 67108863, l3 = Math.imul(G2, le), n = Math.imul(G2, de), n = n + Math.imul(Y3, le) | 0, d4 = Math.imul(Y3, de), l3 = l3 + Math.imul(V4, ce3) | 0, n = n + Math.imul(V4, pe2) | 0, n = n + Math.imul($, ce3) | 0, d4 = d4 + Math.imul($, pe2) | 0, l3 = l3 + Math.imul(j4, ve) | 0, n = n + Math.imul(j4, be) | 0, n = n + Math.imul(Z3, ve) | 0, d4 = d4 + Math.imul(Z3, be) | 0;
        var et4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (et4 >>> 26) | 0, et4 &= 67108863, l3 = Math.imul(G2, ce3), n = Math.imul(G2, pe2), n = n + Math.imul(Y3, ce3) | 0, d4 = Math.imul(Y3, pe2), l3 = l3 + Math.imul(V4, ve) | 0, n = n + Math.imul(V4, be) | 0, n = n + Math.imul($, ve) | 0, d4 = d4 + Math.imul($, be) | 0;
        var tt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        b5 = (d4 + (n >>> 13) | 0) + (tt4 >>> 26) | 0, tt4 &= 67108863, l3 = Math.imul(G2, ve), n = Math.imul(G2, be), n = n + Math.imul(Y3, ve) | 0, d4 = Math.imul(Y3, be);
        var rt4 = (b5 + l3 | 0) + ((n & 8191) << 13) | 0;
        return b5 = (d4 + (n >>> 13) | 0) + (rt4 >>> 26) | 0, rt4 &= 67108863, c2[0] = ft, c2[1] = Be, c2[2] = qe2, c2[3] = ze, c2[4] = He3, c2[5] = We2, c2[6] = Ke2, c2[7] = je, c2[8] = Ze2, c2[9] = Ve, c2[10] = $e2, c2[11] = Ge, c2[12] = Ye, c2[13] = Xe, c2[14] = Je, c2[15] = Qe2, c2[16] = et4, c2[17] = tt4, c2[18] = rt4, b5 !== 0 && (c2[19] = b5, h3.length++), h3;
      };
      Math.imul || (L3 = q);
      function ge(v2, i, a3) {
        a3.negative = i.negative ^ v2.negative, a3.length = v2.length + i.length;
        for (var h3 = 0, s3 = 0, u2 = 0;u2 < a3.length - 1; u2++) {
          var c2 = s3;
          s3 = 0;
          for (var b5 = h3 & 67108863, l3 = Math.min(u2, i.length - 1), n = Math.max(0, u2 - v2.length + 1);n <= l3; n++) {
            var d4 = u2 - n, w3 = v2.words[d4] | 0, g3 = i.words[n] | 0, _4 = w3 * g3, A4 = _4 & 67108863;
            c2 = c2 + (_4 / 67108864 | 0) | 0, A4 = A4 + b5 | 0, b5 = A4 & 67108863, c2 = c2 + (A4 >>> 26) | 0, s3 += c2 >>> 26, c2 &= 67108863;
          }
          a3.words[u2] = b5, h3 = c2, c2 = s3;
        }
        return h3 !== 0 ? a3.words[u2] = h3 : a3.length--, a3.strip();
      }
      function _e3(v2, i, a3) {
        var h3 = new N5;
        return h3.mulp(v2, i, a3);
      }
      f2.prototype.mulTo = function(i, a3) {
        var h3, s3 = this.length + i.length;
        return this.length === 10 && i.length === 10 ? h3 = L3(this, i, a3) : s3 < 63 ? h3 = q(this, i, a3) : s3 < 1024 ? h3 = ge(this, i, a3) : h3 = _e3(this, i, a3), h3;
      };
      function N5(v2, i) {
        this.x = v2, this.y = i;
      }
      N5.prototype.makeRBT = function(i) {
        for (var a3 = new Array(i), h3 = f2.prototype._countBits(i) - 1, s3 = 0;s3 < i; s3++)
          a3[s3] = this.revBin(s3, h3, i);
        return a3;
      }, N5.prototype.revBin = function(i, a3, h3) {
        if (i === 0 || i === h3 - 1)
          return i;
        for (var s3 = 0, u2 = 0;u2 < a3; u2++)
          s3 |= (i & 1) << a3 - u2 - 1, i >>= 1;
        return s3;
      }, N5.prototype.permute = function(i, a3, h3, s3, u2, c2) {
        for (var b5 = 0;b5 < c2; b5++)
          s3[b5] = a3[i[b5]], u2[b5] = h3[i[b5]];
      }, N5.prototype.transform = function(i, a3, h3, s3, u2, c2) {
        this.permute(c2, i, a3, h3, s3, u2);
        for (var b5 = 1;b5 < u2; b5 <<= 1)
          for (var l3 = b5 << 1, n = Math.cos(2 * Math.PI / l3), d4 = Math.sin(2 * Math.PI / l3), w3 = 0;w3 < u2; w3 += l3)
            for (var g3 = n, _4 = d4, A4 = 0;A4 < b5; A4++) {
              var R2 = h3[w3 + A4], I4 = s3[w3 + A4], Me = h3[w3 + A4 + b5], k4 = s3[w3 + A4 + b5], D2 = g3 * Me - _4 * k4;
              k4 = g3 * k4 + _4 * Me, Me = D2, h3[w3 + A4] = R2 + Me, s3[w3 + A4] = I4 + k4, h3[w3 + A4 + b5] = R2 - Me, s3[w3 + A4 + b5] = I4 - k4, A4 !== l3 && (D2 = n * g3 - d4 * _4, _4 = n * _4 + d4 * g3, g3 = D2);
            }
      }, N5.prototype.guessLen13b = function(i, a3) {
        var h3 = Math.max(a3, i) | 1, s3 = h3 & 1, u2 = 0;
        for (h3 = h3 / 2 | 0;h3; h3 = h3 >>> 1)
          u2++;
        return 1 << u2 + 1 + s3;
      }, N5.prototype.conjugate = function(i, a3, h3) {
        if (!(h3 <= 1))
          for (var s3 = 0;s3 < h3 / 2; s3++) {
            var u2 = i[s3];
            i[s3] = i[h3 - s3 - 1], i[h3 - s3 - 1] = u2, u2 = a3[s3], a3[s3] = -a3[h3 - s3 - 1], a3[h3 - s3 - 1] = -u2;
          }
      }, N5.prototype.normalize13b = function(i, a3) {
        for (var h3 = 0, s3 = 0;s3 < a3 / 2; s3++) {
          var u2 = Math.round(i[2 * s3 + 1] / a3) * 8192 + Math.round(i[2 * s3] / a3) + h3;
          i[s3] = u2 & 67108863, u2 < 67108864 ? h3 = 0 : h3 = u2 / 67108864 | 0;
        }
        return i;
      }, N5.prototype.convert13b = function(i, a3, h3, s3) {
        for (var u2 = 0, c2 = 0;c2 < a3; c2++)
          u2 = u2 + (i[c2] | 0), h3[2 * c2] = u2 & 8191, u2 = u2 >>> 13, h3[2 * c2 + 1] = u2 & 8191, u2 = u2 >>> 13;
        for (c2 = 2 * a3;c2 < s3; ++c2)
          h3[c2] = 0;
        r(u2 === 0), r((u2 & -8192) === 0);
      }, N5.prototype.stub = function(i) {
        for (var a3 = new Array(i), h3 = 0;h3 < i; h3++)
          a3[h3] = 0;
        return a3;
      }, N5.prototype.mulp = function(i, a3, h3) {
        var s3 = 2 * this.guessLen13b(i.length, a3.length), u2 = this.makeRBT(s3), c2 = this.stub(s3), b5 = new Array(s3), l3 = new Array(s3), n = new Array(s3), d4 = new Array(s3), w3 = new Array(s3), g3 = new Array(s3), _4 = h3.words;
        _4.length = s3, this.convert13b(i.words, i.length, b5, s3), this.convert13b(a3.words, a3.length, d4, s3), this.transform(b5, c2, l3, n, s3, u2), this.transform(d4, c2, w3, g3, s3, u2);
        for (var A4 = 0;A4 < s3; A4++) {
          var R2 = l3[A4] * w3[A4] - n[A4] * g3[A4];
          n[A4] = l3[A4] * g3[A4] + n[A4] * w3[A4], l3[A4] = R2;
        }
        return this.conjugate(l3, n, s3), this.transform(l3, n, _4, c2, s3, u2), this.conjugate(_4, c2, s3), this.normalize13b(_4, s3), h3.negative = i.negative ^ a3.negative, h3.length = i.length + a3.length, h3.strip();
      }, f2.prototype.mul = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), this.mulTo(i, a3);
      }, f2.prototype.mulf = function(i) {
        var a3 = new f2(null);
        return a3.words = new Array(this.length + i.length), _e3(this, i, a3);
      }, f2.prototype.imul = function(i) {
        return this.clone().mulTo(i, this);
      }, f2.prototype.imuln = function(i) {
        r(typeof i == "number"), r(i < 67108864);
        for (var a3 = 0, h3 = 0;h3 < this.length; h3++) {
          var s3 = (this.words[h3] | 0) * i, u2 = (s3 & 67108863) + (a3 & 67108863);
          a3 >>= 26, a3 += s3 / 67108864 | 0, a3 += u2 >>> 26, this.words[h3] = u2 & 67108863;
        }
        return a3 !== 0 && (this.words[h3] = a3, this.length++), this;
      }, f2.prototype.muln = function(i) {
        return this.clone().imuln(i);
      }, f2.prototype.sqr = function() {
        return this.mul(this);
      }, f2.prototype.isqr = function() {
        return this.imul(this.clone());
      }, f2.prototype.pow = function(i) {
        var a3 = B3(i);
        if (a3.length === 0)
          return new f2(1);
        for (var h3 = this, s3 = 0;s3 < a3.length && a3[s3] === 0; s3++, h3 = h3.sqr())
          ;
        if (++s3 < a3.length)
          for (var u2 = h3.sqr();s3 < a3.length; s3++, u2 = u2.sqr())
            a3[s3] !== 0 && (h3 = h3.mul(u2));
        return h3;
      }, f2.prototype.iushln = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 67108863 >>> 26 - a3 << 26 - a3, u2;
        if (a3 !== 0) {
          var c2 = 0;
          for (u2 = 0;u2 < this.length; u2++) {
            var b5 = this.words[u2] & s3, l3 = (this.words[u2] | 0) - b5 << a3;
            this.words[u2] = l3 | c2, c2 = b5 >>> 26 - a3;
          }
          c2 && (this.words[u2] = c2, this.length++);
        }
        if (h3 !== 0) {
          for (u2 = this.length - 1;u2 >= 0; u2--)
            this.words[u2 + h3] = this.words[u2];
          for (u2 = 0;u2 < h3; u2++)
            this.words[u2] = 0;
          this.length += h3;
        }
        return this.strip();
      }, f2.prototype.ishln = function(i) {
        return r(this.negative === 0), this.iushln(i);
      }, f2.prototype.iushrn = function(i, a3, h3) {
        r(typeof i == "number" && i >= 0);
        var s3;
        a3 ? s3 = (a3 - a3 % 26) / 26 : s3 = 0;
        var u2 = i % 26, c2 = Math.min((i - u2) / 26, this.length), b5 = 67108863 ^ 67108863 >>> u2 << u2, l3 = h3;
        if (s3 -= c2, s3 = Math.max(0, s3), l3) {
          for (var n = 0;n < c2; n++)
            l3.words[n] = this.words[n];
          l3.length = c2;
        }
        if (c2 !== 0)
          if (this.length > c2)
            for (this.length -= c2, n = 0;n < this.length; n++)
              this.words[n] = this.words[n + c2];
          else
            this.words[0] = 0, this.length = 1;
        var d4 = 0;
        for (n = this.length - 1;n >= 0 && (d4 !== 0 || n >= s3); n--) {
          var w3 = this.words[n] | 0;
          this.words[n] = d4 << 26 - u2 | w3 >>> u2, d4 = w3 & b5;
        }
        return l3 && d4 !== 0 && (l3.words[l3.length++] = d4), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, f2.prototype.ishrn = function(i, a3, h3) {
        return r(this.negative === 0), this.iushrn(i, a3, h3);
      }, f2.prototype.shln = function(i) {
        return this.clone().ishln(i);
      }, f2.prototype.ushln = function(i) {
        return this.clone().iushln(i);
      }, f2.prototype.shrn = function(i) {
        return this.clone().ishrn(i);
      }, f2.prototype.ushrn = function(i) {
        return this.clone().iushrn(i);
      }, f2.prototype.testn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return false;
        var u2 = this.words[h3];
        return !!(u2 & s3);
      }, f2.prototype.imaskn = function(i) {
        r(typeof i == "number" && i >= 0);
        var a3 = i % 26, h3 = (i - a3) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= h3)
          return this;
        if (a3 !== 0 && h3++, this.length = Math.min(h3, this.length), a3 !== 0) {
          var s3 = 67108863 ^ 67108863 >>> a3 << a3;
          this.words[this.length - 1] &= s3;
        }
        return this.strip();
      }, f2.prototype.maskn = function(i) {
        return this.clone().imaskn(i);
      }, f2.prototype.iaddn = function(i) {
        return r(typeof i == "number"), r(i < 67108864), i < 0 ? this.isubn(-i) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < i ? (this.words[0] = i - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(i), this.negative = 1, this) : this._iaddn(i);
      }, f2.prototype._iaddn = function(i) {
        this.words[0] += i;
        for (var a3 = 0;a3 < this.length && this.words[a3] >= 67108864; a3++)
          this.words[a3] -= 67108864, a3 === this.length - 1 ? this.words[a3 + 1] = 1 : this.words[a3 + 1]++;
        return this.length = Math.max(this.length, a3 + 1), this;
      }, f2.prototype.isubn = function(i) {
        if (r(typeof i == "number"), r(i < 67108864), i < 0)
          return this.iaddn(-i);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(i), this.negative = 1, this;
        if (this.words[0] -= i, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var a3 = 0;a3 < this.length && this.words[a3] < 0; a3++)
            this.words[a3] += 67108864, this.words[a3 + 1] -= 1;
        return this.strip();
      }, f2.prototype.addn = function(i) {
        return this.clone().iaddn(i);
      }, f2.prototype.subn = function(i) {
        return this.clone().isubn(i);
      }, f2.prototype.iabs = function() {
        return this.negative = 0, this;
      }, f2.prototype.abs = function() {
        return this.clone().iabs();
      }, f2.prototype._ishlnsubmul = function(i, a3, h3) {
        var s3 = i.length + h3, u2;
        this._expand(s3);
        var c2, b5 = 0;
        for (u2 = 0;u2 < i.length; u2++) {
          c2 = (this.words[u2 + h3] | 0) + b5;
          var l3 = (i.words[u2] | 0) * a3;
          c2 -= l3 & 67108863, b5 = (c2 >> 26) - (l3 / 67108864 | 0), this.words[u2 + h3] = c2 & 67108863;
        }
        for (;u2 < this.length - h3; u2++)
          c2 = (this.words[u2 + h3] | 0) + b5, b5 = c2 >> 26, this.words[u2 + h3] = c2 & 67108863;
        if (b5 === 0)
          return this.strip();
        for (r(b5 === -1), b5 = 0, u2 = 0;u2 < this.length; u2++)
          c2 = -(this.words[u2] | 0) + b5, b5 = c2 >> 26, this.words[u2] = c2 & 67108863;
        return this.negative = 1, this.strip();
      }, f2.prototype._wordDiv = function(i, a3) {
        var h3 = this.length - i.length, s3 = this.clone(), u2 = i, c2 = u2.words[u2.length - 1] | 0, b5 = this._countBits(c2);
        h3 = 26 - b5, h3 !== 0 && (u2 = u2.ushln(h3), s3.iushln(h3), c2 = u2.words[u2.length - 1] | 0);
        var l3 = s3.length - u2.length, n;
        if (a3 !== "mod") {
          n = new f2(null), n.length = l3 + 1, n.words = new Array(n.length);
          for (var d4 = 0;d4 < n.length; d4++)
            n.words[d4] = 0;
        }
        var w3 = s3.clone()._ishlnsubmul(u2, 1, l3);
        w3.negative === 0 && (s3 = w3, n && (n.words[l3] = 1));
        for (var g3 = l3 - 1;g3 >= 0; g3--) {
          var _4 = (s3.words[u2.length + g3] | 0) * 67108864 + (s3.words[u2.length + g3 - 1] | 0);
          for (_4 = Math.min(_4 / c2 | 0, 67108863), s3._ishlnsubmul(u2, _4, g3);s3.negative !== 0; )
            _4--, s3.negative = 0, s3._ishlnsubmul(u2, 1, g3), s3.isZero() || (s3.negative ^= 1);
          n && (n.words[g3] = _4);
        }
        return n && n.strip(), s3.strip(), a3 !== "div" && h3 !== 0 && s3.iushrn(h3), { div: n || null, mod: s3 };
      }, f2.prototype.divmod = function(i, a3, h3) {
        if (r(!i.isZero()), this.isZero())
          return { div: new f2(0), mod: new f2(0) };
        var s3, u2, c2;
        return this.negative !== 0 && i.negative === 0 ? (c2 = this.neg().divmod(i, a3), a3 !== "mod" && (s3 = c2.div.neg()), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.iadd(i)), { div: s3, mod: u2 }) : this.negative === 0 && i.negative !== 0 ? (c2 = this.divmod(i.neg(), a3), a3 !== "mod" && (s3 = c2.div.neg()), { div: s3, mod: c2.mod }) : (this.negative & i.negative) !== 0 ? (c2 = this.neg().divmod(i.neg(), a3), a3 !== "div" && (u2 = c2.mod.neg(), h3 && u2.negative !== 0 && u2.isub(i)), { div: c2.div, mod: u2 }) : i.length > this.length || this.cmp(i) < 0 ? { div: new f2(0), mod: this } : i.length === 1 ? a3 === "div" ? { div: this.divn(i.words[0]), mod: null } : a3 === "mod" ? { div: null, mod: new f2(this.modn(i.words[0])) } : { div: this.divn(i.words[0]), mod: new f2(this.modn(i.words[0])) } : this._wordDiv(i, a3);
      }, f2.prototype.div = function(i) {
        return this.divmod(i, "div", false).div;
      }, f2.prototype.mod = function(i) {
        return this.divmod(i, "mod", false).mod;
      }, f2.prototype.umod = function(i) {
        return this.divmod(i, "mod", true).mod;
      }, f2.prototype.divRound = function(i) {
        var a3 = this.divmod(i);
        if (a3.mod.isZero())
          return a3.div;
        var h3 = a3.div.negative !== 0 ? a3.mod.isub(i) : a3.mod, s3 = i.ushrn(1), u2 = i.andln(1), c2 = h3.cmp(s3);
        return c2 < 0 || u2 === 1 && c2 === 0 ? a3.div : a3.div.negative !== 0 ? a3.div.isubn(1) : a3.div.iaddn(1);
      }, f2.prototype.modn = function(i) {
        r(i <= 67108863);
        for (var a3 = (1 << 26) % i, h3 = 0, s3 = this.length - 1;s3 >= 0; s3--)
          h3 = (a3 * h3 + (this.words[s3] | 0)) % i;
        return h3;
      }, f2.prototype.idivn = function(i) {
        r(i <= 67108863);
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = (this.words[h3] | 0) + a3 * 67108864;
          this.words[h3] = s3 / i | 0, a3 = s3 % i;
        }
        return this.strip();
      }, f2.prototype.divn = function(i) {
        return this.clone().idivn(i);
      }, f2.prototype.egcd = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = new f2(0), b5 = new f2(1), l3 = 0;a3.isEven() && h3.isEven(); )
          a3.iushrn(1), h3.iushrn(1), ++l3;
        for (var n = h3.clone(), d4 = a3.clone();!a3.isZero(); ) {
          for (var w3 = 0, g3 = 1;(a3.words[0] & g3) === 0 && w3 < 26; ++w3, g3 <<= 1)
            ;
          if (w3 > 0)
            for (a3.iushrn(w3);w3-- > 0; )
              (s3.isOdd() || u2.isOdd()) && (s3.iadd(n), u2.isub(d4)), s3.iushrn(1), u2.iushrn(1);
          for (var _4 = 0, A4 = 1;(h3.words[0] & A4) === 0 && _4 < 26; ++_4, A4 <<= 1)
            ;
          if (_4 > 0)
            for (h3.iushrn(_4);_4-- > 0; )
              (c2.isOdd() || b5.isOdd()) && (c2.iadd(n), b5.isub(d4)), c2.iushrn(1), b5.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(c2), u2.isub(b5)) : (h3.isub(a3), c2.isub(s3), b5.isub(u2));
        }
        return { a: c2, b: b5, gcd: h3.iushln(l3) };
      }, f2.prototype._invmp = function(i) {
        r(i.negative === 0), r(!i.isZero());
        var a3 = this, h3 = i.clone();
        a3.negative !== 0 ? a3 = a3.umod(i) : a3 = a3.clone();
        for (var s3 = new f2(1), u2 = new f2(0), c2 = h3.clone();a3.cmpn(1) > 0 && h3.cmpn(1) > 0; ) {
          for (var b5 = 0, l3 = 1;(a3.words[0] & l3) === 0 && b5 < 26; ++b5, l3 <<= 1)
            ;
          if (b5 > 0)
            for (a3.iushrn(b5);b5-- > 0; )
              s3.isOdd() && s3.iadd(c2), s3.iushrn(1);
          for (var n = 0, d4 = 1;(h3.words[0] & d4) === 0 && n < 26; ++n, d4 <<= 1)
            ;
          if (n > 0)
            for (h3.iushrn(n);n-- > 0; )
              u2.isOdd() && u2.iadd(c2), u2.iushrn(1);
          a3.cmp(h3) >= 0 ? (a3.isub(h3), s3.isub(u2)) : (h3.isub(a3), u2.isub(s3));
        }
        var w3;
        return a3.cmpn(1) === 0 ? w3 = s3 : w3 = u2, w3.cmpn(0) < 0 && w3.iadd(i), w3;
      }, f2.prototype.gcd = function(i) {
        if (this.isZero())
          return i.abs();
        if (i.isZero())
          return this.abs();
        var a3 = this.clone(), h3 = i.clone();
        a3.negative = 0, h3.negative = 0;
        for (var s3 = 0;a3.isEven() && h3.isEven(); s3++)
          a3.iushrn(1), h3.iushrn(1);
        do {
          for (;a3.isEven(); )
            a3.iushrn(1);
          for (;h3.isEven(); )
            h3.iushrn(1);
          var u2 = a3.cmp(h3);
          if (u2 < 0) {
            var c2 = a3;
            a3 = h3, h3 = c2;
          } else if (u2 === 0 || h3.cmpn(1) === 0)
            break;
          a3.isub(h3);
        } while (true);
        return h3.iushln(s3);
      }, f2.prototype.invm = function(i) {
        return this.egcd(i).a.umod(i);
      }, f2.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, f2.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, f2.prototype.andln = function(i) {
        return this.words[0] & i;
      }, f2.prototype.bincn = function(i) {
        r(typeof i == "number");
        var a3 = i % 26, h3 = (i - a3) / 26, s3 = 1 << a3;
        if (this.length <= h3)
          return this._expand(h3 + 1), this.words[h3] |= s3, this;
        for (var u2 = s3, c2 = h3;u2 !== 0 && c2 < this.length; c2++) {
          var b5 = this.words[c2] | 0;
          b5 += u2, u2 = b5 >>> 26, b5 &= 67108863, this.words[c2] = b5;
        }
        return u2 !== 0 && (this.words[c2] = u2, this.length++), this;
      }, f2.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, f2.prototype.cmpn = function(i) {
        var a3 = i < 0;
        if (this.negative !== 0 && !a3)
          return -1;
        if (this.negative === 0 && a3)
          return 1;
        this.strip();
        var h3;
        if (this.length > 1)
          h3 = 1;
        else {
          a3 && (i = -i), r(i <= 67108863, "Number is too big");
          var s3 = this.words[0] | 0;
          h3 = s3 === i ? 0 : s3 < i ? -1 : 1;
        }
        return this.negative !== 0 ? -h3 | 0 : h3;
      }, f2.prototype.cmp = function(i) {
        if (this.negative !== 0 && i.negative === 0)
          return -1;
        if (this.negative === 0 && i.negative !== 0)
          return 1;
        var a3 = this.ucmp(i);
        return this.negative !== 0 ? -a3 | 0 : a3;
      }, f2.prototype.ucmp = function(i) {
        if (this.length > i.length)
          return 1;
        if (this.length < i.length)
          return -1;
        for (var a3 = 0, h3 = this.length - 1;h3 >= 0; h3--) {
          var s3 = this.words[h3] | 0, u2 = i.words[h3] | 0;
          if (s3 !== u2) {
            s3 < u2 ? a3 = -1 : s3 > u2 && (a3 = 1);
            break;
          }
        }
        return a3;
      }, f2.prototype.gtn = function(i) {
        return this.cmpn(i) === 1;
      }, f2.prototype.gt = function(i) {
        return this.cmp(i) === 1;
      }, f2.prototype.gten = function(i) {
        return this.cmpn(i) >= 0;
      }, f2.prototype.gte = function(i) {
        return this.cmp(i) >= 0;
      }, f2.prototype.ltn = function(i) {
        return this.cmpn(i) === -1;
      }, f2.prototype.lt = function(i) {
        return this.cmp(i) === -1;
      }, f2.prototype.lten = function(i) {
        return this.cmpn(i) <= 0;
      }, f2.prototype.lte = function(i) {
        return this.cmp(i) <= 0;
      }, f2.prototype.eqn = function(i) {
        return this.cmpn(i) === 0;
      }, f2.prototype.eq = function(i) {
        return this.cmp(i) === 0;
      }, f2.red = function(i) {
        return new P2(i);
      }, f2.prototype.toRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), i.convertTo(this)._forceRed(i);
      }, f2.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, f2.prototype._forceRed = function(i) {
        return this.red = i, this;
      }, f2.prototype.forceRed = function(i) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(i);
      }, f2.prototype.redAdd = function(i) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, i);
      }, f2.prototype.redIAdd = function(i) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, i);
      }, f2.prototype.redSub = function(i) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, i);
      }, f2.prototype.redISub = function(i) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, i);
      }, f2.prototype.redShl = function(i) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, i);
      }, f2.prototype.redMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.mul(this, i);
      }, f2.prototype.redIMul = function(i) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, i), this.red.imul(this, i);
      }, f2.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, f2.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, f2.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, f2.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, f2.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, f2.prototype.redPow = function(i) {
        return r(this.red && !i.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, i);
      };
      var we = { k256: null, p224: null, p192: null, p25519: null };
      function ye(v2, i) {
        this.name = v2, this.p = new f2(i, 16), this.n = this.p.bitLength(), this.k = new f2(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ye.prototype._tmp = function() {
        var i = new f2(null);
        return i.words = new Array(Math.ceil(this.n / 13)), i;
      }, ye.prototype.ireduce = function(i) {
        var a3 = i, h3;
        do
          this.split(a3, this.tmp), a3 = this.imulK(a3), a3 = a3.iadd(this.tmp), h3 = a3.bitLength();
        while (h3 > this.n);
        var s3 = h3 < this.n ? -1 : a3.ucmp(this.p);
        return s3 === 0 ? (a3.words[0] = 0, a3.length = 1) : s3 > 0 ? a3.isub(this.p) : a3.strip !== undefined ? a3.strip() : a3._strip(), a3;
      }, ye.prototype.split = function(i, a3) {
        i.iushrn(this.n, 0, a3);
      }, ye.prototype.imulK = function(i) {
        return i.imul(this.k);
      };
      function xe() {
        ye.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      o2(xe, ye), xe.prototype.split = function(i, a3) {
        for (var h3 = 4194303, s3 = Math.min(i.length, 9), u2 = 0;u2 < s3; u2++)
          a3.words[u2] = i.words[u2];
        if (a3.length = s3, i.length <= 9) {
          i.words[0] = 0, i.length = 1;
          return;
        }
        var c2 = i.words[9];
        for (a3.words[a3.length++] = c2 & h3, u2 = 10;u2 < i.length; u2++) {
          var b5 = i.words[u2] | 0;
          i.words[u2 - 10] = (b5 & h3) << 4 | c2 >>> 22, c2 = b5;
        }
        c2 >>>= 22, i.words[u2 - 10] = c2, c2 === 0 && i.length > 10 ? i.length -= 10 : i.length -= 9;
      }, xe.prototype.imulK = function(i) {
        i.words[i.length] = 0, i.words[i.length + 1] = 0, i.length += 2;
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = i.words[h3] | 0;
          a3 += s3 * 977, i.words[h3] = a3 & 67108863, a3 = s3 * 64 + (a3 / 67108864 | 0);
        }
        return i.words[i.length - 1] === 0 && (i.length--, i.words[i.length - 1] === 0 && i.length--), i;
      };
      function Re() {
        ye.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      o2(Re, ye);
      function Ee() {
        ye.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      o2(Ee, ye);
      function Ae2() {
        ye.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      o2(Ae2, ye), Ae2.prototype.imulK = function(i) {
        for (var a3 = 0, h3 = 0;h3 < i.length; h3++) {
          var s3 = (i.words[h3] | 0) * 19 + a3, u2 = s3 & 67108863;
          s3 >>>= 26, i.words[h3] = u2, a3 = s3;
        }
        return a3 !== 0 && (i.words[i.length++] = a3), i;
      }, f2._prime = function(i) {
        if (we[i])
          return we[i];
        var a3;
        if (i === "k256")
          a3 = new xe;
        else if (i === "p224")
          a3 = new Re;
        else if (i === "p192")
          a3 = new Ee;
        else if (i === "p25519")
          a3 = new Ae2;
        else
          throw new Error("Unknown prime " + i);
        return we[i] = a3, a3;
      };
      function P2(v2) {
        if (typeof v2 == "string") {
          var i = f2._prime(v2);
          this.m = i.p, this.prime = i;
        } else
          r(v2.gtn(1), "modulus must be greater than 1"), this.m = v2, this.prime = null;
      }
      P2.prototype._verify1 = function(i) {
        r(i.negative === 0, "red works only with positives"), r(i.red, "red works only with red numbers");
      }, P2.prototype._verify2 = function(i, a3) {
        r((i.negative | a3.negative) === 0, "red works only with positives"), r(i.red && i.red === a3.red, "red works only with red numbers");
      }, P2.prototype.imod = function(i) {
        return this.prime ? this.prime.ireduce(i)._forceRed(this) : i.umod(this.m)._forceRed(this);
      }, P2.prototype.neg = function(i) {
        return i.isZero() ? i.clone() : this.m.sub(i)._forceRed(this);
      }, P2.prototype.add = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.add(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3._forceRed(this);
      }, P2.prototype.iadd = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.iadd(a3);
        return h3.cmp(this.m) >= 0 && h3.isub(this.m), h3;
      }, P2.prototype.sub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.sub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3._forceRed(this);
      }, P2.prototype.isub = function(i, a3) {
        this._verify2(i, a3);
        var h3 = i.isub(a3);
        return h3.cmpn(0) < 0 && h3.iadd(this.m), h3;
      }, P2.prototype.shl = function(i, a3) {
        return this._verify1(i), this.imod(i.ushln(a3));
      }, P2.prototype.imul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.imul(a3));
      }, P2.prototype.mul = function(i, a3) {
        return this._verify2(i, a3), this.imod(i.mul(a3));
      }, P2.prototype.isqr = function(i) {
        return this.imul(i, i.clone());
      }, P2.prototype.sqr = function(i) {
        return this.mul(i, i);
      }, P2.prototype.sqrt = function(i) {
        if (i.isZero())
          return i.clone();
        var a3 = this.m.andln(3);
        if (r(a3 % 2 === 1), a3 === 3) {
          var h3 = this.m.add(new f2(1)).iushrn(2);
          return this.pow(i, h3);
        }
        for (var s3 = this.m.subn(1), u2 = 0;!s3.isZero() && s3.andln(1) === 0; )
          u2++, s3.iushrn(1);
        r(!s3.isZero());
        var c2 = new f2(1).toRed(this), b5 = c2.redNeg(), l3 = this.m.subn(1).iushrn(1), n = this.m.bitLength();
        for (n = new f2(2 * n * n).toRed(this);this.pow(n, l3).cmp(b5) !== 0; )
          n.redIAdd(b5);
        for (var d4 = this.pow(n, s3), w3 = this.pow(i, s3.addn(1).iushrn(1)), g3 = this.pow(i, s3), _4 = u2;g3.cmp(c2) !== 0; ) {
          for (var A4 = g3, R2 = 0;A4.cmp(c2) !== 0; R2++)
            A4 = A4.redSqr();
          r(R2 < _4);
          var I4 = this.pow(d4, new f2(1).iushln(_4 - R2 - 1));
          w3 = w3.redMul(I4), d4 = I4.redSqr(), g3 = g3.redMul(d4), _4 = R2;
        }
        return w3;
      }, P2.prototype.invm = function(i) {
        var a3 = i._invmp(this.m);
        return a3.negative !== 0 ? (a3.negative = 0, this.imod(a3).redNeg()) : this.imod(a3);
      }, P2.prototype.pow = function(i, a3) {
        if (a3.isZero())
          return new f2(1).toRed(this);
        if (a3.cmpn(1) === 0)
          return i.clone();
        var h3 = 4, s3 = new Array(1 << h3);
        s3[0] = new f2(1).toRed(this), s3[1] = i;
        for (var u2 = 2;u2 < s3.length; u2++)
          s3[u2] = this.mul(s3[u2 - 1], i);
        var c2 = s3[0], b5 = 0, l3 = 0, n = a3.bitLength() % 26;
        for (n === 0 && (n = 26), u2 = a3.length - 1;u2 >= 0; u2--) {
          for (var d4 = a3.words[u2], w3 = n - 1;w3 >= 0; w3--) {
            var g3 = d4 >> w3 & 1;
            if (c2 !== s3[0] && (c2 = this.sqr(c2)), g3 === 0 && b5 === 0) {
              l3 = 0;
              continue;
            }
            b5 <<= 1, b5 |= g3, l3++, !(l3 !== h3 && (u2 !== 0 || w3 !== 0)) && (c2 = this.mul(c2, s3[b5]), l3 = 0, b5 = 0);
          }
          n = 26;
        }
        return c2;
      }, P2.prototype.convertTo = function(i) {
        var a3 = i.umod(this.m);
        return a3 === i ? a3.clone() : a3;
      }, P2.prototype.convertFrom = function(i) {
        var a3 = i.clone();
        return a3.red = null, a3;
      }, f2.mont = function(i) {
        return new Se3(i);
      };
      function Se3(v2) {
        P2.call(this, v2), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new f2(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      o2(Se3, P2), Se3.prototype.convertTo = function(i) {
        return this.imod(i.ushln(this.shift));
      }, Se3.prototype.convertFrom = function(i) {
        var a3 = this.imod(i.mul(this.rinv));
        return a3.red = null, a3;
      }, Se3.prototype.imul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return i.words[0] = 0, i.length = 1, i;
        var h3 = i.imul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.mul = function(i, a3) {
        if (i.isZero() || a3.isZero())
          return new f2(0)._forceRed(this);
        var h3 = i.mul(a3), s3 = h3.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), u2 = h3.isub(s3).iushrn(this.shift), c2 = u2;
        return u2.cmp(this.m) >= 0 ? c2 = u2.isub(this.m) : u2.cmpn(0) < 0 && (c2 = u2.iadd(this.m)), c2._forceRed(this);
      }, Se3.prototype.invm = function(i) {
        var a3 = this.imod(i._invmp(this.m).mul(this.r2));
        return a3._forceRed(this);
      };
    })(typeof Sd > "u" || Sd, F3);
  });
  Ed = T((xL, z3) => {
    var U3 = w0(), wq = Te().Buffer;
    function Mq(t, e) {
      return wq.from(t.toRed(U3.mont(e.modulus)).redPow(new U3(e.publicExponent)).fromRed().toArray());
    }
    z3.exports = Mq;
  });
  j32 = T((SL, K32) => {
    var _q = Ha(), Ad = on(), xq = bf(), H3 = _d(), W3 = xd(), Rd = w0(), Sq = Ed(), Eq = Ks2(), Kr3 = Te().Buffer;
    K32.exports = function(e, r, o2) {
      var f2;
      e.padding ? f2 = e.padding : o2 ? f2 = 1 : f2 = 4;
      var p4 = _q(e), m4;
      if (f2 === 4)
        m4 = Aq(p4, r);
      else if (f2 === 1)
        m4 = Rq(p4, r, o2);
      else if (f2 === 3) {
        if (m4 = new Rd(r), m4.cmp(p4.modulus) >= 0)
          throw new Error("data too long for modulus");
      } else
        throw new Error("unknown padding");
      return o2 ? Eq(m4, p4) : Sq(m4, p4);
    };
    function Aq(t, e) {
      var r = t.modulus.byteLength(), o2 = e.length, f2 = xq("sha1").update(Kr3.alloc(0)).digest(), p4 = f2.length, m4 = 2 * p4;
      if (o2 > r - m4 - 2)
        throw new Error("message too long");
      var y3 = Kr3.alloc(r - o2 - m4 - 2), M4 = r - p4 - 1, x3 = Ad(p4), S2 = W3(Kr3.concat([f2, y3, Kr3.alloc(1, 1), e], M4), H3(x3, M4)), E6 = W3(x3, H3(S2, p4));
      return new Rd(Kr3.concat([Kr3.alloc(1), E6, S2], r));
    }
    function Rq(t, e, r) {
      var o2 = e.length, f2 = t.modulus.byteLength();
      if (o2 > f2 - 11)
        throw new Error("message too long");
      var p4;
      return r ? p4 = Kr3.alloc(f2 - o2 - 3, 255) : p4 = Bq(f2 - o2 - 3), new Rd(Kr3.concat([Kr3.from([0, r ? 1 : 2]), p4, Kr3.alloc(1), e], f2));
    }
    function Bq(t) {
      for (var e = Kr3.allocUnsafe(t), r = 0, o2 = Ad(t * 2), f2 = 0, p4;r < t; )
        f2 === o2.length && (o2 = Ad(t * 2), f2 = 0), p4 = o2[f2++], p4 && (e[r++] = p4);
      return e;
    }
  });
  Y3 = T((EL, G3) => {
    var qq = Ha(), Z3 = _d(), V32 = xd(), $3 = w0(), Iq = Ks2(), Tq = bf(), kq = Ed(), Za = Te().Buffer;
    G3.exports = function(e, r, o2) {
      var f2;
      e.padding ? f2 = e.padding : o2 ? f2 = 1 : f2 = 4;
      var p4 = qq(e), m4 = p4.modulus.byteLength();
      if (r.length > m4 || new $3(r).cmp(p4.modulus) >= 0)
        throw new Error("decryption error");
      var y3;
      o2 ? y3 = kq(new $3(r), p4) : y3 = Iq(r, p4);
      var M4 = Za.alloc(m4 - y3.length);
      if (y3 = Za.concat([M4, y3], m4), f2 === 4)
        return Lq(p4, y3);
      if (f2 === 1)
        return Nq(p4, y3, o2);
      if (f2 === 3)
        return y3;
      throw new Error("unknown padding");
    };
    function Lq(t, e) {
      var r = t.modulus.byteLength(), o2 = Tq("sha1").update(Za.alloc(0)).digest(), f2 = o2.length;
      if (e[0] !== 0)
        throw new Error("decryption error");
      var p4 = e.slice(1, f2 + 1), m4 = e.slice(f2 + 1), y3 = V32(p4, Z3(m4, f2)), M4 = V32(m4, Z3(y3, r - f2 - 1));
      if (Dq(o2, M4.slice(0, f2)))
        throw new Error("decryption error");
      for (var x3 = f2;M4[x3] === 0; )
        x3++;
      if (M4[x3++] !== 1)
        throw new Error("decryption error");
      return M4.slice(x3);
    }
    function Nq(t, e, r) {
      for (var o2 = e.slice(0, 2), f2 = 2, p4 = 0;e[f2++] !== 0; )
        if (f2 >= e.length) {
          p4++;
          break;
        }
      var m4 = e.slice(2, f2 - 1);
      if ((o2.toString("hex") !== "0002" && !r || o2.toString("hex") !== "0001" && r) && p4++, m4.length < 8 && p4++, p4)
        throw new Error("decryption error");
      return e.slice(f2);
    }
    function Dq(t, e) {
      t = Za.from(t), e = Za.from(e);
      var r = 0, o2 = t.length;
      t.length !== e.length && (r++, o2 = Math.min(t.length, e.length));
      for (var f2 = -1;++f2 < o2; )
        r += t[f2] ^ e[f2];
      return r;
    }
  });
  X3 = T((Vn) => {
    Vn.publicEncrypt = j32();
    Vn.privateDecrypt = Y3();
    Vn.privateEncrypt = function(e, r) {
      return Vn.publicEncrypt(e, r, true);
    };
    Vn.publicDecrypt = function(e, r) {
      return Vn.privateDecrypt(e, r, true);
    };
  });
  ow = T((Va) => {
    function J3() {
      throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
    }
    var ew = Te(), Q32 = on(), tw = ew.Buffer, rw = ew.kMaxLength, Bd = global.crypto || global.msCrypto, iw = Math.pow(2, 32) - 1;
    function nw(t, e) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("offset must be a number");
      if (t > iw || t < 0)
        throw new TypeError("offset must be a uint32");
      if (t > rw || t > e)
        throw new RangeError("offset out of range");
    }
    function fw(t, e, r) {
      if (typeof t != "number" || t !== t)
        throw new TypeError("size must be a number");
      if (t > iw || t < 0)
        throw new TypeError("size must be a uint32");
      if (t + e > r || t > rw)
        throw new RangeError("buffer too small");
    }
    Bd && Bd.getRandomValues ? (Va.randomFill = Pq, Va.randomFillSync = Cq) : (Va.randomFill = J3, Va.randomFillSync = J3);
    function Pq(t, e, r, o2) {
      if (!tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      if (typeof e == "function")
        o2 = e, e = 0, r = t.length;
      else if (typeof r == "function")
        o2 = r, r = t.length - e;
      else if (typeof o2 != "function")
        throw new TypeError('"cb" argument must be a function');
      return nw(e, t.length), fw(r, e, t.length), aw(t, e, r, o2);
    }
    function aw(t, e, r, o2) {
      if (true) {
        var f2 = t.buffer, p4 = new Uint8Array(f2, e, r);
        if (Bd.getRandomValues(p4), o2) {
          process.nextTick(function() {
            o2(null, t);
          });
          return;
        }
        return t;
      }
      if (o2) {
        Q32(r, function(y3, M4) {
          if (y3)
            return o2(y3);
          M4.copy(t, e), o2(null, t);
        });
        return;
      }
      var m4 = Q32(r);
      return m4.copy(t, e), t;
    }
    function Cq(t, e, r) {
      if (typeof e > "u" && (e = 0), !tw.isBuffer(t) && !(t instanceof global.Uint8Array))
        throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
      return nw(e, t.length), r === undefined && (r = t.length - e), fw(r, e, t.length), aw(t, e, r);
    }
  });
  qd = T((ke3) => {
    ke3.randomBytes = ke3.rng = ke3.pseudoRandomBytes = ke3.prng = on();
    ke3.createHash = ke3.Hash = bf();
    ke3.createHmac = ke3.Hmac = wu();
    var Oq = Eb(), Fq = Object.keys(Oq), Uq = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(Fq);
    ke3.getHashes = function() {
      return Uq;
    };
    var sw = Iu();
    ke3.pbkdf2 = sw.pbkdf2;
    ke3.pbkdf2Sync = sw.pbkdf2Sync;
    var ui = Vm();
    ke3.Cipher = ui.Cipher;
    ke3.createCipher = ui.createCipher;
    ke3.Cipheriv = ui.Cipheriv;
    ke3.createCipheriv = ui.createCipheriv;
    ke3.Decipher = ui.Decipher;
    ke3.createDecipher = ui.createDecipher;
    ke3.Decipheriv = ui.Decipheriv;
    ke3.createDecipheriv = ui.createDecipheriv;
    ke3.getCiphers = ui.getCiphers;
    ke3.listCiphers = ui.listCiphers;
    var $a = hg();
    ke3.DiffieHellmanGroup = $a.DiffieHellmanGroup;
    ke3.createDiffieHellmanGroup = $a.createDiffieHellmanGroup;
    ke3.getDiffieHellman = $a.getDiffieHellman;
    ke3.createDiffieHellman = $a.createDiffieHellman;
    ke3.DiffieHellman = $a.DiffieHellman;
    var M0 = k32();
    ke3.createSign = M0.createSign;
    ke3.Sign = M0.Sign;
    ke3.createVerify = M0.createVerify;
    ke3.Verify = M0.Verify;
    ke3.createECDH = P3();
    var _0 = X3();
    ke3.publicEncrypt = _0.publicEncrypt;
    ke3.privateEncrypt = _0.privateEncrypt;
    ke3.publicDecrypt = _0.publicDecrypt;
    ke3.privateDecrypt = _0.privateDecrypt;
    var hw = ow();
    ke3.randomFill = hw.randomFill;
    ke3.randomFillSync = hw.randomFillSync;
    ke3.createCredentials = function() {
      throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join(`
`));
    };
    ke3.constants = { DH_CHECK_P_NOT_SAFE_PRIME: 2, DH_CHECK_P_NOT_PRIME: 1, DH_UNABLE_TO_CHECK_GENERATOR: 4, DH_NOT_SUITABLE_GENERATOR: 8, NPN_ENABLED: 1, ALPN_ENABLED: 1, RSA_PKCS1_PADDING: 1, RSA_SSLV23_PADDING: 2, RSA_NO_PADDING: 3, RSA_PKCS1_OAEP_PADDING: 4, RSA_X931_PADDING: 5, RSA_PKCS1_PSS_PADDING: 6, POINT_CONVERSION_COMPRESSED: 2, POINT_CONVERSION_UNCOMPRESSED: 4, POINT_CONVERSION_HYBRID: 6 };
  });
  Xt2 = {};
  Ja(Xt2, { DEFAULT_ENCODING: () => Ga, default: () => Wq, getCurves: () => dw, getRandomValues: () => uw, randomUUID: () => lw, scrypt: () => Td, scryptSync: () => Id, timingSafeEqual: () => x0, webcrypto: () => cw });
  ot2(Xt2, rn2(qd()));
  zq = rn2(qd());
  Hq = ["p192", "p224", "p256", "p384", "p521", "curve25519", "ed25519", "secp256k1", "secp224r1", "prime256v1", "prime192v1", "ed25519", "secp384r1", "secp521r1"];
  x0 = "timingSafeEqual" in crypto ? (t, e) => {
    let { byteLength: r } = t, { byteLength: o2 } = e;
    if (typeof r != "number" || typeof o2 != "number")
      throw new TypeError("Input must be an array buffer view");
    if (r !== o2)
      throw new RangeError("Input buffers must have the same length");
    return crypto.timingSafeEqual(t, e);
  } : undefined;
  Id = "scryptSync" in crypto ? (t, e, r, o2) => {
    let f2 = crypto.scryptSync(t, e, r, o2);
    return Ga !== "buffer" ? new Buffer(f2).toString(Ga) : new Buffer(f2);
  } : undefined;
  Td = "scryptSync" in crypto ? function(t, e, r, o2, f2) {
    if (typeof o2 == "function" && (f2 = o2, o2 = undefined), typeof f2 != "function") {
      var p4 = new TypeError("callback must be a function");
      throw p4.code = "ERR_INVALID_CALLBACK", p4;
    }
    try {
      let m4 = crypto.scryptSync(t, e, r, o2);
      process.nextTick(f2, null, Ga !== "buffer" ? new Buffer(m4).toString(Ga) : new Buffer(m4));
    } catch (m4) {
      throw m4;
    }
  } : undefined;
  x0 && (Object.defineProperty(x0, "name", { value: "::bunternal::" }), Object.defineProperty(Td, "name", { value: "::bunternal::" }), Object.defineProperty(Id, "name", { value: "::bunternal::" }));
  cw = crypto;
  Wq = { ...zq, getRandomValues: uw, randomUUID: lw, timingSafeEqual: x0, scryptSync: Id, scrypt: Td, webcrypto: cw, getCurves: dw };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/light-my-request/lib/form-data.js
var require_form_data = __commonJS((exports, module) => {
  var { randomUUID } = (init_crypto(), __toCommonJS(exports_crypto));
  var { Readable } = (init_stream(), __toCommonJS(exports_stream));
  var textEncoder;
  function isFormDataLike(payload) {
    return payload && typeof payload === "object" && typeof payload.append === "function" && typeof payload.delete === "function" && typeof payload.get === "function" && typeof payload.getAll === "function" && typeof payload.has === "function" && typeof payload.set === "function" && payload[Symbol.toStringTag] === "FormData";
  }
  function formDataToStream(formdata) {
    textEncoder = textEncoder ?? new TextEncoder;
    const boundary = `----formdata-${randomUUID()}`;
    const prefix = `--${boundary}\r
Content-Disposition: form-data`;
    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
    const escape2 = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, `\r
`);
    const linebreak = new Uint8Array([13, 10]);
    async function* asyncIterator() {
      for (const [name, value] of formdata) {
        if (typeof value === "string") {
          yield textEncoder.encode(`${prefix}; name="${escape2(normalizeLinefeeds(name))}"\r
\r
`);
          yield textEncoder.encode(`${normalizeLinefeeds(value)}\r
`);
        } else {
          let header = `${prefix}; name="${escape2(normalizeLinefeeds(name))}"`;
          value.name && (header += `; filename="${escape2(value.name)}"`);
          header += `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`;
          yield textEncoder.encode(header);
          if (value.stream) {
            yield* value.stream();
          } else {
            yield value;
          }
          yield linebreak;
        }
      }
      yield textEncoder.encode(`--${boundary}--`);
    }
    const stream = Readable.from(asyncIterator());
    return {
      stream,
      contentType: `multipart/form-data; boundary=${boundary}`
    };
  }
  exports.isFormDataLike = isFormDataLike;
  exports.formDataToStream = formDataToStream;
});

// node_modules/light-my-request/lib/request.js
var require_request2 = __commonJS((exports, module) => {
  var { Readable, addAbortSignal } = (init_stream(), __toCommonJS(exports_stream));
  var util = (init_util(), __toCommonJS(exports_util));
  var cookie = require_dist4();
  var assert = require_assert();
  var { createDeprecation } = require_process_warning2();
  var parseURL = require_parse_url();
  var { isFormDataLike, formDataToStream } = require_form_data();
  var { EventEmitter } = (init_events(), __toCommonJS(exports_events));
  var FST_LIGHTMYREQUEST_DEP01 = createDeprecation({
    name: "FastifyDeprecationLightMyRequest",
    code: "FST_LIGHTMYREQUEST_DEP01",
    message: 'You are accessing "request.connection", use "request.socket" instead.'
  });
  function hostHeaderFromURL(parsedURL) {
    return parsedURL.port ? parsedURL.host : parsedURL.hostname + (parsedURL.protocol === "https:" ? ":443" : ":80");
  }

  class MockSocket extends EventEmitter {
    constructor(remoteAddress) {
      super();
      this.remoteAddress = remoteAddress;
    }
  }
  function CustomRequest(options) {
    return new _CustomLMRRequest(this);
    function _CustomLMRRequest(obj) {
      Request.call(obj, {
        ...options,
        Request: undefined
      });
      Object.assign(this, obj);
      for (const fn of Object.keys(Request.prototype)) {
        this.constructor.prototype[fn] = Request.prototype[fn];
      }
      util.inherits(this.constructor, options.Request);
      return this;
    }
  }
  function Request(options) {
    Readable.call(this, {
      autoDestroy: false
    });
    const parsedURL = parseURL(options.url || options.path, options.query);
    this.url = parsedURL.pathname + parsedURL.search;
    this.aborted = false;
    this.httpVersionMajor = 1;
    this.httpVersionMinor = 1;
    this.httpVersion = "1.1";
    this.method = options.method ? options.method.toUpperCase() : "GET";
    this.headers = {};
    this.rawHeaders = [];
    const headers = options.headers || {};
    for (const field in headers) {
      const fieldLowerCase = field.toLowerCase();
      if ((fieldLowerCase === "user-agent" || fieldLowerCase === "content-type") && headers[field] === undefined) {
        this.headers[fieldLowerCase] = undefined;
        continue;
      }
      const value = headers[field];
      assert(value !== undefined, 'invalid value "undefined" for header ' + field);
      this.headers[fieldLowerCase] = "" + value;
    }
    if ("user-agent" in this.headers === false) {
      this.headers["user-agent"] = "lightMyRequest";
    }
    this.headers.host = this.headers.host || options.authority || hostHeaderFromURL(parsedURL);
    if (options.cookies) {
      const { cookies } = options;
      const cookieValues = Object.keys(cookies).map((key) => cookie.serialize(key, cookies[key]));
      if (this.headers.cookie) {
        cookieValues.unshift(this.headers.cookie);
      }
      this.headers.cookie = cookieValues.join("; ");
    }
    this.socket = new MockSocket(options.remoteAddress || "127.0.0.1");
    Object.defineProperty(this, "connection", {
      get() {
        FST_LIGHTMYREQUEST_DEP01();
        return this.socket;
      },
      configurable: true
    });
    let payload = options.payload || options.body || null;
    let payloadResume = payload && typeof payload.resume === "function";
    if (isFormDataLike(payload)) {
      const stream = formDataToStream(payload);
      payload = stream.stream;
      payloadResume = true;
      this.headers["content-type"] = stream.contentType;
      this.headers["transfer-encoding"] = "chunked";
    }
    if (payload && typeof payload !== "string" && !payloadResume && !Buffer.isBuffer(payload)) {
      payload = JSON.stringify(payload);
      if ("content-type" in this.headers === false) {
        this.headers["content-type"] = "application/json";
      }
    }
    if (payload && !payloadResume && !Object.hasOwn(this.headers, "content-length")) {
      this.headers["content-length"] = (Buffer.isBuffer(payload) ? payload.length : Buffer.byteLength(payload)).toString();
    }
    for (const header of Object.keys(this.headers)) {
      this.rawHeaders.push(header, this.headers[header]);
    }
    this._lightMyRequest = {
      payload,
      isDone: false,
      simulate: options.simulate || {},
      payloadAsStream: options.payloadAsStream,
      signal: options.signal
    };
    const signal = options.signal;
    if (signal) {
      addAbortSignal(signal, this);
    }
    {
      const payload2 = this._lightMyRequest.payload;
      if (payload2?._readableState) {
        this._read = readStream;
        payload2.on("error", (err) => {
          this.destroy(err);
        });
        payload2.on("end", () => {
          this.push(null);
        });
      } else {
        this._read = readEverythingElse;
      }
    }
    return this;
  }
  function readStream() {
    const payload = this._lightMyRequest.payload;
    let more = true;
    let pushed = false;
    let chunk;
    while (more && (chunk = payload.read())) {
      pushed = true;
      more = this.push(chunk);
    }
    if (more && !pushed) {
      this._lightMyRequest.payload.once("readable", this._read.bind(this));
    }
  }
  function readEverythingElse() {
    setImmediate(() => {
      if (this._lightMyRequest.isDone) {
        if (this._lightMyRequest.simulate.end !== false) {
          this.push(null);
        }
        return;
      }
      this._lightMyRequest.isDone = true;
      if (this._lightMyRequest.payload) {
        if (this._lightMyRequest.simulate.split) {
          this.push(this._lightMyRequest.payload.slice(0, 1));
          this.push(this._lightMyRequest.payload.slice(1));
        } else {
          this.push(this._lightMyRequest.payload);
        }
      }
      if (this._lightMyRequest.simulate.error) {
        this.emit("error", new Error("Simulated"));
      }
      if (this._lightMyRequest.simulate.close) {
        this.emit("close");
      }
      if (this._lightMyRequest.simulate.end !== false) {
        this.push(null);
      }
    });
  }
  util.inherits(Request, Readable);
  util.inherits(CustomRequest, Request);
  Request.prototype.destroy = function(error) {
    if (this.destroyed || this._lightMyRequest.isDone)
      return;
    this.destroyed = true;
    if (error) {
      this._error = true;
      process.nextTick(() => this.emit("error", error));
    }
    process.nextTick(() => this.emit("close"));
  };
  module.exports = Request;
  module.exports.Request = Request;
  module.exports.CustomRequest = CustomRequest;
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS((exports, module) => {
  var defaultParseOptions = {
    decodeValues: true,
    map: false,
    silent: false
  };
  function isNonEmptyString(str) {
    return typeof str === "string" && !!str.trim();
  }
  function parseString(setCookieValue, options) {
    var parts = setCookieValue.split(";").filter(isNonEmptyString);
    var nameValuePairStr = parts.shift();
    var parsed = parseNameValuePair(nameValuePairStr);
    var name = parsed.name;
    var value = parsed.value;
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    try {
      value = options.decodeValues ? decodeURIComponent(value) : value;
    } catch (e) {
      console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
    }
    var cookie = {
      name,
      value
    };
    parts.forEach(function(part) {
      var sides = part.split("=");
      var key = sides.shift().trimLeft().toLowerCase();
      var value2 = sides.join("=");
      if (key === "expires") {
        cookie.expires = new Date(value2);
      } else if (key === "max-age") {
        cookie.maxAge = parseInt(value2, 10);
      } else if (key === "secure") {
        cookie.secure = true;
      } else if (key === "httponly") {
        cookie.httpOnly = true;
      } else if (key === "samesite") {
        cookie.sameSite = value2;
      } else if (key === "partitioned") {
        cookie.partitioned = true;
      } else {
        cookie[key] = value2;
      }
    });
    return cookie;
  }
  function parseNameValuePair(nameValuePairStr) {
    var name = "";
    var value = "";
    var nameValueArr = nameValuePairStr.split("=");
    if (nameValueArr.length > 1) {
      name = nameValueArr.shift();
      value = nameValueArr.join("=");
    } else {
      value = nameValuePairStr;
    }
    return { name, value };
  }
  function parse(input, options) {
    options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
    if (!input) {
      if (!options.map) {
        return [];
      } else {
        return {};
      }
    }
    if (input.headers) {
      if (typeof input.headers.getSetCookie === "function") {
        input = input.headers.getSetCookie();
      } else if (input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
    }
    if (!Array.isArray(input)) {
      input = [input];
    }
    if (!options.map) {
      return input.filter(isNonEmptyString).map(function(str) {
        return parseString(str, options);
      });
    } else {
      var cookies = {};
      return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
        var cookie = parseString(str, options);
        cookies2[cookie.name] = cookie;
        return cookies2;
      }, cookies);
    }
  }
  function splitCookiesString(cookiesString) {
    if (Array.isArray(cookiesString)) {
      return cookiesString;
    }
    if (typeof cookiesString !== "string") {
      return [];
    }
    var cookiesStrings = [];
    var pos = 0;
    var start;
    var ch;
    var lastComma;
    var nextStart;
    var cookiesSeparatorFound;
    function skipWhitespace() {
      while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
        pos += 1;
      }
      return pos < cookiesString.length;
    }
    function notSpecialChar() {
      ch = cookiesString.charAt(pos);
      return ch !== "=" && ch !== ";" && ch !== ",";
    }
    while (pos < cookiesString.length) {
      start = pos;
      cookiesSeparatorFound = false;
      while (skipWhitespace()) {
        ch = cookiesString.charAt(pos);
        if (ch === ",") {
          lastComma = pos;
          pos += 1;
          skipWhitespace();
          nextStart = pos;
          while (pos < cookiesString.length && notSpecialChar()) {
            pos += 1;
          }
          if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
            cookiesSeparatorFound = true;
            pos = nextStart;
            cookiesStrings.push(cookiesString.substring(start, lastComma));
            start = pos;
          } else {
            pos = lastComma + 1;
          }
        } else {
          pos += 1;
        }
      }
      if (!cookiesSeparatorFound || pos >= cookiesString.length) {
        cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
      }
    }
    return cookiesStrings;
  }
  module.exports = parse;
  module.exports.parse = parse;
  module.exports.parseString = parseString;
  module.exports.splitCookiesString = splitCookiesString;
});

// node_modules/light-my-request/lib/response.js
var require_response = __commonJS((exports, module) => {
  var http = (init_http(), __toCommonJS(exports_http));
  var { Writable, Readable, addAbortSignal } = (init_stream(), __toCommonJS(exports_stream));
  var util = (init_util(), __toCommonJS(exports_util));
  var setCookie = require_set_cookie();
  function Response(req, onEnd, reject) {
    http.ServerResponse.call(this, req);
    if (req._lightMyRequest?.payloadAsStream) {
      const read = this.emit.bind(this, "drain");
      this._lightMyRequest = { headers: null, trailers: {}, stream: new Readable({ read }) };
      const signal = req._lightMyRequest.signal;
      if (signal) {
        addAbortSignal(signal, this._lightMyRequest.stream);
      }
    } else {
      this._lightMyRequest = { headers: null, trailers: {}, payloadChunks: [] };
    }
    this.setHeader("foo", "bar");
    this.removeHeader("foo");
    this.assignSocket(getNullSocket());
    this._promiseCallback = typeof reject === "function";
    let called = false;
    const onEndSuccess = (payload) => {
      if (called)
        return;
      called = true;
      if (this._promiseCallback) {
        return process.nextTick(() => onEnd(payload));
      }
      process.nextTick(() => onEnd(null, payload));
    };
    this._lightMyRequest.onEndSuccess = onEndSuccess;
    let finished = false;
    const onEndFailure = (err) => {
      if (called) {
        if (this._lightMyRequest.stream && !finished) {
          if (!err) {
            err = new Error("response destroyed before completion");
            err.code = "LIGHT_ECONNRESET";
          }
          this._lightMyRequest.stream.destroy(err);
          this._lightMyRequest.stream.on("error", () => {});
        }
        return;
      }
      called = true;
      if (!err) {
        err = new Error("response destroyed before completion");
        err.code = "LIGHT_ECONNRESET";
      }
      if (this._promiseCallback) {
        return process.nextTick(() => reject(err));
      }
      process.nextTick(() => onEnd(err, null));
    };
    if (this._lightMyRequest.stream) {
      this.once("finish", () => {
        finished = true;
        this._lightMyRequest.stream.push(null);
      });
    } else {
      this.once("finish", () => {
        const res = generatePayload(this);
        res.raw.req = req;
        onEndSuccess(res);
      });
    }
    this.connection.once("error", onEndFailure);
    this.once("error", onEndFailure);
    this.once("close", onEndFailure);
  }
  util.inherits(Response, http.ServerResponse);
  Response.prototype.setTimeout = function(msecs, callback) {
    this.timeoutHandle = setTimeout(() => {
      this.emit("timeout");
    }, msecs);
    this.on("timeout", callback);
    return this;
  };
  Response.prototype.writeHead = function() {
    const result = http.ServerResponse.prototype.writeHead.apply(this, arguments);
    copyHeaders(this);
    if (this._lightMyRequest.stream) {
      this._lightMyRequest.onEndSuccess(generatePayload(this));
    }
    return result;
  };
  Response.prototype.write = function(data, encoding, callback) {
    if (this.timeoutHandle) {
      clearTimeout(this.timeoutHandle);
    }
    http.ServerResponse.prototype.write.call(this, data, encoding, callback);
    if (this._lightMyRequest.stream) {
      return this._lightMyRequest.stream.push(Buffer.from(data, encoding));
    } else {
      this._lightMyRequest.payloadChunks.push(Buffer.from(data, encoding));
      return true;
    }
  };
  Response.prototype.end = function(data, encoding, callback) {
    if (data) {
      this.write(data, encoding);
    }
    http.ServerResponse.prototype.end.call(this, callback);
    this.emit("finish");
    this.destroy();
  };
  Response.prototype.destroy = function(error) {
    if (this.destroyed)
      return;
    this.destroyed = true;
    if (error) {
      process.nextTick(() => this.emit("error", error));
    }
    process.nextTick(() => this.emit("close"));
  };
  Response.prototype.addTrailers = function(trailers) {
    for (const key in trailers) {
      this._lightMyRequest.trailers[key.toLowerCase().trim()] = trailers[key].toString().trim();
    }
  };
  function generatePayload(response) {
    if (response._lightMyRequest.headers === null) {
      copyHeaders(response);
    }
    serializeHeaders(response);
    const res = {
      raw: {
        res: response
      },
      headers: response._lightMyRequest.headers,
      statusCode: response.statusCode,
      statusMessage: response.statusMessage,
      trailers: {},
      get cookies() {
        return setCookie.parse(this);
      }
    };
    res.trailers = response._lightMyRequest.trailers;
    if (response._lightMyRequest.payloadChunks) {
      const rawBuffer = Buffer.concat(response._lightMyRequest.payloadChunks);
      res.rawPayload = rawBuffer;
      res.payload = rawBuffer.toString();
      res.body = res.payload;
      res.json = function parseJsonPayload() {
        return JSON.parse(res.payload);
      };
    } else {
      res.json = function() {
        throw new Error("Response payload is not available with payloadAsStream: true");
      };
    }
    res.stream = function streamPayload() {
      if (response._lightMyRequest.stream) {
        return response._lightMyRequest.stream;
      }
      return Readable.from(response._lightMyRequest.payloadChunks);
    };
    return res;
  }
  function getNullSocket() {
    return new Writable({
      write(_chunk, _encoding, callback) {
        setImmediate(callback);
      }
    });
  }
  function serializeHeaders(response) {
    const headers = response._lightMyRequest.headers;
    for (const headerName of Object.keys(headers)) {
      const headerValue = headers[headerName];
      if (Array.isArray(headerValue)) {
        headers[headerName] = headerValue.map((value) => "" + value);
      } else {
        headers[headerName] = "" + headerValue;
      }
    }
  }
  function copyHeaders(response) {
    response._lightMyRequest.headers = Object.assign({}, response.getHeaders());
    ["Date", "Connection", "Transfer-Encoding"].forEach((name) => {
      const regex = new RegExp("\\r\\n" + name + ": ([^\\r]*)\\r\\n");
      const field = response._header?.match(regex);
      if (field) {
        response._lightMyRequest.headers[name.toLowerCase()] = field[1];
      }
    });
  }
  module.exports = Response;
});

// node_modules/light-my-request/lib/config-validator.js
var require_config_validator = __commonJS((exports, module) => {
  module.exports = validate10;
  module.exports.default = validate10;
  var schema11 = { type: "object", properties: { url: { oneOf: [{ type: "string" }, { type: "object", properties: { protocol: { type: "string" }, hostname: { type: "string" }, pathname: { type: "string" } }, additionalProperties: true, required: ["pathname"] }] }, path: { oneOf: [{ type: "string" }, { type: "object", properties: { protocol: { type: "string" }, hostname: { type: "string" }, pathname: { type: "string" } }, additionalProperties: true, required: ["pathname"] }] }, cookies: { type: "object", additionalProperties: true }, headers: { type: "object", additionalProperties: true }, query: { anyOf: [{ type: "object", additionalProperties: true }, { type: "string" }] }, simulate: { type: "object", properties: { end: { type: "boolean" }, split: { type: "boolean" }, error: { type: "boolean" }, close: { type: "boolean" } } }, authority: { type: "string" }, remoteAddress: { type: "string" }, method: { type: "string", enum: ["ACL", "BIND", "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LINK", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCALENDAR", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "QUERY", "REBIND", "REPORT", "SEARCH", "SOURCE", "SUBSCRIBE", "TRACE", "UNBIND", "UNLINK", "UNLOCK", "UNSUBSCRIBE", "acl", "bind", "checkout", "connect", "copy", "delete", "get", "head", "link", "lock", "m-search", "merge", "mkactivity", "mkcalendar", "mkcol", "move", "notify", "options", "patch", "post", "propfind", "proppatch", "purge", "put", "query", "rebind", "report", "search", "source", "subscribe", "trace", "unbind", "unlink", "unlock", "unsubscribe"] }, validate: { type: "boolean" } }, additionalProperties: true, oneOf: [{ required: ["url"] }, { required: ["path"] }] };
  function validate10(data, { instancePath = "", parentData, parentDataProperty, rootData = data } = {}) {
    let vErrors = null;
    let errors = 0;
    const _errs1 = errors;
    let valid0 = false;
    let passing0 = null;
    const _errs2 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing0;
      if (data.url === undefined && (missing0 = "url")) {
        const err0 = { instancePath, schemaPath: "#/oneOf/0/required", keyword: "required", params: { missingProperty: missing0 }, message: "must have required property '" + missing0 + "'" };
        if (vErrors === null) {
          vErrors = [err0];
        } else {
          vErrors.push(err0);
        }
        errors++;
      }
    }
    var _valid0 = _errs2 === errors;
    if (_valid0) {
      valid0 = true;
      passing0 = 0;
    }
    const _errs3 = errors;
    if (data && typeof data == "object" && !Array.isArray(data)) {
      let missing1;
      if (data.path === undefined && (missing1 = "path")) {
        const err1 = { instancePath, schemaPath: "#/oneOf/1/required", keyword: "required", params: { missingProperty: missing1 }, message: "must have required property '" + missing1 + "'" };
        if (vErrors === null) {
          vErrors = [err1];
        } else {
          vErrors.push(err1);
        }
        errors++;
      }
    }
    var _valid0 = _errs3 === errors;
    if (_valid0 && valid0) {
      valid0 = false;
      passing0 = [passing0, 1];
    } else {
      if (_valid0) {
        valid0 = true;
        passing0 = 1;
      }
    }
    if (!valid0) {
      const err2 = { instancePath, schemaPath: "#/oneOf", keyword: "oneOf", params: { passingSchemas: passing0 }, message: "must match exactly one schema in oneOf" };
      if (vErrors === null) {
        vErrors = [err2];
      } else {
        vErrors.push(err2);
      }
      errors++;
      validate10.errors = vErrors;
      return false;
    } else {
      errors = _errs1;
      if (vErrors !== null) {
        if (_errs1) {
          vErrors.length = _errs1;
        } else {
          vErrors = null;
        }
      }
    }
    if (errors === 0) {
      if (data && typeof data == "object" && !Array.isArray(data)) {
        if (data.url !== undefined) {
          let data0 = data.url;
          const _errs5 = errors;
          const _errs6 = errors;
          let valid2 = false;
          let passing1 = null;
          const _errs7 = errors;
          if (typeof data0 !== "string") {
            let dataType0 = typeof data0;
            let coerced0 = undefined;
            if (!(coerced0 !== undefined)) {
              if (dataType0 == "number" || dataType0 == "boolean") {
                coerced0 = "" + data0;
              } else if (data0 === null) {
                coerced0 = "";
              } else {
                const err3 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                if (vErrors === null) {
                  vErrors = [err3];
                } else {
                  vErrors.push(err3);
                }
                errors++;
              }
            }
            if (coerced0 !== undefined) {
              data0 = coerced0;
              if (data !== undefined) {
                data["url"] = coerced0;
              }
            }
          }
          var _valid1 = _errs7 === errors;
          if (_valid1) {
            valid2 = true;
            passing1 = 0;
          }
          const _errs9 = errors;
          if (errors === _errs9) {
            if (data0 && typeof data0 == "object" && !Array.isArray(data0)) {
              let missing2;
              if (data0.pathname === undefined && (missing2 = "pathname")) {
                const err4 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/required", keyword: "required", params: { missingProperty: missing2 }, message: "must have required property '" + missing2 + "'" };
                if (vErrors === null) {
                  vErrors = [err4];
                } else {
                  vErrors.push(err4);
                }
                errors++;
              } else {
                if (data0.protocol !== undefined) {
                  let data1 = data0.protocol;
                  const _errs12 = errors;
                  if (typeof data1 !== "string") {
                    let dataType1 = typeof data1;
                    let coerced1 = undefined;
                    if (!(coerced1 !== undefined)) {
                      if (dataType1 == "number" || dataType1 == "boolean") {
                        coerced1 = "" + data1;
                      } else if (data1 === null) {
                        coerced1 = "";
                      } else {
                        const err5 = { instancePath: instancePath + "/url/protocol", schemaPath: "#/properties/url/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                        if (vErrors === null) {
                          vErrors = [err5];
                        } else {
                          vErrors.push(err5);
                        }
                        errors++;
                      }
                    }
                    if (coerced1 !== undefined) {
                      data1 = coerced1;
                      if (data0 !== undefined) {
                        data0["protocol"] = coerced1;
                      }
                    }
                  }
                  var valid3 = _errs12 === errors;
                } else {
                  var valid3 = true;
                }
                if (valid3) {
                  if (data0.hostname !== undefined) {
                    let data2 = data0.hostname;
                    const _errs14 = errors;
                    if (typeof data2 !== "string") {
                      let dataType2 = typeof data2;
                      let coerced2 = undefined;
                      if (!(coerced2 !== undefined)) {
                        if (dataType2 == "number" || dataType2 == "boolean") {
                          coerced2 = "" + data2;
                        } else if (data2 === null) {
                          coerced2 = "";
                        } else {
                          const err6 = { instancePath: instancePath + "/url/hostname", schemaPath: "#/properties/url/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err6];
                          } else {
                            vErrors.push(err6);
                          }
                          errors++;
                        }
                      }
                      if (coerced2 !== undefined) {
                        data2 = coerced2;
                        if (data0 !== undefined) {
                          data0["hostname"] = coerced2;
                        }
                      }
                    }
                    var valid3 = _errs14 === errors;
                  } else {
                    var valid3 = true;
                  }
                  if (valid3) {
                    if (data0.pathname !== undefined) {
                      let data3 = data0.pathname;
                      const _errs16 = errors;
                      if (typeof data3 !== "string") {
                        let dataType3 = typeof data3;
                        let coerced3 = undefined;
                        if (!(coerced3 !== undefined)) {
                          if (dataType3 == "number" || dataType3 == "boolean") {
                            coerced3 = "" + data3;
                          } else if (data3 === null) {
                            coerced3 = "";
                          } else {
                            const err7 = { instancePath: instancePath + "/url/pathname", schemaPath: "#/properties/url/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err7];
                            } else {
                              vErrors.push(err7);
                            }
                            errors++;
                          }
                        }
                        if (coerced3 !== undefined) {
                          data3 = coerced3;
                          if (data0 !== undefined) {
                            data0["pathname"] = coerced3;
                          }
                        }
                      }
                      var valid3 = _errs16 === errors;
                    } else {
                      var valid3 = true;
                    }
                  }
                }
              }
            } else {
              const err8 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
              if (vErrors === null) {
                vErrors = [err8];
              } else {
                vErrors.push(err8);
              }
              errors++;
            }
          }
          var _valid1 = _errs9 === errors;
          if (_valid1 && valid2) {
            valid2 = false;
            passing1 = [passing1, 1];
          } else {
            if (_valid1) {
              valid2 = true;
              passing1 = 1;
            }
          }
          if (!valid2) {
            const err9 = { instancePath: instancePath + "/url", schemaPath: "#/properties/url/oneOf", keyword: "oneOf", params: { passingSchemas: passing1 }, message: "must match exactly one schema in oneOf" };
            if (vErrors === null) {
              vErrors = [err9];
            } else {
              vErrors.push(err9);
            }
            errors++;
            validate10.errors = vErrors;
            return false;
          } else {
            errors = _errs6;
            if (vErrors !== null) {
              if (_errs6) {
                vErrors.length = _errs6;
              } else {
                vErrors = null;
              }
            }
          }
          var valid1 = _errs5 === errors;
        } else {
          var valid1 = true;
        }
        if (valid1) {
          if (data.path !== undefined) {
            let data4 = data.path;
            const _errs18 = errors;
            const _errs19 = errors;
            let valid4 = false;
            let passing2 = null;
            const _errs20 = errors;
            if (typeof data4 !== "string") {
              let dataType4 = typeof data4;
              let coerced4 = undefined;
              if (!(coerced4 !== undefined)) {
                if (dataType4 == "number" || dataType4 == "boolean") {
                  coerced4 = "" + data4;
                } else if (data4 === null) {
                  coerced4 = "";
                } else {
                  const err10 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/0/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                  if (vErrors === null) {
                    vErrors = [err10];
                  } else {
                    vErrors.push(err10);
                  }
                  errors++;
                }
              }
              if (coerced4 !== undefined) {
                data4 = coerced4;
                if (data !== undefined) {
                  data["path"] = coerced4;
                }
              }
            }
            var _valid2 = _errs20 === errors;
            if (_valid2) {
              valid4 = true;
              passing2 = 0;
            }
            const _errs22 = errors;
            if (errors === _errs22) {
              if (data4 && typeof data4 == "object" && !Array.isArray(data4)) {
                let missing3;
                if (data4.pathname === undefined && (missing3 = "pathname")) {
                  const err11 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/required", keyword: "required", params: { missingProperty: missing3 }, message: "must have required property '" + missing3 + "'" };
                  if (vErrors === null) {
                    vErrors = [err11];
                  } else {
                    vErrors.push(err11);
                  }
                  errors++;
                } else {
                  if (data4.protocol !== undefined) {
                    let data5 = data4.protocol;
                    const _errs25 = errors;
                    if (typeof data5 !== "string") {
                      let dataType5 = typeof data5;
                      let coerced5 = undefined;
                      if (!(coerced5 !== undefined)) {
                        if (dataType5 == "number" || dataType5 == "boolean") {
                          coerced5 = "" + data5;
                        } else if (data5 === null) {
                          coerced5 = "";
                        } else {
                          const err12 = { instancePath: instancePath + "/path/protocol", schemaPath: "#/properties/path/oneOf/1/properties/protocol/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err12];
                          } else {
                            vErrors.push(err12);
                          }
                          errors++;
                        }
                      }
                      if (coerced5 !== undefined) {
                        data5 = coerced5;
                        if (data4 !== undefined) {
                          data4["protocol"] = coerced5;
                        }
                      }
                    }
                    var valid5 = _errs25 === errors;
                  } else {
                    var valid5 = true;
                  }
                  if (valid5) {
                    if (data4.hostname !== undefined) {
                      let data6 = data4.hostname;
                      const _errs27 = errors;
                      if (typeof data6 !== "string") {
                        let dataType6 = typeof data6;
                        let coerced6 = undefined;
                        if (!(coerced6 !== undefined)) {
                          if (dataType6 == "number" || dataType6 == "boolean") {
                            coerced6 = "" + data6;
                          } else if (data6 === null) {
                            coerced6 = "";
                          } else {
                            const err13 = { instancePath: instancePath + "/path/hostname", schemaPath: "#/properties/path/oneOf/1/properties/hostname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                            if (vErrors === null) {
                              vErrors = [err13];
                            } else {
                              vErrors.push(err13);
                            }
                            errors++;
                          }
                        }
                        if (coerced6 !== undefined) {
                          data6 = coerced6;
                          if (data4 !== undefined) {
                            data4["hostname"] = coerced6;
                          }
                        }
                      }
                      var valid5 = _errs27 === errors;
                    } else {
                      var valid5 = true;
                    }
                    if (valid5) {
                      if (data4.pathname !== undefined) {
                        let data7 = data4.pathname;
                        const _errs29 = errors;
                        if (typeof data7 !== "string") {
                          let dataType7 = typeof data7;
                          let coerced7 = undefined;
                          if (!(coerced7 !== undefined)) {
                            if (dataType7 == "number" || dataType7 == "boolean") {
                              coerced7 = "" + data7;
                            } else if (data7 === null) {
                              coerced7 = "";
                            } else {
                              const err14 = { instancePath: instancePath + "/path/pathname", schemaPath: "#/properties/path/oneOf/1/properties/pathname/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                              if (vErrors === null) {
                                vErrors = [err14];
                              } else {
                                vErrors.push(err14);
                              }
                              errors++;
                            }
                          }
                          if (coerced7 !== undefined) {
                            data7 = coerced7;
                            if (data4 !== undefined) {
                              data4["pathname"] = coerced7;
                            }
                          }
                        }
                        var valid5 = _errs29 === errors;
                      } else {
                        var valid5 = true;
                      }
                    }
                  }
                }
              } else {
                const err15 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf/1/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                if (vErrors === null) {
                  vErrors = [err15];
                } else {
                  vErrors.push(err15);
                }
                errors++;
              }
            }
            var _valid2 = _errs22 === errors;
            if (_valid2 && valid4) {
              valid4 = false;
              passing2 = [passing2, 1];
            } else {
              if (_valid2) {
                valid4 = true;
                passing2 = 1;
              }
            }
            if (!valid4) {
              const err16 = { instancePath: instancePath + "/path", schemaPath: "#/properties/path/oneOf", keyword: "oneOf", params: { passingSchemas: passing2 }, message: "must match exactly one schema in oneOf" };
              if (vErrors === null) {
                vErrors = [err16];
              } else {
                vErrors.push(err16);
              }
              errors++;
              validate10.errors = vErrors;
              return false;
            } else {
              errors = _errs19;
              if (vErrors !== null) {
                if (_errs19) {
                  vErrors.length = _errs19;
                } else {
                  vErrors = null;
                }
              }
            }
            var valid1 = _errs18 === errors;
          } else {
            var valid1 = true;
          }
          if (valid1) {
            if (data.cookies !== undefined) {
              let data8 = data.cookies;
              const _errs31 = errors;
              if (errors === _errs31) {
                if (!(data8 && typeof data8 == "object" && !Array.isArray(data8))) {
                  validate10.errors = [{ instancePath: instancePath + "/cookies", schemaPath: "#/properties/cookies/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                  return false;
                }
              }
              var valid1 = _errs31 === errors;
            } else {
              var valid1 = true;
            }
            if (valid1) {
              if (data.headers !== undefined) {
                let data9 = data.headers;
                const _errs34 = errors;
                if (errors === _errs34) {
                  if (!(data9 && typeof data9 == "object" && !Array.isArray(data9))) {
                    validate10.errors = [{ instancePath: instancePath + "/headers", schemaPath: "#/properties/headers/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                    return false;
                  }
                }
                var valid1 = _errs34 === errors;
              } else {
                var valid1 = true;
              }
              if (valid1) {
                if (data.query !== undefined) {
                  let data10 = data.query;
                  const _errs37 = errors;
                  const _errs38 = errors;
                  let valid6 = false;
                  const _errs39 = errors;
                  if (errors === _errs39) {
                    if (!(data10 && typeof data10 == "object" && !Array.isArray(data10))) {
                      const err17 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/0/type", keyword: "type", params: { type: "object" }, message: "must be object" };
                      if (vErrors === null) {
                        vErrors = [err17];
                      } else {
                        vErrors.push(err17);
                      }
                      errors++;
                    }
                  }
                  var _valid3 = _errs39 === errors;
                  valid6 = valid6 || _valid3;
                  if (!valid6) {
                    const _errs42 = errors;
                    if (typeof data10 !== "string") {
                      let dataType8 = typeof data10;
                      let coerced8 = undefined;
                      if (!(coerced8 !== undefined)) {
                        if (dataType8 == "number" || dataType8 == "boolean") {
                          coerced8 = "" + data10;
                        } else if (data10 === null) {
                          coerced8 = "";
                        } else {
                          const err18 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf/1/type", keyword: "type", params: { type: "string" }, message: "must be string" };
                          if (vErrors === null) {
                            vErrors = [err18];
                          } else {
                            vErrors.push(err18);
                          }
                          errors++;
                        }
                      }
                      if (coerced8 !== undefined) {
                        data10 = coerced8;
                        if (data !== undefined) {
                          data["query"] = coerced8;
                        }
                      }
                    }
                    var _valid3 = _errs42 === errors;
                    valid6 = valid6 || _valid3;
                  }
                  if (!valid6) {
                    const err19 = { instancePath: instancePath + "/query", schemaPath: "#/properties/query/anyOf", keyword: "anyOf", params: {}, message: "must match a schema in anyOf" };
                    if (vErrors === null) {
                      vErrors = [err19];
                    } else {
                      vErrors.push(err19);
                    }
                    errors++;
                    validate10.errors = vErrors;
                    return false;
                  } else {
                    errors = _errs38;
                    if (vErrors !== null) {
                      if (_errs38) {
                        vErrors.length = _errs38;
                      } else {
                        vErrors = null;
                      }
                    }
                  }
                  var valid1 = _errs37 === errors;
                } else {
                  var valid1 = true;
                }
                if (valid1) {
                  if (data.simulate !== undefined) {
                    let data11 = data.simulate;
                    const _errs44 = errors;
                    if (errors === _errs44) {
                      if (data11 && typeof data11 == "object" && !Array.isArray(data11)) {
                        if (data11.end !== undefined) {
                          let data12 = data11.end;
                          const _errs46 = errors;
                          if (typeof data12 !== "boolean") {
                            let coerced9 = undefined;
                            if (!(coerced9 !== undefined)) {
                              if (data12 === "false" || data12 === 0 || data12 === null) {
                                coerced9 = false;
                              } else if (data12 === "true" || data12 === 1) {
                                coerced9 = true;
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/simulate/end", schemaPath: "#/properties/simulate/properties/end/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                return false;
                              }
                            }
                            if (coerced9 !== undefined) {
                              data12 = coerced9;
                              if (data11 !== undefined) {
                                data11["end"] = coerced9;
                              }
                            }
                          }
                          var valid7 = _errs46 === errors;
                        } else {
                          var valid7 = true;
                        }
                        if (valid7) {
                          if (data11.split !== undefined) {
                            let data13 = data11.split;
                            const _errs48 = errors;
                            if (typeof data13 !== "boolean") {
                              let coerced10 = undefined;
                              if (!(coerced10 !== undefined)) {
                                if (data13 === "false" || data13 === 0 || data13 === null) {
                                  coerced10 = false;
                                } else if (data13 === "true" || data13 === 1) {
                                  coerced10 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/simulate/split", schemaPath: "#/properties/simulate/properties/split/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced10 !== undefined) {
                                data13 = coerced10;
                                if (data11 !== undefined) {
                                  data11["split"] = coerced10;
                                }
                              }
                            }
                            var valid7 = _errs48 === errors;
                          } else {
                            var valid7 = true;
                          }
                          if (valid7) {
                            if (data11.error !== undefined) {
                              let data14 = data11.error;
                              const _errs50 = errors;
                              if (typeof data14 !== "boolean") {
                                let coerced11 = undefined;
                                if (!(coerced11 !== undefined)) {
                                  if (data14 === "false" || data14 === 0 || data14 === null) {
                                    coerced11 = false;
                                  } else if (data14 === "true" || data14 === 1) {
                                    coerced11 = true;
                                  } else {
                                    validate10.errors = [{ instancePath: instancePath + "/simulate/error", schemaPath: "#/properties/simulate/properties/error/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                    return false;
                                  }
                                }
                                if (coerced11 !== undefined) {
                                  data14 = coerced11;
                                  if (data11 !== undefined) {
                                    data11["error"] = coerced11;
                                  }
                                }
                              }
                              var valid7 = _errs50 === errors;
                            } else {
                              var valid7 = true;
                            }
                            if (valid7) {
                              if (data11.close !== undefined) {
                                let data15 = data11.close;
                                const _errs52 = errors;
                                if (typeof data15 !== "boolean") {
                                  let coerced12 = undefined;
                                  if (!(coerced12 !== undefined)) {
                                    if (data15 === "false" || data15 === 0 || data15 === null) {
                                      coerced12 = false;
                                    } else if (data15 === "true" || data15 === 1) {
                                      coerced12 = true;
                                    } else {
                                      validate10.errors = [{ instancePath: instancePath + "/simulate/close", schemaPath: "#/properties/simulate/properties/close/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                      return false;
                                    }
                                  }
                                  if (coerced12 !== undefined) {
                                    data15 = coerced12;
                                    if (data11 !== undefined) {
                                      data11["close"] = coerced12;
                                    }
                                  }
                                }
                                var valid7 = _errs52 === errors;
                              } else {
                                var valid7 = true;
                              }
                            }
                          }
                        }
                      } else {
                        validate10.errors = [{ instancePath: instancePath + "/simulate", schemaPath: "#/properties/simulate/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
                        return false;
                      }
                    }
                    var valid1 = _errs44 === errors;
                  } else {
                    var valid1 = true;
                  }
                  if (valid1) {
                    if (data.authority !== undefined) {
                      let data16 = data.authority;
                      const _errs54 = errors;
                      if (typeof data16 !== "string") {
                        let dataType13 = typeof data16;
                        let coerced13 = undefined;
                        if (!(coerced13 !== undefined)) {
                          if (dataType13 == "number" || dataType13 == "boolean") {
                            coerced13 = "" + data16;
                          } else if (data16 === null) {
                            coerced13 = "";
                          } else {
                            validate10.errors = [{ instancePath: instancePath + "/authority", schemaPath: "#/properties/authority/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                            return false;
                          }
                        }
                        if (coerced13 !== undefined) {
                          data16 = coerced13;
                          if (data !== undefined) {
                            data["authority"] = coerced13;
                          }
                        }
                      }
                      var valid1 = _errs54 === errors;
                    } else {
                      var valid1 = true;
                    }
                    if (valid1) {
                      if (data.remoteAddress !== undefined) {
                        let data17 = data.remoteAddress;
                        const _errs56 = errors;
                        if (typeof data17 !== "string") {
                          let dataType14 = typeof data17;
                          let coerced14 = undefined;
                          if (!(coerced14 !== undefined)) {
                            if (dataType14 == "number" || dataType14 == "boolean") {
                              coerced14 = "" + data17;
                            } else if (data17 === null) {
                              coerced14 = "";
                            } else {
                              validate10.errors = [{ instancePath: instancePath + "/remoteAddress", schemaPath: "#/properties/remoteAddress/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                              return false;
                            }
                          }
                          if (coerced14 !== undefined) {
                            data17 = coerced14;
                            if (data !== undefined) {
                              data["remoteAddress"] = coerced14;
                            }
                          }
                        }
                        var valid1 = _errs56 === errors;
                      } else {
                        var valid1 = true;
                      }
                      if (valid1) {
                        if (data.method !== undefined) {
                          let data18 = data.method;
                          const _errs58 = errors;
                          if (typeof data18 !== "string") {
                            let dataType15 = typeof data18;
                            let coerced15 = undefined;
                            if (!(coerced15 !== undefined)) {
                              if (dataType15 == "number" || dataType15 == "boolean") {
                                coerced15 = "" + data18;
                              } else if (data18 === null) {
                                coerced15 = "";
                              } else {
                                validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/type", keyword: "type", params: { type: "string" }, message: "must be string" }];
                                return false;
                              }
                            }
                            if (coerced15 !== undefined) {
                              data18 = coerced15;
                              if (data !== undefined) {
                                data["method"] = coerced15;
                              }
                            }
                          }
                          if (!(data18 === "ACL" || data18 === "BIND" || data18 === "CHECKOUT" || data18 === "CONNECT" || data18 === "COPY" || data18 === "DELETE" || data18 === "GET" || data18 === "HEAD" || data18 === "LINK" || data18 === "LOCK" || data18 === "M-SEARCH" || data18 === "MERGE" || data18 === "MKACTIVITY" || data18 === "MKCALENDAR" || data18 === "MKCOL" || data18 === "MOVE" || data18 === "NOTIFY" || data18 === "OPTIONS" || data18 === "PATCH" || data18 === "POST" || data18 === "PROPFIND" || data18 === "PROPPATCH" || data18 === "PURGE" || data18 === "PUT" || data18 === "QUERY" || data18 === "REBIND" || data18 === "REPORT" || data18 === "SEARCH" || data18 === "SOURCE" || data18 === "SUBSCRIBE" || data18 === "TRACE" || data18 === "UNBIND" || data18 === "UNLINK" || data18 === "UNLOCK" || data18 === "UNSUBSCRIBE" || data18 === "acl" || data18 === "bind" || data18 === "checkout" || data18 === "connect" || data18 === "copy" || data18 === "delete" || data18 === "get" || data18 === "head" || data18 === "link" || data18 === "lock" || data18 === "m-search" || data18 === "merge" || data18 === "mkactivity" || data18 === "mkcalendar" || data18 === "mkcol" || data18 === "move" || data18 === "notify" || data18 === "options" || data18 === "patch" || data18 === "post" || data18 === "propfind" || data18 === "proppatch" || data18 === "purge" || data18 === "put" || data18 === "query" || data18 === "rebind" || data18 === "report" || data18 === "search" || data18 === "source" || data18 === "subscribe" || data18 === "trace" || data18 === "unbind" || data18 === "unlink" || data18 === "unlock" || data18 === "unsubscribe")) {
                            validate10.errors = [{ instancePath: instancePath + "/method", schemaPath: "#/properties/method/enum", keyword: "enum", params: { allowedValues: schema11.properties.method.enum }, message: "must be equal to one of the allowed values" }];
                            return false;
                          }
                          var valid1 = _errs58 === errors;
                        } else {
                          var valid1 = true;
                        }
                        if (valid1) {
                          if (data.validate !== undefined) {
                            let data19 = data.validate;
                            const _errs60 = errors;
                            if (typeof data19 !== "boolean") {
                              let coerced16 = undefined;
                              if (!(coerced16 !== undefined)) {
                                if (data19 === "false" || data19 === 0 || data19 === null) {
                                  coerced16 = false;
                                } else if (data19 === "true" || data19 === 1) {
                                  coerced16 = true;
                                } else {
                                  validate10.errors = [{ instancePath: instancePath + "/validate", schemaPath: "#/properties/validate/type", keyword: "type", params: { type: "boolean" }, message: "must be boolean" }];
                                  return false;
                                }
                              }
                              if (coerced16 !== undefined) {
                                data19 = coerced16;
                                if (data !== undefined) {
                                  data["validate"] = coerced16;
                                }
                              }
                            }
                            var valid1 = _errs60 === errors;
                          } else {
                            var valid1 = true;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        validate10.errors = [{ instancePath, schemaPath: "#/type", keyword: "type", params: { type: "object" }, message: "must be object" }];
        return false;
      }
    }
    validate10.errors = vErrors;
    return errors === 0;
  }
});

// node_modules/light-my-request/index.js
var require_light_my_request = __commonJS((exports, module) => {
  var assert = require_assert();
  var Request = require_request2();
  var Response = require_response();
  var errorMessage = "The dispatch function has already been invoked";
  var optsValidator = require_config_validator();
  function inject(dispatchFunc, options, callback) {
    if (callback === undefined) {
      return new Chain(dispatchFunc, options);
    } else {
      return doInject(dispatchFunc, options, callback);
    }
  }
  function supportStream1(req, next) {
    const payload = req._lightMyRequest.payload;
    if (!payload || payload._readableState || typeof payload.resume !== "function") {
      return next();
    }
    const chunks = [];
    payload.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
    payload.on("end", () => {
      const payload2 = Buffer.concat(chunks);
      req.headers["content-length"] = req.headers["content-length"] || "" + payload2.length;
      delete req.headers["transfer-encoding"];
      req._lightMyRequest.payload = payload2;
      return next();
    });
    payload.resume();
  }
  function makeRequest(dispatchFunc, server, req, res) {
    req.once("error", function(err) {
      if (this.destroyed)
        res.destroy(err);
    });
    req.once("close", function() {
      if (this.destroyed && !this._error) {
        res.destroy();
      }
    });
    return supportStream1(req, () => dispatchFunc.call(server, req, res));
  }
  function doInject(dispatchFunc, options, callback) {
    options = typeof options === "string" ? { url: options } : options;
    if (options.validate !== false) {
      assert(typeof dispatchFunc === "function", "dispatchFunc should be a function");
      const isOptionValid = optsValidator(options);
      if (!isOptionValid) {
        throw new Error(optsValidator.errors.map((e) => e.message));
      }
    }
    const server = options.server || {};
    const RequestConstructor = options.Request ? Request.CustomRequest : Request;
    if (dispatchFunc.request && dispatchFunc.request.app === dispatchFunc) {
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.request), RequestConstructor.prototype);
      Object.setPrototypeOf(Object.getPrototypeOf(dispatchFunc.response), Response.prototype);
    }
    if (typeof callback === "function") {
      const req = new RequestConstructor(options);
      const res = new Response(req, callback);
      return makeRequest(dispatchFunc, server, req, res);
    } else {
      return new Promise((resolve, reject) => {
        const req = new RequestConstructor(options);
        const res = new Response(req, resolve, reject);
        makeRequest(dispatchFunc, server, req, res);
      });
    }
  }
  function Chain(dispatch, option) {
    if (typeof option === "string") {
      this.option = { url: option };
    } else {
      this.option = Object.assign({}, option);
    }
    this.dispatch = dispatch;
    this._hasInvoked = false;
    this._promise = null;
    if (this.option.autoStart !== false) {
      process.nextTick(() => {
        if (!this._hasInvoked) {
          this.end();
        }
      });
    }
  }
  var httpMethods = [
    "delete",
    "get",
    "head",
    "options",
    "patch",
    "post",
    "put",
    "trace"
  ];
  httpMethods.forEach((method) => {
    Chain.prototype[method] = function(url) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option.url = url;
      this.option.method = method.toUpperCase();
      return this;
    };
  });
  var chainMethods = [
    "body",
    "cookies",
    "headers",
    "payload",
    "query"
  ];
  chainMethods.forEach((method) => {
    Chain.prototype[method] = function(value) {
      if (this._hasInvoked === true || this._promise) {
        throw new Error(errorMessage);
      }
      this.option[method] = value;
      return this;
    };
  });
  Chain.prototype.end = function(callback) {
    if (this._hasInvoked === true || this._promise) {
      throw new Error(errorMessage);
    }
    this._hasInvoked = true;
    if (typeof callback === "function") {
      doInject(this.dispatch, this.option, callback);
    } else {
      this._promise = doInject(this.dispatch, this.option);
      return this._promise;
    }
  };
  Object.getOwnPropertyNames(Promise.prototype).forEach((method) => {
    if (method === "constructor")
      return;
    Chain.prototype[method] = function(...args) {
      if (!this._promise) {
        if (this._hasInvoked === true) {
          throw new Error(errorMessage);
        }
        this._hasInvoked = true;
        this._promise = doInject(this.dispatch, this.option);
      }
      return this._promise[method](...args);
    };
  });
  function isInjection(obj) {
    return obj instanceof Request || obj instanceof Response || obj?.constructor?.name === "_CustomLMRRequest";
  }
  module.exports = inject;
  module.exports.default = inject;
  module.exports.inject = inject;
  module.exports.isInjection = isInjection;
});

// node_modules/fastify/fastify.js
var require_fastify = __commonJS((exports, module) => {
  var VERSION = "5.6.1";
  var Avvio = require_boot();
  var http = (init_http(), __toCommonJS(exports_http));
  var diagnostics = (() => ({}));
  var lightMyRequest;
  var {
    kAvvioBoot,
    kChildren,
    kServerBindings,
    kBodyLimit,
    kSupportedHTTPMethods,
    kRoutePrefix,
    kLogLevel,
    kLogSerializers,
    kHooks,
    kSchemaController,
    kRequestAcceptVersion,
    kReplySerializerDefault,
    kContentTypeParser,
    kReply,
    kRequest,
    kFourOhFour,
    kState,
    kOptions,
    kPluginNameChain,
    kSchemaErrorFormatter,
    kErrorHandler,
    kKeepAliveConnections,
    kChildLoggerFactory,
    kGenReqId,
    kErrorHandlerAlreadySet
  } = require_symbols2();
  var { createServer } = require_server();
  var Reply = require_reply();
  var Request = require_request();
  var Context = require_context();
  var decorator = require_decorate();
  var ContentTypeParser = require_contentTypeParser();
  var SchemaController = require_schema_controller();
  var { Hooks, hookRunnerApplication, supportedHooks } = require_hooks();
  var { createChildLogger, defaultChildLoggerFactory, createLogger } = require_logger_factory();
  var pluginUtils = require_pluginUtils();
  var { getGenReqId, reqIdGenFactory } = require_reqIdGenFactory();
  var { buildRouting, validateBodyLimitOption, buildRouterOptions } = require_route();
  var build404 = require_fourOhFour();
  var getSecuredInitialConfig = require_initialConfigValidation();
  var override = require_pluginOverride();
  var noopSet = require_noop_set();
  var {
    appendStackTrace,
    AVVIO_ERRORS_MAP,
    ...errorCodes
  } = require_errors2();
  var PonyPromise = require_promise();
  var { defaultInitOptions } = getSecuredInitialConfig;
  var {
    FST_ERR_ASYNC_CONSTRAINT,
    FST_ERR_BAD_URL,
    FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE,
    FST_ERR_OPTIONS_NOT_OBJ,
    FST_ERR_QSP_NOT_FN,
    FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN,
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ,
    FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR,
    FST_ERR_INSTANCE_ALREADY_LISTENING,
    FST_ERR_REOPENED_CLOSE_SERVER,
    FST_ERR_ROUTE_REWRITE_NOT_STR,
    FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN,
    FST_ERR_ERROR_HANDLER_NOT_FN,
    FST_ERR_ERROR_HANDLER_ALREADY_SET,
    FST_ERR_ROUTE_METHOD_INVALID
  } = errorCodes;
  var { buildErrorHandler } = require_error_handler();
  var { FSTWRN004 } = require_warnings();
  var initChannel = diagnostics.channel("fastify.initialization");
  function defaultBuildPrettyMeta(route) {
    const cleanKeys = {};
    const allowedProps = ["errorHandler", "logLevel", "logSerializers"];
    allowedProps.concat(supportedHooks).forEach((k4) => {
      cleanKeys[k4] = route.store[k4];
    });
    return Object.assign({}, cleanKeys);
  }
  function fastify(options) {
    if (options && typeof options !== "object") {
      throw new FST_ERR_OPTIONS_NOT_OBJ;
    } else {
      options = Object.assign({}, options);
    }
    if (options.querystringParser && typeof options.querystringParser !== "function" || options.routerOptions?.querystringParser && typeof options.routerOptions.querystringParser !== "function") {
      throw new FST_ERR_QSP_NOT_FN(typeof (options.querystringParser ?? options.routerOptions.querystringParser));
    }
    if (options.schemaController && options.schemaController.bucket && typeof options.schemaController.bucket !== "function") {
      throw new FST_ERR_SCHEMA_CONTROLLER_BUCKET_OPT_NOT_FN(typeof options.schemaController.bucket);
    }
    validateBodyLimitOption(options.bodyLimit);
    const requestIdHeader = typeof options.requestIdHeader === "string" && options.requestIdHeader.length !== 0 ? options.requestIdHeader.toLowerCase() : options.requestIdHeader === true && "request-id";
    const genReqId = reqIdGenFactory(requestIdHeader, options.genReqId);
    const requestIdLogLabel = options.requestIdLogLabel || "reqId";
    const bodyLimit = options.bodyLimit || defaultInitOptions.bodyLimit;
    const disableRequestLogging = options.disableRequestLogging || false;
    const ajvOptions = Object.assign({
      customOptions: {},
      plugins: []
    }, options.ajv);
    const frameworkErrors = options.frameworkErrors;
    if (!ajvOptions.customOptions || Object.prototype.toString.call(ajvOptions.customOptions) !== "[object Object]") {
      throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_OBJ(typeof ajvOptions.customOptions);
    }
    if (!ajvOptions.plugins || !Array.isArray(ajvOptions.plugins)) {
      throw new FST_ERR_AJV_CUSTOM_OPTIONS_OPT_NOT_ARR(typeof ajvOptions.plugins);
    }
    const { logger, hasLogger } = createLogger(options);
    options.connectionTimeout = options.connectionTimeout || defaultInitOptions.connectionTimeout;
    options.keepAliveTimeout = options.keepAliveTimeout || defaultInitOptions.keepAliveTimeout;
    options.maxRequestsPerSocket = options.maxRequestsPerSocket || defaultInitOptions.maxRequestsPerSocket;
    options.requestTimeout = options.requestTimeout || defaultInitOptions.requestTimeout;
    options.logger = logger;
    options.requestIdHeader = requestIdHeader;
    options.requestIdLogLabel = requestIdLogLabel;
    options.disableRequestLogging = disableRequestLogging;
    options.ajv = ajvOptions;
    options.clientErrorHandler = options.clientErrorHandler || defaultClientErrorHandler;
    options.allowErrorHandlerOverride = options.allowErrorHandlerOverride ?? defaultInitOptions.allowErrorHandlerOverride;
    const initialConfig = getSecuredInitialConfig(options);
    options.exposeHeadRoutes = initialConfig.exposeHeadRoutes;
    options.routerOptions = buildRouterOptions(options, {
      defaultRoute,
      onBadUrl,
      ignoreTrailingSlash: defaultInitOptions.ignoreTrailingSlash,
      ignoreDuplicateSlashes: defaultInitOptions.ignoreDuplicateSlashes,
      maxParamLength: defaultInitOptions.maxParamLength,
      allowUnsafeRegex: defaultInitOptions.allowUnsafeRegex,
      buildPrettyMeta: defaultBuildPrettyMeta,
      useSemicolonDelimiter: defaultInitOptions.useSemicolonDelimiter
    });
    const router = buildRouting({
      config: options.routerOptions
    });
    const fourOhFour = build404(options);
    const httpHandler = wrapRouting(router, options);
    options.http2SessionTimeout = initialConfig.http2SessionTimeout;
    const { server, listen } = createServer(options, httpHandler);
    const serverHasCloseAllConnections = typeof server.closeAllConnections === "function";
    const serverHasCloseIdleConnections = typeof server.closeIdleConnections === "function";
    const serverHasCloseHttp2Sessions = typeof server.closeHttp2Sessions === "function";
    let forceCloseConnections = options.forceCloseConnections;
    if (forceCloseConnections === "idle" && !serverHasCloseIdleConnections) {
      throw new FST_ERR_FORCE_CLOSE_CONNECTIONS_IDLE_NOT_AVAILABLE;
    } else if (typeof forceCloseConnections !== "boolean") {
      forceCloseConnections = serverHasCloseIdleConnections ? "idle" : false;
    }
    const keepAliveConnections = !serverHasCloseAllConnections && forceCloseConnections === true ? new Set : noopSet();
    const setupResponseListeners = Reply.setupResponseListeners;
    const schemaController = SchemaController.buildSchemaController(null, options.schemaController);
    const fastify2 = {
      [kState]: {
        listening: false,
        closing: false,
        started: false,
        ready: false,
        booting: false,
        aborted: false,
        readyResolver: null
      },
      [kKeepAliveConnections]: keepAliveConnections,
      [kSupportedHTTPMethods]: {
        bodyless: new Set([
          "GET",
          "HEAD",
          "TRACE"
        ]),
        bodywith: new Set([
          "DELETE",
          "OPTIONS",
          "PATCH",
          "PUT",
          "POST"
        ])
      },
      [kOptions]: options,
      [kChildren]: [],
      [kServerBindings]: [],
      [kBodyLimit]: bodyLimit,
      [kRoutePrefix]: "",
      [kLogLevel]: "",
      [kLogSerializers]: null,
      [kHooks]: new Hooks,
      [kSchemaController]: schemaController,
      [kSchemaErrorFormatter]: null,
      [kErrorHandler]: buildErrorHandler(),
      [kErrorHandlerAlreadySet]: false,
      [kChildLoggerFactory]: defaultChildLoggerFactory,
      [kReplySerializerDefault]: null,
      [kContentTypeParser]: new ContentTypeParser(bodyLimit, options.onProtoPoisoning || defaultInitOptions.onProtoPoisoning, options.onConstructorPoisoning || defaultInitOptions.onConstructorPoisoning),
      [kReply]: Reply.buildReply(Reply),
      [kRequest]: Request.buildRequest(Request, options.trustProxy),
      [kFourOhFour]: fourOhFour,
      [pluginUtils.kRegisteredPlugins]: [],
      [kPluginNameChain]: ["fastify"],
      [kAvvioBoot]: null,
      [kGenReqId]: genReqId,
      routing: httpHandler,
      delete: function _delete(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "DELETE", url, options: options2, handler });
      },
      get: function _get(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "GET", url, options: options2, handler });
      },
      head: function _head(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "HEAD", url, options: options2, handler });
      },
      trace: function _trace(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "TRACE", url, options: options2, handler });
      },
      patch: function _patch(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "PATCH", url, options: options2, handler });
      },
      post: function _post(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "POST", url, options: options2, handler });
      },
      put: function _put(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "PUT", url, options: options2, handler });
      },
      options: function _options(url, options2, handler) {
        return router.prepareRoute.call(this, { method: "OPTIONS", url, options: options2, handler });
      },
      all: function _all(url, options2, handler) {
        return router.prepareRoute.call(this, { method: this.supportedMethods, url, options: options2, handler });
      },
      route: function _route(options2) {
        return router.route.call(this, { options: options2 });
      },
      hasRoute: function _route(options2) {
        return router.hasRoute.call(this, { options: options2 });
      },
      findRoute: function _findRoute(options2) {
        return router.findRoute(options2);
      },
      log: logger,
      withTypeProvider,
      addHook,
      addSchema,
      getSchema: schemaController.getSchema.bind(schemaController),
      getSchemas: schemaController.getSchemas.bind(schemaController),
      setValidatorCompiler,
      setSerializerCompiler,
      setSchemaController,
      setReplySerializer,
      setSchemaErrorFormatter,
      setGenReqId,
      addContentTypeParser: ContentTypeParser.helpers.addContentTypeParser,
      hasContentTypeParser: ContentTypeParser.helpers.hasContentTypeParser,
      getDefaultJsonParser: ContentTypeParser.defaultParsers.getDefaultJsonParser,
      defaultTextParser: ContentTypeParser.defaultParsers.defaultTextParser,
      removeContentTypeParser: ContentTypeParser.helpers.removeContentTypeParser,
      removeAllContentTypeParsers: ContentTypeParser.helpers.removeAllContentTypeParsers,
      register: null,
      after: null,
      ready: null,
      onClose: null,
      close: null,
      printPlugins: null,
      hasPlugin: function(name) {
        return this[pluginUtils.kRegisteredPlugins].includes(name) || this[kPluginNameChain].includes(name);
      },
      listen,
      server,
      addresses: function() {
        const binded = this[kServerBindings].map((b5) => b5.address());
        binded.push(this.server.address());
        return binded.filter((adr) => adr);
      },
      decorate: decorator.add,
      hasDecorator: decorator.exist,
      decorateReply: decorator.decorateReply,
      decorateRequest: decorator.decorateRequest,
      hasRequestDecorator: decorator.existRequest,
      hasReplyDecorator: decorator.existReply,
      getDecorator: decorator.getInstanceDecorator,
      addHttpMethod,
      inject,
      printRoutes,
      setNotFoundHandler,
      setErrorHandler,
      setChildLoggerFactory,
      initialConfig,
      addConstraintStrategy: router.addConstraintStrategy.bind(router),
      hasConstraintStrategy: router.hasConstraintStrategy.bind(router)
    };
    Object.defineProperties(fastify2, {
      listeningOrigin: {
        get() {
          const address = this.addresses().slice(-1).pop();
          if (typeof address === "string") {
            return address;
          }
          const host = address.family === "IPv6" ? `[${address.address}]` : address.address;
          return `${this[kOptions].https ? "https" : "http"}://${host}:${address.port}`;
        }
      },
      pluginName: {
        configurable: true,
        get() {
          if (this[kPluginNameChain].length > 1) {
            return this[kPluginNameChain].join(" -> ");
          }
          return this[kPluginNameChain][0];
        }
      },
      prefix: {
        configurable: true,
        get() {
          return this[kRoutePrefix];
        }
      },
      validatorCompiler: {
        configurable: true,
        get() {
          return this[kSchemaController].getValidatorCompiler();
        }
      },
      serializerCompiler: {
        configurable: true,
        get() {
          return this[kSchemaController].getSerializerCompiler();
        }
      },
      childLoggerFactory: {
        configurable: true,
        get() {
          return this[kChildLoggerFactory];
        }
      },
      version: {
        configurable: true,
        get() {
          return VERSION;
        }
      },
      errorHandler: {
        configurable: true,
        get() {
          return this[kErrorHandler].func;
        }
      },
      genReqId: {
        configurable: true,
        get() {
          return this[kGenReqId];
        }
      },
      supportedMethods: {
        configurable: false,
        get() {
          return [
            ...this[kSupportedHTTPMethods].bodyless,
            ...this[kSupportedHTTPMethods].bodywith
          ];
        }
      }
    });
    if (options.schemaErrorFormatter) {
      validateSchemaErrorFormatter(options.schemaErrorFormatter);
      fastify2[kSchemaErrorFormatter] = options.schemaErrorFormatter.bind(fastify2);
    }
    const avvioPluginTimeout = Number(options.pluginTimeout);
    const avvio = Avvio(fastify2, {
      autostart: false,
      timeout: isNaN(avvioPluginTimeout) === false ? avvioPluginTimeout : defaultInitOptions.pluginTimeout,
      expose: {
        use: "register"
      }
    });
    avvio.override = override;
    avvio.on("start", () => fastify2[kState].started = true);
    fastify2[kAvvioBoot] = fastify2.ready;
    fastify2.ready = ready;
    fastify2.printPlugins = avvio.prettyPrint.bind(avvio);
    avvio.once("preReady", () => {
      fastify2.onClose((instance, done) => {
        fastify2[kState].closing = true;
        router.closeRoutes();
        hookRunnerApplication("preClose", fastify2[kAvvioBoot], fastify2, function() {
          if (fastify2[kState].listening) {
            if (forceCloseConnections === "idle") {
              instance.server.closeIdleConnections();
            } else if (serverHasCloseAllConnections && forceCloseConnections) {
              instance.server.closeAllConnections();
            } else if (forceCloseConnections === true) {
              for (const conn of fastify2[kKeepAliveConnections]) {
                conn.destroy();
                fastify2[kKeepAliveConnections].delete(conn);
              }
            }
          }
          if (serverHasCloseHttp2Sessions) {
            instance.server.closeHttp2Sessions();
          }
          if (!options.serverFactory || fastify2[kState].listening) {
            instance.server.close(function(err) {
              if (err && err.code !== "ERR_SERVER_NOT_RUNNING") {
                done(null);
              } else {
                done();
              }
            });
          } else {
            process.nextTick(done, null);
          }
        });
      });
    });
    const onBadUrlContext = new Context({
      server: fastify2,
      config: {}
    });
    fastify2.setNotFoundHandler();
    fourOhFour.arrange404(fastify2);
    router.setup(options, {
      avvio,
      fourOhFour,
      logger,
      hasLogger,
      setupResponseListeners,
      throwIfAlreadyStarted,
      keepAliveConnections
    });
    server.on("clientError", options.clientErrorHandler.bind(fastify2));
    if (initChannel.hasSubscribers) {
      initChannel.publish({ fastify: fastify2 });
    }
    if ("asyncDispose" in Symbol) {
      fastify2[Symbol.asyncDispose] = function dispose() {
        return fastify2.close();
      };
    }
    return fastify2;
    function throwIfAlreadyStarted(msg) {
      if (fastify2[kState].started)
        throw new FST_ERR_INSTANCE_ALREADY_LISTENING(msg);
    }
    function inject(opts, cb) {
      if (lightMyRequest === undefined) {
        lightMyRequest = require_light_my_request();
      }
      if (fastify2[kState].started) {
        if (fastify2[kState].closing) {
          const error = new FST_ERR_REOPENED_CLOSE_SERVER;
          if (cb) {
            cb(error);
            return;
          } else {
            return Promise.reject(error);
          }
        }
        return lightMyRequest(httpHandler, opts, cb);
      }
      if (cb) {
        this.ready((err) => {
          if (err)
            cb(err, null);
          else
            lightMyRequest(httpHandler, opts, cb);
        });
      } else {
        return lightMyRequest((req, res) => {
          this.ready(function(err) {
            if (err) {
              res.emit("error", err);
              return;
            }
            httpHandler(req, res);
          });
        }, opts);
      }
    }
    function ready(cb) {
      if (this[kState].readyResolver !== null) {
        if (cb != null) {
          this[kState].readyResolver.promise.then(() => cb(null, fastify2), cb);
          return;
        }
        return this[kState].readyResolver.promise;
      }
      process.nextTick(runHooks);
      this[kState].readyResolver = PonyPromise.withResolvers();
      if (!cb) {
        return this[kState].readyResolver.promise;
      } else {
        this[kState].readyResolver.promise.then(() => cb(null, fastify2), cb);
      }
      function runHooks() {
        fastify2[kAvvioBoot]((err, done) => {
          if (err || fastify2[kState].started || fastify2[kState].ready || fastify2[kState].booting) {
            manageErr(err);
          } else {
            fastify2[kState].booting = true;
            hookRunnerApplication("onReady", fastify2[kAvvioBoot], fastify2, manageErr);
          }
          done();
        });
      }
      function manageErr(err) {
        err = err != null && AVVIO_ERRORS_MAP[err.code] != null ? appendStackTrace(err, new AVVIO_ERRORS_MAP[err.code](err.message)) : err;
        if (err) {
          return fastify2[kState].readyResolver.reject(err);
        }
        fastify2[kState].readyResolver.resolve(fastify2);
        fastify2[kState].booting = false;
        fastify2[kState].ready = true;
        fastify2[kState].readyResolver = null;
      }
    }
    function withTypeProvider() {
      return this;
    }
    function addHook(name, fn) {
      throwIfAlreadyStarted('Cannot call "addHook"!');
      if (fn == null) {
        throw new errorCodes.FST_ERR_HOOK_INVALID_HANDLER(name, fn);
      }
      if (name === "onSend" || name === "preSerialization" || name === "onError" || name === "preParsing") {
        if (fn.constructor.name === "AsyncFunction" && fn.length === 4) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      } else if (name === "onReady" || name === "onListen") {
        if (fn.constructor.name === "AsyncFunction" && fn.length !== 0) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      } else if (name === "onRequestAbort") {
        if (fn.constructor.name === "AsyncFunction" && fn.length !== 1) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      } else {
        if (fn.constructor.name === "AsyncFunction" && fn.length === 3) {
          throw new errorCodes.FST_ERR_HOOK_INVALID_ASYNC_HANDLER;
        }
      }
      if (name === "onClose") {
        this.onClose(fn.bind(this));
      } else if (name === "onReady" || name === "onListen" || name === "onRoute") {
        this[kHooks].add(name, fn);
      } else {
        this.after((err, done) => {
          try {
            _addHook.call(this, name, fn);
            done(err);
          } catch (err2) {
            done(err2);
          }
        });
      }
      return this;
      function _addHook(name2, fn2) {
        this[kHooks].add(name2, fn2);
        this[kChildren].forEach((child) => _addHook.call(child, name2, fn2));
      }
    }
    function addSchema(schema) {
      throwIfAlreadyStarted('Cannot call "addSchema"!');
      this[kSchemaController].add(schema);
      this[kChildren].forEach((child) => child.addSchema(schema));
      return this;
    }
    function defaultClientErrorHandler(err, socket) {
      if (err.code === "ECONNRESET" || socket.destroyed) {
        return;
      }
      let body, errorCode, errorStatus, errorLabel;
      if (err.code === "ERR_HTTP_REQUEST_TIMEOUT") {
        errorCode = "408";
        errorStatus = http.STATUS_CODES[errorCode];
        body = `{"error":"${errorStatus}","message":"Client Timeout","statusCode":408}`;
        errorLabel = "timeout";
      } else if (err.code === "HPE_HEADER_OVERFLOW") {
        errorCode = "431";
        errorStatus = http.STATUS_CODES[errorCode];
        body = `{"error":"${errorStatus}","message":"Exceeded maximum allowed HTTP header size","statusCode":431}`;
        errorLabel = "header_overflow";
      } else {
        errorCode = "400";
        errorStatus = http.STATUS_CODES[errorCode];
        body = `{"error":"${errorStatus}","message":"Client Error","statusCode":400}`;
        errorLabel = "error";
      }
      this.log.trace({ err }, `client ${errorLabel}`);
      if (socket.writable) {
        socket.write(`HTTP/1.1 ${errorCode} ${errorStatus}\r
Content-Length: ${body.length}\r
Content-Type: application/json\r
\r
${body}`);
      }
      socket.destroy(err);
    }
    function defaultRoute(req, res) {
      if (req.headers["accept-version"] !== undefined) {
        req.headers[kRequestAcceptVersion] = req.headers["accept-version"];
        req.headers["accept-version"] = undefined;
      }
      fourOhFour.router.lookup(req, res);
    }
    function onBadUrl(path, req, res) {
      if (frameworkErrors) {
        const id = getGenReqId(onBadUrlContext.server, req);
        const childLogger = createChildLogger(onBadUrlContext, logger, req, id);
        const request = new Request(id, null, req, null, childLogger, onBadUrlContext);
        const reply = new Reply(res, request, childLogger);
        if (disableRequestLogging === false) {
          childLogger.info({ req: request }, "incoming request");
        }
        return frameworkErrors(new FST_ERR_BAD_URL(path), request, reply);
      }
      const body = `{"error":"Bad Request","code":"FST_ERR_BAD_URL","message":"'${path}' is not a valid url component","statusCode":400}`;
      res.writeHead(400, {
        "Content-Type": "application/json",
        "Content-Length": body.length
      });
      res.end(body);
    }
    function buildAsyncConstraintCallback(isAsync, req, res) {
      if (isAsync === false)
        return;
      return function onAsyncConstraintError(err) {
        if (err) {
          if (frameworkErrors) {
            const id = getGenReqId(onBadUrlContext.server, req);
            const childLogger = createChildLogger(onBadUrlContext, logger, req, id);
            const request = new Request(id, null, req, null, childLogger, onBadUrlContext);
            const reply = new Reply(res, request, childLogger);
            if (disableRequestLogging === false) {
              childLogger.info({ req: request }, "incoming request");
            }
            return frameworkErrors(new FST_ERR_ASYNC_CONSTRAINT, request, reply);
          }
          const body = '{"error":"Internal Server Error","message":"Unexpected error from async constraint","statusCode":500}';
          res.writeHead(500, {
            "Content-Type": "application/json",
            "Content-Length": body.length
          });
          res.end(body);
        }
      };
    }
    function setNotFoundHandler(opts, handler) {
      throwIfAlreadyStarted('Cannot call "setNotFoundHandler"!');
      fourOhFour.setNotFoundHandler.call(this, opts, handler, avvio, router.routeHandler);
      return this;
    }
    function setValidatorCompiler(validatorCompiler) {
      throwIfAlreadyStarted('Cannot call "setValidatorCompiler"!');
      this[kSchemaController].setValidatorCompiler(validatorCompiler);
      return this;
    }
    function setSchemaErrorFormatter(errorFormatter) {
      throwIfAlreadyStarted('Cannot call "setSchemaErrorFormatter"!');
      validateSchemaErrorFormatter(errorFormatter);
      this[kSchemaErrorFormatter] = errorFormatter.bind(this);
      return this;
    }
    function setSerializerCompiler(serializerCompiler) {
      throwIfAlreadyStarted('Cannot call "setSerializerCompiler"!');
      this[kSchemaController].setSerializerCompiler(serializerCompiler);
      return this;
    }
    function setSchemaController(schemaControllerOpts) {
      throwIfAlreadyStarted('Cannot call "setSchemaController"!');
      const old = this[kSchemaController];
      const schemaController2 = SchemaController.buildSchemaController(old, Object.assign({}, old.opts, schemaControllerOpts));
      this[kSchemaController] = schemaController2;
      this.getSchema = schemaController2.getSchema.bind(schemaController2);
      this.getSchemas = schemaController2.getSchemas.bind(schemaController2);
      return this;
    }
    function setReplySerializer(replySerializer) {
      throwIfAlreadyStarted('Cannot call "setReplySerializer"!');
      this[kReplySerializerDefault] = replySerializer;
      return this;
    }
    function setErrorHandler(func) {
      throwIfAlreadyStarted('Cannot call "setErrorHandler"!');
      if (typeof func !== "function") {
        throw new FST_ERR_ERROR_HANDLER_NOT_FN;
      }
      if (!options.allowErrorHandlerOverride && this[kErrorHandlerAlreadySet]) {
        throw new FST_ERR_ERROR_HANDLER_ALREADY_SET;
      } else if (this[kErrorHandlerAlreadySet]) {
        FSTWRN004("To disable this behavior, set 'allowErrorHandlerOverride' to false or ignore this message. For more information, visit: https://fastify.dev/docs/latest/Reference/Server/#allowerrorhandleroverride");
      }
      this[kErrorHandlerAlreadySet] = true;
      this[kErrorHandler] = buildErrorHandler(this[kErrorHandler], func.bind(this));
      return this;
    }
    function setChildLoggerFactory(factory) {
      throwIfAlreadyStarted('Cannot call "setChildLoggerFactory"!');
      this[kChildLoggerFactory] = factory;
      return this;
    }
    function printRoutes(opts = {}) {
      opts.includeMeta = opts.includeHooks ? opts.includeMeta ? supportedHooks.concat(opts.includeMeta) : supportedHooks : opts.includeMeta;
      return router.printRoutes(opts);
    }
    function wrapRouting(router2, { rewriteUrl, logger: logger2 }) {
      let isAsync;
      return function preRouting(req, res) {
        if (isAsync === undefined)
          isAsync = router2.isAsyncConstraint();
        if (rewriteUrl) {
          req.originalUrl = req.url;
          const url = rewriteUrl.call(fastify2, req);
          if (typeof url === "string") {
            req.url = url;
          } else {
            const err = new FST_ERR_ROUTE_REWRITE_NOT_STR(req.url, typeof url);
            req.destroy(err);
          }
        }
        router2.routing(req, res, buildAsyncConstraintCallback(isAsync, req, res));
      };
    }
    function setGenReqId(func) {
      throwIfAlreadyStarted('Cannot call "setGenReqId"!');
      this[kGenReqId] = reqIdGenFactory(this[kOptions].requestIdHeader, func);
      return this;
    }
    function addHttpMethod(method, { hasBody = false } = {}) {
      if (typeof method !== "string" || http.METHODS.indexOf(method) === -1) {
        throw new FST_ERR_ROUTE_METHOD_INVALID;
      }
      if (hasBody === true) {
        this[kSupportedHTTPMethods].bodywith.add(method);
        this[kSupportedHTTPMethods].bodyless.delete(method);
      } else {
        this[kSupportedHTTPMethods].bodywith.delete(method);
        this[kSupportedHTTPMethods].bodyless.add(method);
      }
      const _method = method.toLowerCase();
      if (!this.hasDecorator(_method)) {
        this.decorate(_method, function(url, options2, handler) {
          return router.prepareRoute.call(this, { method, url, options: options2, handler });
        });
      }
      return this;
    }
  }
  function validateSchemaErrorFormatter(schemaErrorFormatter) {
    if (typeof schemaErrorFormatter !== "function") {
      throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN(typeof schemaErrorFormatter);
    } else if (schemaErrorFormatter.constructor.name === "AsyncFunction") {
      throw new FST_ERR_SCHEMA_ERROR_FORMATTER_NOT_FN("AsyncFunction");
    }
  }
  module.exports = fastify;
  module.exports.errorCodes = errorCodes;
  module.exports.fastify = fastify;
  module.exports.default = fastify;
});

// node_modules/fastify-plugin/lib/getPluginName.js
var require_getPluginName = __commonJS((exports, module) => {
  var fpStackTracePattern = /at\s(?:.*\.)?plugin\s.*\n\s*(.*)/;
  var fileNamePattern = /(\w*(\.\w*)*)\..*/;
  module.exports = function getPluginName(fn) {
    if (fn.name.length > 0)
      return fn.name;
    const stackTraceLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 10;
    try {
      throw new Error("anonymous function");
    } catch (e) {
      Error.stackTraceLimit = stackTraceLimit;
      return extractPluginName(e.stack);
    }
  };
  function extractPluginName(stack) {
    const m4 = stack.match(fpStackTracePattern);
    return m4 ? m4[1].split(/[/\\]/).slice(-1)[0].match(fileNamePattern)[1] : "anonymous";
  }
  module.exports.extractPluginName = extractPluginName;
});

// node_modules/fastify-plugin/lib/toCamelCase.js
var require_toCamelCase = __commonJS((exports, module) => {
  module.exports = function toCamelCase(name) {
    if (name[0] === "@") {
      name = name.slice(1).replace("/", "-");
    }
    return name.replace(/-(.)/g, function(match, g1) {
      return g1.toUpperCase();
    });
  };
});

// node_modules/fastify-plugin/plugin.js
var require_plugin2 = __commonJS((exports, module) => {
  var getPluginName = require_getPluginName();
  var toCamelCase = require_toCamelCase();
  var count = 0;
  function plugin(fn, options = {}) {
    let autoName = false;
    if (fn.default !== undefined) {
      fn = fn.default;
    }
    if (typeof fn !== "function") {
      throw new TypeError(`fastify-plugin expects a function, instead got a '${typeof fn}'`);
    }
    if (typeof options === "string") {
      options = {
        fastify: options
      };
    }
    if (typeof options !== "object" || Array.isArray(options) || options === null) {
      throw new TypeError("The options object should be an object");
    }
    if (options.fastify !== undefined && typeof options.fastify !== "string") {
      throw new TypeError(`fastify-plugin expects a version string, instead got '${typeof options.fastify}'`);
    }
    if (!options.name) {
      autoName = true;
      options.name = getPluginName(fn) + "-auto-" + count++;
    }
    fn[Symbol.for("skip-override")] = options.encapsulate !== true;
    fn[Symbol.for("fastify.display-name")] = options.name;
    fn[Symbol.for("plugin-meta")] = options;
    if (!fn.default) {
      fn.default = fn;
    }
    const camelCase = toCamelCase(options.name);
    if (!autoName && !fn[camelCase]) {
      fn[camelCase] = fn;
    }
    return fn;
  }
  module.exports = plugin;
  module.exports.default = plugin;
  module.exports.fastifyPlugin = plugin;
});

// node_modules/@fastify/cors/vary.js
var require_vary = __commonJS((exports, module) => {
  var { FifoMap: FifoCache } = require_toad_cache();
  var validFieldnameRE = /^[!#$%&'*+\-.^\w`|~]+$/u;
  function validateFieldname(fieldname) {
    if (validFieldnameRE.test(fieldname) === false) {
      throw new TypeError("Fieldname contains invalid characters.");
    }
  }
  function parse(header) {
    header = header.trim().toLowerCase();
    const result = [];
    if (header.length === 0) {} else if (header.indexOf(",") === -1) {
      result.push(header);
    } else {
      const il = header.length;
      let i = 0;
      let pos = 0;
      let char;
      for (i;i < il; ++i) {
        char = header[i];
        if (char === " ") {
          pos = i + 1;
        } else if (char === ",") {
          if (pos !== i) {
            result.push(header.slice(pos, i));
          }
          pos = i + 1;
        }
      }
      if (pos !== i) {
        result.push(header.slice(pos, i));
      }
    }
    return result;
  }
  function createAddFieldnameToVary(fieldname) {
    const headerCache = new FifoCache(1000);
    validateFieldname(fieldname);
    return function(reply) {
      let header = reply.getHeader("Vary");
      if (!header) {
        reply.header("Vary", fieldname);
        return;
      }
      if (header === "*") {
        return;
      }
      if (fieldname === "*") {
        reply.header("Vary", "*");
        return;
      }
      if (Array.isArray(header)) {
        header = header.join(", ");
      }
      if (headerCache.get(header) === undefined) {
        const vals = parse(header);
        if (vals.indexOf("*") !== -1) {
          headerCache.set(header, "*");
        } else if (vals.indexOf(fieldname.toLowerCase()) === -1) {
          headerCache.set(header, header + ", " + fieldname);
        } else {
          headerCache.set(header, null);
        }
      }
      const cached = headerCache.get(header);
      if (cached !== null) {
        reply.header("Vary", cached);
      }
    };
  }
  exports.createAddFieldnameToVary = createAddFieldnameToVary;
  exports.addOriginToVaryHeader = createAddFieldnameToVary("Origin");
  exports.addAccessControlRequestHeadersToVaryHeader = createAddFieldnameToVary("Access-Control-Request-Headers");
  exports.parse = parse;
});

// node_modules/@fastify/cors/index.js
var require_cors = __commonJS((exports, module) => {
  var fp = require_plugin2();
  var {
    addAccessControlRequestHeadersToVaryHeader,
    addOriginToVaryHeader
  } = require_vary();
  var defaultOptions = {
    origin: "*",
    methods: "GET,HEAD,POST",
    hook: "onRequest",
    preflightContinue: false,
    optionsSuccessStatus: 204,
    credentials: false,
    exposedHeaders: null,
    allowedHeaders: null,
    maxAge: null,
    preflight: true,
    strictPreflight: true
  };
  var validHooks = [
    "onRequest",
    "preParsing",
    "preValidation",
    "preHandler",
    "preSerialization",
    "onSend"
  ];
  var hookWithPayload = [
    "preSerialization",
    "preParsing",
    "onSend"
  ];
  function validateHook(value, next) {
    if (validHooks.indexOf(value) !== -1) {
      return;
    }
    next(new TypeError("@fastify/cors: Invalid hook option provided."));
  }
  function fastifyCors(fastify, opts, next) {
    fastify.decorateRequest("corsPreflightEnabled", false);
    let hideOptionsRoute = true;
    let logLevel;
    if (typeof opts === "function") {
      handleCorsOptionsDelegator(opts, fastify, { hook: defaultOptions.hook }, next);
    } else if (opts.delegator) {
      const { delegator, ...options } = opts;
      handleCorsOptionsDelegator(delegator, fastify, options, next);
    } else {
      const corsOptions = normalizeCorsOptions(opts);
      validateHook(corsOptions.hook, next);
      if (hookWithPayload.indexOf(corsOptions.hook) !== -1) {
        fastify.addHook(corsOptions.hook, function handleCors(req, reply, _payload, next2) {
          addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
        });
      } else {
        fastify.addHook(corsOptions.hook, function handleCors(req, reply, next2) {
          addCorsHeadersHandler(fastify, corsOptions, req, reply, next2);
        });
      }
    }
    if (opts.logLevel !== undefined)
      logLevel = opts.logLevel;
    if (opts.hideOptionsRoute !== undefined)
      hideOptionsRoute = opts.hideOptionsRoute;
    fastify.options("*", { schema: { hide: hideOptionsRoute }, logLevel }, (req, reply) => {
      if (!req.corsPreflightEnabled) {
        reply.callNotFound();
        return;
      }
      reply.send();
    });
    next();
  }
  function handleCorsOptionsDelegator(optionsResolver, fastify, opts, next) {
    const hook = opts?.hook || defaultOptions.hook;
    validateHook(hook, next);
    if (optionsResolver.length === 2) {
      if (hookWithPayload.indexOf(hook) !== -1) {
        fastify.addHook(hook, function handleCors(req, reply, _payload, next2) {
          handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
        });
      } else {
        fastify.addHook(hook, function handleCors(req, reply, next2) {
          handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next2);
        });
      }
    } else {
      if (hookWithPayload.indexOf(hook) !== -1) {
        fastify.addHook(hook, function handleCors(req, reply, _payload, next2) {
          const ret = optionsResolver(req);
          if (ret && typeof ret.then === "function") {
            ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
            return;
          }
          next2(new Error("Invalid CORS origin option"));
        });
      } else {
        fastify.addHook(hook, function handleCors(req, reply, next2) {
          const ret = optionsResolver(req);
          if (ret && typeof ret.then === "function") {
            ret.then((options) => addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next2)).catch(next2);
            return;
          }
          next2(new Error("Invalid CORS origin option"));
        });
      }
    }
  }
  function handleCorsOptionsCallbackDelegator(optionsResolver, fastify, req, reply, next) {
    optionsResolver(req, (err, options) => {
      if (err) {
        next(err);
      } else {
        addCorsHeadersHandler(fastify, normalizeCorsOptions(options, true), req, reply, next);
      }
    });
  }
  function normalizeCorsOptions(opts, dynamic) {
    const corsOptions = { ...defaultOptions, ...opts };
    if (Array.isArray(opts.origin) && opts.origin.indexOf("*") !== -1) {
      corsOptions.origin = "*";
    }
    if (Number.isInteger(corsOptions.cacheControl)) {
      corsOptions.cacheControl = `max-age=${corsOptions.cacheControl}`;
    } else if (typeof corsOptions.cacheControl !== "string") {
      corsOptions.cacheControl = null;
    }
    corsOptions.dynamic = dynamic || false;
    return corsOptions;
  }
  function addCorsHeadersHandler(fastify, options, req, reply, next) {
    if (typeof options.origin !== "string" && options.origin !== false || options.dynamic) {
      addOriginToVaryHeader(reply);
    }
    const resolveOriginOption = typeof options.origin === "function" ? resolveOriginWrapper(fastify, options.origin) : (_4, cb) => cb(null, options.origin);
    resolveOriginOption(req, (error, resolvedOriginOption) => {
      if (error !== null) {
        return next(error);
      }
      if (resolvedOriginOption === false) {
        return next();
      }
      if (req.routeOptions.config?.cors === false) {
        return next();
      }
      if (!resolvedOriginOption) {
        return next(new Error("Invalid CORS origin option"));
      }
      addCorsHeaders(req, reply, resolvedOriginOption, options);
      if (req.raw.method === "OPTIONS" && options.preflight === true) {
        if (options.strictPreflight === true && (!req.headers.origin || !req.headers["access-control-request-method"])) {
          reply.status(400).type("text/plain").send("Invalid Preflight Request");
          return;
        }
        req.corsPreflightEnabled = true;
        addPreflightHeaders(req, reply, options);
        if (!options.preflightContinue) {
          reply.code(options.optionsSuccessStatus).header("Content-Length", "0").send();
          return;
        }
      }
      return next();
    });
  }
  function addCorsHeaders(req, reply, originOption, corsOptions) {
    const origin = getAccessControlAllowOriginHeader(req.headers.origin, originOption);
    if (origin) {
      reply.header("Access-Control-Allow-Origin", origin);
    }
    if (corsOptions.credentials) {
      reply.header("Access-Control-Allow-Credentials", "true");
    }
    if (corsOptions.exposedHeaders !== null) {
      reply.header("Access-Control-Expose-Headers", Array.isArray(corsOptions.exposedHeaders) ? corsOptions.exposedHeaders.join(", ") : corsOptions.exposedHeaders);
    }
  }
  function addPreflightHeaders(req, reply, corsOptions) {
    reply.header("Access-Control-Allow-Methods", Array.isArray(corsOptions.methods) ? corsOptions.methods.join(", ") : corsOptions.methods);
    if (corsOptions.allowedHeaders === null) {
      addAccessControlRequestHeadersToVaryHeader(reply);
      const reqAllowedHeaders = req.headers["access-control-request-headers"];
      if (reqAllowedHeaders !== undefined) {
        reply.header("Access-Control-Allow-Headers", reqAllowedHeaders);
      }
    } else {
      reply.header("Access-Control-Allow-Headers", Array.isArray(corsOptions.allowedHeaders) ? corsOptions.allowedHeaders.join(", ") : corsOptions.allowedHeaders);
    }
    if (corsOptions.maxAge !== null) {
      reply.header("Access-Control-Max-Age", String(corsOptions.maxAge));
    }
    if (corsOptions.cacheControl) {
      reply.header("Cache-Control", corsOptions.cacheControl);
    }
  }
  function resolveOriginWrapper(fastify, origin) {
    return function(req, cb) {
      const result = origin.call(fastify, req.headers.origin, cb);
      if (result && typeof result.then === "function") {
        result.then((res) => cb(null, res), cb);
      }
    };
  }
  function getAccessControlAllowOriginHeader(reqOrigin, originOption) {
    if (typeof originOption === "string") {
      return originOption;
    }
    return isRequestOriginAllowed(reqOrigin, originOption) ? reqOrigin : false;
  }
  function isRequestOriginAllowed(reqOrigin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (let i = 0;i < allowedOrigin.length; ++i) {
        if (isRequestOriginAllowed(reqOrigin, allowedOrigin[i])) {
          return true;
        }
      }
      return false;
    } else if (typeof allowedOrigin === "string") {
      return reqOrigin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      allowedOrigin.lastIndex = 0;
      return allowedOrigin.test(reqOrigin);
    } else {
      return !!allowedOrigin;
    }
  }
  var _fastifyCors = fp(fastifyCors, {
    fastify: "5.x",
    name: "@fastify/cors"
  });
  module.exports = _fastifyCors;
  module.exports.fastifyCors = _fastifyCors;
  module.exports.default = _fastifyCors;
});

// node_modules/forwarded/index.js
var require_forwarded2 = __commonJS((exports, module) => {
  /*!
   * forwarded
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = forwarded;
  function forwarded(req) {
    if (!req) {
      throw new TypeError("argument req is required");
    }
    var proxyAddrs = parse(req.headers["x-forwarded-for"] || "");
    var socketAddr = getSocketAddr(req);
    var addrs = [socketAddr].concat(proxyAddrs);
    return addrs;
  }
  function getSocketAddr(req) {
    return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;
  }
  function parse(header) {
    var end = header.length;
    var list = [];
    var start = header.length;
    for (var i = header.length - 1;i >= 0; i--) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i;
          }
          break;
        case 44:
          if (start !== end) {
            list.push(header.substring(start, end));
          }
          start = end = i;
          break;
        default:
          start = i;
          break;
      }
    }
    if (start !== end) {
      list.push(header.substring(start, end));
    }
    return list;
  }
});

// node_modules/media-typer/index.js
var require_media_typer = __commonJS((exports) => {
  /*!
   * media-typer
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   */
  var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
  var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
  var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
  var qescRegExp = /\\([\u0000-\u007f])/g;
  var quoteRegExp = /([\\"])/g;
  var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
  var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
  var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
  exports.format = format;
  exports.parse = parse;
  function format(obj) {
    if (!obj || typeof obj !== "object") {
      throw new TypeError("argument obj is required");
    }
    var parameters = obj.parameters;
    var subtype = obj.subtype;
    var suffix = obj.suffix;
    var type = obj.type;
    if (!type || !typeNameRegExp.test(type)) {
      throw new TypeError("invalid type");
    }
    if (!subtype || !subtypeNameRegExp.test(subtype)) {
      throw new TypeError("invalid subtype");
    }
    var string = type + "/" + subtype;
    if (suffix) {
      if (!typeNameRegExp.test(suffix)) {
        throw new TypeError("invalid suffix");
      }
      string += "+" + suffix;
    }
    if (parameters && typeof parameters === "object") {
      var param;
      var params = Object.keys(parameters).sort();
      for (var i = 0;i < params.length; i++) {
        param = params[i];
        if (!tokenRegExp.test(param)) {
          throw new TypeError("invalid parameter name");
        }
        string += "; " + param + "=" + qstring(parameters[param]);
      }
    }
    return string;
  }
  function parse(string) {
    if (!string) {
      throw new TypeError("argument string is required");
    }
    if (typeof string === "object") {
      string = getcontenttype(string);
    }
    if (typeof string !== "string") {
      throw new TypeError("argument string is required to be a string");
    }
    var index = string.indexOf(";");
    var type = index !== -1 ? string.substr(0, index) : string;
    var key;
    var match;
    var obj = splitType(type);
    var params = {};
    var value;
    paramRegExp.lastIndex = index;
    while (match = paramRegExp.exec(string)) {
      if (match.index !== index) {
        throw new TypeError("invalid parameter format");
      }
      index += match[0].length;
      key = match[1].toLowerCase();
      value = match[2];
      if (value[0] === '"') {
        value = value.substr(1, value.length - 2).replace(qescRegExp, "$1");
      }
      params[key] = value;
    }
    if (index !== -1 && index !== string.length) {
      throw new TypeError("invalid parameter format");
    }
    obj.parameters = params;
    return obj;
  }
  function getcontenttype(obj) {
    if (typeof obj.getHeader === "function") {
      return obj.getHeader("content-type");
    }
    if (typeof obj.headers === "object") {
      return obj.headers && obj.headers["content-type"];
    }
  }
  function qstring(val) {
    var str = String(val);
    if (tokenRegExp.test(str)) {
      return str;
    }
    if (str.length > 0 && !textRegExp.test(str)) {
      throw new TypeError("invalid parameter value");
    }
    return '"' + str.replace(quoteRegExp, "\\$1") + '"';
  }
  function splitType(string) {
    var match = typeRegExp.exec(string.toLowerCase());
    if (!match) {
      throw new TypeError("invalid media type");
    }
    var type = match[1];
    var subtype = match[2];
    var suffix;
    var index = subtype.lastIndexOf("+");
    if (index !== -1) {
      suffix = subtype.substr(index + 1);
      subtype = subtype.substr(0, index);
    }
    var obj = {
      type,
      subtype,
      suffix
    };
    return obj;
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS((exports, module) => {
  module.exports = {
    "application/1d-interleaved-parityfec": {
      source: "iana"
    },
    "application/3gpdash-qoe-report+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/3gpp-ims+xml": {
      source: "iana",
      compressible: true
    },
    "application/3gpphal+json": {
      source: "iana",
      compressible: true
    },
    "application/3gpphalforms+json": {
      source: "iana",
      compressible: true
    },
    "application/a2l": {
      source: "iana"
    },
    "application/ace+cbor": {
      source: "iana"
    },
    "application/activemessage": {
      source: "iana"
    },
    "application/activity+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-costmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-directory+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcost+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointcostparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointprop+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-endpointpropparams+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-error+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmap+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-networkmapfilter+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamcontrol+json": {
      source: "iana",
      compressible: true
    },
    "application/alto-updatestreamparams+json": {
      source: "iana",
      compressible: true
    },
    "application/aml": {
      source: "iana"
    },
    "application/andrew-inset": {
      source: "iana",
      extensions: ["ez"]
    },
    "application/applefile": {
      source: "iana"
    },
    "application/applixware": {
      source: "apache",
      extensions: ["aw"]
    },
    "application/at+jwt": {
      source: "iana"
    },
    "application/atf": {
      source: "iana"
    },
    "application/atfx": {
      source: "iana"
    },
    "application/atom+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atom"]
    },
    "application/atomcat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomcat"]
    },
    "application/atomdeleted+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomdeleted"]
    },
    "application/atomicmail": {
      source: "iana"
    },
    "application/atomsvc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["atomsvc"]
    },
    "application/atsc-dwd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dwd"]
    },
    "application/atsc-dynamic-event-message": {
      source: "iana"
    },
    "application/atsc-held+xml": {
      source: "iana",
      compressible: true,
      extensions: ["held"]
    },
    "application/atsc-rdt+json": {
      source: "iana",
      compressible: true
    },
    "application/atsc-rsat+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsat"]
    },
    "application/atxml": {
      source: "iana"
    },
    "application/auth-policy+xml": {
      source: "iana",
      compressible: true
    },
    "application/bacnet-xdd+zip": {
      source: "iana",
      compressible: false
    },
    "application/batch-smtp": {
      source: "iana"
    },
    "application/bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/beep+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/calendar+json": {
      source: "iana",
      compressible: true
    },
    "application/calendar+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xcs"]
    },
    "application/call-completion": {
      source: "iana"
    },
    "application/cals-1840": {
      source: "iana"
    },
    "application/captive+json": {
      source: "iana",
      compressible: true
    },
    "application/cbor": {
      source: "iana"
    },
    "application/cbor-seq": {
      source: "iana"
    },
    "application/cccex": {
      source: "iana"
    },
    "application/ccmp+xml": {
      source: "iana",
      compressible: true
    },
    "application/ccxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ccxml"]
    },
    "application/cdfx+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdfx"]
    },
    "application/cdmi-capability": {
      source: "iana",
      extensions: ["cdmia"]
    },
    "application/cdmi-container": {
      source: "iana",
      extensions: ["cdmic"]
    },
    "application/cdmi-domain": {
      source: "iana",
      extensions: ["cdmid"]
    },
    "application/cdmi-object": {
      source: "iana",
      extensions: ["cdmio"]
    },
    "application/cdmi-queue": {
      source: "iana",
      extensions: ["cdmiq"]
    },
    "application/cdni": {
      source: "iana"
    },
    "application/cea": {
      source: "iana"
    },
    "application/cea-2018+xml": {
      source: "iana",
      compressible: true
    },
    "application/cellml+xml": {
      source: "iana",
      compressible: true
    },
    "application/cfw": {
      source: "iana"
    },
    "application/city+json": {
      source: "iana",
      compressible: true
    },
    "application/clr": {
      source: "iana"
    },
    "application/clue+xml": {
      source: "iana",
      compressible: true
    },
    "application/clue_info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cms": {
      source: "iana"
    },
    "application/cnrp+xml": {
      source: "iana",
      compressible: true
    },
    "application/coap-group+json": {
      source: "iana",
      compressible: true
    },
    "application/coap-payload": {
      source: "iana"
    },
    "application/commonground": {
      source: "iana"
    },
    "application/conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/cose": {
      source: "iana"
    },
    "application/cose-key": {
      source: "iana"
    },
    "application/cose-key-set": {
      source: "iana"
    },
    "application/cpl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cpl"]
    },
    "application/csrattrs": {
      source: "iana"
    },
    "application/csta+xml": {
      source: "iana",
      compressible: true
    },
    "application/cstadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/csvm+json": {
      source: "iana",
      compressible: true
    },
    "application/cu-seeme": {
      source: "apache",
      extensions: ["cu"]
    },
    "application/cwt": {
      source: "iana"
    },
    "application/cybercash": {
      source: "iana"
    },
    "application/dart": {
      compressible: true
    },
    "application/dash+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpd"]
    },
    "application/dash-patch+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpp"]
    },
    "application/dashdelta": {
      source: "iana"
    },
    "application/davmount+xml": {
      source: "iana",
      compressible: true,
      extensions: ["davmount"]
    },
    "application/dca-rft": {
      source: "iana"
    },
    "application/dcd": {
      source: "iana"
    },
    "application/dec-dx": {
      source: "iana"
    },
    "application/dialog-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/dicom": {
      source: "iana"
    },
    "application/dicom+json": {
      source: "iana",
      compressible: true
    },
    "application/dicom+xml": {
      source: "iana",
      compressible: true
    },
    "application/dii": {
      source: "iana"
    },
    "application/dit": {
      source: "iana"
    },
    "application/dns": {
      source: "iana"
    },
    "application/dns+json": {
      source: "iana",
      compressible: true
    },
    "application/dns-message": {
      source: "iana"
    },
    "application/docbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dbk"]
    },
    "application/dots+cbor": {
      source: "iana"
    },
    "application/dskpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/dssc+der": {
      source: "iana",
      extensions: ["dssc"]
    },
    "application/dssc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdssc"]
    },
    "application/dvcs": {
      source: "iana"
    },
    "application/ecmascript": {
      source: "iana",
      compressible: true,
      extensions: ["es", "ecma"]
    },
    "application/edi-consent": {
      source: "iana"
    },
    "application/edi-x12": {
      source: "iana",
      compressible: false
    },
    "application/edifact": {
      source: "iana",
      compressible: false
    },
    "application/efi": {
      source: "iana"
    },
    "application/elm+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/elm+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.cap+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/emergencycalldata.comment+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.control+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.deviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.ecall.msd": {
      source: "iana"
    },
    "application/emergencycalldata.providerinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.serviceinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.subscriberinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/emergencycalldata.veds+xml": {
      source: "iana",
      compressible: true
    },
    "application/emma+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emma"]
    },
    "application/emotionml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["emotionml"]
    },
    "application/encaprtp": {
      source: "iana"
    },
    "application/epp+xml": {
      source: "iana",
      compressible: true
    },
    "application/epub+zip": {
      source: "iana",
      compressible: false,
      extensions: ["epub"]
    },
    "application/eshop": {
      source: "iana"
    },
    "application/exi": {
      source: "iana",
      extensions: ["exi"]
    },
    "application/expect-ct-report+json": {
      source: "iana",
      compressible: true
    },
    "application/express": {
      source: "iana",
      extensions: ["exp"]
    },
    "application/fastinfoset": {
      source: "iana"
    },
    "application/fastsoap": {
      source: "iana"
    },
    "application/fdt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fdt"]
    },
    "application/fhir+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fhir+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/fido.trusted-apps+json": {
      compressible: true
    },
    "application/fits": {
      source: "iana"
    },
    "application/flexfec": {
      source: "iana"
    },
    "application/font-sfnt": {
      source: "iana"
    },
    "application/font-tdpfr": {
      source: "iana",
      extensions: ["pfr"]
    },
    "application/font-woff": {
      source: "iana",
      compressible: false
    },
    "application/framework-attributes+xml": {
      source: "iana",
      compressible: true
    },
    "application/geo+json": {
      source: "iana",
      compressible: true,
      extensions: ["geojson"]
    },
    "application/geo+json-seq": {
      source: "iana"
    },
    "application/geopackage+sqlite3": {
      source: "iana"
    },
    "application/geoxacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/gltf-buffer": {
      source: "iana"
    },
    "application/gml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["gml"]
    },
    "application/gpx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["gpx"]
    },
    "application/gxf": {
      source: "apache",
      extensions: ["gxf"]
    },
    "application/gzip": {
      source: "iana",
      compressible: false,
      extensions: ["gz"]
    },
    "application/h224": {
      source: "iana"
    },
    "application/held+xml": {
      source: "iana",
      compressible: true
    },
    "application/hjson": {
      extensions: ["hjson"]
    },
    "application/http": {
      source: "iana"
    },
    "application/hyperstudio": {
      source: "iana",
      extensions: ["stk"]
    },
    "application/ibe-key-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pkg-reply+xml": {
      source: "iana",
      compressible: true
    },
    "application/ibe-pp-data": {
      source: "iana"
    },
    "application/iges": {
      source: "iana"
    },
    "application/im-iscomposing+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/index": {
      source: "iana"
    },
    "application/index.cmd": {
      source: "iana"
    },
    "application/index.obj": {
      source: "iana"
    },
    "application/index.response": {
      source: "iana"
    },
    "application/index.vnd": {
      source: "iana"
    },
    "application/inkml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ink", "inkml"]
    },
    "application/iotp": {
      source: "iana"
    },
    "application/ipfix": {
      source: "iana",
      extensions: ["ipfix"]
    },
    "application/ipp": {
      source: "iana"
    },
    "application/isup": {
      source: "iana"
    },
    "application/its+xml": {
      source: "iana",
      compressible: true,
      extensions: ["its"]
    },
    "application/java-archive": {
      source: "apache",
      compressible: false,
      extensions: ["jar", "war", "ear"]
    },
    "application/java-serialized-object": {
      source: "apache",
      compressible: false,
      extensions: ["ser"]
    },
    "application/java-vm": {
      source: "apache",
      compressible: false,
      extensions: ["class"]
    },
    "application/javascript": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["js", "mjs"]
    },
    "application/jf2feed+json": {
      source: "iana",
      compressible: true
    },
    "application/jose": {
      source: "iana"
    },
    "application/jose+json": {
      source: "iana",
      compressible: true
    },
    "application/jrd+json": {
      source: "iana",
      compressible: true
    },
    "application/jscalendar+json": {
      source: "iana",
      compressible: true
    },
    "application/json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["json", "map"]
    },
    "application/json-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/json-seq": {
      source: "iana"
    },
    "application/json5": {
      extensions: ["json5"]
    },
    "application/jsonml+json": {
      source: "apache",
      compressible: true,
      extensions: ["jsonml"]
    },
    "application/jwk+json": {
      source: "iana",
      compressible: true
    },
    "application/jwk-set+json": {
      source: "iana",
      compressible: true
    },
    "application/jwt": {
      source: "iana"
    },
    "application/kpml-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/kpml-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/ld+json": {
      source: "iana",
      compressible: true,
      extensions: ["jsonld"]
    },
    "application/lgr+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lgr"]
    },
    "application/link-format": {
      source: "iana"
    },
    "application/load-control+xml": {
      source: "iana",
      compressible: true
    },
    "application/lost+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lostxml"]
    },
    "application/lostsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/lpf+zip": {
      source: "iana",
      compressible: false
    },
    "application/lxf": {
      source: "iana"
    },
    "application/mac-binhex40": {
      source: "iana",
      extensions: ["hqx"]
    },
    "application/mac-compactpro": {
      source: "apache",
      extensions: ["cpt"]
    },
    "application/macwriteii": {
      source: "iana"
    },
    "application/mads+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mads"]
    },
    "application/manifest+json": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["webmanifest"]
    },
    "application/marc": {
      source: "iana",
      extensions: ["mrc"]
    },
    "application/marcxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mrcx"]
    },
    "application/mathematica": {
      source: "iana",
      extensions: ["ma", "nb", "mb"]
    },
    "application/mathml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mathml"]
    },
    "application/mathml-content+xml": {
      source: "iana",
      compressible: true
    },
    "application/mathml-presentation+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-associated-procedure-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-deregister+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-envelope+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-msk-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-protection-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-reception-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-register-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-schedule+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbms-user-service-description+xml": {
      source: "iana",
      compressible: true
    },
    "application/mbox": {
      source: "iana",
      extensions: ["mbox"]
    },
    "application/media-policy-dataset+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpf"]
    },
    "application/media_control+xml": {
      source: "iana",
      compressible: true
    },
    "application/mediaservercontrol+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mscml"]
    },
    "application/merge-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/metalink+xml": {
      source: "apache",
      compressible: true,
      extensions: ["metalink"]
    },
    "application/metalink4+xml": {
      source: "iana",
      compressible: true,
      extensions: ["meta4"]
    },
    "application/mets+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mets"]
    },
    "application/mf4": {
      source: "iana"
    },
    "application/mikey": {
      source: "iana"
    },
    "application/mipc": {
      source: "iana"
    },
    "application/missing-blocks+cbor-seq": {
      source: "iana"
    },
    "application/mmt-aei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["maei"]
    },
    "application/mmt-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musd"]
    },
    "application/mods+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mods"]
    },
    "application/moss-keys": {
      source: "iana"
    },
    "application/moss-signature": {
      source: "iana"
    },
    "application/mosskey-data": {
      source: "iana"
    },
    "application/mosskey-request": {
      source: "iana"
    },
    "application/mp21": {
      source: "iana",
      extensions: ["m21", "mp21"]
    },
    "application/mp4": {
      source: "iana",
      extensions: ["mp4s", "m4p"]
    },
    "application/mpeg4-generic": {
      source: "iana"
    },
    "application/mpeg4-iod": {
      source: "iana"
    },
    "application/mpeg4-iod-xmt": {
      source: "iana"
    },
    "application/mrb-consumer+xml": {
      source: "iana",
      compressible: true
    },
    "application/mrb-publish+xml": {
      source: "iana",
      compressible: true
    },
    "application/msc-ivr+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msc-mixer+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/msword": {
      source: "iana",
      compressible: false,
      extensions: ["doc", "dot"]
    },
    "application/mud+json": {
      source: "iana",
      compressible: true
    },
    "application/multipart-core": {
      source: "iana"
    },
    "application/mxf": {
      source: "iana",
      extensions: ["mxf"]
    },
    "application/n-quads": {
      source: "iana",
      extensions: ["nq"]
    },
    "application/n-triples": {
      source: "iana",
      extensions: ["nt"]
    },
    "application/nasdata": {
      source: "iana"
    },
    "application/news-checkgroups": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-groupinfo": {
      source: "iana",
      charset: "US-ASCII"
    },
    "application/news-transmission": {
      source: "iana"
    },
    "application/nlsml+xml": {
      source: "iana",
      compressible: true
    },
    "application/node": {
      source: "iana",
      extensions: ["cjs"]
    },
    "application/nss": {
      source: "iana"
    },
    "application/oauth-authz-req+jwt": {
      source: "iana"
    },
    "application/oblivious-dns-message": {
      source: "iana"
    },
    "application/ocsp-request": {
      source: "iana"
    },
    "application/ocsp-response": {
      source: "iana"
    },
    "application/octet-stream": {
      source: "iana",
      compressible: false,
      extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
    },
    "application/oda": {
      source: "iana",
      extensions: ["oda"]
    },
    "application/odm+xml": {
      source: "iana",
      compressible: true
    },
    "application/odx": {
      source: "iana"
    },
    "application/oebps-package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["opf"]
    },
    "application/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogx"]
    },
    "application/omdoc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["omdoc"]
    },
    "application/onenote": {
      source: "apache",
      extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
    },
    "application/opc-nodeset+xml": {
      source: "iana",
      compressible: true
    },
    "application/oscore": {
      source: "iana"
    },
    "application/oxps": {
      source: "iana",
      extensions: ["oxps"]
    },
    "application/p21": {
      source: "iana"
    },
    "application/p21+zip": {
      source: "iana",
      compressible: false
    },
    "application/p2p-overlay+xml": {
      source: "iana",
      compressible: true,
      extensions: ["relo"]
    },
    "application/parityfec": {
      source: "iana"
    },
    "application/passport": {
      source: "iana"
    },
    "application/patch-ops-error+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xer"]
    },
    "application/pdf": {
      source: "iana",
      compressible: false,
      extensions: ["pdf"]
    },
    "application/pdx": {
      source: "iana"
    },
    "application/pem-certificate-chain": {
      source: "iana"
    },
    "application/pgp-encrypted": {
      source: "iana",
      compressible: false,
      extensions: ["pgp"]
    },
    "application/pgp-keys": {
      source: "iana",
      extensions: ["asc"]
    },
    "application/pgp-signature": {
      source: "iana",
      extensions: ["asc", "sig"]
    },
    "application/pics-rules": {
      source: "apache",
      extensions: ["prf"]
    },
    "application/pidf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pidf-diff+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/pkcs10": {
      source: "iana",
      extensions: ["p10"]
    },
    "application/pkcs12": {
      source: "iana"
    },
    "application/pkcs7-mime": {
      source: "iana",
      extensions: ["p7m", "p7c"]
    },
    "application/pkcs7-signature": {
      source: "iana",
      extensions: ["p7s"]
    },
    "application/pkcs8": {
      source: "iana",
      extensions: ["p8"]
    },
    "application/pkcs8-encrypted": {
      source: "iana"
    },
    "application/pkix-attr-cert": {
      source: "iana",
      extensions: ["ac"]
    },
    "application/pkix-cert": {
      source: "iana",
      extensions: ["cer"]
    },
    "application/pkix-crl": {
      source: "iana",
      extensions: ["crl"]
    },
    "application/pkix-pkipath": {
      source: "iana",
      extensions: ["pkipath"]
    },
    "application/pkixcmp": {
      source: "iana",
      extensions: ["pki"]
    },
    "application/pls+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pls"]
    },
    "application/poc-settings+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/postscript": {
      source: "iana",
      compressible: true,
      extensions: ["ai", "eps", "ps"]
    },
    "application/ppsp-tracker+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+json": {
      source: "iana",
      compressible: true
    },
    "application/problem+xml": {
      source: "iana",
      compressible: true
    },
    "application/provenance+xml": {
      source: "iana",
      compressible: true,
      extensions: ["provx"]
    },
    "application/prs.alvestrand.titrax-sheet": {
      source: "iana"
    },
    "application/prs.cww": {
      source: "iana",
      extensions: ["cww"]
    },
    "application/prs.cyn": {
      source: "iana",
      charset: "7-BIT"
    },
    "application/prs.hpub+zip": {
      source: "iana",
      compressible: false
    },
    "application/prs.nprend": {
      source: "iana"
    },
    "application/prs.plucker": {
      source: "iana"
    },
    "application/prs.rdf-xml-crypt": {
      source: "iana"
    },
    "application/prs.xsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/pskc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["pskcxml"]
    },
    "application/pvd+json": {
      source: "iana",
      compressible: true
    },
    "application/qsig": {
      source: "iana"
    },
    "application/raml+yaml": {
      compressible: true,
      extensions: ["raml"]
    },
    "application/raptorfec": {
      source: "iana"
    },
    "application/rdap+json": {
      source: "iana",
      compressible: true
    },
    "application/rdf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rdf", "owl"]
    },
    "application/reginfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rif"]
    },
    "application/relax-ng-compact-syntax": {
      source: "iana",
      extensions: ["rnc"]
    },
    "application/remote-printing": {
      source: "iana"
    },
    "application/reputon+json": {
      source: "iana",
      compressible: true
    },
    "application/resource-lists+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rl"]
    },
    "application/resource-lists-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rld"]
    },
    "application/rfc+xml": {
      source: "iana",
      compressible: true
    },
    "application/riscos": {
      source: "iana"
    },
    "application/rlmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/rls-services+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rs"]
    },
    "application/route-apd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rapd"]
    },
    "application/route-s-tsid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sls"]
    },
    "application/route-usd+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rusd"]
    },
    "application/rpki-ghostbusters": {
      source: "iana",
      extensions: ["gbr"]
    },
    "application/rpki-manifest": {
      source: "iana",
      extensions: ["mft"]
    },
    "application/rpki-publication": {
      source: "iana"
    },
    "application/rpki-roa": {
      source: "iana",
      extensions: ["roa"]
    },
    "application/rpki-updown": {
      source: "iana"
    },
    "application/rsd+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rsd"]
    },
    "application/rss+xml": {
      source: "apache",
      compressible: true,
      extensions: ["rss"]
    },
    "application/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "application/rtploopback": {
      source: "iana"
    },
    "application/rtx": {
      source: "iana"
    },
    "application/samlassertion+xml": {
      source: "iana",
      compressible: true
    },
    "application/samlmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/sarif+json": {
      source: "iana",
      compressible: true
    },
    "application/sarif-external-properties+json": {
      source: "iana",
      compressible: true
    },
    "application/sbe": {
      source: "iana"
    },
    "application/sbml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sbml"]
    },
    "application/scaip+xml": {
      source: "iana",
      compressible: true
    },
    "application/scim+json": {
      source: "iana",
      compressible: true
    },
    "application/scvp-cv-request": {
      source: "iana",
      extensions: ["scq"]
    },
    "application/scvp-cv-response": {
      source: "iana",
      extensions: ["scs"]
    },
    "application/scvp-vp-request": {
      source: "iana",
      extensions: ["spq"]
    },
    "application/scvp-vp-response": {
      source: "iana",
      extensions: ["spp"]
    },
    "application/sdp": {
      source: "iana",
      extensions: ["sdp"]
    },
    "application/secevent+jwt": {
      source: "iana"
    },
    "application/senml+cbor": {
      source: "iana"
    },
    "application/senml+json": {
      source: "iana",
      compressible: true
    },
    "application/senml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["senmlx"]
    },
    "application/senml-etch+cbor": {
      source: "iana"
    },
    "application/senml-etch+json": {
      source: "iana",
      compressible: true
    },
    "application/senml-exi": {
      source: "iana"
    },
    "application/sensml+cbor": {
      source: "iana"
    },
    "application/sensml+json": {
      source: "iana",
      compressible: true
    },
    "application/sensml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sensmlx"]
    },
    "application/sensml-exi": {
      source: "iana"
    },
    "application/sep+xml": {
      source: "iana",
      compressible: true
    },
    "application/sep-exi": {
      source: "iana"
    },
    "application/session-info": {
      source: "iana"
    },
    "application/set-payment": {
      source: "iana"
    },
    "application/set-payment-initiation": {
      source: "iana",
      extensions: ["setpay"]
    },
    "application/set-registration": {
      source: "iana"
    },
    "application/set-registration-initiation": {
      source: "iana",
      extensions: ["setreg"]
    },
    "application/sgml": {
      source: "iana"
    },
    "application/sgml-open-catalog": {
      source: "iana"
    },
    "application/shf+xml": {
      source: "iana",
      compressible: true,
      extensions: ["shf"]
    },
    "application/sieve": {
      source: "iana",
      extensions: ["siv", "sieve"]
    },
    "application/simple-filter+xml": {
      source: "iana",
      compressible: true
    },
    "application/simple-message-summary": {
      source: "iana"
    },
    "application/simplesymbolcontainer": {
      source: "iana"
    },
    "application/sipc": {
      source: "iana"
    },
    "application/slate": {
      source: "iana"
    },
    "application/smil": {
      source: "iana"
    },
    "application/smil+xml": {
      source: "iana",
      compressible: true,
      extensions: ["smi", "smil"]
    },
    "application/smpte336m": {
      source: "iana"
    },
    "application/soap+fastinfoset": {
      source: "iana"
    },
    "application/soap+xml": {
      source: "iana",
      compressible: true
    },
    "application/sparql-query": {
      source: "iana",
      extensions: ["rq"]
    },
    "application/sparql-results+xml": {
      source: "iana",
      compressible: true,
      extensions: ["srx"]
    },
    "application/spdx+json": {
      source: "iana",
      compressible: true
    },
    "application/spirits-event+xml": {
      source: "iana",
      compressible: true
    },
    "application/sql": {
      source: "iana"
    },
    "application/srgs": {
      source: "iana",
      extensions: ["gram"]
    },
    "application/srgs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["grxml"]
    },
    "application/sru+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sru"]
    },
    "application/ssdl+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ssdl"]
    },
    "application/ssml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ssml"]
    },
    "application/stix+json": {
      source: "iana",
      compressible: true
    },
    "application/swid+xml": {
      source: "iana",
      compressible: true,
      extensions: ["swidtag"]
    },
    "application/tamp-apex-update": {
      source: "iana"
    },
    "application/tamp-apex-update-confirm": {
      source: "iana"
    },
    "application/tamp-community-update": {
      source: "iana"
    },
    "application/tamp-community-update-confirm": {
      source: "iana"
    },
    "application/tamp-error": {
      source: "iana"
    },
    "application/tamp-sequence-adjust": {
      source: "iana"
    },
    "application/tamp-sequence-adjust-confirm": {
      source: "iana"
    },
    "application/tamp-status-query": {
      source: "iana"
    },
    "application/tamp-status-response": {
      source: "iana"
    },
    "application/tamp-update": {
      source: "iana"
    },
    "application/tamp-update-confirm": {
      source: "iana"
    },
    "application/tar": {
      compressible: true
    },
    "application/taxii+json": {
      source: "iana",
      compressible: true
    },
    "application/td+json": {
      source: "iana",
      compressible: true
    },
    "application/tei+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tei", "teicorpus"]
    },
    "application/tetra_isi": {
      source: "iana"
    },
    "application/thraud+xml": {
      source: "iana",
      compressible: true,
      extensions: ["tfi"]
    },
    "application/timestamp-query": {
      source: "iana"
    },
    "application/timestamp-reply": {
      source: "iana"
    },
    "application/timestamped-data": {
      source: "iana",
      extensions: ["tsd"]
    },
    "application/tlsrpt+gzip": {
      source: "iana"
    },
    "application/tlsrpt+json": {
      source: "iana",
      compressible: true
    },
    "application/tnauthlist": {
      source: "iana"
    },
    "application/token-introspection+jwt": {
      source: "iana"
    },
    "application/toml": {
      compressible: true,
      extensions: ["toml"]
    },
    "application/trickle-ice-sdpfrag": {
      source: "iana"
    },
    "application/trig": {
      source: "iana",
      extensions: ["trig"]
    },
    "application/ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ttml"]
    },
    "application/tve-trigger": {
      source: "iana"
    },
    "application/tzif": {
      source: "iana"
    },
    "application/tzif-leap": {
      source: "iana"
    },
    "application/ubjson": {
      compressible: false,
      extensions: ["ubj"]
    },
    "application/ulpfec": {
      source: "iana"
    },
    "application/urc-grpsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/urc-ressheet+xml": {
      source: "iana",
      compressible: true,
      extensions: ["rsheet"]
    },
    "application/urc-targetdesc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["td"]
    },
    "application/urc-uisocketdesc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vcard+json": {
      source: "iana",
      compressible: true
    },
    "application/vcard+xml": {
      source: "iana",
      compressible: true
    },
    "application/vemmi": {
      source: "iana"
    },
    "application/vividence.scriptfile": {
      source: "apache"
    },
    "application/vnd.1000minds.decision-model+xml": {
      source: "iana",
      compressible: true,
      extensions: ["1km"]
    },
    "application/vnd.3gpp-prose+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-prose-pc3ch+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp-v2x-local-service-information": {
      source: "iana"
    },
    "application/vnd.3gpp.5gnas": {
      source: "iana"
    },
    "application/vnd.3gpp.access-transfer-events+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.bsf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gmop+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.gtpc": {
      source: "iana"
    },
    "application/vnd.3gpp.interworking-data": {
      source: "iana"
    },
    "application/vnd.3gpp.lpp": {
      source: "iana"
    },
    "application/vnd.3gpp.mc-signalling-ear": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-payload": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-signalling": {
      source: "iana"
    },
    "application/vnd.3gpp.mcdata-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcdata-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-floor-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-signed+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-ue-init-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcptt-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-location-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-service-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-transmission-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-ue-config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mcvideo-user-profile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.mid-call+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ngap": {
      source: "iana"
    },
    "application/vnd.3gpp.pfcp": {
      source: "iana"
    },
    "application/vnd.3gpp.pic-bw-large": {
      source: "iana",
      extensions: ["plb"]
    },
    "application/vnd.3gpp.pic-bw-small": {
      source: "iana",
      extensions: ["psb"]
    },
    "application/vnd.3gpp.pic-bw-var": {
      source: "iana",
      extensions: ["pvb"]
    },
    "application/vnd.3gpp.s1ap": {
      source: "iana"
    },
    "application/vnd.3gpp.sms": {
      source: "iana"
    },
    "application/vnd.3gpp.sms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-ext+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.srvcc-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.state-and-event-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp.ussd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.bcmcsinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.3gpp2.sms": {
      source: "iana"
    },
    "application/vnd.3gpp2.tcap": {
      source: "iana",
      extensions: ["tcap"]
    },
    "application/vnd.3lightssoftware.imagescal": {
      source: "iana"
    },
    "application/vnd.3m.post-it-notes": {
      source: "iana",
      extensions: ["pwn"]
    },
    "application/vnd.accpac.simply.aso": {
      source: "iana",
      extensions: ["aso"]
    },
    "application/vnd.accpac.simply.imp": {
      source: "iana",
      extensions: ["imp"]
    },
    "application/vnd.acucobol": {
      source: "iana",
      extensions: ["acu"]
    },
    "application/vnd.acucorp": {
      source: "iana",
      extensions: ["atc", "acutc"]
    },
    "application/vnd.adobe.air-application-installer-package+zip": {
      source: "apache",
      compressible: false,
      extensions: ["air"]
    },
    "application/vnd.adobe.flash.movie": {
      source: "iana"
    },
    "application/vnd.adobe.formscentral.fcdt": {
      source: "iana",
      extensions: ["fcdt"]
    },
    "application/vnd.adobe.fxp": {
      source: "iana",
      extensions: ["fxp", "fxpl"]
    },
    "application/vnd.adobe.partial-upload": {
      source: "iana"
    },
    "application/vnd.adobe.xdp+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdp"]
    },
    "application/vnd.adobe.xfdf": {
      source: "iana",
      extensions: ["xfdf"]
    },
    "application/vnd.aether.imp": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata": {
      source: "iana"
    },
    "application/vnd.afpc.afplinedata-pagedef": {
      source: "iana"
    },
    "application/vnd.afpc.cmoca-cmresource": {
      source: "iana"
    },
    "application/vnd.afpc.foca-charset": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codedfont": {
      source: "iana"
    },
    "application/vnd.afpc.foca-codepage": {
      source: "iana"
    },
    "application/vnd.afpc.modca": {
      source: "iana"
    },
    "application/vnd.afpc.modca-cmtable": {
      source: "iana"
    },
    "application/vnd.afpc.modca-formdef": {
      source: "iana"
    },
    "application/vnd.afpc.modca-mediummap": {
      source: "iana"
    },
    "application/vnd.afpc.modca-objectcontainer": {
      source: "iana"
    },
    "application/vnd.afpc.modca-overlay": {
      source: "iana"
    },
    "application/vnd.afpc.modca-pagesegment": {
      source: "iana"
    },
    "application/vnd.age": {
      source: "iana",
      extensions: ["age"]
    },
    "application/vnd.ah-barcode": {
      source: "iana"
    },
    "application/vnd.ahead.space": {
      source: "iana",
      extensions: ["ahead"]
    },
    "application/vnd.airzip.filesecure.azf": {
      source: "iana",
      extensions: ["azf"]
    },
    "application/vnd.airzip.filesecure.azs": {
      source: "iana",
      extensions: ["azs"]
    },
    "application/vnd.amadeus+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.amazon.ebook": {
      source: "apache",
      extensions: ["azw"]
    },
    "application/vnd.amazon.mobi8-ebook": {
      source: "iana"
    },
    "application/vnd.americandynamics.acc": {
      source: "iana",
      extensions: ["acc"]
    },
    "application/vnd.amiga.ami": {
      source: "iana",
      extensions: ["ami"]
    },
    "application/vnd.amundsen.maze+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.android.ota": {
      source: "iana"
    },
    "application/vnd.android.package-archive": {
      source: "apache",
      compressible: false,
      extensions: ["apk"]
    },
    "application/vnd.anki": {
      source: "iana"
    },
    "application/vnd.anser-web-certificate-issue-initiation": {
      source: "iana",
      extensions: ["cii"]
    },
    "application/vnd.anser-web-funds-transfer-initiation": {
      source: "apache",
      extensions: ["fti"]
    },
    "application/vnd.antix.game-component": {
      source: "iana",
      extensions: ["atx"]
    },
    "application/vnd.apache.arrow.file": {
      source: "iana"
    },
    "application/vnd.apache.arrow.stream": {
      source: "iana"
    },
    "application/vnd.apache.thrift.binary": {
      source: "iana"
    },
    "application/vnd.apache.thrift.compact": {
      source: "iana"
    },
    "application/vnd.apache.thrift.json": {
      source: "iana"
    },
    "application/vnd.api+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.aplextor.warrp+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apothekende.reservation+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.apple.installer+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mpkg"]
    },
    "application/vnd.apple.keynote": {
      source: "iana",
      extensions: ["key"]
    },
    "application/vnd.apple.mpegurl": {
      source: "iana",
      extensions: ["m3u8"]
    },
    "application/vnd.apple.numbers": {
      source: "iana",
      extensions: ["numbers"]
    },
    "application/vnd.apple.pages": {
      source: "iana",
      extensions: ["pages"]
    },
    "application/vnd.apple.pkpass": {
      compressible: false,
      extensions: ["pkpass"]
    },
    "application/vnd.arastra.swi": {
      source: "iana"
    },
    "application/vnd.aristanetworks.swi": {
      source: "iana",
      extensions: ["swi"]
    },
    "application/vnd.artisan+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.artsquare": {
      source: "iana"
    },
    "application/vnd.astraea-software.iota": {
      source: "iana",
      extensions: ["iota"]
    },
    "application/vnd.audiograph": {
      source: "iana",
      extensions: ["aep"]
    },
    "application/vnd.autopackage": {
      source: "iana"
    },
    "application/vnd.avalon+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.avistar+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.balsamiq.bmml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["bmml"]
    },
    "application/vnd.balsamiq.bmpr": {
      source: "iana"
    },
    "application/vnd.banana-accounting": {
      source: "iana"
    },
    "application/vnd.bbf.usp.error": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg": {
      source: "iana"
    },
    "application/vnd.bbf.usp.msg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bekitzur-stech+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.bint.med-content": {
      source: "iana"
    },
    "application/vnd.biopax.rdf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.blink-idb-value-wrapper": {
      source: "iana"
    },
    "application/vnd.blueice.multipass": {
      source: "iana",
      extensions: ["mpm"]
    },
    "application/vnd.bluetooth.ep.oob": {
      source: "iana"
    },
    "application/vnd.bluetooth.le.oob": {
      source: "iana"
    },
    "application/vnd.bmi": {
      source: "iana",
      extensions: ["bmi"]
    },
    "application/vnd.bpf": {
      source: "iana"
    },
    "application/vnd.bpf3": {
      source: "iana"
    },
    "application/vnd.businessobjects": {
      source: "iana",
      extensions: ["rep"]
    },
    "application/vnd.byu.uapi+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cab-jscript": {
      source: "iana"
    },
    "application/vnd.canon-cpdl": {
      source: "iana"
    },
    "application/vnd.canon-lips": {
      source: "iana"
    },
    "application/vnd.capasystems-pg+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cendio.thinlinc.clientconf": {
      source: "iana"
    },
    "application/vnd.century-systems.tcp_stream": {
      source: "iana"
    },
    "application/vnd.chemdraw+xml": {
      source: "iana",
      compressible: true,
      extensions: ["cdxml"]
    },
    "application/vnd.chess-pgn": {
      source: "iana"
    },
    "application/vnd.chipnuts.karaoke-mmd": {
      source: "iana",
      extensions: ["mmd"]
    },
    "application/vnd.ciedi": {
      source: "iana"
    },
    "application/vnd.cinderella": {
      source: "iana",
      extensions: ["cdy"]
    },
    "application/vnd.cirpack.isdn-ext": {
      source: "iana"
    },
    "application/vnd.citationstyles.style+xml": {
      source: "iana",
      compressible: true,
      extensions: ["csl"]
    },
    "application/vnd.claymore": {
      source: "iana",
      extensions: ["cla"]
    },
    "application/vnd.cloanto.rp9": {
      source: "iana",
      extensions: ["rp9"]
    },
    "application/vnd.clonk.c4group": {
      source: "iana",
      extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
    },
    "application/vnd.cluetrust.cartomobile-config": {
      source: "iana",
      extensions: ["c11amc"]
    },
    "application/vnd.cluetrust.cartomobile-config-pkg": {
      source: "iana",
      extensions: ["c11amz"]
    },
    "application/vnd.coffeescript": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.document-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.presentation-template": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet": {
      source: "iana"
    },
    "application/vnd.collabio.xodocuments.spreadsheet-template": {
      source: "iana"
    },
    "application/vnd.collection+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.doc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.collection.next+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.comicbook+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.comicbook-rar": {
      source: "iana"
    },
    "application/vnd.commerce-battelle": {
      source: "iana"
    },
    "application/vnd.commonspace": {
      source: "iana",
      extensions: ["csp"]
    },
    "application/vnd.contact.cmsg": {
      source: "iana",
      extensions: ["cdbcmsg"]
    },
    "application/vnd.coreos.ignition+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cosmocaller": {
      source: "iana",
      extensions: ["cmc"]
    },
    "application/vnd.crick.clicker": {
      source: "iana",
      extensions: ["clkx"]
    },
    "application/vnd.crick.clicker.keyboard": {
      source: "iana",
      extensions: ["clkk"]
    },
    "application/vnd.crick.clicker.palette": {
      source: "iana",
      extensions: ["clkp"]
    },
    "application/vnd.crick.clicker.template": {
      source: "iana",
      extensions: ["clkt"]
    },
    "application/vnd.crick.clicker.wordbank": {
      source: "iana",
      extensions: ["clkw"]
    },
    "application/vnd.criticaltools.wbs+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wbs"]
    },
    "application/vnd.cryptii.pipe+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.crypto-shade-file": {
      source: "iana"
    },
    "application/vnd.cryptomator.encrypted": {
      source: "iana"
    },
    "application/vnd.cryptomator.vault": {
      source: "iana"
    },
    "application/vnd.ctc-posml": {
      source: "iana",
      extensions: ["pml"]
    },
    "application/vnd.ctct.ws+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cups-pdf": {
      source: "iana"
    },
    "application/vnd.cups-postscript": {
      source: "iana"
    },
    "application/vnd.cups-ppd": {
      source: "iana",
      extensions: ["ppd"]
    },
    "application/vnd.cups-raster": {
      source: "iana"
    },
    "application/vnd.cups-raw": {
      source: "iana"
    },
    "application/vnd.curl": {
      source: "iana"
    },
    "application/vnd.curl.car": {
      source: "apache",
      extensions: ["car"]
    },
    "application/vnd.curl.pcurl": {
      source: "apache",
      extensions: ["pcurl"]
    },
    "application/vnd.cyan.dean.root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cybank": {
      source: "iana"
    },
    "application/vnd.cyclonedx+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.cyclonedx+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.d2l.coursepackage1p0+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.d3m-dataset": {
      source: "iana"
    },
    "application/vnd.d3m-problem": {
      source: "iana"
    },
    "application/vnd.dart": {
      source: "iana",
      compressible: true,
      extensions: ["dart"]
    },
    "application/vnd.data-vision.rdz": {
      source: "iana",
      extensions: ["rdz"]
    },
    "application/vnd.datapackage+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dataresource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dbf": {
      source: "iana",
      extensions: ["dbf"]
    },
    "application/vnd.debian.binary-package": {
      source: "iana"
    },
    "application/vnd.dece.data": {
      source: "iana",
      extensions: ["uvf", "uvvf", "uvd", "uvvd"]
    },
    "application/vnd.dece.ttml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uvt", "uvvt"]
    },
    "application/vnd.dece.unspecified": {
      source: "iana",
      extensions: ["uvx", "uvvx"]
    },
    "application/vnd.dece.zip": {
      source: "iana",
      extensions: ["uvz", "uvvz"]
    },
    "application/vnd.denovo.fcselayout-link": {
      source: "iana",
      extensions: ["fe_launch"]
    },
    "application/vnd.desmume.movie": {
      source: "iana"
    },
    "application/vnd.dir-bi.plate-dl-nosuffix": {
      source: "iana"
    },
    "application/vnd.dm.delegation+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dna": {
      source: "iana",
      extensions: ["dna"]
    },
    "application/vnd.document+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dolby.mlp": {
      source: "apache",
      extensions: ["mlp"]
    },
    "application/vnd.dolby.mobile.1": {
      source: "iana"
    },
    "application/vnd.dolby.mobile.2": {
      source: "iana"
    },
    "application/vnd.doremir.scorecloud-binary-document": {
      source: "iana"
    },
    "application/vnd.dpgraph": {
      source: "iana",
      extensions: ["dpg"]
    },
    "application/vnd.dreamfactory": {
      source: "iana",
      extensions: ["dfac"]
    },
    "application/vnd.drive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ds-keypoint": {
      source: "apache",
      extensions: ["kpxx"]
    },
    "application/vnd.dtg.local": {
      source: "iana"
    },
    "application/vnd.dtg.local.flash": {
      source: "iana"
    },
    "application/vnd.dtg.local.html": {
      source: "iana"
    },
    "application/vnd.dvb.ait": {
      source: "iana",
      extensions: ["ait"]
    },
    "application/vnd.dvb.dvbisl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.dvbj": {
      source: "iana"
    },
    "application/vnd.dvb.esgcontainer": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcdftnotifaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgaccess2": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcesgpdd": {
      source: "iana"
    },
    "application/vnd.dvb.ipdcroaming": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-base": {
      source: "iana"
    },
    "application/vnd.dvb.iptv.alfec-enhancement": {
      source: "iana"
    },
    "application/vnd.dvb.notif-aggregate-root+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-container+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-generic+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-msglist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-ia-registration-response+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.notif-init+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.dvb.pfr": {
      source: "iana"
    },
    "application/vnd.dvb.service": {
      source: "iana",
      extensions: ["svc"]
    },
    "application/vnd.dxr": {
      source: "iana"
    },
    "application/vnd.dynageo": {
      source: "iana",
      extensions: ["geo"]
    },
    "application/vnd.dzr": {
      source: "iana"
    },
    "application/vnd.easykaraoke.cdgdownload": {
      source: "iana"
    },
    "application/vnd.ecdis-update": {
      source: "iana"
    },
    "application/vnd.ecip.rlp": {
      source: "iana"
    },
    "application/vnd.eclipse.ditto+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ecowin.chart": {
      source: "iana",
      extensions: ["mag"]
    },
    "application/vnd.ecowin.filerequest": {
      source: "iana"
    },
    "application/vnd.ecowin.fileupdate": {
      source: "iana"
    },
    "application/vnd.ecowin.series": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesrequest": {
      source: "iana"
    },
    "application/vnd.ecowin.seriesupdate": {
      source: "iana"
    },
    "application/vnd.efi.img": {
      source: "iana"
    },
    "application/vnd.efi.iso": {
      source: "iana"
    },
    "application/vnd.emclient.accessrequest+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.enliven": {
      source: "iana",
      extensions: ["nml"]
    },
    "application/vnd.enphase.envoy": {
      source: "iana"
    },
    "application/vnd.eprints.data+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.epson.esf": {
      source: "iana",
      extensions: ["esf"]
    },
    "application/vnd.epson.msf": {
      source: "iana",
      extensions: ["msf"]
    },
    "application/vnd.epson.quickanime": {
      source: "iana",
      extensions: ["qam"]
    },
    "application/vnd.epson.salt": {
      source: "iana",
      extensions: ["slt"]
    },
    "application/vnd.epson.ssf": {
      source: "iana",
      extensions: ["ssf"]
    },
    "application/vnd.ericsson.quickcall": {
      source: "iana"
    },
    "application/vnd.espass-espass+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.eszigno3+xml": {
      source: "iana",
      compressible: true,
      extensions: ["es3", "et3"]
    },
    "application/vnd.etsi.aoc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.asic-e+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.asic-s+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.etsi.cug+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvcommand+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-bc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-cod+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsad-npvr+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvservice+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvsync+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.iptvueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mcid+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.mheg5": {
      source: "iana"
    },
    "application/vnd.etsi.overload-control-policy-dataset+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.pstn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.sci+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.simservs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.timestamp-token": {
      source: "iana"
    },
    "application/vnd.etsi.tsl+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.etsi.tsl.der": {
      source: "iana"
    },
    "application/vnd.eu.kasparian.car+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.eudora.data": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.profile": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.settings": {
      source: "iana"
    },
    "application/vnd.evolv.ecig.theme": {
      source: "iana"
    },
    "application/vnd.exstream-empower+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.exstream-package": {
      source: "iana"
    },
    "application/vnd.ezpix-album": {
      source: "iana",
      extensions: ["ez2"]
    },
    "application/vnd.ezpix-package": {
      source: "iana",
      extensions: ["ez3"]
    },
    "application/vnd.f-secure.mobile": {
      source: "iana"
    },
    "application/vnd.familysearch.gedcom+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.fastcopy-disk-image": {
      source: "iana"
    },
    "application/vnd.fdf": {
      source: "iana",
      extensions: ["fdf"]
    },
    "application/vnd.fdsn.mseed": {
      source: "iana",
      extensions: ["mseed"]
    },
    "application/vnd.fdsn.seed": {
      source: "iana",
      extensions: ["seed", "dataless"]
    },
    "application/vnd.ffsns": {
      source: "iana"
    },
    "application/vnd.ficlab.flb+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.filmit.zfc": {
      source: "iana"
    },
    "application/vnd.fints": {
      source: "iana"
    },
    "application/vnd.firemonkeys.cloudcell": {
      source: "iana"
    },
    "application/vnd.flographit": {
      source: "iana",
      extensions: ["gph"]
    },
    "application/vnd.fluxtime.clip": {
      source: "iana",
      extensions: ["ftc"]
    },
    "application/vnd.font-fontforge-sfd": {
      source: "iana"
    },
    "application/vnd.framemaker": {
      source: "iana",
      extensions: ["fm", "frame", "maker", "book"]
    },
    "application/vnd.frogans.fnc": {
      source: "iana",
      extensions: ["fnc"]
    },
    "application/vnd.frogans.ltf": {
      source: "iana",
      extensions: ["ltf"]
    },
    "application/vnd.fsc.weblaunch": {
      source: "iana",
      extensions: ["fsc"]
    },
    "application/vnd.fujifilm.fb.docuworks": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.binder": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujifilm.fb.jfi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fujitsu.oasys": {
      source: "iana",
      extensions: ["oas"]
    },
    "application/vnd.fujitsu.oasys2": {
      source: "iana",
      extensions: ["oa2"]
    },
    "application/vnd.fujitsu.oasys3": {
      source: "iana",
      extensions: ["oa3"]
    },
    "application/vnd.fujitsu.oasysgp": {
      source: "iana",
      extensions: ["fg5"]
    },
    "application/vnd.fujitsu.oasysprs": {
      source: "iana",
      extensions: ["bh2"]
    },
    "application/vnd.fujixerox.art-ex": {
      source: "iana"
    },
    "application/vnd.fujixerox.art4": {
      source: "iana"
    },
    "application/vnd.fujixerox.ddd": {
      source: "iana",
      extensions: ["ddd"]
    },
    "application/vnd.fujixerox.docuworks": {
      source: "iana",
      extensions: ["xdw"]
    },
    "application/vnd.fujixerox.docuworks.binder": {
      source: "iana",
      extensions: ["xbd"]
    },
    "application/vnd.fujixerox.docuworks.container": {
      source: "iana"
    },
    "application/vnd.fujixerox.hbpl": {
      source: "iana"
    },
    "application/vnd.fut-misnet": {
      source: "iana"
    },
    "application/vnd.futoin+cbor": {
      source: "iana"
    },
    "application/vnd.futoin+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.fuzzysheet": {
      source: "iana",
      extensions: ["fzs"]
    },
    "application/vnd.genomatix.tuxedo": {
      source: "iana",
      extensions: ["txd"]
    },
    "application/vnd.gentics.grd+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geo+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geocube+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.geogebra.file": {
      source: "iana",
      extensions: ["ggb"]
    },
    "application/vnd.geogebra.slides": {
      source: "iana"
    },
    "application/vnd.geogebra.tool": {
      source: "iana",
      extensions: ["ggt"]
    },
    "application/vnd.geometry-explorer": {
      source: "iana",
      extensions: ["gex", "gre"]
    },
    "application/vnd.geonext": {
      source: "iana",
      extensions: ["gxt"]
    },
    "application/vnd.geoplan": {
      source: "iana",
      extensions: ["g2w"]
    },
    "application/vnd.geospace": {
      source: "iana",
      extensions: ["g3w"]
    },
    "application/vnd.gerber": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt": {
      source: "iana"
    },
    "application/vnd.globalplatform.card-content-mgt-response": {
      source: "iana"
    },
    "application/vnd.gmx": {
      source: "iana",
      extensions: ["gmx"]
    },
    "application/vnd.google-apps.document": {
      compressible: false,
      extensions: ["gdoc"]
    },
    "application/vnd.google-apps.presentation": {
      compressible: false,
      extensions: ["gslides"]
    },
    "application/vnd.google-apps.spreadsheet": {
      compressible: false,
      extensions: ["gsheet"]
    },
    "application/vnd.google-earth.kml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["kml"]
    },
    "application/vnd.google-earth.kmz": {
      source: "iana",
      compressible: false,
      extensions: ["kmz"]
    },
    "application/vnd.gov.sk.e-form+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.gov.sk.e-form+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.gov.sk.xmldatacontainer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.grafeq": {
      source: "iana",
      extensions: ["gqf", "gqs"]
    },
    "application/vnd.gridmp": {
      source: "iana"
    },
    "application/vnd.groove-account": {
      source: "iana",
      extensions: ["gac"]
    },
    "application/vnd.groove-help": {
      source: "iana",
      extensions: ["ghf"]
    },
    "application/vnd.groove-identity-message": {
      source: "iana",
      extensions: ["gim"]
    },
    "application/vnd.groove-injector": {
      source: "iana",
      extensions: ["grv"]
    },
    "application/vnd.groove-tool-message": {
      source: "iana",
      extensions: ["gtm"]
    },
    "application/vnd.groove-tool-template": {
      source: "iana",
      extensions: ["tpl"]
    },
    "application/vnd.groove-vcard": {
      source: "iana",
      extensions: ["vcg"]
    },
    "application/vnd.hal+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hal+xml": {
      source: "iana",
      compressible: true,
      extensions: ["hal"]
    },
    "application/vnd.handheld-entertainment+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zmm"]
    },
    "application/vnd.hbci": {
      source: "iana",
      extensions: ["hbci"]
    },
    "application/vnd.hc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hcl-bireports": {
      source: "iana"
    },
    "application/vnd.hdt": {
      source: "iana"
    },
    "application/vnd.heroku+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hhe.lesson-player": {
      source: "iana",
      extensions: ["les"]
    },
    "application/vnd.hl7cda+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hl7v2+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.hp-hpgl": {
      source: "iana",
      extensions: ["hpgl"]
    },
    "application/vnd.hp-hpid": {
      source: "iana",
      extensions: ["hpid"]
    },
    "application/vnd.hp-hps": {
      source: "iana",
      extensions: ["hps"]
    },
    "application/vnd.hp-jlyt": {
      source: "iana",
      extensions: ["jlt"]
    },
    "application/vnd.hp-pcl": {
      source: "iana",
      extensions: ["pcl"]
    },
    "application/vnd.hp-pclxl": {
      source: "iana",
      extensions: ["pclxl"]
    },
    "application/vnd.httphone": {
      source: "iana"
    },
    "application/vnd.hydrostatix.sof-data": {
      source: "iana",
      extensions: ["sfd-hdstx"]
    },
    "application/vnd.hyper+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyper-item+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hyperdrive+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.hzn-3d-crossword": {
      source: "iana"
    },
    "application/vnd.ibm.afplinedata": {
      source: "iana"
    },
    "application/vnd.ibm.electronic-media": {
      source: "iana"
    },
    "application/vnd.ibm.minipay": {
      source: "iana",
      extensions: ["mpy"]
    },
    "application/vnd.ibm.modcap": {
      source: "iana",
      extensions: ["afp", "listafp", "list3820"]
    },
    "application/vnd.ibm.rights-management": {
      source: "iana",
      extensions: ["irm"]
    },
    "application/vnd.ibm.secure-container": {
      source: "iana",
      extensions: ["sc"]
    },
    "application/vnd.iccprofile": {
      source: "iana",
      extensions: ["icc", "icm"]
    },
    "application/vnd.ieee.1905": {
      source: "iana"
    },
    "application/vnd.igloader": {
      source: "iana",
      extensions: ["igl"]
    },
    "application/vnd.imagemeter.folder+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.imagemeter.image+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.immervision-ivp": {
      source: "iana",
      extensions: ["ivp"]
    },
    "application/vnd.immervision-ivu": {
      source: "iana",
      extensions: ["ivu"]
    },
    "application/vnd.ims.imsccv1p1": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p2": {
      source: "iana"
    },
    "application/vnd.ims.imsccv1p3": {
      source: "iana"
    },
    "application/vnd.ims.lis.v2.result+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolproxy.id+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ims.lti.v2.toolsettings.simple+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informedcontrol.rms+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.informix-visionary": {
      source: "iana"
    },
    "application/vnd.infotech.project": {
      source: "iana"
    },
    "application/vnd.infotech.project+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.innopath.wamp.notification": {
      source: "iana"
    },
    "application/vnd.insors.igm": {
      source: "iana",
      extensions: ["igm"]
    },
    "application/vnd.intercon.formnet": {
      source: "iana",
      extensions: ["xpw", "xpx"]
    },
    "application/vnd.intergeo": {
      source: "iana",
      extensions: ["i2g"]
    },
    "application/vnd.intertrust.digibox": {
      source: "iana"
    },
    "application/vnd.intertrust.nncp": {
      source: "iana"
    },
    "application/vnd.intu.qbo": {
      source: "iana",
      extensions: ["qbo"]
    },
    "application/vnd.intu.qfx": {
      source: "iana",
      extensions: ["qfx"]
    },
    "application/vnd.iptc.g2.catalogitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.conceptitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.knowledgeitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.newsmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.packageitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.iptc.g2.planningitem+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ipunplugged.rcprofile": {
      source: "iana",
      extensions: ["rcprofile"]
    },
    "application/vnd.irepository.package+xml": {
      source: "iana",
      compressible: true,
      extensions: ["irp"]
    },
    "application/vnd.is-xpr": {
      source: "iana",
      extensions: ["xpr"]
    },
    "application/vnd.isac.fcs": {
      source: "iana",
      extensions: ["fcs"]
    },
    "application/vnd.iso11783-10+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.jam": {
      source: "iana",
      extensions: ["jam"]
    },
    "application/vnd.japannet-directory-service": {
      source: "iana"
    },
    "application/vnd.japannet-jpnstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-payment-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-registration": {
      source: "iana"
    },
    "application/vnd.japannet-registration-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-setstore-wakeup": {
      source: "iana"
    },
    "application/vnd.japannet-verification": {
      source: "iana"
    },
    "application/vnd.japannet-verification-wakeup": {
      source: "iana"
    },
    "application/vnd.jcp.javame.midlet-rms": {
      source: "iana",
      extensions: ["rms"]
    },
    "application/vnd.jisp": {
      source: "iana",
      extensions: ["jisp"]
    },
    "application/vnd.joost.joda-archive": {
      source: "iana",
      extensions: ["joda"]
    },
    "application/vnd.jsk.isdn-ngn": {
      source: "iana"
    },
    "application/vnd.kahootz": {
      source: "iana",
      extensions: ["ktz", "ktr"]
    },
    "application/vnd.kde.karbon": {
      source: "iana",
      extensions: ["karbon"]
    },
    "application/vnd.kde.kchart": {
      source: "iana",
      extensions: ["chrt"]
    },
    "application/vnd.kde.kformula": {
      source: "iana",
      extensions: ["kfo"]
    },
    "application/vnd.kde.kivio": {
      source: "iana",
      extensions: ["flw"]
    },
    "application/vnd.kde.kontour": {
      source: "iana",
      extensions: ["kon"]
    },
    "application/vnd.kde.kpresenter": {
      source: "iana",
      extensions: ["kpr", "kpt"]
    },
    "application/vnd.kde.kspread": {
      source: "iana",
      extensions: ["ksp"]
    },
    "application/vnd.kde.kword": {
      source: "iana",
      extensions: ["kwd", "kwt"]
    },
    "application/vnd.kenameaapp": {
      source: "iana",
      extensions: ["htke"]
    },
    "application/vnd.kidspiration": {
      source: "iana",
      extensions: ["kia"]
    },
    "application/vnd.kinar": {
      source: "iana",
      extensions: ["kne", "knp"]
    },
    "application/vnd.koan": {
      source: "iana",
      extensions: ["skp", "skd", "skt", "skm"]
    },
    "application/vnd.kodak-descriptor": {
      source: "iana",
      extensions: ["sse"]
    },
    "application/vnd.las": {
      source: "iana"
    },
    "application/vnd.las.las+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.las.las+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lasxml"]
    },
    "application/vnd.laszip": {
      source: "iana"
    },
    "application/vnd.leap+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.liberty-request+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.llamagraphics.life-balance.desktop": {
      source: "iana",
      extensions: ["lbd"]
    },
    "application/vnd.llamagraphics.life-balance.exchange+xml": {
      source: "iana",
      compressible: true,
      extensions: ["lbe"]
    },
    "application/vnd.logipipe.circuit+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.loom": {
      source: "iana"
    },
    "application/vnd.lotus-1-2-3": {
      source: "iana",
      extensions: ["123"]
    },
    "application/vnd.lotus-approach": {
      source: "iana",
      extensions: ["apr"]
    },
    "application/vnd.lotus-freelance": {
      source: "iana",
      extensions: ["pre"]
    },
    "application/vnd.lotus-notes": {
      source: "iana",
      extensions: ["nsf"]
    },
    "application/vnd.lotus-organizer": {
      source: "iana",
      extensions: ["org"]
    },
    "application/vnd.lotus-screencam": {
      source: "iana",
      extensions: ["scm"]
    },
    "application/vnd.lotus-wordpro": {
      source: "iana",
      extensions: ["lwp"]
    },
    "application/vnd.macports.portpkg": {
      source: "iana",
      extensions: ["portpkg"]
    },
    "application/vnd.mapbox-vector-tile": {
      source: "iana",
      extensions: ["mvt"]
    },
    "application/vnd.marlin.drm.actiontoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.conftoken+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.license+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.marlin.drm.mdcf": {
      source: "iana"
    },
    "application/vnd.mason+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.maxar.archive.3tz+zip": {
      source: "iana",
      compressible: false
    },
    "application/vnd.maxmind.maxmind-db": {
      source: "iana"
    },
    "application/vnd.mcd": {
      source: "iana",
      extensions: ["mcd"]
    },
    "application/vnd.medcalcdata": {
      source: "iana",
      extensions: ["mc1"]
    },
    "application/vnd.mediastation.cdkey": {
      source: "iana",
      extensions: ["cdkey"]
    },
    "application/vnd.meridian-slingshot": {
      source: "iana"
    },
    "application/vnd.mfer": {
      source: "iana",
      extensions: ["mwf"]
    },
    "application/vnd.mfmp": {
      source: "iana",
      extensions: ["mfm"]
    },
    "application/vnd.micro+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.micrografx.flo": {
      source: "iana",
      extensions: ["flo"]
    },
    "application/vnd.micrografx.igx": {
      source: "iana",
      extensions: ["igx"]
    },
    "application/vnd.microsoft.portable-executable": {
      source: "iana"
    },
    "application/vnd.microsoft.windows.thumbnail-cache": {
      source: "iana"
    },
    "application/vnd.miele+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.mif": {
      source: "iana",
      extensions: ["mif"]
    },
    "application/vnd.minisoft-hp3000-save": {
      source: "iana"
    },
    "application/vnd.mitsubishi.misty-guard.trustweb": {
      source: "iana"
    },
    "application/vnd.mobius.daf": {
      source: "iana",
      extensions: ["daf"]
    },
    "application/vnd.mobius.dis": {
      source: "iana",
      extensions: ["dis"]
    },
    "application/vnd.mobius.mbk": {
      source: "iana",
      extensions: ["mbk"]
    },
    "application/vnd.mobius.mqy": {
      source: "iana",
      extensions: ["mqy"]
    },
    "application/vnd.mobius.msl": {
      source: "iana",
      extensions: ["msl"]
    },
    "application/vnd.mobius.plc": {
      source: "iana",
      extensions: ["plc"]
    },
    "application/vnd.mobius.txf": {
      source: "iana",
      extensions: ["txf"]
    },
    "application/vnd.mophun.application": {
      source: "iana",
      extensions: ["mpn"]
    },
    "application/vnd.mophun.certificate": {
      source: "iana",
      extensions: ["mpc"]
    },
    "application/vnd.motorola.flexsuite": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.adsi": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.fis": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.gotap": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.kmr": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.ttc": {
      source: "iana"
    },
    "application/vnd.motorola.flexsuite.wem": {
      source: "iana"
    },
    "application/vnd.motorola.iprm": {
      source: "iana"
    },
    "application/vnd.mozilla.xul+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xul"]
    },
    "application/vnd.ms-3mfdocument": {
      source: "iana"
    },
    "application/vnd.ms-artgalry": {
      source: "iana",
      extensions: ["cil"]
    },
    "application/vnd.ms-asf": {
      source: "iana"
    },
    "application/vnd.ms-cab-compressed": {
      source: "iana",
      extensions: ["cab"]
    },
    "application/vnd.ms-color.iccprofile": {
      source: "apache"
    },
    "application/vnd.ms-excel": {
      source: "iana",
      compressible: false,
      extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
    },
    "application/vnd.ms-excel.addin.macroenabled.12": {
      source: "iana",
      extensions: ["xlam"]
    },
    "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
      source: "iana",
      extensions: ["xlsb"]
    },
    "application/vnd.ms-excel.sheet.macroenabled.12": {
      source: "iana",
      extensions: ["xlsm"]
    },
    "application/vnd.ms-excel.template.macroenabled.12": {
      source: "iana",
      extensions: ["xltm"]
    },
    "application/vnd.ms-fontobject": {
      source: "iana",
      compressible: true,
      extensions: ["eot"]
    },
    "application/vnd.ms-htmlhelp": {
      source: "iana",
      extensions: ["chm"]
    },
    "application/vnd.ms-ims": {
      source: "iana",
      extensions: ["ims"]
    },
    "application/vnd.ms-lrm": {
      source: "iana",
      extensions: ["lrm"]
    },
    "application/vnd.ms-office.activex+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-officetheme": {
      source: "iana",
      extensions: ["thmx"]
    },
    "application/vnd.ms-opentype": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-outlook": {
      compressible: false,
      extensions: ["msg"]
    },
    "application/vnd.ms-package.obfuscated-opentype": {
      source: "apache"
    },
    "application/vnd.ms-pki.seccat": {
      source: "apache",
      extensions: ["cat"]
    },
    "application/vnd.ms-pki.stl": {
      source: "apache",
      extensions: ["stl"]
    },
    "application/vnd.ms-playready.initiator+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-powerpoint": {
      source: "iana",
      compressible: false,
      extensions: ["ppt", "pps", "pot"]
    },
    "application/vnd.ms-powerpoint.addin.macroenabled.12": {
      source: "iana",
      extensions: ["ppam"]
    },
    "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
      source: "iana",
      extensions: ["pptm"]
    },
    "application/vnd.ms-powerpoint.slide.macroenabled.12": {
      source: "iana",
      extensions: ["sldm"]
    },
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
      source: "iana",
      extensions: ["ppsm"]
    },
    "application/vnd.ms-powerpoint.template.macroenabled.12": {
      source: "iana",
      extensions: ["potm"]
    },
    "application/vnd.ms-printdevicecapabilities+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-printing.printticket+xml": {
      source: "apache",
      compressible: true
    },
    "application/vnd.ms-printschematicket+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ms-project": {
      source: "iana",
      extensions: ["mpp", "mpt"]
    },
    "application/vnd.ms-tnef": {
      source: "iana"
    },
    "application/vnd.ms-windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.nwprinting.oob": {
      source: "iana"
    },
    "application/vnd.ms-windows.printerpairing": {
      source: "iana"
    },
    "application/vnd.ms-windows.wsd.oob": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.lic-resp": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-chlg-req": {
      source: "iana"
    },
    "application/vnd.ms-wmdrm.meter-resp": {
      source: "iana"
    },
    "application/vnd.ms-word.document.macroenabled.12": {
      source: "iana",
      extensions: ["docm"]
    },
    "application/vnd.ms-word.template.macroenabled.12": {
      source: "iana",
      extensions: ["dotm"]
    },
    "application/vnd.ms-works": {
      source: "iana",
      extensions: ["wps", "wks", "wcm", "wdb"]
    },
    "application/vnd.ms-wpl": {
      source: "iana",
      extensions: ["wpl"]
    },
    "application/vnd.ms-xpsdocument": {
      source: "iana",
      compressible: false,
      extensions: ["xps"]
    },
    "application/vnd.msa-disk-image": {
      source: "iana"
    },
    "application/vnd.mseq": {
      source: "iana",
      extensions: ["mseq"]
    },
    "application/vnd.msign": {
      source: "iana"
    },
    "application/vnd.multiad.creator": {
      source: "iana"
    },
    "application/vnd.multiad.creator.cif": {
      source: "iana"
    },
    "application/vnd.music-niff": {
      source: "iana"
    },
    "application/vnd.musician": {
      source: "iana",
      extensions: ["mus"]
    },
    "application/vnd.muvee.style": {
      source: "iana",
      extensions: ["msty"]
    },
    "application/vnd.mynfc": {
      source: "iana",
      extensions: ["taglet"]
    },
    "application/vnd.nacamar.ybrid+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.ncd.control": {
      source: "iana"
    },
    "application/vnd.ncd.reference": {
      source: "iana"
    },
    "application/vnd.nearst.inv+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nebumind.line": {
      source: "iana"
    },
    "application/vnd.nervana": {
      source: "iana"
    },
    "application/vnd.netfpx": {
      source: "iana"
    },
    "application/vnd.neurolanguage.nlu": {
      source: "iana",
      extensions: ["nlu"]
    },
    "application/vnd.nimn": {
      source: "iana"
    },
    "application/vnd.nintendo.nitro.rom": {
      source: "iana"
    },
    "application/vnd.nintendo.snes.rom": {
      source: "iana"
    },
    "application/vnd.nitf": {
      source: "iana",
      extensions: ["ntf", "nitf"]
    },
    "application/vnd.noblenet-directory": {
      source: "iana",
      extensions: ["nnd"]
    },
    "application/vnd.noblenet-sealer": {
      source: "iana",
      extensions: ["nns"]
    },
    "application/vnd.noblenet-web": {
      source: "iana",
      extensions: ["nnw"]
    },
    "application/vnd.nokia.catalogs": {
      source: "iana"
    },
    "application/vnd.nokia.conml+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.conml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.iptv.config+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.isds-radio-presets": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.landmark+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.landmarkcollection+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.n-gage.ac+xml": {
      source: "iana",
      compressible: true,
      extensions: ["ac"]
    },
    "application/vnd.nokia.n-gage.data": {
      source: "iana",
      extensions: ["ngdat"]
    },
    "application/vnd.nokia.n-gage.symbian.install": {
      source: "iana",
      extensions: ["n-gage"]
    },
    "application/vnd.nokia.ncd": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+wbxml": {
      source: "iana"
    },
    "application/vnd.nokia.pcd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.nokia.radio-preset": {
      source: "iana",
      extensions: ["rpst"]
    },
    "application/vnd.nokia.radio-presets": {
      source: "iana",
      extensions: ["rpss"]
    },
    "application/vnd.novadigm.edm": {
      source: "iana",
      extensions: ["edm"]
    },
    "application/vnd.novadigm.edx": {
      source: "iana",
      extensions: ["edx"]
    },
    "application/vnd.novadigm.ext": {
      source: "iana",
      extensions: ["ext"]
    },
    "application/vnd.ntt-local.content-share": {
      source: "iana"
    },
    "application/vnd.ntt-local.file-transfer": {
      source: "iana"
    },
    "application/vnd.ntt-local.ogw_remote-access": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_remote": {
      source: "iana"
    },
    "application/vnd.ntt-local.sip-ta_tcp_stream": {
      source: "iana"
    },
    "application/vnd.oasis.opendocument.chart": {
      source: "iana",
      extensions: ["odc"]
    },
    "application/vnd.oasis.opendocument.chart-template": {
      source: "iana",
      extensions: ["otc"]
    },
    "application/vnd.oasis.opendocument.database": {
      source: "iana",
      extensions: ["odb"]
    },
    "application/vnd.oasis.opendocument.formula": {
      source: "iana",
      extensions: ["odf"]
    },
    "application/vnd.oasis.opendocument.formula-template": {
      source: "iana",
      extensions: ["odft"]
    },
    "application/vnd.oasis.opendocument.graphics": {
      source: "iana",
      compressible: false,
      extensions: ["odg"]
    },
    "application/vnd.oasis.opendocument.graphics-template": {
      source: "iana",
      extensions: ["otg"]
    },
    "application/vnd.oasis.opendocument.image": {
      source: "iana",
      extensions: ["odi"]
    },
    "application/vnd.oasis.opendocument.image-template": {
      source: "iana",
      extensions: ["oti"]
    },
    "application/vnd.oasis.opendocument.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["odp"]
    },
    "application/vnd.oasis.opendocument.presentation-template": {
      source: "iana",
      extensions: ["otp"]
    },
    "application/vnd.oasis.opendocument.spreadsheet": {
      source: "iana",
      compressible: false,
      extensions: ["ods"]
    },
    "application/vnd.oasis.opendocument.spreadsheet-template": {
      source: "iana",
      extensions: ["ots"]
    },
    "application/vnd.oasis.opendocument.text": {
      source: "iana",
      compressible: false,
      extensions: ["odt"]
    },
    "application/vnd.oasis.opendocument.text-master": {
      source: "iana",
      extensions: ["odm"]
    },
    "application/vnd.oasis.opendocument.text-template": {
      source: "iana",
      extensions: ["ott"]
    },
    "application/vnd.oasis.opendocument.text-web": {
      source: "iana",
      extensions: ["oth"]
    },
    "application/vnd.obn": {
      source: "iana"
    },
    "application/vnd.ocf+cbor": {
      source: "iana"
    },
    "application/vnd.oci.image.manifest.v1+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oftn.l10n+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessdownload+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.contentaccessstreaming+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.cspg-hexbinary": {
      source: "iana"
    },
    "application/vnd.oipf.dae.svg+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.dae.xhtml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.mippvcontrolmessage+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.pae.gem": {
      source: "iana"
    },
    "application/vnd.oipf.spdiscovery+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.spdlist+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.ueprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oipf.userprofile+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.olpc-sugar": {
      source: "iana",
      extensions: ["xo"]
    },
    "application/vnd.oma-scws-config": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-request": {
      source: "iana"
    },
    "application/vnd.oma-scws-http-response": {
      source: "iana"
    },
    "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.drm-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.imd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.ltkm": {
      source: "iana"
    },
    "application/vnd.oma.bcast.notification+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.provisioningtrigger": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgboot": {
      source: "iana"
    },
    "application/vnd.oma.bcast.sgdd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sgdu": {
      source: "iana"
    },
    "application/vnd.oma.bcast.simple-symbol-container": {
      source: "iana"
    },
    "application/vnd.oma.bcast.smartcard-trigger+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.sprov+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.bcast.stkm": {
      source: "iana"
    },
    "application/vnd.oma.cab-address-book+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-feature-handler+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-pcc+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-subs-invite+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.cab-user-prefs+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.dcd": {
      source: "iana"
    },
    "application/vnd.oma.dcdc": {
      source: "iana"
    },
    "application/vnd.oma.dd2+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dd2"]
    },
    "application/vnd.oma.drm.risd+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.group-usage-list+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+cbor": {
      source: "iana"
    },
    "application/vnd.oma.lwm2m+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.lwm2m+tlv": {
      source: "iana"
    },
    "application/vnd.oma.pal+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.detailed-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.final-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.groups+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.invocation-descriptor+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.poc.optimized-progress-report+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.push": {
      source: "iana"
    },
    "application/vnd.oma.scidm.messages+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oma.xcap-directory+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.omads-email+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-file+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omads-folder+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.omaloc-supl-init": {
      source: "iana"
    },
    "application/vnd.onepager": {
      source: "iana"
    },
    "application/vnd.onepagertamp": {
      source: "iana"
    },
    "application/vnd.onepagertamx": {
      source: "iana"
    },
    "application/vnd.onepagertat": {
      source: "iana"
    },
    "application/vnd.onepagertatp": {
      source: "iana"
    },
    "application/vnd.onepagertatx": {
      source: "iana"
    },
    "application/vnd.openblox.game+xml": {
      source: "iana",
      compressible: true,
      extensions: ["obgx"]
    },
    "application/vnd.openblox.game-binary": {
      source: "iana"
    },
    "application/vnd.openeye.oeb": {
      source: "iana"
    },
    "application/vnd.openofficeorg.extension": {
      source: "apache",
      extensions: ["oxt"]
    },
    "application/vnd.openstreetmap.data+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osm"]
    },
    "application/vnd.opentimestamps.ots": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawing+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
      source: "iana",
      compressible: false,
      extensions: ["pptx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide": {
      source: "iana",
      extensions: ["sldx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
      source: "iana",
      extensions: ["ppsx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template": {
      source: "iana",
      extensions: ["potx"]
    },
    "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
      source: "iana",
      compressible: false,
      extensions: ["xlsx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
      source: "iana",
      extensions: ["xltx"]
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.theme+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.vmldrawing": {
      source: "iana"
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
      source: "iana",
      compressible: false,
      extensions: ["docx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
      source: "iana",
      extensions: ["dotx"]
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.core-properties+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.openxmlformats-package.relationships+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oracle.resource+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.orange.indata": {
      source: "iana"
    },
    "application/vnd.osa.netdeploy": {
      source: "iana"
    },
    "application/vnd.osgeo.mapguide.package": {
      source: "iana",
      extensions: ["mgp"]
    },
    "application/vnd.osgi.bundle": {
      source: "iana"
    },
    "application/vnd.osgi.dp": {
      source: "iana",
      extensions: ["dp"]
    },
    "application/vnd.osgi.subsystem": {
      source: "iana",
      extensions: ["esa"]
    },
    "application/vnd.otps.ct-kip+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.oxli.countgraph": {
      source: "iana"
    },
    "application/vnd.pagerduty+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.palm": {
      source: "iana",
      extensions: ["pdb", "pqa", "oprc"]
    },
    "application/vnd.panoply": {
      source: "iana"
    },
    "application/vnd.paos.xml": {
      source: "iana"
    },
    "application/vnd.patentdive": {
      source: "iana"
    },
    "application/vnd.patientecommsdoc": {
      source: "iana"
    },
    "application/vnd.pawaafile": {
      source: "iana",
      extensions: ["paw"]
    },
    "application/vnd.pcos": {
      source: "iana"
    },
    "application/vnd.pg.format": {
      source: "iana",
      extensions: ["str"]
    },
    "application/vnd.pg.osasli": {
      source: "iana",
      extensions: ["ei6"]
    },
    "application/vnd.piaccess.application-licence": {
      source: "iana"
    },
    "application/vnd.picsel": {
      source: "iana",
      extensions: ["efif"]
    },
    "application/vnd.pmi.widget": {
      source: "iana",
      extensions: ["wg"]
    },
    "application/vnd.poc.group-advertisement+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.pocketlearn": {
      source: "iana",
      extensions: ["plf"]
    },
    "application/vnd.powerbuilder6": {
      source: "iana",
      extensions: ["pbd"]
    },
    "application/vnd.powerbuilder6-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder7": {
      source: "iana"
    },
    "application/vnd.powerbuilder7-s": {
      source: "iana"
    },
    "application/vnd.powerbuilder75": {
      source: "iana"
    },
    "application/vnd.powerbuilder75-s": {
      source: "iana"
    },
    "application/vnd.preminet": {
      source: "iana"
    },
    "application/vnd.previewsystems.box": {
      source: "iana",
      extensions: ["box"]
    },
    "application/vnd.proteus.magazine": {
      source: "iana",
      extensions: ["mgz"]
    },
    "application/vnd.psfs": {
      source: "iana"
    },
    "application/vnd.publishare-delta-tree": {
      source: "iana",
      extensions: ["qps"]
    },
    "application/vnd.pvi.ptid1": {
      source: "iana",
      extensions: ["ptid"]
    },
    "application/vnd.pwg-multiplexed": {
      source: "iana"
    },
    "application/vnd.pwg-xhtml-print+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.qualcomm.brew-app-res": {
      source: "iana"
    },
    "application/vnd.quarantainenet": {
      source: "iana"
    },
    "application/vnd.quark.quarkxpress": {
      source: "iana",
      extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
    },
    "application/vnd.quobject-quoxdocument": {
      source: "iana"
    },
    "application/vnd.radisys.moml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-conn+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-audit-stream+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-conf+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-base+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-detect+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-group+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-speech+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.radisys.msml-dialog-transform+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rainstor.data": {
      source: "iana"
    },
    "application/vnd.rapid": {
      source: "iana"
    },
    "application/vnd.rar": {
      source: "iana",
      extensions: ["rar"]
    },
    "application/vnd.realvnc.bed": {
      source: "iana",
      extensions: ["bed"]
    },
    "application/vnd.recordare.musicxml": {
      source: "iana",
      extensions: ["mxl"]
    },
    "application/vnd.recordare.musicxml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["musicxml"]
    },
    "application/vnd.renlearn.rlprint": {
      source: "iana"
    },
    "application/vnd.resilient.logic": {
      source: "iana"
    },
    "application/vnd.restful+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.rig.cryptonote": {
      source: "iana",
      extensions: ["cryptonote"]
    },
    "application/vnd.rim.cod": {
      source: "apache",
      extensions: ["cod"]
    },
    "application/vnd.rn-realmedia": {
      source: "apache",
      extensions: ["rm"]
    },
    "application/vnd.rn-realmedia-vbr": {
      source: "apache",
      extensions: ["rmvb"]
    },
    "application/vnd.route66.link66+xml": {
      source: "iana",
      compressible: true,
      extensions: ["link66"]
    },
    "application/vnd.rs-274x": {
      source: "iana"
    },
    "application/vnd.ruckus.download": {
      source: "iana"
    },
    "application/vnd.s3sms": {
      source: "iana"
    },
    "application/vnd.sailingtracker.track": {
      source: "iana",
      extensions: ["st"]
    },
    "application/vnd.sar": {
      source: "iana"
    },
    "application/vnd.sbm.cid": {
      source: "iana"
    },
    "application/vnd.sbm.mid2": {
      source: "iana"
    },
    "application/vnd.scribus": {
      source: "iana"
    },
    "application/vnd.sealed.3df": {
      source: "iana"
    },
    "application/vnd.sealed.csf": {
      source: "iana"
    },
    "application/vnd.sealed.doc": {
      source: "iana"
    },
    "application/vnd.sealed.eml": {
      source: "iana"
    },
    "application/vnd.sealed.mht": {
      source: "iana"
    },
    "application/vnd.sealed.net": {
      source: "iana"
    },
    "application/vnd.sealed.ppt": {
      source: "iana"
    },
    "application/vnd.sealed.tiff": {
      source: "iana"
    },
    "application/vnd.sealed.xls": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.html": {
      source: "iana"
    },
    "application/vnd.sealedmedia.softseal.pdf": {
      source: "iana"
    },
    "application/vnd.seemail": {
      source: "iana",
      extensions: ["see"]
    },
    "application/vnd.seis+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.sema": {
      source: "iana",
      extensions: ["sema"]
    },
    "application/vnd.semd": {
      source: "iana",
      extensions: ["semd"]
    },
    "application/vnd.semf": {
      source: "iana",
      extensions: ["semf"]
    },
    "application/vnd.shade-save-file": {
      source: "iana"
    },
    "application/vnd.shana.informed.formdata": {
      source: "iana",
      extensions: ["ifm"]
    },
    "application/vnd.shana.informed.formtemplate": {
      source: "iana",
      extensions: ["itp"]
    },
    "application/vnd.shana.informed.interchange": {
      source: "iana",
      extensions: ["iif"]
    },
    "application/vnd.shana.informed.package": {
      source: "iana",
      extensions: ["ipk"]
    },
    "application/vnd.shootproof+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shopkick+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.shp": {
      source: "iana"
    },
    "application/vnd.shx": {
      source: "iana"
    },
    "application/vnd.sigrok.session": {
      source: "iana"
    },
    "application/vnd.simtech-mindmapper": {
      source: "iana",
      extensions: ["twd", "twds"]
    },
    "application/vnd.siren+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.smaf": {
      source: "iana",
      extensions: ["mmf"]
    },
    "application/vnd.smart.notebook": {
      source: "iana"
    },
    "application/vnd.smart.teacher": {
      source: "iana",
      extensions: ["teacher"]
    },
    "application/vnd.snesdev-page-table": {
      source: "iana"
    },
    "application/vnd.software602.filler.form+xml": {
      source: "iana",
      compressible: true,
      extensions: ["fo"]
    },
    "application/vnd.software602.filler.form-xml-zip": {
      source: "iana"
    },
    "application/vnd.solent.sdkm+xml": {
      source: "iana",
      compressible: true,
      extensions: ["sdkm", "sdkd"]
    },
    "application/vnd.spotfire.dxp": {
      source: "iana",
      extensions: ["dxp"]
    },
    "application/vnd.spotfire.sfs": {
      source: "iana",
      extensions: ["sfs"]
    },
    "application/vnd.sqlite3": {
      source: "iana"
    },
    "application/vnd.sss-cod": {
      source: "iana"
    },
    "application/vnd.sss-dtf": {
      source: "iana"
    },
    "application/vnd.sss-ntf": {
      source: "iana"
    },
    "application/vnd.stardivision.calc": {
      source: "apache",
      extensions: ["sdc"]
    },
    "application/vnd.stardivision.draw": {
      source: "apache",
      extensions: ["sda"]
    },
    "application/vnd.stardivision.impress": {
      source: "apache",
      extensions: ["sdd"]
    },
    "application/vnd.stardivision.math": {
      source: "apache",
      extensions: ["smf"]
    },
    "application/vnd.stardivision.writer": {
      source: "apache",
      extensions: ["sdw", "vor"]
    },
    "application/vnd.stardivision.writer-global": {
      source: "apache",
      extensions: ["sgl"]
    },
    "application/vnd.stepmania.package": {
      source: "iana",
      extensions: ["smzip"]
    },
    "application/vnd.stepmania.stepchart": {
      source: "iana",
      extensions: ["sm"]
    },
    "application/vnd.street-stream": {
      source: "iana"
    },
    "application/vnd.sun.wadl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wadl"]
    },
    "application/vnd.sun.xml.calc": {
      source: "apache",
      extensions: ["sxc"]
    },
    "application/vnd.sun.xml.calc.template": {
      source: "apache",
      extensions: ["stc"]
    },
    "application/vnd.sun.xml.draw": {
      source: "apache",
      extensions: ["sxd"]
    },
    "application/vnd.sun.xml.draw.template": {
      source: "apache",
      extensions: ["std"]
    },
    "application/vnd.sun.xml.impress": {
      source: "apache",
      extensions: ["sxi"]
    },
    "application/vnd.sun.xml.impress.template": {
      source: "apache",
      extensions: ["sti"]
    },
    "application/vnd.sun.xml.math": {
      source: "apache",
      extensions: ["sxm"]
    },
    "application/vnd.sun.xml.writer": {
      source: "apache",
      extensions: ["sxw"]
    },
    "application/vnd.sun.xml.writer.global": {
      source: "apache",
      extensions: ["sxg"]
    },
    "application/vnd.sun.xml.writer.template": {
      source: "apache",
      extensions: ["stw"]
    },
    "application/vnd.sus-calendar": {
      source: "iana",
      extensions: ["sus", "susp"]
    },
    "application/vnd.svd": {
      source: "iana",
      extensions: ["svd"]
    },
    "application/vnd.swiftview-ics": {
      source: "iana"
    },
    "application/vnd.sycle+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.syft+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.symbian.install": {
      source: "apache",
      extensions: ["sis", "sisx"]
    },
    "application/vnd.syncml+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xsm"]
    },
    "application/vnd.syncml.dm+wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["bdm"]
    },
    "application/vnd.syncml.dm+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["xdm"]
    },
    "application/vnd.syncml.dm.notification": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmddf+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["ddf"]
    },
    "application/vnd.syncml.dmtnds+wbxml": {
      source: "iana"
    },
    "application/vnd.syncml.dmtnds+xml": {
      source: "iana",
      charset: "UTF-8",
      compressible: true
    },
    "application/vnd.syncml.ds.notification": {
      source: "iana"
    },
    "application/vnd.tableschema+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tao.intent-module-archive": {
      source: "iana",
      extensions: ["tao"]
    },
    "application/vnd.tcpdump.pcap": {
      source: "iana",
      extensions: ["pcap", "cap", "dmp"]
    },
    "application/vnd.think-cell.ppttc+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tmd.mediaflex.api+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.tml": {
      source: "iana"
    },
    "application/vnd.tmobile-livetv": {
      source: "iana",
      extensions: ["tmo"]
    },
    "application/vnd.tri.onesource": {
      source: "iana"
    },
    "application/vnd.trid.tpt": {
      source: "iana",
      extensions: ["tpt"]
    },
    "application/vnd.triscape.mxs": {
      source: "iana",
      extensions: ["mxs"]
    },
    "application/vnd.trueapp": {
      source: "iana",
      extensions: ["tra"]
    },
    "application/vnd.truedoc": {
      source: "iana"
    },
    "application/vnd.ubisoft.webplayer": {
      source: "iana"
    },
    "application/vnd.ufdl": {
      source: "iana",
      extensions: ["ufd", "ufdl"]
    },
    "application/vnd.uiq.theme": {
      source: "iana",
      extensions: ["utz"]
    },
    "application/vnd.umajin": {
      source: "iana",
      extensions: ["umj"]
    },
    "application/vnd.unity": {
      source: "iana",
      extensions: ["unityweb"]
    },
    "application/vnd.uoml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["uoml"]
    },
    "application/vnd.uplanet.alert": {
      source: "iana"
    },
    "application/vnd.uplanet.alert-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice": {
      source: "iana"
    },
    "application/vnd.uplanet.bearer-choice-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop": {
      source: "iana"
    },
    "application/vnd.uplanet.cacheop-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.channel": {
      source: "iana"
    },
    "application/vnd.uplanet.channel-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.list": {
      source: "iana"
    },
    "application/vnd.uplanet.list-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd": {
      source: "iana"
    },
    "application/vnd.uplanet.listcmd-wbxml": {
      source: "iana"
    },
    "application/vnd.uplanet.signal": {
      source: "iana"
    },
    "application/vnd.uri-map": {
      source: "iana"
    },
    "application/vnd.valve.source.material": {
      source: "iana"
    },
    "application/vnd.vcx": {
      source: "iana",
      extensions: ["vcx"]
    },
    "application/vnd.vd-study": {
      source: "iana"
    },
    "application/vnd.vectorworks": {
      source: "iana"
    },
    "application/vnd.vel+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.verimatrix.vcas": {
      source: "iana"
    },
    "application/vnd.veritone.aion+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.veryant.thin": {
      source: "iana"
    },
    "application/vnd.ves.encrypted": {
      source: "iana"
    },
    "application/vnd.vidsoft.vidconference": {
      source: "iana"
    },
    "application/vnd.visio": {
      source: "iana",
      extensions: ["vsd", "vst", "vss", "vsw"]
    },
    "application/vnd.visionary": {
      source: "iana",
      extensions: ["vis"]
    },
    "application/vnd.vividence.scriptfile": {
      source: "iana"
    },
    "application/vnd.vsf": {
      source: "iana",
      extensions: ["vsf"]
    },
    "application/vnd.wap.sic": {
      source: "iana"
    },
    "application/vnd.wap.slc": {
      source: "iana"
    },
    "application/vnd.wap.wbxml": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["wbxml"]
    },
    "application/vnd.wap.wmlc": {
      source: "iana",
      extensions: ["wmlc"]
    },
    "application/vnd.wap.wmlscriptc": {
      source: "iana",
      extensions: ["wmlsc"]
    },
    "application/vnd.webturbo": {
      source: "iana",
      extensions: ["wtb"]
    },
    "application/vnd.wfa.dpp": {
      source: "iana"
    },
    "application/vnd.wfa.p2p": {
      source: "iana"
    },
    "application/vnd.wfa.wsc": {
      source: "iana"
    },
    "application/vnd.windows.devicepairing": {
      source: "iana"
    },
    "application/vnd.wmc": {
      source: "iana"
    },
    "application/vnd.wmf.bootstrap": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica": {
      source: "iana"
    },
    "application/vnd.wolfram.mathematica.package": {
      source: "iana"
    },
    "application/vnd.wolfram.player": {
      source: "iana",
      extensions: ["nbp"]
    },
    "application/vnd.wordperfect": {
      source: "iana",
      extensions: ["wpd"]
    },
    "application/vnd.wqd": {
      source: "iana",
      extensions: ["wqd"]
    },
    "application/vnd.wrq-hp3000-labelled": {
      source: "iana"
    },
    "application/vnd.wt.stf": {
      source: "iana",
      extensions: ["stf"]
    },
    "application/vnd.wv.csp+wbxml": {
      source: "iana"
    },
    "application/vnd.wv.csp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.wv.ssp+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xacml+json": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xara": {
      source: "iana",
      extensions: ["xar"]
    },
    "application/vnd.xfdl": {
      source: "iana",
      extensions: ["xfdl"]
    },
    "application/vnd.xfdl.webform": {
      source: "iana"
    },
    "application/vnd.xmi+xml": {
      source: "iana",
      compressible: true
    },
    "application/vnd.xmpie.cpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.dpkg": {
      source: "iana"
    },
    "application/vnd.xmpie.plan": {
      source: "iana"
    },
    "application/vnd.xmpie.ppkg": {
      source: "iana"
    },
    "application/vnd.xmpie.xlim": {
      source: "iana"
    },
    "application/vnd.yamaha.hv-dic": {
      source: "iana",
      extensions: ["hvd"]
    },
    "application/vnd.yamaha.hv-script": {
      source: "iana",
      extensions: ["hvs"]
    },
    "application/vnd.yamaha.hv-voice": {
      source: "iana",
      extensions: ["hvp"]
    },
    "application/vnd.yamaha.openscoreformat": {
      source: "iana",
      extensions: ["osf"]
    },
    "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["osfpvg"]
    },
    "application/vnd.yamaha.remote-setup": {
      source: "iana"
    },
    "application/vnd.yamaha.smaf-audio": {
      source: "iana",
      extensions: ["saf"]
    },
    "application/vnd.yamaha.smaf-phrase": {
      source: "iana",
      extensions: ["spf"]
    },
    "application/vnd.yamaha.through-ngn": {
      source: "iana"
    },
    "application/vnd.yamaha.tunnel-udpencap": {
      source: "iana"
    },
    "application/vnd.yaoweme": {
      source: "iana"
    },
    "application/vnd.yellowriver-custom-menu": {
      source: "iana",
      extensions: ["cmp"]
    },
    "application/vnd.youtube.yt": {
      source: "iana"
    },
    "application/vnd.zul": {
      source: "iana",
      extensions: ["zir", "zirz"]
    },
    "application/vnd.zzazz.deck+xml": {
      source: "iana",
      compressible: true,
      extensions: ["zaz"]
    },
    "application/voicexml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["vxml"]
    },
    "application/voucher-cms+json": {
      source: "iana",
      compressible: true
    },
    "application/vq-rtcpxr": {
      source: "iana"
    },
    "application/wasm": {
      source: "iana",
      compressible: true,
      extensions: ["wasm"]
    },
    "application/watcherinfo+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wif"]
    },
    "application/webpush-options+json": {
      source: "iana",
      compressible: true
    },
    "application/whoispp-query": {
      source: "iana"
    },
    "application/whoispp-response": {
      source: "iana"
    },
    "application/widget": {
      source: "iana",
      extensions: ["wgt"]
    },
    "application/winhlp": {
      source: "apache",
      extensions: ["hlp"]
    },
    "application/wita": {
      source: "iana"
    },
    "application/wordperfect5.1": {
      source: "iana"
    },
    "application/wsdl+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wsdl"]
    },
    "application/wspolicy+xml": {
      source: "iana",
      compressible: true,
      extensions: ["wspolicy"]
    },
    "application/x-7z-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["7z"]
    },
    "application/x-abiword": {
      source: "apache",
      extensions: ["abw"]
    },
    "application/x-ace-compressed": {
      source: "apache",
      extensions: ["ace"]
    },
    "application/x-amf": {
      source: "apache"
    },
    "application/x-apple-diskimage": {
      source: "apache",
      extensions: ["dmg"]
    },
    "application/x-arj": {
      compressible: false,
      extensions: ["arj"]
    },
    "application/x-authorware-bin": {
      source: "apache",
      extensions: ["aab", "x32", "u32", "vox"]
    },
    "application/x-authorware-map": {
      source: "apache",
      extensions: ["aam"]
    },
    "application/x-authorware-seg": {
      source: "apache",
      extensions: ["aas"]
    },
    "application/x-bcpio": {
      source: "apache",
      extensions: ["bcpio"]
    },
    "application/x-bdoc": {
      compressible: false,
      extensions: ["bdoc"]
    },
    "application/x-bittorrent": {
      source: "apache",
      extensions: ["torrent"]
    },
    "application/x-blorb": {
      source: "apache",
      extensions: ["blb", "blorb"]
    },
    "application/x-bzip": {
      source: "apache",
      compressible: false,
      extensions: ["bz"]
    },
    "application/x-bzip2": {
      source: "apache",
      compressible: false,
      extensions: ["bz2", "boz"]
    },
    "application/x-cbr": {
      source: "apache",
      extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
    },
    "application/x-cdlink": {
      source: "apache",
      extensions: ["vcd"]
    },
    "application/x-cfs-compressed": {
      source: "apache",
      extensions: ["cfs"]
    },
    "application/x-chat": {
      source: "apache",
      extensions: ["chat"]
    },
    "application/x-chess-pgn": {
      source: "apache",
      extensions: ["pgn"]
    },
    "application/x-chrome-extension": {
      extensions: ["crx"]
    },
    "application/x-cocoa": {
      source: "nginx",
      extensions: ["cco"]
    },
    "application/x-compress": {
      source: "apache"
    },
    "application/x-conference": {
      source: "apache",
      extensions: ["nsc"]
    },
    "application/x-cpio": {
      source: "apache",
      extensions: ["cpio"]
    },
    "application/x-csh": {
      source: "apache",
      extensions: ["csh"]
    },
    "application/x-deb": {
      compressible: false
    },
    "application/x-debian-package": {
      source: "apache",
      extensions: ["deb", "udeb"]
    },
    "application/x-dgc-compressed": {
      source: "apache",
      extensions: ["dgc"]
    },
    "application/x-director": {
      source: "apache",
      extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
    },
    "application/x-doom": {
      source: "apache",
      extensions: ["wad"]
    },
    "application/x-dtbncx+xml": {
      source: "apache",
      compressible: true,
      extensions: ["ncx"]
    },
    "application/x-dtbook+xml": {
      source: "apache",
      compressible: true,
      extensions: ["dtb"]
    },
    "application/x-dtbresource+xml": {
      source: "apache",
      compressible: true,
      extensions: ["res"]
    },
    "application/x-dvi": {
      source: "apache",
      compressible: false,
      extensions: ["dvi"]
    },
    "application/x-envoy": {
      source: "apache",
      extensions: ["evy"]
    },
    "application/x-eva": {
      source: "apache",
      extensions: ["eva"]
    },
    "application/x-font-bdf": {
      source: "apache",
      extensions: ["bdf"]
    },
    "application/x-font-dos": {
      source: "apache"
    },
    "application/x-font-framemaker": {
      source: "apache"
    },
    "application/x-font-ghostscript": {
      source: "apache",
      extensions: ["gsf"]
    },
    "application/x-font-libgrx": {
      source: "apache"
    },
    "application/x-font-linux-psf": {
      source: "apache",
      extensions: ["psf"]
    },
    "application/x-font-pcf": {
      source: "apache",
      extensions: ["pcf"]
    },
    "application/x-font-snf": {
      source: "apache",
      extensions: ["snf"]
    },
    "application/x-font-speedo": {
      source: "apache"
    },
    "application/x-font-sunos-news": {
      source: "apache"
    },
    "application/x-font-type1": {
      source: "apache",
      extensions: ["pfa", "pfb", "pfm", "afm"]
    },
    "application/x-font-vfont": {
      source: "apache"
    },
    "application/x-freearc": {
      source: "apache",
      extensions: ["arc"]
    },
    "application/x-futuresplash": {
      source: "apache",
      extensions: ["spl"]
    },
    "application/x-gca-compressed": {
      source: "apache",
      extensions: ["gca"]
    },
    "application/x-glulx": {
      source: "apache",
      extensions: ["ulx"]
    },
    "application/x-gnumeric": {
      source: "apache",
      extensions: ["gnumeric"]
    },
    "application/x-gramps-xml": {
      source: "apache",
      extensions: ["gramps"]
    },
    "application/x-gtar": {
      source: "apache",
      extensions: ["gtar"]
    },
    "application/x-gzip": {
      source: "apache"
    },
    "application/x-hdf": {
      source: "apache",
      extensions: ["hdf"]
    },
    "application/x-httpd-php": {
      compressible: true,
      extensions: ["php"]
    },
    "application/x-install-instructions": {
      source: "apache",
      extensions: ["install"]
    },
    "application/x-iso9660-image": {
      source: "apache",
      extensions: ["iso"]
    },
    "application/x-iwork-keynote-sffkey": {
      extensions: ["key"]
    },
    "application/x-iwork-numbers-sffnumbers": {
      extensions: ["numbers"]
    },
    "application/x-iwork-pages-sffpages": {
      extensions: ["pages"]
    },
    "application/x-java-archive-diff": {
      source: "nginx",
      extensions: ["jardiff"]
    },
    "application/x-java-jnlp-file": {
      source: "apache",
      compressible: false,
      extensions: ["jnlp"]
    },
    "application/x-javascript": {
      compressible: true
    },
    "application/x-keepass2": {
      extensions: ["kdbx"]
    },
    "application/x-latex": {
      source: "apache",
      compressible: false,
      extensions: ["latex"]
    },
    "application/x-lua-bytecode": {
      extensions: ["luac"]
    },
    "application/x-lzh-compressed": {
      source: "apache",
      extensions: ["lzh", "lha"]
    },
    "application/x-makeself": {
      source: "nginx",
      extensions: ["run"]
    },
    "application/x-mie": {
      source: "apache",
      extensions: ["mie"]
    },
    "application/x-mobipocket-ebook": {
      source: "apache",
      extensions: ["prc", "mobi"]
    },
    "application/x-mpegurl": {
      compressible: false
    },
    "application/x-ms-application": {
      source: "apache",
      extensions: ["application"]
    },
    "application/x-ms-shortcut": {
      source: "apache",
      extensions: ["lnk"]
    },
    "application/x-ms-wmd": {
      source: "apache",
      extensions: ["wmd"]
    },
    "application/x-ms-wmz": {
      source: "apache",
      extensions: ["wmz"]
    },
    "application/x-ms-xbap": {
      source: "apache",
      extensions: ["xbap"]
    },
    "application/x-msaccess": {
      source: "apache",
      extensions: ["mdb"]
    },
    "application/x-msbinder": {
      source: "apache",
      extensions: ["obd"]
    },
    "application/x-mscardfile": {
      source: "apache",
      extensions: ["crd"]
    },
    "application/x-msclip": {
      source: "apache",
      extensions: ["clp"]
    },
    "application/x-msdos-program": {
      extensions: ["exe"]
    },
    "application/x-msdownload": {
      source: "apache",
      extensions: ["exe", "dll", "com", "bat", "msi"]
    },
    "application/x-msmediaview": {
      source: "apache",
      extensions: ["mvb", "m13", "m14"]
    },
    "application/x-msmetafile": {
      source: "apache",
      extensions: ["wmf", "wmz", "emf", "emz"]
    },
    "application/x-msmoney": {
      source: "apache",
      extensions: ["mny"]
    },
    "application/x-mspublisher": {
      source: "apache",
      extensions: ["pub"]
    },
    "application/x-msschedule": {
      source: "apache",
      extensions: ["scd"]
    },
    "application/x-msterminal": {
      source: "apache",
      extensions: ["trm"]
    },
    "application/x-mswrite": {
      source: "apache",
      extensions: ["wri"]
    },
    "application/x-netcdf": {
      source: "apache",
      extensions: ["nc", "cdf"]
    },
    "application/x-ns-proxy-autoconfig": {
      compressible: true,
      extensions: ["pac"]
    },
    "application/x-nzb": {
      source: "apache",
      extensions: ["nzb"]
    },
    "application/x-perl": {
      source: "nginx",
      extensions: ["pl", "pm"]
    },
    "application/x-pilot": {
      source: "nginx",
      extensions: ["prc", "pdb"]
    },
    "application/x-pkcs12": {
      source: "apache",
      compressible: false,
      extensions: ["p12", "pfx"]
    },
    "application/x-pkcs7-certificates": {
      source: "apache",
      extensions: ["p7b", "spc"]
    },
    "application/x-pkcs7-certreqresp": {
      source: "apache",
      extensions: ["p7r"]
    },
    "application/x-pki-message": {
      source: "iana"
    },
    "application/x-rar-compressed": {
      source: "apache",
      compressible: false,
      extensions: ["rar"]
    },
    "application/x-redhat-package-manager": {
      source: "nginx",
      extensions: ["rpm"]
    },
    "application/x-research-info-systems": {
      source: "apache",
      extensions: ["ris"]
    },
    "application/x-sea": {
      source: "nginx",
      extensions: ["sea"]
    },
    "application/x-sh": {
      source: "apache",
      compressible: true,
      extensions: ["sh"]
    },
    "application/x-shar": {
      source: "apache",
      extensions: ["shar"]
    },
    "application/x-shockwave-flash": {
      source: "apache",
      compressible: false,
      extensions: ["swf"]
    },
    "application/x-silverlight-app": {
      source: "apache",
      extensions: ["xap"]
    },
    "application/x-sql": {
      source: "apache",
      extensions: ["sql"]
    },
    "application/x-stuffit": {
      source: "apache",
      compressible: false,
      extensions: ["sit"]
    },
    "application/x-stuffitx": {
      source: "apache",
      extensions: ["sitx"]
    },
    "application/x-subrip": {
      source: "apache",
      extensions: ["srt"]
    },
    "application/x-sv4cpio": {
      source: "apache",
      extensions: ["sv4cpio"]
    },
    "application/x-sv4crc": {
      source: "apache",
      extensions: ["sv4crc"]
    },
    "application/x-t3vm-image": {
      source: "apache",
      extensions: ["t3"]
    },
    "application/x-tads": {
      source: "apache",
      extensions: ["gam"]
    },
    "application/x-tar": {
      source: "apache",
      compressible: true,
      extensions: ["tar"]
    },
    "application/x-tcl": {
      source: "apache",
      extensions: ["tcl", "tk"]
    },
    "application/x-tex": {
      source: "apache",
      extensions: ["tex"]
    },
    "application/x-tex-tfm": {
      source: "apache",
      extensions: ["tfm"]
    },
    "application/x-texinfo": {
      source: "apache",
      extensions: ["texinfo", "texi"]
    },
    "application/x-tgif": {
      source: "apache",
      extensions: ["obj"]
    },
    "application/x-ustar": {
      source: "apache",
      extensions: ["ustar"]
    },
    "application/x-virtualbox-hdd": {
      compressible: true,
      extensions: ["hdd"]
    },
    "application/x-virtualbox-ova": {
      compressible: true,
      extensions: ["ova"]
    },
    "application/x-virtualbox-ovf": {
      compressible: true,
      extensions: ["ovf"]
    },
    "application/x-virtualbox-vbox": {
      compressible: true,
      extensions: ["vbox"]
    },
    "application/x-virtualbox-vbox-extpack": {
      compressible: false,
      extensions: ["vbox-extpack"]
    },
    "application/x-virtualbox-vdi": {
      compressible: true,
      extensions: ["vdi"]
    },
    "application/x-virtualbox-vhd": {
      compressible: true,
      extensions: ["vhd"]
    },
    "application/x-virtualbox-vmdk": {
      compressible: true,
      extensions: ["vmdk"]
    },
    "application/x-wais-source": {
      source: "apache",
      extensions: ["src"]
    },
    "application/x-web-app-manifest+json": {
      compressible: true,
      extensions: ["webapp"]
    },
    "application/x-www-form-urlencoded": {
      source: "iana",
      compressible: true
    },
    "application/x-x509-ca-cert": {
      source: "iana",
      extensions: ["der", "crt", "pem"]
    },
    "application/x-x509-ca-ra-cert": {
      source: "iana"
    },
    "application/x-x509-next-ca-cert": {
      source: "iana"
    },
    "application/x-xfig": {
      source: "apache",
      extensions: ["fig"]
    },
    "application/x-xliff+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/x-xpinstall": {
      source: "apache",
      compressible: false,
      extensions: ["xpi"]
    },
    "application/x-xz": {
      source: "apache",
      extensions: ["xz"]
    },
    "application/x-zmachine": {
      source: "apache",
      extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
    },
    "application/x400-bp": {
      source: "iana"
    },
    "application/xacml+xml": {
      source: "iana",
      compressible: true
    },
    "application/xaml+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xaml"]
    },
    "application/xcap-att+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xav"]
    },
    "application/xcap-caps+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xca"]
    },
    "application/xcap-diff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xdf"]
    },
    "application/xcap-el+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xel"]
    },
    "application/xcap-error+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcap-ns+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xns"]
    },
    "application/xcon-conference-info+xml": {
      source: "iana",
      compressible: true
    },
    "application/xcon-conference-info-diff+xml": {
      source: "iana",
      compressible: true
    },
    "application/xenc+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xenc"]
    },
    "application/xhtml+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xhtml", "xht"]
    },
    "application/xhtml-voice+xml": {
      source: "apache",
      compressible: true
    },
    "application/xliff+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xlf"]
    },
    "application/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml", "xsl", "xsd", "rng"]
    },
    "application/xml-dtd": {
      source: "iana",
      compressible: true,
      extensions: ["dtd"]
    },
    "application/xml-external-parsed-entity": {
      source: "iana"
    },
    "application/xml-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/xmpp+xml": {
      source: "iana",
      compressible: true
    },
    "application/xop+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xop"]
    },
    "application/xproc+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xpl"]
    },
    "application/xslt+xml": {
      source: "iana",
      compressible: true,
      extensions: ["xsl", "xslt"]
    },
    "application/xspf+xml": {
      source: "apache",
      compressible: true,
      extensions: ["xspf"]
    },
    "application/xv+xml": {
      source: "iana",
      compressible: true,
      extensions: ["mxml", "xhvml", "xvml", "xvm"]
    },
    "application/yang": {
      source: "iana",
      extensions: ["yang"]
    },
    "application/yang-data+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-data+xml": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+json": {
      source: "iana",
      compressible: true
    },
    "application/yang-patch+xml": {
      source: "iana",
      compressible: true
    },
    "application/yin+xml": {
      source: "iana",
      compressible: true,
      extensions: ["yin"]
    },
    "application/zip": {
      source: "iana",
      compressible: false,
      extensions: ["zip"]
    },
    "application/zlib": {
      source: "iana"
    },
    "application/zstd": {
      source: "iana"
    },
    "audio/1d-interleaved-parityfec": {
      source: "iana"
    },
    "audio/32kadpcm": {
      source: "iana"
    },
    "audio/3gpp": {
      source: "iana",
      compressible: false,
      extensions: ["3gpp"]
    },
    "audio/3gpp2": {
      source: "iana"
    },
    "audio/aac": {
      source: "iana"
    },
    "audio/ac3": {
      source: "iana"
    },
    "audio/adpcm": {
      source: "apache",
      extensions: ["adp"]
    },
    "audio/amr": {
      source: "iana",
      extensions: ["amr"]
    },
    "audio/amr-wb": {
      source: "iana"
    },
    "audio/amr-wb+": {
      source: "iana"
    },
    "audio/aptx": {
      source: "iana"
    },
    "audio/asc": {
      source: "iana"
    },
    "audio/atrac-advanced-lossless": {
      source: "iana"
    },
    "audio/atrac-x": {
      source: "iana"
    },
    "audio/atrac3": {
      source: "iana"
    },
    "audio/basic": {
      source: "iana",
      compressible: false,
      extensions: ["au", "snd"]
    },
    "audio/bv16": {
      source: "iana"
    },
    "audio/bv32": {
      source: "iana"
    },
    "audio/clearmode": {
      source: "iana"
    },
    "audio/cn": {
      source: "iana"
    },
    "audio/dat12": {
      source: "iana"
    },
    "audio/dls": {
      source: "iana"
    },
    "audio/dsr-es201108": {
      source: "iana"
    },
    "audio/dsr-es202050": {
      source: "iana"
    },
    "audio/dsr-es202211": {
      source: "iana"
    },
    "audio/dsr-es202212": {
      source: "iana"
    },
    "audio/dv": {
      source: "iana"
    },
    "audio/dvi4": {
      source: "iana"
    },
    "audio/eac3": {
      source: "iana"
    },
    "audio/encaprtp": {
      source: "iana"
    },
    "audio/evrc": {
      source: "iana"
    },
    "audio/evrc-qcp": {
      source: "iana"
    },
    "audio/evrc0": {
      source: "iana"
    },
    "audio/evrc1": {
      source: "iana"
    },
    "audio/evrcb": {
      source: "iana"
    },
    "audio/evrcb0": {
      source: "iana"
    },
    "audio/evrcb1": {
      source: "iana"
    },
    "audio/evrcnw": {
      source: "iana"
    },
    "audio/evrcnw0": {
      source: "iana"
    },
    "audio/evrcnw1": {
      source: "iana"
    },
    "audio/evrcwb": {
      source: "iana"
    },
    "audio/evrcwb0": {
      source: "iana"
    },
    "audio/evrcwb1": {
      source: "iana"
    },
    "audio/evs": {
      source: "iana"
    },
    "audio/flexfec": {
      source: "iana"
    },
    "audio/fwdred": {
      source: "iana"
    },
    "audio/g711-0": {
      source: "iana"
    },
    "audio/g719": {
      source: "iana"
    },
    "audio/g722": {
      source: "iana"
    },
    "audio/g7221": {
      source: "iana"
    },
    "audio/g723": {
      source: "iana"
    },
    "audio/g726-16": {
      source: "iana"
    },
    "audio/g726-24": {
      source: "iana"
    },
    "audio/g726-32": {
      source: "iana"
    },
    "audio/g726-40": {
      source: "iana"
    },
    "audio/g728": {
      source: "iana"
    },
    "audio/g729": {
      source: "iana"
    },
    "audio/g7291": {
      source: "iana"
    },
    "audio/g729d": {
      source: "iana"
    },
    "audio/g729e": {
      source: "iana"
    },
    "audio/gsm": {
      source: "iana"
    },
    "audio/gsm-efr": {
      source: "iana"
    },
    "audio/gsm-hr-08": {
      source: "iana"
    },
    "audio/ilbc": {
      source: "iana"
    },
    "audio/ip-mr_v2.5": {
      source: "iana"
    },
    "audio/isac": {
      source: "apache"
    },
    "audio/l16": {
      source: "iana"
    },
    "audio/l20": {
      source: "iana"
    },
    "audio/l24": {
      source: "iana",
      compressible: false
    },
    "audio/l8": {
      source: "iana"
    },
    "audio/lpc": {
      source: "iana"
    },
    "audio/melp": {
      source: "iana"
    },
    "audio/melp1200": {
      source: "iana"
    },
    "audio/melp2400": {
      source: "iana"
    },
    "audio/melp600": {
      source: "iana"
    },
    "audio/mhas": {
      source: "iana"
    },
    "audio/midi": {
      source: "apache",
      extensions: ["mid", "midi", "kar", "rmi"]
    },
    "audio/mobile-xmf": {
      source: "iana",
      extensions: ["mxmf"]
    },
    "audio/mp3": {
      compressible: false,
      extensions: ["mp3"]
    },
    "audio/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["m4a", "mp4a"]
    },
    "audio/mp4a-latm": {
      source: "iana"
    },
    "audio/mpa": {
      source: "iana"
    },
    "audio/mpa-robust": {
      source: "iana"
    },
    "audio/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
    },
    "audio/mpeg4-generic": {
      source: "iana"
    },
    "audio/musepack": {
      source: "apache"
    },
    "audio/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["oga", "ogg", "spx", "opus"]
    },
    "audio/opus": {
      source: "iana"
    },
    "audio/parityfec": {
      source: "iana"
    },
    "audio/pcma": {
      source: "iana"
    },
    "audio/pcma-wb": {
      source: "iana"
    },
    "audio/pcmu": {
      source: "iana"
    },
    "audio/pcmu-wb": {
      source: "iana"
    },
    "audio/prs.sid": {
      source: "iana"
    },
    "audio/qcelp": {
      source: "iana"
    },
    "audio/raptorfec": {
      source: "iana"
    },
    "audio/red": {
      source: "iana"
    },
    "audio/rtp-enc-aescm128": {
      source: "iana"
    },
    "audio/rtp-midi": {
      source: "iana"
    },
    "audio/rtploopback": {
      source: "iana"
    },
    "audio/rtx": {
      source: "iana"
    },
    "audio/s3m": {
      source: "apache",
      extensions: ["s3m"]
    },
    "audio/scip": {
      source: "iana"
    },
    "audio/silk": {
      source: "apache",
      extensions: ["sil"]
    },
    "audio/smv": {
      source: "iana"
    },
    "audio/smv-qcp": {
      source: "iana"
    },
    "audio/smv0": {
      source: "iana"
    },
    "audio/sofa": {
      source: "iana"
    },
    "audio/sp-midi": {
      source: "iana"
    },
    "audio/speex": {
      source: "iana"
    },
    "audio/t140c": {
      source: "iana"
    },
    "audio/t38": {
      source: "iana"
    },
    "audio/telephone-event": {
      source: "iana"
    },
    "audio/tetra_acelp": {
      source: "iana"
    },
    "audio/tetra_acelp_bb": {
      source: "iana"
    },
    "audio/tone": {
      source: "iana"
    },
    "audio/tsvcis": {
      source: "iana"
    },
    "audio/uemclip": {
      source: "iana"
    },
    "audio/ulpfec": {
      source: "iana"
    },
    "audio/usac": {
      source: "iana"
    },
    "audio/vdvi": {
      source: "iana"
    },
    "audio/vmr-wb": {
      source: "iana"
    },
    "audio/vnd.3gpp.iufp": {
      source: "iana"
    },
    "audio/vnd.4sb": {
      source: "iana"
    },
    "audio/vnd.audiokoz": {
      source: "iana"
    },
    "audio/vnd.celp": {
      source: "iana"
    },
    "audio/vnd.cisco.nse": {
      source: "iana"
    },
    "audio/vnd.cmles.radio-events": {
      source: "iana"
    },
    "audio/vnd.cns.anp1": {
      source: "iana"
    },
    "audio/vnd.cns.inf1": {
      source: "iana"
    },
    "audio/vnd.dece.audio": {
      source: "iana",
      extensions: ["uva", "uvva"]
    },
    "audio/vnd.digital-winds": {
      source: "iana",
      extensions: ["eol"]
    },
    "audio/vnd.dlna.adts": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.1": {
      source: "iana"
    },
    "audio/vnd.dolby.heaac.2": {
      source: "iana"
    },
    "audio/vnd.dolby.mlp": {
      source: "iana"
    },
    "audio/vnd.dolby.mps": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2x": {
      source: "iana"
    },
    "audio/vnd.dolby.pl2z": {
      source: "iana"
    },
    "audio/vnd.dolby.pulse.1": {
      source: "iana"
    },
    "audio/vnd.dra": {
      source: "iana",
      extensions: ["dra"]
    },
    "audio/vnd.dts": {
      source: "iana",
      extensions: ["dts"]
    },
    "audio/vnd.dts.hd": {
      source: "iana",
      extensions: ["dtshd"]
    },
    "audio/vnd.dts.uhd": {
      source: "iana"
    },
    "audio/vnd.dvb.file": {
      source: "iana"
    },
    "audio/vnd.everad.plj": {
      source: "iana"
    },
    "audio/vnd.hns.audio": {
      source: "iana"
    },
    "audio/vnd.lucent.voice": {
      source: "iana",
      extensions: ["lvp"]
    },
    "audio/vnd.ms-playready.media.pya": {
      source: "iana",
      extensions: ["pya"]
    },
    "audio/vnd.nokia.mobile-xmf": {
      source: "iana"
    },
    "audio/vnd.nortel.vbk": {
      source: "iana"
    },
    "audio/vnd.nuera.ecelp4800": {
      source: "iana",
      extensions: ["ecelp4800"]
    },
    "audio/vnd.nuera.ecelp7470": {
      source: "iana",
      extensions: ["ecelp7470"]
    },
    "audio/vnd.nuera.ecelp9600": {
      source: "iana",
      extensions: ["ecelp9600"]
    },
    "audio/vnd.octel.sbc": {
      source: "iana"
    },
    "audio/vnd.presonus.multitrack": {
      source: "iana"
    },
    "audio/vnd.qcelp": {
      source: "iana"
    },
    "audio/vnd.rhetorex.32kadpcm": {
      source: "iana"
    },
    "audio/vnd.rip": {
      source: "iana",
      extensions: ["rip"]
    },
    "audio/vnd.rn-realaudio": {
      compressible: false
    },
    "audio/vnd.sealedmedia.softseal.mpeg": {
      source: "iana"
    },
    "audio/vnd.vmx.cvsd": {
      source: "iana"
    },
    "audio/vnd.wave": {
      compressible: false
    },
    "audio/vorbis": {
      source: "iana",
      compressible: false
    },
    "audio/vorbis-config": {
      source: "iana"
    },
    "audio/wav": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/wave": {
      compressible: false,
      extensions: ["wav"]
    },
    "audio/webm": {
      source: "apache",
      compressible: false,
      extensions: ["weba"]
    },
    "audio/x-aac": {
      source: "apache",
      compressible: false,
      extensions: ["aac"]
    },
    "audio/x-aiff": {
      source: "apache",
      extensions: ["aif", "aiff", "aifc"]
    },
    "audio/x-caf": {
      source: "apache",
      compressible: false,
      extensions: ["caf"]
    },
    "audio/x-flac": {
      source: "apache",
      extensions: ["flac"]
    },
    "audio/x-m4a": {
      source: "nginx",
      extensions: ["m4a"]
    },
    "audio/x-matroska": {
      source: "apache",
      extensions: ["mka"]
    },
    "audio/x-mpegurl": {
      source: "apache",
      extensions: ["m3u"]
    },
    "audio/x-ms-wax": {
      source: "apache",
      extensions: ["wax"]
    },
    "audio/x-ms-wma": {
      source: "apache",
      extensions: ["wma"]
    },
    "audio/x-pn-realaudio": {
      source: "apache",
      extensions: ["ram", "ra"]
    },
    "audio/x-pn-realaudio-plugin": {
      source: "apache",
      extensions: ["rmp"]
    },
    "audio/x-realaudio": {
      source: "nginx",
      extensions: ["ra"]
    },
    "audio/x-tta": {
      source: "apache"
    },
    "audio/x-wav": {
      source: "apache",
      extensions: ["wav"]
    },
    "audio/xm": {
      source: "apache",
      extensions: ["xm"]
    },
    "chemical/x-cdx": {
      source: "apache",
      extensions: ["cdx"]
    },
    "chemical/x-cif": {
      source: "apache",
      extensions: ["cif"]
    },
    "chemical/x-cmdf": {
      source: "apache",
      extensions: ["cmdf"]
    },
    "chemical/x-cml": {
      source: "apache",
      extensions: ["cml"]
    },
    "chemical/x-csml": {
      source: "apache",
      extensions: ["csml"]
    },
    "chemical/x-pdb": {
      source: "apache"
    },
    "chemical/x-xyz": {
      source: "apache",
      extensions: ["xyz"]
    },
    "font/collection": {
      source: "iana",
      extensions: ["ttc"]
    },
    "font/otf": {
      source: "iana",
      compressible: true,
      extensions: ["otf"]
    },
    "font/sfnt": {
      source: "iana"
    },
    "font/ttf": {
      source: "iana",
      compressible: true,
      extensions: ["ttf"]
    },
    "font/woff": {
      source: "iana",
      extensions: ["woff"]
    },
    "font/woff2": {
      source: "iana",
      extensions: ["woff2"]
    },
    "image/aces": {
      source: "iana",
      extensions: ["exr"]
    },
    "image/apng": {
      compressible: false,
      extensions: ["apng"]
    },
    "image/avci": {
      source: "iana",
      extensions: ["avci"]
    },
    "image/avcs": {
      source: "iana",
      extensions: ["avcs"]
    },
    "image/avif": {
      source: "iana",
      compressible: false,
      extensions: ["avif"]
    },
    "image/bmp": {
      source: "iana",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/cgm": {
      source: "iana",
      extensions: ["cgm"]
    },
    "image/dicom-rle": {
      source: "iana",
      extensions: ["drle"]
    },
    "image/emf": {
      source: "iana",
      extensions: ["emf"]
    },
    "image/fits": {
      source: "iana",
      extensions: ["fits"]
    },
    "image/g3fax": {
      source: "iana",
      extensions: ["g3"]
    },
    "image/gif": {
      source: "iana",
      compressible: false,
      extensions: ["gif"]
    },
    "image/heic": {
      source: "iana",
      extensions: ["heic"]
    },
    "image/heic-sequence": {
      source: "iana",
      extensions: ["heics"]
    },
    "image/heif": {
      source: "iana",
      extensions: ["heif"]
    },
    "image/heif-sequence": {
      source: "iana",
      extensions: ["heifs"]
    },
    "image/hej2k": {
      source: "iana",
      extensions: ["hej2"]
    },
    "image/hsj2": {
      source: "iana",
      extensions: ["hsj2"]
    },
    "image/ief": {
      source: "iana",
      extensions: ["ief"]
    },
    "image/jls": {
      source: "iana",
      extensions: ["jls"]
    },
    "image/jp2": {
      source: "iana",
      compressible: false,
      extensions: ["jp2", "jpg2"]
    },
    "image/jpeg": {
      source: "iana",
      compressible: false,
      extensions: ["jpeg", "jpg", "jpe"]
    },
    "image/jph": {
      source: "iana",
      extensions: ["jph"]
    },
    "image/jphc": {
      source: "iana",
      extensions: ["jhc"]
    },
    "image/jpm": {
      source: "iana",
      compressible: false,
      extensions: ["jpm"]
    },
    "image/jpx": {
      source: "iana",
      compressible: false,
      extensions: ["jpx", "jpf"]
    },
    "image/jxr": {
      source: "iana",
      extensions: ["jxr"]
    },
    "image/jxra": {
      source: "iana",
      extensions: ["jxra"]
    },
    "image/jxrs": {
      source: "iana",
      extensions: ["jxrs"]
    },
    "image/jxs": {
      source: "iana",
      extensions: ["jxs"]
    },
    "image/jxsc": {
      source: "iana",
      extensions: ["jxsc"]
    },
    "image/jxsi": {
      source: "iana",
      extensions: ["jxsi"]
    },
    "image/jxss": {
      source: "iana",
      extensions: ["jxss"]
    },
    "image/ktx": {
      source: "iana",
      extensions: ["ktx"]
    },
    "image/ktx2": {
      source: "iana",
      extensions: ["ktx2"]
    },
    "image/naplps": {
      source: "iana"
    },
    "image/pjpeg": {
      compressible: false
    },
    "image/png": {
      source: "iana",
      compressible: false,
      extensions: ["png"]
    },
    "image/prs.btif": {
      source: "iana",
      extensions: ["btif"]
    },
    "image/prs.pti": {
      source: "iana",
      extensions: ["pti"]
    },
    "image/pwg-raster": {
      source: "iana"
    },
    "image/sgi": {
      source: "apache",
      extensions: ["sgi"]
    },
    "image/svg+xml": {
      source: "iana",
      compressible: true,
      extensions: ["svg", "svgz"]
    },
    "image/t38": {
      source: "iana",
      extensions: ["t38"]
    },
    "image/tiff": {
      source: "iana",
      compressible: false,
      extensions: ["tif", "tiff"]
    },
    "image/tiff-fx": {
      source: "iana",
      extensions: ["tfx"]
    },
    "image/vnd.adobe.photoshop": {
      source: "iana",
      compressible: true,
      extensions: ["psd"]
    },
    "image/vnd.airzip.accelerator.azv": {
      source: "iana",
      extensions: ["azv"]
    },
    "image/vnd.cns.inf2": {
      source: "iana"
    },
    "image/vnd.dece.graphic": {
      source: "iana",
      extensions: ["uvi", "uvvi", "uvg", "uvvg"]
    },
    "image/vnd.djvu": {
      source: "iana",
      extensions: ["djvu", "djv"]
    },
    "image/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "image/vnd.dwg": {
      source: "iana",
      extensions: ["dwg"]
    },
    "image/vnd.dxf": {
      source: "iana",
      extensions: ["dxf"]
    },
    "image/vnd.fastbidsheet": {
      source: "iana",
      extensions: ["fbs"]
    },
    "image/vnd.fpx": {
      source: "iana",
      extensions: ["fpx"]
    },
    "image/vnd.fst": {
      source: "iana",
      extensions: ["fst"]
    },
    "image/vnd.fujixerox.edmics-mmr": {
      source: "iana",
      extensions: ["mmr"]
    },
    "image/vnd.fujixerox.edmics-rlc": {
      source: "iana",
      extensions: ["rlc"]
    },
    "image/vnd.globalgraphics.pgb": {
      source: "iana"
    },
    "image/vnd.microsoft.icon": {
      source: "iana",
      compressible: true,
      extensions: ["ico"]
    },
    "image/vnd.mix": {
      source: "iana"
    },
    "image/vnd.mozilla.apng": {
      source: "iana"
    },
    "image/vnd.ms-dds": {
      compressible: true,
      extensions: ["dds"]
    },
    "image/vnd.ms-modi": {
      source: "iana",
      extensions: ["mdi"]
    },
    "image/vnd.ms-photo": {
      source: "apache",
      extensions: ["wdp"]
    },
    "image/vnd.net-fpx": {
      source: "iana",
      extensions: ["npx"]
    },
    "image/vnd.pco.b16": {
      source: "iana",
      extensions: ["b16"]
    },
    "image/vnd.radiance": {
      source: "iana"
    },
    "image/vnd.sealed.png": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.gif": {
      source: "iana"
    },
    "image/vnd.sealedmedia.softseal.jpg": {
      source: "iana"
    },
    "image/vnd.svf": {
      source: "iana"
    },
    "image/vnd.tencent.tap": {
      source: "iana",
      extensions: ["tap"]
    },
    "image/vnd.valve.source.texture": {
      source: "iana",
      extensions: ["vtf"]
    },
    "image/vnd.wap.wbmp": {
      source: "iana",
      extensions: ["wbmp"]
    },
    "image/vnd.xiff": {
      source: "iana",
      extensions: ["xif"]
    },
    "image/vnd.zbrush.pcx": {
      source: "iana",
      extensions: ["pcx"]
    },
    "image/webp": {
      source: "apache",
      extensions: ["webp"]
    },
    "image/wmf": {
      source: "iana",
      extensions: ["wmf"]
    },
    "image/x-3ds": {
      source: "apache",
      extensions: ["3ds"]
    },
    "image/x-cmu-raster": {
      source: "apache",
      extensions: ["ras"]
    },
    "image/x-cmx": {
      source: "apache",
      extensions: ["cmx"]
    },
    "image/x-freehand": {
      source: "apache",
      extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
    },
    "image/x-icon": {
      source: "apache",
      compressible: true,
      extensions: ["ico"]
    },
    "image/x-jng": {
      source: "nginx",
      extensions: ["jng"]
    },
    "image/x-mrsid-image": {
      source: "apache",
      extensions: ["sid"]
    },
    "image/x-ms-bmp": {
      source: "nginx",
      compressible: true,
      extensions: ["bmp"]
    },
    "image/x-pcx": {
      source: "apache",
      extensions: ["pcx"]
    },
    "image/x-pict": {
      source: "apache",
      extensions: ["pic", "pct"]
    },
    "image/x-portable-anymap": {
      source: "apache",
      extensions: ["pnm"]
    },
    "image/x-portable-bitmap": {
      source: "apache",
      extensions: ["pbm"]
    },
    "image/x-portable-graymap": {
      source: "apache",
      extensions: ["pgm"]
    },
    "image/x-portable-pixmap": {
      source: "apache",
      extensions: ["ppm"]
    },
    "image/x-rgb": {
      source: "apache",
      extensions: ["rgb"]
    },
    "image/x-tga": {
      source: "apache",
      extensions: ["tga"]
    },
    "image/x-xbitmap": {
      source: "apache",
      extensions: ["xbm"]
    },
    "image/x-xcf": {
      compressible: false
    },
    "image/x-xpixmap": {
      source: "apache",
      extensions: ["xpm"]
    },
    "image/x-xwindowdump": {
      source: "apache",
      extensions: ["xwd"]
    },
    "message/cpim": {
      source: "iana"
    },
    "message/delivery-status": {
      source: "iana"
    },
    "message/disposition-notification": {
      source: "iana",
      extensions: [
        "disposition-notification"
      ]
    },
    "message/external-body": {
      source: "iana"
    },
    "message/feedback-report": {
      source: "iana"
    },
    "message/global": {
      source: "iana",
      extensions: ["u8msg"]
    },
    "message/global-delivery-status": {
      source: "iana",
      extensions: ["u8dsn"]
    },
    "message/global-disposition-notification": {
      source: "iana",
      extensions: ["u8mdn"]
    },
    "message/global-headers": {
      source: "iana",
      extensions: ["u8hdr"]
    },
    "message/http": {
      source: "iana",
      compressible: false
    },
    "message/imdn+xml": {
      source: "iana",
      compressible: true
    },
    "message/news": {
      source: "iana"
    },
    "message/partial": {
      source: "iana",
      compressible: false
    },
    "message/rfc822": {
      source: "iana",
      compressible: true,
      extensions: ["eml", "mime"]
    },
    "message/s-http": {
      source: "iana"
    },
    "message/sip": {
      source: "iana"
    },
    "message/sipfrag": {
      source: "iana"
    },
    "message/tracking-status": {
      source: "iana"
    },
    "message/vnd.si.simp": {
      source: "iana"
    },
    "message/vnd.wfa.wsc": {
      source: "iana",
      extensions: ["wsc"]
    },
    "model/3mf": {
      source: "iana",
      extensions: ["3mf"]
    },
    "model/e57": {
      source: "iana"
    },
    "model/gltf+json": {
      source: "iana",
      compressible: true,
      extensions: ["gltf"]
    },
    "model/gltf-binary": {
      source: "iana",
      compressible: true,
      extensions: ["glb"]
    },
    "model/iges": {
      source: "iana",
      compressible: false,
      extensions: ["igs", "iges"]
    },
    "model/mesh": {
      source: "iana",
      compressible: false,
      extensions: ["msh", "mesh", "silo"]
    },
    "model/mtl": {
      source: "iana",
      extensions: ["mtl"]
    },
    "model/obj": {
      source: "iana",
      extensions: ["obj"]
    },
    "model/step": {
      source: "iana"
    },
    "model/step+xml": {
      source: "iana",
      compressible: true,
      extensions: ["stpx"]
    },
    "model/step+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpz"]
    },
    "model/step-xml+zip": {
      source: "iana",
      compressible: false,
      extensions: ["stpxz"]
    },
    "model/stl": {
      source: "iana",
      extensions: ["stl"]
    },
    "model/vnd.collada+xml": {
      source: "iana",
      compressible: true,
      extensions: ["dae"]
    },
    "model/vnd.dwf": {
      source: "iana",
      extensions: ["dwf"]
    },
    "model/vnd.flatland.3dml": {
      source: "iana"
    },
    "model/vnd.gdl": {
      source: "iana",
      extensions: ["gdl"]
    },
    "model/vnd.gs-gdl": {
      source: "apache"
    },
    "model/vnd.gs.gdl": {
      source: "iana"
    },
    "model/vnd.gtw": {
      source: "iana",
      extensions: ["gtw"]
    },
    "model/vnd.moml+xml": {
      source: "iana",
      compressible: true
    },
    "model/vnd.mts": {
      source: "iana",
      extensions: ["mts"]
    },
    "model/vnd.opengex": {
      source: "iana",
      extensions: ["ogex"]
    },
    "model/vnd.parasolid.transmit.binary": {
      source: "iana",
      extensions: ["x_b"]
    },
    "model/vnd.parasolid.transmit.text": {
      source: "iana",
      extensions: ["x_t"]
    },
    "model/vnd.pytha.pyox": {
      source: "iana"
    },
    "model/vnd.rosette.annotated-data-model": {
      source: "iana"
    },
    "model/vnd.sap.vds": {
      source: "iana",
      extensions: ["vds"]
    },
    "model/vnd.usdz+zip": {
      source: "iana",
      compressible: false,
      extensions: ["usdz"]
    },
    "model/vnd.valve.source.compiled-map": {
      source: "iana",
      extensions: ["bsp"]
    },
    "model/vnd.vtu": {
      source: "iana",
      extensions: ["vtu"]
    },
    "model/vrml": {
      source: "iana",
      compressible: false,
      extensions: ["wrl", "vrml"]
    },
    "model/x3d+binary": {
      source: "apache",
      compressible: false,
      extensions: ["x3db", "x3dbz"]
    },
    "model/x3d+fastinfoset": {
      source: "iana",
      extensions: ["x3db"]
    },
    "model/x3d+vrml": {
      source: "apache",
      compressible: false,
      extensions: ["x3dv", "x3dvz"]
    },
    "model/x3d+xml": {
      source: "iana",
      compressible: true,
      extensions: ["x3d", "x3dz"]
    },
    "model/x3d-vrml": {
      source: "iana",
      extensions: ["x3dv"]
    },
    "multipart/alternative": {
      source: "iana",
      compressible: false
    },
    "multipart/appledouble": {
      source: "iana"
    },
    "multipart/byteranges": {
      source: "iana"
    },
    "multipart/digest": {
      source: "iana"
    },
    "multipart/encrypted": {
      source: "iana",
      compressible: false
    },
    "multipart/form-data": {
      source: "iana",
      compressible: false
    },
    "multipart/header-set": {
      source: "iana"
    },
    "multipart/mixed": {
      source: "iana"
    },
    "multipart/multilingual": {
      source: "iana"
    },
    "multipart/parallel": {
      source: "iana"
    },
    "multipart/related": {
      source: "iana",
      compressible: false
    },
    "multipart/report": {
      source: "iana"
    },
    "multipart/signed": {
      source: "iana",
      compressible: false
    },
    "multipart/vnd.bint.med-plus": {
      source: "iana"
    },
    "multipart/voice-message": {
      source: "iana"
    },
    "multipart/x-mixed-replace": {
      source: "iana"
    },
    "text/1d-interleaved-parityfec": {
      source: "iana"
    },
    "text/cache-manifest": {
      source: "iana",
      compressible: true,
      extensions: ["appcache", "manifest"]
    },
    "text/calendar": {
      source: "iana",
      extensions: ["ics", "ifb"]
    },
    "text/calender": {
      compressible: true
    },
    "text/cmd": {
      compressible: true
    },
    "text/coffeescript": {
      extensions: ["coffee", "litcoffee"]
    },
    "text/cql": {
      source: "iana"
    },
    "text/cql-expression": {
      source: "iana"
    },
    "text/cql-identifier": {
      source: "iana"
    },
    "text/css": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["css"]
    },
    "text/csv": {
      source: "iana",
      compressible: true,
      extensions: ["csv"]
    },
    "text/csv-schema": {
      source: "iana"
    },
    "text/directory": {
      source: "iana"
    },
    "text/dns": {
      source: "iana"
    },
    "text/ecmascript": {
      source: "iana"
    },
    "text/encaprtp": {
      source: "iana"
    },
    "text/enriched": {
      source: "iana"
    },
    "text/fhirpath": {
      source: "iana"
    },
    "text/flexfec": {
      source: "iana"
    },
    "text/fwdred": {
      source: "iana"
    },
    "text/gff3": {
      source: "iana"
    },
    "text/grammar-ref-list": {
      source: "iana"
    },
    "text/html": {
      source: "iana",
      compressible: true,
      extensions: ["html", "htm", "shtml"]
    },
    "text/jade": {
      extensions: ["jade"]
    },
    "text/javascript": {
      source: "iana",
      compressible: true
    },
    "text/jcr-cnd": {
      source: "iana"
    },
    "text/jsx": {
      compressible: true,
      extensions: ["jsx"]
    },
    "text/less": {
      compressible: true,
      extensions: ["less"]
    },
    "text/markdown": {
      source: "iana",
      compressible: true,
      extensions: ["markdown", "md"]
    },
    "text/mathml": {
      source: "nginx",
      extensions: ["mml"]
    },
    "text/mdx": {
      compressible: true,
      extensions: ["mdx"]
    },
    "text/mizar": {
      source: "iana"
    },
    "text/n3": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["n3"]
    },
    "text/parameters": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/parityfec": {
      source: "iana"
    },
    "text/plain": {
      source: "iana",
      compressible: true,
      extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
    },
    "text/provenance-notation": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/prs.fallenstein.rst": {
      source: "iana"
    },
    "text/prs.lines.tag": {
      source: "iana",
      extensions: ["dsc"]
    },
    "text/prs.prop.logic": {
      source: "iana"
    },
    "text/raptorfec": {
      source: "iana"
    },
    "text/red": {
      source: "iana"
    },
    "text/rfc822-headers": {
      source: "iana"
    },
    "text/richtext": {
      source: "iana",
      compressible: true,
      extensions: ["rtx"]
    },
    "text/rtf": {
      source: "iana",
      compressible: true,
      extensions: ["rtf"]
    },
    "text/rtp-enc-aescm128": {
      source: "iana"
    },
    "text/rtploopback": {
      source: "iana"
    },
    "text/rtx": {
      source: "iana"
    },
    "text/sgml": {
      source: "iana",
      extensions: ["sgml", "sgm"]
    },
    "text/shaclc": {
      source: "iana"
    },
    "text/shex": {
      source: "iana",
      extensions: ["shex"]
    },
    "text/slim": {
      extensions: ["slim", "slm"]
    },
    "text/spdx": {
      source: "iana",
      extensions: ["spdx"]
    },
    "text/strings": {
      source: "iana"
    },
    "text/stylus": {
      extensions: ["stylus", "styl"]
    },
    "text/t140": {
      source: "iana"
    },
    "text/tab-separated-values": {
      source: "iana",
      compressible: true,
      extensions: ["tsv"]
    },
    "text/troff": {
      source: "iana",
      extensions: ["t", "tr", "roff", "man", "me", "ms"]
    },
    "text/turtle": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["ttl"]
    },
    "text/ulpfec": {
      source: "iana"
    },
    "text/uri-list": {
      source: "iana",
      compressible: true,
      extensions: ["uri", "uris", "urls"]
    },
    "text/vcard": {
      source: "iana",
      compressible: true,
      extensions: ["vcard"]
    },
    "text/vnd.a": {
      source: "iana"
    },
    "text/vnd.abc": {
      source: "iana"
    },
    "text/vnd.ascii-art": {
      source: "iana"
    },
    "text/vnd.curl": {
      source: "iana",
      extensions: ["curl"]
    },
    "text/vnd.curl.dcurl": {
      source: "apache",
      extensions: ["dcurl"]
    },
    "text/vnd.curl.mcurl": {
      source: "apache",
      extensions: ["mcurl"]
    },
    "text/vnd.curl.scurl": {
      source: "apache",
      extensions: ["scurl"]
    },
    "text/vnd.debian.copyright": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.dmclientscript": {
      source: "iana"
    },
    "text/vnd.dvb.subtitle": {
      source: "iana",
      extensions: ["sub"]
    },
    "text/vnd.esmertec.theme-descriptor": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.familysearch.gedcom": {
      source: "iana",
      extensions: ["ged"]
    },
    "text/vnd.ficlab.flt": {
      source: "iana"
    },
    "text/vnd.fly": {
      source: "iana",
      extensions: ["fly"]
    },
    "text/vnd.fmi.flexstor": {
      source: "iana",
      extensions: ["flx"]
    },
    "text/vnd.gml": {
      source: "iana"
    },
    "text/vnd.graphviz": {
      source: "iana",
      extensions: ["gv"]
    },
    "text/vnd.hans": {
      source: "iana"
    },
    "text/vnd.hgl": {
      source: "iana"
    },
    "text/vnd.in3d.3dml": {
      source: "iana",
      extensions: ["3dml"]
    },
    "text/vnd.in3d.spot": {
      source: "iana",
      extensions: ["spot"]
    },
    "text/vnd.iptc.newsml": {
      source: "iana"
    },
    "text/vnd.iptc.nitf": {
      source: "iana"
    },
    "text/vnd.latex-z": {
      source: "iana"
    },
    "text/vnd.motorola.reflex": {
      source: "iana"
    },
    "text/vnd.ms-mediapackage": {
      source: "iana"
    },
    "text/vnd.net2phone.commcenter.command": {
      source: "iana"
    },
    "text/vnd.radisys.msml-basic-layout": {
      source: "iana"
    },
    "text/vnd.senx.warpscript": {
      source: "iana"
    },
    "text/vnd.si.uricatalogue": {
      source: "iana"
    },
    "text/vnd.sosi": {
      source: "iana"
    },
    "text/vnd.sun.j2me.app-descriptor": {
      source: "iana",
      charset: "UTF-8",
      extensions: ["jad"]
    },
    "text/vnd.trolltech.linguist": {
      source: "iana",
      charset: "UTF-8"
    },
    "text/vnd.wap.si": {
      source: "iana"
    },
    "text/vnd.wap.sl": {
      source: "iana"
    },
    "text/vnd.wap.wml": {
      source: "iana",
      extensions: ["wml"]
    },
    "text/vnd.wap.wmlscript": {
      source: "iana",
      extensions: ["wmls"]
    },
    "text/vtt": {
      source: "iana",
      charset: "UTF-8",
      compressible: true,
      extensions: ["vtt"]
    },
    "text/x-asm": {
      source: "apache",
      extensions: ["s", "asm"]
    },
    "text/x-c": {
      source: "apache",
      extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
    },
    "text/x-component": {
      source: "nginx",
      extensions: ["htc"]
    },
    "text/x-fortran": {
      source: "apache",
      extensions: ["f", "for", "f77", "f90"]
    },
    "text/x-gwt-rpc": {
      compressible: true
    },
    "text/x-handlebars-template": {
      extensions: ["hbs"]
    },
    "text/x-java-source": {
      source: "apache",
      extensions: ["java"]
    },
    "text/x-jquery-tmpl": {
      compressible: true
    },
    "text/x-lua": {
      extensions: ["lua"]
    },
    "text/x-markdown": {
      compressible: true,
      extensions: ["mkd"]
    },
    "text/x-nfo": {
      source: "apache",
      extensions: ["nfo"]
    },
    "text/x-opml": {
      source: "apache",
      extensions: ["opml"]
    },
    "text/x-org": {
      compressible: true,
      extensions: ["org"]
    },
    "text/x-pascal": {
      source: "apache",
      extensions: ["p", "pas"]
    },
    "text/x-processing": {
      compressible: true,
      extensions: ["pde"]
    },
    "text/x-sass": {
      extensions: ["sass"]
    },
    "text/x-scss": {
      extensions: ["scss"]
    },
    "text/x-setext": {
      source: "apache",
      extensions: ["etx"]
    },
    "text/x-sfv": {
      source: "apache",
      extensions: ["sfv"]
    },
    "text/x-suse-ymp": {
      compressible: true,
      extensions: ["ymp"]
    },
    "text/x-uuencode": {
      source: "apache",
      extensions: ["uu"]
    },
    "text/x-vcalendar": {
      source: "apache",
      extensions: ["vcs"]
    },
    "text/x-vcard": {
      source: "apache",
      extensions: ["vcf"]
    },
    "text/xml": {
      source: "iana",
      compressible: true,
      extensions: ["xml"]
    },
    "text/xml-external-parsed-entity": {
      source: "iana"
    },
    "text/yaml": {
      compressible: true,
      extensions: ["yaml", "yml"]
    },
    "video/1d-interleaved-parityfec": {
      source: "iana"
    },
    "video/3gpp": {
      source: "iana",
      extensions: ["3gp", "3gpp"]
    },
    "video/3gpp-tt": {
      source: "iana"
    },
    "video/3gpp2": {
      source: "iana",
      extensions: ["3g2"]
    },
    "video/av1": {
      source: "iana"
    },
    "video/bmpeg": {
      source: "iana"
    },
    "video/bt656": {
      source: "iana"
    },
    "video/celb": {
      source: "iana"
    },
    "video/dv": {
      source: "iana"
    },
    "video/encaprtp": {
      source: "iana"
    },
    "video/ffv1": {
      source: "iana"
    },
    "video/flexfec": {
      source: "iana"
    },
    "video/h261": {
      source: "iana",
      extensions: ["h261"]
    },
    "video/h263": {
      source: "iana",
      extensions: ["h263"]
    },
    "video/h263-1998": {
      source: "iana"
    },
    "video/h263-2000": {
      source: "iana"
    },
    "video/h264": {
      source: "iana",
      extensions: ["h264"]
    },
    "video/h264-rcdo": {
      source: "iana"
    },
    "video/h264-svc": {
      source: "iana"
    },
    "video/h265": {
      source: "iana"
    },
    "video/iso.segment": {
      source: "iana",
      extensions: ["m4s"]
    },
    "video/jpeg": {
      source: "iana",
      extensions: ["jpgv"]
    },
    "video/jpeg2000": {
      source: "iana"
    },
    "video/jpm": {
      source: "apache",
      extensions: ["jpm", "jpgm"]
    },
    "video/jxsv": {
      source: "iana"
    },
    "video/mj2": {
      source: "iana",
      extensions: ["mj2", "mjp2"]
    },
    "video/mp1s": {
      source: "iana"
    },
    "video/mp2p": {
      source: "iana"
    },
    "video/mp2t": {
      source: "iana",
      extensions: ["ts"]
    },
    "video/mp4": {
      source: "iana",
      compressible: false,
      extensions: ["mp4", "mp4v", "mpg4"]
    },
    "video/mp4v-es": {
      source: "iana"
    },
    "video/mpeg": {
      source: "iana",
      compressible: false,
      extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
    },
    "video/mpeg4-generic": {
      source: "iana"
    },
    "video/mpv": {
      source: "iana"
    },
    "video/nv": {
      source: "iana"
    },
    "video/ogg": {
      source: "iana",
      compressible: false,
      extensions: ["ogv"]
    },
    "video/parityfec": {
      source: "iana"
    },
    "video/pointer": {
      source: "iana"
    },
    "video/quicktime": {
      source: "iana",
      compressible: false,
      extensions: ["qt", "mov"]
    },
    "video/raptorfec": {
      source: "iana"
    },
    "video/raw": {
      source: "iana"
    },
    "video/rtp-enc-aescm128": {
      source: "iana"
    },
    "video/rtploopback": {
      source: "iana"
    },
    "video/rtx": {
      source: "iana"
    },
    "video/scip": {
      source: "iana"
    },
    "video/smpte291": {
      source: "iana"
    },
    "video/smpte292m": {
      source: "iana"
    },
    "video/ulpfec": {
      source: "iana"
    },
    "video/vc1": {
      source: "iana"
    },
    "video/vc2": {
      source: "iana"
    },
    "video/vnd.cctv": {
      source: "iana"
    },
    "video/vnd.dece.hd": {
      source: "iana",
      extensions: ["uvh", "uvvh"]
    },
    "video/vnd.dece.mobile": {
      source: "iana",
      extensions: ["uvm", "uvvm"]
    },
    "video/vnd.dece.mp4": {
      source: "iana"
    },
    "video/vnd.dece.pd": {
      source: "iana",
      extensions: ["uvp", "uvvp"]
    },
    "video/vnd.dece.sd": {
      source: "iana",
      extensions: ["uvs", "uvvs"]
    },
    "video/vnd.dece.video": {
      source: "iana",
      extensions: ["uvv", "uvvv"]
    },
    "video/vnd.directv.mpeg": {
      source: "iana"
    },
    "video/vnd.directv.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dlna.mpeg-tts": {
      source: "iana"
    },
    "video/vnd.dvb.file": {
      source: "iana",
      extensions: ["dvb"]
    },
    "video/vnd.fvt": {
      source: "iana",
      extensions: ["fvt"]
    },
    "video/vnd.hns.video": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.1dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-1010": {
      source: "iana"
    },
    "video/vnd.iptvforum.2dparityfec-2005": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsavc": {
      source: "iana"
    },
    "video/vnd.iptvforum.ttsmpeg2": {
      source: "iana"
    },
    "video/vnd.motorola.video": {
      source: "iana"
    },
    "video/vnd.motorola.videop": {
      source: "iana"
    },
    "video/vnd.mpegurl": {
      source: "iana",
      extensions: ["mxu", "m4u"]
    },
    "video/vnd.ms-playready.media.pyv": {
      source: "iana",
      extensions: ["pyv"]
    },
    "video/vnd.nokia.interleaved-multimedia": {
      source: "iana"
    },
    "video/vnd.nokia.mp4vr": {
      source: "iana"
    },
    "video/vnd.nokia.videovoip": {
      source: "iana"
    },
    "video/vnd.objectvideo": {
      source: "iana"
    },
    "video/vnd.radgamettools.bink": {
      source: "iana"
    },
    "video/vnd.radgamettools.smacker": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg1": {
      source: "iana"
    },
    "video/vnd.sealed.mpeg4": {
      source: "iana"
    },
    "video/vnd.sealed.swf": {
      source: "iana"
    },
    "video/vnd.sealedmedia.softseal.mov": {
      source: "iana"
    },
    "video/vnd.uvvu.mp4": {
      source: "iana",
      extensions: ["uvu", "uvvu"]
    },
    "video/vnd.vivo": {
      source: "iana",
      extensions: ["viv"]
    },
    "video/vnd.youtube.yt": {
      source: "iana"
    },
    "video/vp8": {
      source: "iana"
    },
    "video/vp9": {
      source: "iana"
    },
    "video/webm": {
      source: "apache",
      compressible: false,
      extensions: ["webm"]
    },
    "video/x-f4v": {
      source: "apache",
      extensions: ["f4v"]
    },
    "video/x-fli": {
      source: "apache",
      extensions: ["fli"]
    },
    "video/x-flv": {
      source: "apache",
      compressible: false,
      extensions: ["flv"]
    },
    "video/x-m4v": {
      source: "apache",
      extensions: ["m4v"]
    },
    "video/x-matroska": {
      source: "apache",
      compressible: false,
      extensions: ["mkv", "mk3d", "mks"]
    },
    "video/x-mng": {
      source: "apache",
      extensions: ["mng"]
    },
    "video/x-ms-asf": {
      source: "apache",
      extensions: ["asf", "asx"]
    },
    "video/x-ms-vob": {
      source: "apache",
      extensions: ["vob"]
    },
    "video/x-ms-wm": {
      source: "apache",
      extensions: ["wm"]
    },
    "video/x-ms-wmv": {
      source: "apache",
      compressible: false,
      extensions: ["wmv"]
    },
    "video/x-ms-wmx": {
      source: "apache",
      extensions: ["wmx"]
    },
    "video/x-ms-wvx": {
      source: "apache",
      extensions: ["wvx"]
    },
    "video/x-msvideo": {
      source: "apache",
      extensions: ["avi"]
    },
    "video/x-sgi-movie": {
      source: "apache",
      extensions: ["movie"]
    },
    "video/x-smv": {
      source: "apache",
      extensions: ["smv"]
    },
    "x-conference/x-cooltalk": {
      source: "apache",
      extensions: ["ice"]
    },
    "x-shader/x-fragment": {
      compressible: true
    },
    "x-shader/x-vertex": {
      compressible: true
    }
  };
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS((exports, module) => {
  /*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = require_db();
});

// node:path
var exports_path = {};
__export(exports_path, {
  win32: () => y3,
  toNamespacedPath: () => U2,
  sep: () => I4,
  resolve: () => B3,
  relative: () => Q4,
  posix: () => g3,
  parse: () => $,
  normalize: () => G2,
  join: () => K4,
  isAbsolute: () => H3,
  format: () => Z3,
  extname: () => Y4,
  dirname: () => V4,
  delimiter: () => O2,
  default: () => q,
  basename: () => X4
});
var L3, h3, D2, T2, _4, E6, R2 = (s3, e) => () => (e || s3((e = { exports: {} }).exports, e), e.exports), N5 = (s3, e, r, t) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let i of T2(e))
      !E6.call(s3, i) && i !== r && h3(s3, i, { get: () => e[i], enumerable: !(t = D2(e, i)) || t.enumerable });
  return s3;
}, j4 = (s3, e, r) => (r = s3 != null ? L3(_4(s3)) : {}, N5(e || !s3 || !s3.__esModule ? h3(r, "default", { value: s3, enumerable: true }) : r, s3)), k4, x3, u2, J3, P2 = function(s3) {
  return s3;
}, S2 = function() {
  throw new Error("Not implemented");
}, g3, y3, q, B3, G2, H3, K4, Q4, U2, V4, X4, Y4, Z3, $, I4, O2;
var init_path = __esm(() => {
  L3 = Object.create;
  h3 = Object.defineProperty;
  D2 = Object.getOwnPropertyDescriptor;
  T2 = Object.getOwnPropertyNames;
  _4 = Object.getPrototypeOf;
  E6 = Object.prototype.hasOwnProperty;
  k4 = R2((W, w3) => {
    function v2(s3) {
      if (typeof s3 != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(s3));
    }
    function C3(s3, e) {
      for (var r = "", t = 0, i = -1, a3 = 0, n, l3 = 0;l3 <= s3.length; ++l3) {
        if (l3 < s3.length)
          n = s3.charCodeAt(l3);
        else {
          if (n === 47)
            break;
          n = 47;
        }
        if (n === 47) {
          if (!(i === l3 - 1 || a3 === 1))
            if (i !== l3 - 1 && a3 === 2) {
              if (r.length < 2 || t !== 2 || r.charCodeAt(r.length - 1) !== 46 || r.charCodeAt(r.length - 2) !== 46) {
                if (r.length > 2) {
                  var f2 = r.lastIndexOf("/");
                  if (f2 !== r.length - 1) {
                    f2 === -1 ? (r = "", t = 0) : (r = r.slice(0, f2), t = r.length - 1 - r.lastIndexOf("/")), i = l3, a3 = 0;
                    continue;
                  }
                } else if (r.length === 2 || r.length === 1) {
                  r = "", t = 0, i = l3, a3 = 0;
                  continue;
                }
              }
              e && (r.length > 0 ? r += "/.." : r = "..", t = 2);
            } else
              r.length > 0 ? r += "/" + s3.slice(i + 1, l3) : r = s3.slice(i + 1, l3), t = l3 - i - 1;
          i = l3, a3 = 0;
        } else
          n === 46 && a3 !== -1 ? ++a3 : a3 = -1;
      }
      return r;
    }
    function F3(s3, e) {
      var r = e.dir || e.root, t = e.base || (e.name || "") + (e.ext || "");
      return r ? r === e.root ? r + t : r + s3 + t : t;
    }
    var m4 = { resolve: function() {
      for (var e = "", r = false, t, i = arguments.length - 1;i >= -1 && !r; i--) {
        var a3;
        i >= 0 ? a3 = arguments[i] : (t === undefined && (t = process.cwd()), a3 = t), v2(a3), a3.length !== 0 && (e = a3 + "/" + e, r = a3.charCodeAt(0) === 47);
      }
      return e = C3(e, !r), r ? e.length > 0 ? "/" + e : "/" : e.length > 0 ? e : ".";
    }, normalize: function(e) {
      if (v2(e), e.length === 0)
        return ".";
      var r = e.charCodeAt(0) === 47, t = e.charCodeAt(e.length - 1) === 47;
      return e = C3(e, !r), e.length === 0 && !r && (e = "."), e.length > 0 && t && (e += "/"), r ? "/" + e : e;
    }, isAbsolute: function(e) {
      return v2(e), e.length > 0 && e.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var e, r = 0;r < arguments.length; ++r) {
        var t = arguments[r];
        v2(t), t.length > 0 && (e === undefined ? e = t : e += "/" + t);
      }
      return e === undefined ? "." : m4.normalize(e);
    }, relative: function(e, r) {
      if (v2(e), v2(r), e === r || (e = m4.resolve(e), r = m4.resolve(r), e === r))
        return "";
      for (var t = 1;t < e.length && e.charCodeAt(t) === 47; ++t)
        ;
      for (var i = e.length, a3 = i - t, n = 1;n < r.length && r.charCodeAt(n) === 47; ++n)
        ;
      for (var l3 = r.length, f2 = l3 - n, c2 = a3 < f2 ? a3 : f2, d4 = -1, o2 = 0;o2 <= c2; ++o2) {
        if (o2 === c2) {
          if (f2 > c2) {
            if (r.charCodeAt(n + o2) === 47)
              return r.slice(n + o2 + 1);
            if (o2 === 0)
              return r.slice(n + o2);
          } else
            a3 > c2 && (e.charCodeAt(t + o2) === 47 ? d4 = o2 : o2 === 0 && (d4 = 0));
          break;
        }
        var A4 = e.charCodeAt(t + o2), z = r.charCodeAt(n + o2);
        if (A4 !== z)
          break;
        A4 === 47 && (d4 = o2);
      }
      var b5 = "";
      for (o2 = t + d4 + 1;o2 <= i; ++o2)
        (o2 === i || e.charCodeAt(o2) === 47) && (b5.length === 0 ? b5 += ".." : b5 += "/..");
      return b5.length > 0 ? b5 + r.slice(n + d4) : (n += d4, r.charCodeAt(n) === 47 && ++n, r.slice(n));
    }, _makeLong: function(e) {
      return e;
    }, dirname: function(e) {
      if (v2(e), e.length === 0)
        return ".";
      for (var r = e.charCodeAt(0), t = r === 47, i = -1, a3 = true, n = e.length - 1;n >= 1; --n)
        if (r = e.charCodeAt(n), r === 47) {
          if (!a3) {
            i = n;
            break;
          }
        } else
          a3 = false;
      return i === -1 ? t ? "/" : "." : t && i === 1 ? "//" : e.slice(0, i);
    }, basename: function(e, r) {
      if (r !== undefined && typeof r != "string")
        throw new TypeError('"ext" argument must be a string');
      v2(e);
      var t = 0, i = -1, a3 = true, n;
      if (r !== undefined && r.length > 0 && r.length <= e.length) {
        if (r.length === e.length && r === e)
          return "";
        var l3 = r.length - 1, f2 = -1;
        for (n = e.length - 1;n >= 0; --n) {
          var c2 = e.charCodeAt(n);
          if (c2 === 47) {
            if (!a3) {
              t = n + 1;
              break;
            }
          } else
            f2 === -1 && (a3 = false, f2 = n + 1), l3 >= 0 && (c2 === r.charCodeAt(l3) ? --l3 === -1 && (i = n) : (l3 = -1, i = f2));
        }
        return t === i ? i = f2 : i === -1 && (i = e.length), e.slice(t, i);
      } else {
        for (n = e.length - 1;n >= 0; --n)
          if (e.charCodeAt(n) === 47) {
            if (!a3) {
              t = n + 1;
              break;
            }
          } else
            i === -1 && (a3 = false, i = n + 1);
        return i === -1 ? "" : e.slice(t, i);
      }
    }, extname: function(e) {
      v2(e);
      for (var r = -1, t = 0, i = -1, a3 = true, n = 0, l3 = e.length - 1;l3 >= 0; --l3) {
        var f2 = e.charCodeAt(l3);
        if (f2 === 47) {
          if (!a3) {
            t = l3 + 1;
            break;
          }
          continue;
        }
        i === -1 && (a3 = false, i = l3 + 1), f2 === 46 ? r === -1 ? r = l3 : n !== 1 && (n = 1) : r !== -1 && (n = -1);
      }
      return r === -1 || i === -1 || n === 0 || n === 1 && r === i - 1 && r === t + 1 ? "" : e.slice(r, i);
    }, format: function(e) {
      if (e === null || typeof e != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e);
      return F3("/", e);
    }, parse: function(e) {
      v2(e);
      var r = { root: "", dir: "", base: "", ext: "", name: "" };
      if (e.length === 0)
        return r;
      var t = e.charCodeAt(0), i = t === 47, a3;
      i ? (r.root = "/", a3 = 1) : a3 = 0;
      for (var n = -1, l3 = 0, f2 = -1, c2 = true, d4 = e.length - 1, o2 = 0;d4 >= a3; --d4) {
        if (t = e.charCodeAt(d4), t === 47) {
          if (!c2) {
            l3 = d4 + 1;
            break;
          }
          continue;
        }
        f2 === -1 && (c2 = false, f2 = d4 + 1), t === 46 ? n === -1 ? n = d4 : o2 !== 1 && (o2 = 1) : n !== -1 && (o2 = -1);
      }
      return n === -1 || f2 === -1 || o2 === 0 || o2 === 1 && n === f2 - 1 && n === l3 + 1 ? f2 !== -1 && (l3 === 0 && i ? r.base = r.name = e.slice(1, f2) : r.base = r.name = e.slice(l3, f2)) : (l3 === 0 && i ? (r.name = e.slice(1, n), r.base = e.slice(1, f2)) : (r.name = e.slice(l3, n), r.base = e.slice(l3, f2)), r.ext = e.slice(n, f2)), l3 > 0 ? r.dir = e.slice(0, l3 - 1) : i && (r.dir = "/"), r;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    m4.posix = m4;
    w3.exports = m4;
  });
  x3 = j4(k4());
  u2 = x3;
  J3 = x3;
  u2.parse ??= S2;
  J3.parse ??= S2;
  g3 = { resolve: u2.resolve.bind(u2), normalize: u2.normalize.bind(u2), isAbsolute: u2.isAbsolute.bind(u2), join: u2.join.bind(u2), relative: u2.relative.bind(u2), toNamespacedPath: P2, dirname: u2.dirname.bind(u2), basename: u2.basename.bind(u2), extname: u2.extname.bind(u2), format: u2.format.bind(u2), parse: u2.parse.bind(u2), sep: "/", delimiter: ":", win32: undefined, posix: undefined, _makeLong: P2 };
  y3 = { sep: "\\", delimiter: ";", win32: undefined, ...g3, posix: g3 };
  g3.win32 = y3.win32 = y3;
  g3.posix = g3;
  q = g3;
  ({ resolve: B3, normalize: G2, isAbsolute: H3, join: K4, relative: Q4, toNamespacedPath: U2, dirname: V4, basename: X4, extname: Y4, format: Z3, parse: $, sep: I4, delimiter: O2 } = g3);
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS((exports) => {
  /*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var db2 = require_mime_db();
  var extname = (init_path(), __toCommonJS(exports_path)).extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset;
  exports.charsets = { lookup: charset };
  exports.contentType = contentType;
  exports.extension = extension;
  exports.extensions = Object.create(null);
  exports.lookup = lookup;
  exports.types = Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db2[match[1].toLowerCase()];
    if (mime && mime.charset) {
      return mime.charset;
    }
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType(str) {
    if (!str || typeof str !== "string") {
      return false;
    }
    var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
    if (!mime) {
      return false;
    }
    if (mime.indexOf("charset") === -1) {
      var charset2 = exports.charset(mime);
      if (charset2)
        mime += "; charset=" + charset2.toLowerCase();
    }
    return mime;
  }
  function extension(type) {
    if (!type || typeof type !== "string") {
      return false;
    }
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup(path) {
    if (!path || typeof path !== "string") {
      return false;
    }
    var extension2 = extname("x." + path).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions, types) {
    var preference = ["nginx", "apache", undefined, "iana"];
    Object.keys(db2).forEach(function forEachMimeType(type) {
      var mime = db2[type];
      var exts = mime.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions[type] = exts;
      for (var i = 0;i < exts.length; i++) {
        var extension2 = exts[i];
        if (types[extension2]) {
          var from = preference.indexOf(db2[types[extension2]].source);
          var to2 = preference.indexOf(mime.source);
          if (types[extension2] !== "application/octet-stream" && (from > to2 || from === to2 && types[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types[extension2] = type;
      }
    });
  }
});

// node_modules/type-is/index.js
var require_type_is = __commonJS((exports, module) => {
  /*!
   * type-is
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var typer = require_media_typer();
  var mime = require_mime_types();
  module.exports = typeofrequest;
  module.exports.is = typeis;
  module.exports.hasBody = hasbody;
  module.exports.normalize = normalize;
  module.exports.match = mimeMatch;
  function typeis(value, types_) {
    var i;
    var types = types_;
    var val = tryNormalizeType(value);
    if (!val) {
      return false;
    }
    if (types && !Array.isArray(types)) {
      types = new Array(arguments.length - 1);
      for (i = 0;i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    if (!types || !types.length) {
      return val;
    }
    var type;
    for (i = 0;i < types.length; i++) {
      if (mimeMatch(normalize(type = types[i]), val)) {
        return type[0] === "+" || type.indexOf("*") !== -1 ? val : type;
      }
    }
    return false;
  }
  function hasbody(req) {
    return req.headers["transfer-encoding"] !== undefined || !isNaN(req.headers["content-length"]);
  }
  function typeofrequest(req, types_) {
    var types = types_;
    if (!hasbody(req)) {
      return null;
    }
    if (arguments.length > 2) {
      types = new Array(arguments.length - 1);
      for (var i = 0;i < types.length; i++) {
        types[i] = arguments[i + 1];
      }
    }
    var value = req.headers["content-type"];
    return typeis(value, types);
  }
  function normalize(type) {
    if (typeof type !== "string") {
      return false;
    }
    switch (type) {
      case "urlencoded":
        return "application/x-www-form-urlencoded";
      case "multipart":
        return "multipart/*";
    }
    if (type[0] === "+") {
      return "*/*" + type;
    }
    return type.indexOf("/") === -1 ? mime.lookup(type) : type;
  }
  function mimeMatch(expected, actual) {
    if (expected === false) {
      return false;
    }
    var actualParts = actual.split("/");
    var expectedParts = expected.split("/");
    if (actualParts.length !== 2 || expectedParts.length !== 2) {
      return false;
    }
    if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
      return false;
    }
    if (expectedParts[1].substr(0, 2) === "*+") {
      return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
    }
    if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
      return false;
    }
    return true;
  }
  function normalizeType(value) {
    var type = typer.parse(value);
    type.parameters = undefined;
    return typer.format(type);
  }
  function tryNormalizeType(value) {
    if (!value) {
      return null;
    }
    try {
      return normalizeType(value);
    } catch (err) {
      return null;
    }
  }
});

// node_modules/depd/lib/browser/index.js
var require_browser2 = __commonJS((exports, module) => {
  /*!
   * depd
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = depd;
  function depd(namespace) {
    if (!namespace) {
      throw new TypeError("argument namespace is required");
    }
    function deprecate(message) {}
    deprecate._file = undefined;
    deprecate._ignored = true;
    deprecate._namespace = namespace;
    deprecate._traced = false;
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
  }
  function wrapfunction(fn, message) {
    if (typeof fn !== "function") {
      throw new TypeError("argument fn must be a function");
    }
    return fn;
  }
  function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new TypeError("argument obj must be object");
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
      throw new TypeError("must call property on owner object");
    }
    if (!descriptor.configurable) {
      throw new TypeError("property must be configurable");
    }
  }
});

// node_modules/setprototypeof/index.js
var require_setprototypeof = __commonJS((exports, module) => {
  module.exports = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
  function setProtoOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
  }
  function mixinProperties(obj, proto) {
    for (var prop in proto) {
      if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
        obj[prop] = proto[prop];
      }
    }
    return obj;
  }
});

// node_modules/statuses/codes.json
var require_codes = __commonJS((exports, module) => {
  module.exports = {
    "100": "Continue",
    "101": "Switching Protocols",
    "102": "Processing",
    "103": "Early Hints",
    "200": "OK",
    "201": "Created",
    "202": "Accepted",
    "203": "Non-Authoritative Information",
    "204": "No Content",
    "205": "Reset Content",
    "206": "Partial Content",
    "207": "Multi-Status",
    "208": "Already Reported",
    "226": "IM Used",
    "300": "Multiple Choices",
    "301": "Moved Permanently",
    "302": "Found",
    "303": "See Other",
    "304": "Not Modified",
    "305": "Use Proxy",
    "307": "Temporary Redirect",
    "308": "Permanent Redirect",
    "400": "Bad Request",
    "401": "Unauthorized",
    "402": "Payment Required",
    "403": "Forbidden",
    "404": "Not Found",
    "405": "Method Not Allowed",
    "406": "Not Acceptable",
    "407": "Proxy Authentication Required",
    "408": "Request Timeout",
    "409": "Conflict",
    "410": "Gone",
    "411": "Length Required",
    "412": "Precondition Failed",
    "413": "Payload Too Large",
    "414": "URI Too Long",
    "415": "Unsupported Media Type",
    "416": "Range Not Satisfiable",
    "417": "Expectation Failed",
    "418": "I'm a Teapot",
    "421": "Misdirected Request",
    "422": "Unprocessable Entity",
    "423": "Locked",
    "424": "Failed Dependency",
    "425": "Too Early",
    "426": "Upgrade Required",
    "428": "Precondition Required",
    "429": "Too Many Requests",
    "431": "Request Header Fields Too Large",
    "451": "Unavailable For Legal Reasons",
    "500": "Internal Server Error",
    "501": "Not Implemented",
    "502": "Bad Gateway",
    "503": "Service Unavailable",
    "504": "Gateway Timeout",
    "505": "HTTP Version Not Supported",
    "506": "Variant Also Negotiates",
    "507": "Insufficient Storage",
    "508": "Loop Detected",
    "509": "Bandwidth Limit Exceeded",
    "510": "Not Extended",
    "511": "Network Authentication Required"
  };
});

// node_modules/statuses/index.js
var require_statuses = __commonJS((exports, module) => {
  /*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var codes = require_codes();
  module.exports = status;
  status.message = codes;
  status.code = createMessageToStatusCodeMap(codes);
  status.codes = createStatusCodeList(codes);
  status.redirect = {
    300: true,
    301: true,
    302: true,
    303: true,
    305: true,
    307: true,
    308: true
  };
  status.empty = {
    204: true,
    205: true,
    304: true
  };
  status.retry = {
    502: true,
    503: true,
    504: true
  };
  function createMessageToStatusCodeMap(codes2) {
    var map = {};
    Object.keys(codes2).forEach(function forEachCode(code) {
      var message = codes2[code];
      var status2 = Number(code);
      map[message.toLowerCase()] = status2;
    });
    return map;
  }
  function createStatusCodeList(codes2) {
    return Object.keys(codes2).map(function mapCode(code) {
      return Number(code);
    });
  }
  function getStatusCode(message) {
    var msg = message.toLowerCase();
    if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
      throw new Error('invalid status message: "' + message + '"');
    }
    return status.code[msg];
  }
  function getStatusMessage(code) {
    if (!Object.prototype.hasOwnProperty.call(status.message, code)) {
      throw new Error("invalid status code: " + code);
    }
    return status.message[code];
  }
  function status(code) {
    if (typeof code === "number") {
      return getStatusMessage(code);
    }
    if (typeof code !== "string") {
      throw new TypeError("code must be a number or string");
    }
    var n = parseInt(code, 10);
    if (!isNaN(n)) {
      return getStatusMessage(n);
    }
    return getStatusCode(code);
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports, module) => {
  if (typeof Object.create === "function") {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/toidentifier/index.js
var require_toidentifier = __commonJS((exports, module) => {
  /*!
   * toidentifier
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = toIdentifier;
  function toIdentifier(str) {
    return str.split(" ").map(function(token) {
      return token.slice(0, 1).toUpperCase() + token.slice(1);
    }).join("").replace(/[^ _0-9a-z]/gi, "");
  }
});

// node_modules/http-errors/index.js
var require_http_errors = __commonJS((exports, module) => {
  /*!
   * http-errors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   */
  var deprecate = require_browser2()("http-errors");
  var setPrototypeOf = require_setprototypeof();
  var statuses = require_statuses();
  var inherits = require_inherits_browser();
  var toIdentifier = require_toidentifier();
  module.exports = createError;
  module.exports.HttpError = createHttpErrorConstructor();
  module.exports.isHttpError = createIsHttpErrorFunction(module.exports.HttpError);
  populateConstructorExports(module.exports, statuses.codes, module.exports.HttpError);
  function codeClass(status) {
    return Number(String(status).charAt(0) + "00");
  }
  function createError() {
    var err;
    var msg;
    var status = 500;
    var props = {};
    for (var i = 0;i < arguments.length; i++) {
      var arg = arguments[i];
      var type = typeof arg;
      if (type === "object" && arg instanceof Error) {
        err = arg;
        status = err.status || err.statusCode || status;
      } else if (type === "number" && i === 0) {
        status = arg;
      } else if (type === "string") {
        msg = arg;
      } else if (type === "object") {
        props = arg;
      } else {
        throw new TypeError("argument #" + (i + 1) + " unsupported type " + type);
      }
    }
    if (typeof status === "number" && (status < 400 || status >= 600)) {
      deprecate("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status !== "number" || !statuses.message[status] && (status < 400 || status >= 600)) {
      status = 500;
    }
    var HttpError = createError[status] || createError[codeClass(status)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses.message[status]);
      Error.captureStackTrace(err, createError);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status) {
      err.expose = status < 500;
      err.status = err.statusCode = status;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ClientError(message) {
      var msg = message != null ? message : statuses.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code;
    ClientError.prototype.statusCode = code;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
      if (!val || typeof val !== "object") {
        return false;
      }
      if (val instanceof HttpError) {
        return true;
      }
      return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
    };
  }
  function createServerErrorConstructor(HttpError, name, code) {
    var className = toClassName(name);
    function ServerError(message) {
      var msg = message != null ? message : statuses.message[code];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code;
    ServerError.prototype.statusCode = code;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name) {
    var desc = Object.getOwnPropertyDescriptor(func, "name");
    if (desc && desc.configurable) {
      desc.value = name;
      Object.defineProperty(func, "name", desc);
    }
  }
  function populateConstructorExports(exports2, codes, HttpError) {
    codes.forEach(function forEachCode(code) {
      var CodeError;
      var name = toIdentifier(statuses.message[code]);
      switch (codeClass(code)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name, code);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name, code);
          break;
      }
      if (CodeError) {
        exports2[code] = CodeError;
        exports2[name] = CodeError;
      }
    });
  }
  function toClassName(name) {
    return name.substr(-5) !== "Error" ? name + "Error" : name;
  }
});

// node_modules/@fastify/sensible/lib/httpErrors.js
var require_httpErrors = __commonJS((exports, module) => {
  var createError = require_http_errors();
  var statusCodes = (init_http(), __toCommonJS(exports_http)).STATUS_CODES;
  var statusCodesMap = Object.assign({}, statusCodes);
  Object.keys(statusCodesMap).forEach((code) => {
    statusCodesMap[code] = normalize(code, statusCodesMap[code]);
  });
  function normalize(code, msg) {
    if (code === "414")
      return "uriTooLong";
    if (code === "505")
      return "httpVersionNotSupported";
    msg = msg.split(" ").join("").replace(/'/g, "");
    msg = msg[0].toLowerCase() + msg.slice(1);
    return msg;
  }
  var httpErrors = {
    badRequest: function badRequest(message) {
      return new createError.BadRequest(message);
    },
    unauthorized: function unauthorized(message) {
      return new createError.Unauthorized(message);
    },
    paymentRequired: function paymentRequired(message) {
      return new createError.PaymentRequired(message);
    },
    forbidden: function forbidden(message) {
      return new createError.Forbidden(message);
    },
    notFound: function notFound(message) {
      return new createError.NotFound(message);
    },
    methodNotAllowed: function methodNotAllowed(message) {
      return new createError.MethodNotAllowed(message);
    },
    notAcceptable: function notAcceptable(message) {
      return new createError.NotAcceptable(message);
    },
    proxyAuthenticationRequired: function proxyAuthenticationRequired(message) {
      return new createError.ProxyAuthenticationRequired(message);
    },
    requestTimeout: function requestTimeout(message) {
      return new createError.RequestTimeout(message);
    },
    conflict: function conflict(message) {
      return new createError.Conflict(message);
    },
    gone: function gone(message) {
      return new createError.Gone(message);
    },
    lengthRequired: function lengthRequired(message) {
      return new createError.LengthRequired(message);
    },
    preconditionFailed: function preconditionFailed(message) {
      return new createError.PreconditionFailed(message);
    },
    payloadTooLarge: function payloadTooLarge(message) {
      return new createError.PayloadTooLarge(message);
    },
    uriTooLong: function uriTooLong(message) {
      return new createError.URITooLong(message);
    },
    unsupportedMediaType: function unsupportedMediaType(message) {
      return new createError.UnsupportedMediaType(message);
    },
    rangeNotSatisfiable: function rangeNotSatisfiable(message) {
      return new createError.RangeNotSatisfiable(message);
    },
    expectationFailed: function expectationFailed(message) {
      return new createError.ExpectationFailed(message);
    },
    imateapot: function imateapot(message) {
      return new createError.ImATeapot(message);
    },
    misdirectedRequest: function misdirectedRequest(message) {
      return new createError.MisdirectedRequest(message);
    },
    unprocessableEntity: function unprocessableEntity(message) {
      return new createError.UnprocessableEntity(message);
    },
    locked: function locked(message) {
      return new createError.Locked(message);
    },
    failedDependency: function failedDependency(message) {
      return new createError.FailedDependency(message);
    },
    tooEarly: function tooEarly(message) {
      return new createError.TooEarly(message);
    },
    upgradeRequired: function upgradeRequired(message) {
      return new createError.UpgradeRequired(message);
    },
    preconditionRequired: function preconditionRequired(message) {
      return new createError.PreconditionRequired(message);
    },
    tooManyRequests: function tooManyRequests(message) {
      return new createError.TooManyRequests(message);
    },
    requestHeaderFieldsTooLarge: function requestHeaderFieldsTooLarge(message) {
      return new createError.RequestHeaderFieldsTooLarge(message);
    },
    unavailableForLegalReasons: function unavailableForLegalReasons(message) {
      return new createError.UnavailableForLegalReasons(message);
    },
    internalServerError: function internalServerError(message) {
      return new createError.InternalServerError(message);
    },
    notImplemented: function notImplemented(message) {
      return new createError.NotImplemented(message);
    },
    badGateway: function badGateway(message) {
      return new createError.BadGateway(message);
    },
    serviceUnavailable: function serviceUnavailable(message) {
      return new createError.ServiceUnavailable(message);
    },
    gatewayTimeout: function gatewayTimeout(message) {
      return new createError.GatewayTimeout(message);
    },
    httpVersionNotSupported: function httpVersionNotSupported(message) {
      return new createError.HTTPVersionNotSupported(message);
    },
    variantAlsoNegotiates: function variantAlsoNegotiates(message) {
      return new createError.VariantAlsoNegotiates(message);
    },
    insufficientStorage: function insufficientStorage(message) {
      return new createError.InsufficientStorage(message);
    },
    loopDetected: function loopDetected(message) {
      return new createError.LoopDetected(message);
    },
    bandwidthLimitExceeded: function bandwidthLimitExceeded(message) {
      return new createError.BandwidthLimitExceeded(message);
    },
    notExtended: function notExtended(message) {
      return new createError.NotExtended(message);
    },
    networkAuthenticationRequired: function networkAuthenticationRequired(message) {
      return new createError.NetworkAuthenticationRequired(message);
    }
  };
  function getHttpError(code, message) {
    return httpErrors[statusCodesMap[code + ""]](message);
  }
  module.exports = httpErrors;
  module.exports.getHttpError = getHttpError;
  module.exports.HttpError = createError.HttpError;
  module.exports.createError = createError;
});

// node_modules/@fastify/sensible/lib/assert.js
var require_assert2 = __commonJS((exports, module) => {
  var { dequal: deepEqual } = require_dist();
  var { getHttpError } = require_httpErrors();
  function assert(condition, code, message) {
    if (condition)
      return;
    throw getHttpError(code, message);
  }
  assert.ok = assert;
  assert.equal = function(a3, b5, code, message) {
    assert(a3 == b5, code, message);
  };
  assert.notEqual = function(a3, b5, code, message) {
    assert(a3 != b5, code, message);
  };
  assert.strictEqual = function(a3, b5, code, message) {
    assert(a3 === b5, code, message);
  };
  assert.notStrictEqual = function(a3, b5, code, message) {
    assert(a3 !== b5, code, message);
  };
  assert.deepEqual = function(a3, b5, code, message) {
    assert(deepEqual(a3, b5), code, message);
  };
  assert.notDeepEqual = function(a3, b5, code, message) {
    assert(!deepEqual(a3, b5), code, message);
  };
  module.exports = assert;
});

// node_modules/vary/index.js
var require_vary2 = __commonJS((exports, module) => {
  /*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   */
  module.exports = vary;
  module.exports.append = append;
  var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
  function append(header, field) {
    if (typeof header !== "string") {
      throw new TypeError("header argument is required");
    }
    if (!field) {
      throw new TypeError("field argument is required");
    }
    var fields = !Array.isArray(field) ? parse(String(field)) : field;
    for (var j5 = 0;j5 < fields.length; j5++) {
      if (!FIELD_NAME_REGEXP.test(fields[j5])) {
        throw new TypeError("field argument contains an invalid header name");
      }
    }
    if (header === "*") {
      return header;
    }
    var val = header;
    var vals = parse(header.toLowerCase());
    if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
      return "*";
    }
    for (var i = 0;i < fields.length; i++) {
      var fld = fields[i].toLowerCase();
      if (vals.indexOf(fld) === -1) {
        vals.push(fld);
        val = val ? val + ", " + fields[i] : fields[i];
      }
    }
    return val;
  }
  function parse(header) {
    var end = 0;
    var list = [];
    var start = 0;
    for (var i = 0, len = header.length;i < len; i++) {
      switch (header.charCodeAt(i)) {
        case 32:
          if (start === end) {
            start = end = i + 1;
          }
          break;
        case 44:
          list.push(header.substring(start, end));
          start = end = i + 1;
          break;
        default:
          end = i + 1;
          break;
      }
    }
    list.push(header.substring(start, end));
    return list;
  }
  function vary(res, field) {
    if (!res || !res.getHeader || !res.setHeader) {
      throw new TypeError("res argument is required");
    }
    var val = res.getHeader("Vary") || "";
    var header = Array.isArray(val) ? val.join(", ") : String(val);
    if (val = append(header, field)) {
      res.setHeader("Vary", val);
    }
  }
});

// node_modules/@fastify/sensible/lib/vary.js
var require_vary3 = __commonJS((exports, module) => {
  var append = require_vary2().append;
  function vary(field) {
    let value = this.getHeader("Vary") || "";
    const header = Array.isArray(value) ? value.join(", ") : String(value);
    value = append(header, field);
    this.header("Vary", value);
  }
  module.exports = vary;
  module.exports.append = append;
});

// node_modules/@lukeed/ms/dist/index.js
var require_dist5 = __commonJS((exports) => {
  var RGX = /^(-?(?:\d+)?\.?\d+) *(m(?:illiseconds?|s(?:ecs?)?))?(s(?:ec(?:onds?|s)?)?)?(m(?:in(?:utes?|s)?)?)?(h(?:ours?|rs?)?)?(d(?:ays?)?)?(w(?:eeks?|ks?)?)?(y(?:ears?|rs?)?)?$/;
  var SEC = 1000;
  var MIN = SEC * 60;
  var HOUR = MIN * 60;
  var DAY = HOUR * 24;
  var YEAR = DAY * 365.25;
  function parse(val) {
    var num, arr = val.toLowerCase().match(RGX);
    if (arr != null && (num = parseFloat(arr[1]))) {
      if (arr[3] != null)
        return num * SEC;
      if (arr[4] != null)
        return num * MIN;
      if (arr[5] != null)
        return num * HOUR;
      if (arr[6] != null)
        return num * DAY;
      if (arr[7] != null)
        return num * DAY * 7;
      if (arr[8] != null)
        return num * YEAR;
      return num;
    }
  }
  function fmt(val, pfx, str, long) {
    var num = (val | 0) === val ? val : ~~(val + 0.5);
    return pfx + num + (long ? " " + str + (num != 1 ? "s" : "") : str[0]);
  }
  function format(num, long) {
    var pfx = num < 0 ? "-" : "", abs = num < 0 ? -num : num;
    if (abs < SEC)
      return num + (long ? " ms" : "ms");
    if (abs < MIN)
      return fmt(abs / SEC, pfx, "second", long);
    if (abs < HOUR)
      return fmt(abs / MIN, pfx, "minute", long);
    if (abs < DAY)
      return fmt(abs / HOUR, pfx, "hour", long);
    if (abs < YEAR)
      return fmt(abs / DAY, pfx, "day", long);
    return fmt(abs / YEAR, pfx, "year", long);
  }
  exports.format = format;
  exports.parse = parse;
});

// node_modules/@fastify/sensible/lib/cache-control.js
var require_cache_control = __commonJS((exports, module) => {
  var assert = require_assert();
  var ms = require_dist5().parse;
  var validSingletimes = [
    "must-revalidate",
    "no-cache",
    "no-store",
    "no-transform",
    "public",
    "private",
    "proxy-revalidate",
    "immutable"
  ];
  var validMultitimes = [
    "max-age",
    "s-maxage",
    "stale-while-revalidate",
    "stale-if-error"
  ];
  function cacheControl(type, time) {
    const previoustime = this.getHeader("Cache-Control");
    if (time == null) {
      assert(validSingletimes.indexOf(type) !== -1, `Invalid Cache Control type: ${type}`);
      this.header("Cache-Control", previoustime ? `${previoustime}, ${type}` : type);
    } else {
      if (typeof time === "string") {
        time = ms(time) / 1000;
      }
      assert(validMultitimes.indexOf(type) !== -1, `Invalid Cache Control type: ${type}`);
      assert(typeof time === "number", "The cache control time should be a number");
      this.header("Cache-Control", previoustime ? `${previoustime}, ${type}=${time}` : `${type}=${time}`);
    }
    return this;
  }
  function preventCache() {
    this.header("Cache-Control", "no-store, max-age=0, private").header("Pragma", "no-cache").header("Expires", 0);
    return this;
  }
  function maxAge(time) {
    return this.cacheControl("max-age", time);
  }
  function revalidate() {
    this.header("Cache-Control", "max-age=0, must-revalidate");
    return this;
  }
  function staticCache(time) {
    if (typeof time === "string") {
      time = ms(time) / 1000;
    }
    assert(typeof time === "number", "The cache control time should be a number");
    this.header("Cache-Control", `public, max-age=${time}, immutable`);
    return this;
  }
  function stale(type, time) {
    if (type === "while-revalidate") {
      return this.cacheControl("stale-while-revalidate", time);
    } else if (type === "if-error") {
      return this.cacheControl("stale-if-error", time);
    } else {
      throw new Error(`Invalid cache control stale time ${time}`);
    }
  }
  module.exports = {
    cacheControl,
    preventCache,
    revalidate,
    staticCache,
    stale,
    maxAge
  };
});

// node_modules/@fastify/sensible/index.js
var require_sensible = __commonJS((exports, module) => {
  var fp = require_plugin2();
  var forwarded = require_forwarded2();
  var typeis = require_type_is();
  var httpErrors = require_httpErrors();
  var assert = require_assert2();
  var vary = require_vary3();
  var cache = require_cache_control();
  function fastifySensible(fastify, opts, next) {
    fastify.decorate("httpErrors", httpErrors);
    fastify.decorate("assert", assert);
    fastify.decorate("to", to2);
    fastify.decorateRequest("forwarded", function() {
      return forwarded(this.raw);
    });
    fastify.decorateRequest("is", function(types) {
      return typeis(this.raw, Array.isArray(types) ? types : [types]);
    });
    fastify.decorateReply("vary", vary);
    fastify.decorateReply("cacheControl", cache.cacheControl);
    fastify.decorateReply("preventCache", cache.preventCache);
    fastify.decorateReply("revalidate", cache.revalidate);
    fastify.decorateReply("staticCache", cache.staticCache);
    fastify.decorateReply("stale", cache.stale);
    fastify.decorateReply("maxAge", cache.maxAge);
    const httpErrorsKeys = Object.keys(httpErrors);
    for (let i = 0;i < httpErrorsKeys.length; ++i) {
      const httpError = httpErrorsKeys[i];
      switch (httpError) {
        case "HttpError":
          break;
        case "getHttpError":
          fastify.decorateReply("getHttpError", function(errorCode, message) {
            this.send(httpErrors.getHttpError(errorCode, message));
            return this;
          });
          break;
        default:
          fastify.decorateReply(httpError, function(message) {
            this.send(httpErrors[httpError](message));
            return this;
          });
      }
    }
    if (opts?.sharedSchemaId) {
      fastify.addSchema({
        $id: opts.sharedSchemaId,
        type: "object",
        properties: {
          statusCode: { type: "number" },
          code: { type: "string" },
          error: { type: "string" },
          message: { type: "string" }
        }
      });
    }
    function to2(promise) {
      return promise.then((data) => [null, data], (err) => [err, undefined]);
    }
    next();
  }
  module.exports = fp(fastifySensible, {
    name: "@fastify/sensible",
    fastify: "5.x"
  });
  module.exports.default = fastifySensible;
  module.exports.fastifySensible = fastifySensible;
  module.exports.httpErrors = httpErrors;
  module.exports.HttpError = httpErrors.HttpError;
});

// node_modules/node-gyp-build/node-gyp-build.js
var require_node_gyp_build = __commonJS((exports, module) => {
  var fs = (() => ({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var os2 = (init_os(), __toCommonJS(exports_os));
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var abi = process.versions.modules;
  var runtime = isElectron() ? "electron" : isNwjs() ? "node-webkit" : "node";
  var arch = process.env.npm_config_arch || os2.arch();
  var platform = process.env.npm_config_platform || os2.platform();
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (process.versions.uv || "").split(".")[0];
  module.exports = load;
  function load(dir) {
    return runtimeRequire(load.resolve(dir));
  }
  load.resolve = load.path = function(dir) {
    dir = path.resolve(dir || ".");
    try {
      var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
      if (process.env[name + "_PREBUILD"])
        dir = process.env[name + "_PREBUILD"];
    } catch (err) {}
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug)
        return debug;
    }
    var prebuild = resolve(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby)
      return nearby;
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + `
    loaded from: ` + dir + `
`);
    function resolve(dir2) {
      var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple2 = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple2)
        return;
      var prebuilds = path.join(dir2, "prebuilds", tuple2.name);
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path.join(prebuilds, winner.file);
    }
  };
  function readdirSync(dir) {
    try {
      return fs.readdirSync(dir);
    } catch (err) {
      return [];
    }
  }
  function getFirst(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  }
  function matchBuild(name) {
    return /\.node$/.test(name);
  }
  function parseTuple(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  }
  function matchTuple(platform2, arch2) {
    return function(tuple2) {
      if (tuple2 == null)
        return false;
      if (tuple2.platform !== platform2)
        return false;
      return tuple2.architectures.includes(arch2);
    };
  }
  function compareTuples(a3, b5) {
    return a3.architectures.length - b5.architectures.length;
  }
  function parseTags(file2) {
    var arr = file2.split(".");
    var extension = arr.pop();
    var tags = { file: file2, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i = 0;i < arr.length; i++) {
      var tag = arr[i];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  }
  function matchTags(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime && tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi && tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  }
  function runtimeAgnostic(tags) {
    return tags.runtime === "node" && tags.napi;
  }
  function compareTags(runtime2) {
    return function(a3, b5) {
      if (a3.runtime !== b5.runtime) {
        return a3.runtime === runtime2 ? -1 : 1;
      } else if (a3.abi !== b5.abi) {
        return a3.abi ? -1 : 1;
      } else if (a3.specificity !== b5.specificity) {
        return a3.specificity > b5.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  }
  function isNwjs() {
    return !!(process.versions && process.versions.nw);
  }
  function isElectron() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  }
  function isAlpine(platform2) {
    return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
  }
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// node_modules/node-gyp-build/index.js
var require_node_gyp_build2 = __commonJS((exports, module) => {
  var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
  if (typeof runtimeRequire.addon === "function") {
    module.exports = runtimeRequire.addon.bind(runtimeRequire);
  } else {
    module.exports = require_node_gyp_build();
  }
});

// node_modules/bcrypt/promises.js
var require_promises = __commonJS((exports, module) => {
  var Promise2 = global.Promise;
  function promise2(fn, context, args) {
    if (!Array.isArray(args)) {
      args = Array.prototype.slice.call(args);
    }
    if (typeof fn !== "function") {
      return Promise2.reject(new Error("fn must be a function"));
    }
    return new Promise2((resolve, reject2) => {
      args.push((err, data) => {
        if (err) {
          reject2(err);
        } else {
          resolve(data);
        }
      });
      fn.apply(context, args);
    });
  }
  function reject(err) {
    return Promise2.reject(err);
  }
  function use(promise3) {
    Promise2 = promise3;
  }
  module.exports = {
    promise: promise2,
    reject,
    use
  };
});

// node_modules/bcrypt/bcrypt.js
var require_bcrypt = __commonJS((exports, module) => {
  var __dirname = "/Users/warus/Github/docker-default-ddd/packages/ms.auth/node_modules/bcrypt";
  var path = (init_path(), __toCommonJS(exports_path));
  var bindings = require_node_gyp_build2()(path.resolve(__dirname));
  var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
  var promises = require_promises();
  function genSaltSync(rounds, minor) {
    if (!rounds) {
      rounds = 10;
    } else if (typeof rounds !== "number") {
      throw new Error("rounds must be a number");
    }
    if (!minor) {
      minor = "b";
    } else if (minor !== "b" && minor !== "a") {
      throw new Error('minor must be either "a" or "b"');
    }
    return bindings.gen_salt_sync(minor, rounds, crypto2.randomBytes(16));
  }
  function genSalt(rounds, minor, cb) {
    let error45;
    if (typeof arguments[0] === "function") {
      cb = arguments[0];
      rounds = 10;
      minor = "b";
    } else if (typeof arguments[1] === "function") {
      cb = arguments[1];
      minor = "b";
    }
    if (!cb) {
      return promises.promise(genSalt, this, [rounds, minor]);
    }
    if (!rounds) {
      rounds = 10;
    } else if (typeof rounds !== "number") {
      error45 = new Error("rounds must be a number");
      return process.nextTick(function() {
        cb(error45);
      });
    }
    if (!minor) {
      minor = "b";
    } else if (minor !== "b" && minor !== "a") {
      error45 = new Error('minor must be either "a" or "b"');
      return process.nextTick(function() {
        cb(error45);
      });
    }
    crypto2.randomBytes(16, function(error46, randomBytes) {
      if (error46) {
        cb(error46);
        return;
      }
      bindings.gen_salt(minor, rounds, randomBytes, cb);
    });
  }
  function hashSync(data, salt) {
    if (data == null || salt == null) {
      throw new Error("data and salt arguments required");
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof salt !== "string" && typeof salt !== "number") {
      throw new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
    }
    if (typeof salt === "number") {
      salt = module.exports.genSaltSync(salt);
    }
    return bindings.encrypt_sync(data, salt);
  }
  function hash2(data, salt, cb) {
    let error45;
    if (typeof data === "function") {
      error45 = new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
      return process.nextTick(function() {
        data(error45);
      });
    }
    if (typeof salt === "function") {
      error45 = new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
      return process.nextTick(function() {
        salt(error45);
      });
    }
    if (cb && typeof cb !== "function") {
      return promises.reject(new Error("cb must be a function or null to return a Promise"));
    }
    if (!cb) {
      return promises.promise(hash2, this, [data, salt]);
    }
    if (data == null || salt == null) {
      error45 = new Error("data and salt arguments required");
      return process.nextTick(function() {
        cb(error45);
      });
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof salt !== "string" && typeof salt !== "number") {
      error45 = new Error("data must be a string or Buffer and salt must either be a salt string or a number of rounds");
      return process.nextTick(function() {
        cb(error45);
      });
    }
    if (typeof salt === "number") {
      return module.exports.genSalt(salt, function(err, salt2) {
        return bindings.encrypt(data, salt2, cb);
      });
    }
    return bindings.encrypt(data, salt, cb);
  }
  function compareSync(data, hash3) {
    if (data == null || hash3 == null) {
      throw new Error("data and hash arguments required");
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof hash3 !== "string") {
      throw new Error("data must be a string or Buffer and hash must be a string");
    }
    return bindings.compare_sync(data, hash3);
  }
  function compare(data, hash3, cb) {
    let error45;
    if (typeof data === "function") {
      error45 = new Error("data and hash arguments required");
      return process.nextTick(function() {
        data(error45);
      });
    }
    if (typeof hash3 === "function") {
      error45 = new Error("data and hash arguments required");
      return process.nextTick(function() {
        hash3(error45);
      });
    }
    if (cb && typeof cb !== "function") {
      return promises.reject(new Error("cb must be a function or null to return a Promise"));
    }
    if (!cb) {
      return promises.promise(compare, this, [data, hash3]);
    }
    if (data == null || hash3 == null) {
      error45 = new Error("data and hash arguments required");
      return process.nextTick(function() {
        cb(error45);
      });
    }
    if (!(typeof data === "string" || data instanceof Buffer) || typeof hash3 !== "string") {
      error45 = new Error("data and hash must be strings");
      return process.nextTick(function() {
        cb(error45);
      });
    }
    return bindings.compare(data, hash3, cb);
  }
  function getRounds(hash3) {
    if (hash3 == null) {
      throw new Error("hash argument required");
    }
    if (typeof hash3 !== "string") {
      throw new Error("hash must be a string");
    }
    return bindings.get_rounds(hash3);
  }
  module.exports = {
    genSaltSync,
    genSalt,
    hashSync,
    hash: hash2,
    compareSync,
    compare,
    getRounds
  };
});

// node:buffer
var exports_buffer = {};
__export(exports_buffer, {
  transcode: () => yt2,
  resolveObjectURL: () => at2,
  kStringMaxLength: () => K5,
  kMaxLength: () => nt3,
  isUtf8: () => st3,
  isAscii: () => pt2,
  default: () => export_default,
  createObjectURL: () => ct2,
  constants: () => lt2,
  btoa: () => ft,
  atob: () => ht2,
  File: () => ut2,
  Buffer: () => export_Buffer,
  Blob: () => ot3
});
function at2(i) {
  throw new Error("Not implemented");
}
function yt2(i, r, t) {
  throw new Error("Not implemented");
}
var gr3, $2, mr2, Ir2, Fr2, Ar2, P4 = (i, r) => () => (r || i((r = { exports: {} }).exports, r), r.exports), Ur2 = (i, r) => {
  for (var t in r)
    $2(i, t, { get: r[t], enumerable: true });
}, D3 = (i, r, t, e) => {
  if (r && typeof r == "object" || typeof r == "function")
    for (let n of Ir2(r))
      !Ar2.call(i, n) && n !== t && $2(i, n, { get: () => r[n], enumerable: !(e = mr2(r, n)) || e.enumerable });
  return i;
}, w3 = (i, r, t) => (D3(i, r, "default"), t && D3(t, r, "default")), O3 = (i, r, t) => (t = i != null ? gr3(Fr2(i)) : {}, D3(r || !i || !i.__esModule ? $2(t, "default", { value: i, enumerable: true }) : t, i)), v2, rr, b5, y4, Br2, Er4, K5, nt3 = 9007199254740991, ot3, ut2, ht2, ft, ct2, pt2 = (i) => ArrayBuffer.isView(i) ? i.every((r) => r < 128) : i.split("").every((r) => r.charCodeAt(0) < 128), st3 = (i) => {
  throw new Error("Not implemented");
}, lt2, export_Buffer, export_default;
var init_buffer = __esm(() => {
  gr3 = Object.create;
  $2 = Object.defineProperty;
  mr2 = Object.getOwnPropertyDescriptor;
  Ir2 = Object.getOwnPropertyNames;
  Fr2 = Object.getPrototypeOf;
  Ar2 = Object.prototype.hasOwnProperty;
  v2 = P4((L4) => {
    L4.byteLength = Tr;
    L4.toByteArray = _r3;
    L4.fromByteArray = Nr;
    var d4 = [], B4 = [], Rr3 = typeof Uint8Array < "u" ? Uint8Array : Array, G3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (F3 = 0, Z4 = G3.length;F3 < Z4; ++F3)
      d4[F3] = G3[F3], B4[G3.charCodeAt(F3)] = F3;
    var F3, Z4;
    B4[45] = 62;
    B4[95] = 63;
    function Q5(i) {
      var r = i.length;
      if (r % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var t = i.indexOf("=");
      t === -1 && (t = r);
      var e = t === r ? 0 : 4 - t % 4;
      return [t, e];
    }
    function Tr(i) {
      var r = Q5(i), t = r[0], e = r[1];
      return (t + e) * 3 / 4 - e;
    }
    function Cr4(i, r, t) {
      return (r + t) * 3 / 4 - t;
    }
    function _r3(i) {
      var r, t = Q5(i), e = t[0], n = t[1], o2 = new Rr3(Cr4(i, e, n)), u3 = 0, f2 = n > 0 ? e - 4 : e, c2;
      for (c2 = 0;c2 < f2; c2 += 4)
        r = B4[i.charCodeAt(c2)] << 18 | B4[i.charCodeAt(c2 + 1)] << 12 | B4[i.charCodeAt(c2 + 2)] << 6 | B4[i.charCodeAt(c2 + 3)], o2[u3++] = r >> 16 & 255, o2[u3++] = r >> 8 & 255, o2[u3++] = r & 255;
      return n === 2 && (r = B4[i.charCodeAt(c2)] << 2 | B4[i.charCodeAt(c2 + 1)] >> 4, o2[u3++] = r & 255), n === 1 && (r = B4[i.charCodeAt(c2)] << 10 | B4[i.charCodeAt(c2 + 1)] << 4 | B4[i.charCodeAt(c2 + 2)] >> 2, o2[u3++] = r >> 8 & 255, o2[u3++] = r & 255), o2;
    }
    function Sr(i) {
      return d4[i >> 18 & 63] + d4[i >> 12 & 63] + d4[i >> 6 & 63] + d4[i & 63];
    }
    function Lr(i, r, t) {
      for (var e, n = [], o2 = r;o2 < t; o2 += 3)
        e = (i[o2] << 16 & 16711680) + (i[o2 + 1] << 8 & 65280) + (i[o2 + 2] & 255), n.push(Sr(e));
      return n.join("");
    }
    function Nr(i) {
      for (var r, t = i.length, e = t % 3, n = [], o2 = 16383, u3 = 0, f2 = t - e;u3 < f2; u3 += o2)
        n.push(Lr(i, u3, u3 + o2 > f2 ? f2 : u3 + o2));
      return e === 1 ? (r = i[t - 1], n.push(d4[r >> 2] + d4[r << 4 & 63] + "==")) : e === 2 && (r = (i[t - 2] << 8) + i[t - 1], n.push(d4[r >> 10] + d4[r >> 4 & 63] + d4[r << 2 & 63] + "=")), n.join("");
    }
  });
  rr = P4((Y5) => {
    Y5.read = function(i, r, t, e, n) {
      var o2, u3, f2 = n * 8 - e - 1, c2 = (1 << f2) - 1, l3 = c2 >> 1, s3 = -7, p4 = t ? n - 1 : 0, U3 = t ? -1 : 1, E7 = i[r + p4];
      for (p4 += U3, o2 = E7 & (1 << -s3) - 1, E7 >>= -s3, s3 += f2;s3 > 0; o2 = o2 * 256 + i[r + p4], p4 += U3, s3 -= 8)
        ;
      for (u3 = o2 & (1 << -s3) - 1, o2 >>= -s3, s3 += e;s3 > 0; u3 = u3 * 256 + i[r + p4], p4 += U3, s3 -= 8)
        ;
      if (o2 === 0)
        o2 = 1 - l3;
      else {
        if (o2 === c2)
          return u3 ? NaN : (E7 ? -1 : 1) * (1 / 0);
        u3 = u3 + Math.pow(2, e), o2 = o2 - l3;
      }
      return (E7 ? -1 : 1) * u3 * Math.pow(2, o2 - e);
    };
    Y5.write = function(i, r, t, e, n, o2) {
      var u3, f2, c2, l3 = o2 * 8 - n - 1, s3 = (1 << l3) - 1, p4 = s3 >> 1, U3 = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, E7 = e ? 0 : o2 - 1, k5 = e ? 1 : -1, dr4 = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
      for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f2 = isNaN(r) ? 1 : 0, u3 = s3) : (u3 = Math.floor(Math.log(r) / Math.LN2), r * (c2 = Math.pow(2, -u3)) < 1 && (u3--, c2 *= 2), u3 + p4 >= 1 ? r += U3 / c2 : r += U3 * Math.pow(2, 1 - p4), r * c2 >= 2 && (u3++, c2 /= 2), u3 + p4 >= s3 ? (f2 = 0, u3 = s3) : u3 + p4 >= 1 ? (f2 = (r * c2 - 1) * Math.pow(2, n), u3 = u3 + p4) : (f2 = r * Math.pow(2, p4 - 1) * Math.pow(2, n), u3 = 0));n >= 8; i[t + E7] = f2 & 255, E7 += k5, f2 /= 256, n -= 8)
        ;
      for (u3 = u3 << n | f2, l3 += n;l3 > 0; i[t + E7] = u3 & 255, E7 += k5, u3 /= 256, l3 -= 8)
        ;
      i[t + E7 - k5] |= dr4 * 128;
    };
  });
  b5 = P4((_5) => {
    var j5 = v2(), T3 = rr(), tr = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    _5.Buffer = h4;
    _5.SlowBuffer = Pr;
    _5.INSPECT_MAX_BYTES = 50;
    var N6 = 2147483647;
    _5.kMaxLength = N6;
    h4.TYPED_ARRAY_SUPPORT = Mr();
    !h4.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    function Mr() {
      try {
        let i = new Uint8Array(1), r = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(r, Uint8Array.prototype), Object.setPrototypeOf(i, r), i.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(h4.prototype, "parent", { enumerable: true, get: function() {
      if (!!h4.isBuffer(this))
        return this.buffer;
    } });
    Object.defineProperty(h4.prototype, "offset", { enumerable: true, get: function() {
      if (!!h4.isBuffer(this))
        return this.byteOffset;
    } });
    function m4(i) {
      if (i > N6)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
      let r = new Uint8Array(i);
      return Object.setPrototypeOf(r, h4.prototype), r;
    }
    function h4(i, r, t) {
      if (typeof i == "number") {
        if (typeof r == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return X5(i);
      }
      return or2(i, r, t);
    }
    h4.poolSize = 8192;
    function or2(i, r, t) {
      if (typeof i == "string")
        return kr(i, r);
      if (ArrayBuffer.isView(i))
        return Dr2(i);
      if (i == null)
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
      if (g4(i, ArrayBuffer) || i && g4(i.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (g4(i, SharedArrayBuffer) || i && g4(i.buffer, SharedArrayBuffer)))
        return W(i, r, t);
      if (typeof i == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      let e = i.valueOf && i.valueOf();
      if (e != null && e !== i)
        return h4.from(e, r, t);
      let n = $r3(i);
      if (n)
        return n;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof i[Symbol.toPrimitive] == "function")
        return h4.from(i[Symbol.toPrimitive]("string"), r, t);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof i);
    }
    h4.from = function(i, r, t) {
      return or2(i, r, t);
    };
    Object.setPrototypeOf(h4.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(h4, Uint8Array);
    function ur3(i) {
      if (typeof i != "number")
        throw new TypeError('"size" argument must be of type number');
      if (i < 0)
        throw new RangeError('The value "' + i + '" is invalid for option "size"');
    }
    function br3(i, r, t) {
      return ur3(i), i <= 0 ? m4(i) : r !== undefined ? typeof t == "string" ? m4(i).fill(r, t) : m4(i).fill(r) : m4(i);
    }
    h4.alloc = function(i, r, t) {
      return br3(i, r, t);
    };
    function X5(i) {
      return ur3(i), m4(i < 0 ? 0 : V5(i) | 0);
    }
    h4.allocUnsafe = function(i) {
      return X5(i);
    };
    h4.allocUnsafeSlow = function(i) {
      return X5(i);
    };
    function kr(i, r) {
      if ((typeof r != "string" || r === "") && (r = "utf8"), !h4.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
      let t = hr3(i, r) | 0, e = m4(t), n = e.write(i, r);
      return n !== t && (e = e.slice(0, n)), e;
    }
    function q2(i) {
      let r = i.length < 0 ? 0 : V5(i.length) | 0, t = m4(r);
      for (let e = 0;e < r; e += 1)
        t[e] = i[e] & 255;
      return t;
    }
    function Dr2(i) {
      if (g4(i, Uint8Array)) {
        let r = new Uint8Array(i);
        return W(r.buffer, r.byteOffset, r.byteLength);
      }
      return q2(i);
    }
    function W(i, r, t) {
      if (r < 0 || i.byteLength < r)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (i.byteLength < r + (t || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let e;
      return r === undefined && t === undefined ? e = new Uint8Array(i) : t === undefined ? e = new Uint8Array(i, r) : e = new Uint8Array(i, r, t), Object.setPrototypeOf(e, h4.prototype), e;
    }
    function $r3(i) {
      if (h4.isBuffer(i)) {
        let r = V5(i.length) | 0, t = m4(r);
        return t.length === 0 || i.copy(t, 0, 0, r), t;
      }
      if (i.length !== undefined)
        return typeof i.length != "number" || J4(i.length) ? m4(0) : q2(i);
      if (i.type === "Buffer" && Array.isArray(i.data))
        return q2(i.data);
    }
    function V5(i) {
      if (i >= N6)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + N6.toString(16) + " bytes");
      return i | 0;
    }
    function Pr(i) {
      return +i != i && (i = 0), h4.alloc(+i);
    }
    h4.isBuffer = function(r) {
      return r != null && r._isBuffer === true && r !== h4.prototype;
    };
    h4.compare = function(r, t) {
      if (g4(r, Uint8Array) && (r = h4.from(r, r.offset, r.byteLength)), g4(t, Uint8Array) && (t = h4.from(t, t.offset, t.byteLength)), !h4.isBuffer(r) || !h4.isBuffer(t))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (r === t)
        return 0;
      let e = r.length, n = t.length;
      for (let o2 = 0, u3 = Math.min(e, n);o2 < u3; ++o2)
        if (r[o2] !== t[o2]) {
          e = r[o2], n = t[o2];
          break;
        }
      return e < n ? -1 : n < e ? 1 : 0;
    };
    h4.isEncoding = function(r) {
      switch (String(r).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    h4.concat = function(r, t) {
      if (!Array.isArray(r))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (r.length === 0)
        return h4.alloc(0);
      let e;
      if (t === undefined)
        for (t = 0, e = 0;e < r.length; ++e)
          t += r[e].length;
      let n = h4.allocUnsafe(t), o2 = 0;
      for (e = 0;e < r.length; ++e) {
        let u3 = r[e];
        if (g4(u3, Uint8Array))
          o2 + u3.length > n.length ? (h4.isBuffer(u3) || (u3 = h4.from(u3)), u3.copy(n, o2)) : Uint8Array.prototype.set.call(n, u3, o2);
        else if (h4.isBuffer(u3))
          u3.copy(n, o2);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        o2 += u3.length;
      }
      return n;
    };
    function hr3(i, r) {
      if (h4.isBuffer(i))
        return i.length;
      if (ArrayBuffer.isView(i) || g4(i, ArrayBuffer))
        return i.byteLength;
      if (typeof i != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof i);
      let t = i.length, e = arguments.length > 2 && arguments[2] === true;
      if (!e && t === 0)
        return 0;
      let n = false;
      for (;; )
        switch (r) {
          case "ascii":
          case "latin1":
          case "binary":
            return t;
          case "utf8":
          case "utf-8":
            return H4(i).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return t * 2;
          case "hex":
            return t >>> 1;
          case "base64":
            return xr2(i).length;
          default:
            if (n)
              return e ? -1 : H4(i).length;
            r = ("" + r).toLowerCase(), n = true;
        }
    }
    h4.byteLength = hr3;
    function Or(i, r, t) {
      let e = false;
      if ((r === undefined || r < 0) && (r = 0), r > this.length || ((t === undefined || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, r >>>= 0, t <= r))
        return "";
      for (i || (i = "utf8");; )
        switch (i) {
          case "hex":
            return Jr2(this, r, t);
          case "utf8":
          case "utf-8":
            return cr2(this, r, t);
          case "ascii":
            return Vr(this, r, t);
          case "latin1":
          case "binary":
            return zr(this, r, t);
          case "base64":
            return Hr(this, r, t);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Kr3(this, r, t);
          default:
            if (e)
              throw new TypeError("Unknown encoding: " + i);
            i = (i + "").toLowerCase(), e = true;
        }
    }
    h4.prototype._isBuffer = true;
    function A4(i, r, t) {
      let e = i[r];
      i[r] = i[t], i[t] = e;
    }
    h4.prototype.swap16 = function() {
      let r = this.length;
      if (r % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t = 0;t < r; t += 2)
        A4(this, t, t + 1);
      return this;
    };
    h4.prototype.swap32 = function() {
      let r = this.length;
      if (r % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t = 0;t < r; t += 4)
        A4(this, t, t + 3), A4(this, t + 1, t + 2);
      return this;
    };
    h4.prototype.swap64 = function() {
      let r = this.length;
      if (r % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0;t < r; t += 8)
        A4(this, t, t + 7), A4(this, t + 1, t + 6), A4(this, t + 2, t + 5), A4(this, t + 3, t + 4);
      return this;
    };
    h4.prototype.toString = function() {
      let r = this.length;
      return r === 0 ? "" : arguments.length === 0 ? cr2(this, 0, r) : Or.apply(this, arguments);
    };
    h4.prototype.toLocaleString = h4.prototype.toString;
    h4.prototype.equals = function(r) {
      if (!h4.isBuffer(r))
        throw new TypeError("Argument must be a Buffer");
      return this === r ? true : h4.compare(this, r) === 0;
    };
    h4.prototype.inspect = function() {
      let r = "", t = _5.INSPECT_MAX_BYTES;
      return r = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (r += " ... "), "<Buffer " + r + ">";
    };
    tr && (h4.prototype[tr] = h4.prototype.inspect);
    h4.prototype.compare = function(r, t, e, n, o2) {
      if (g4(r, Uint8Array) && (r = h4.from(r, r.offset, r.byteLength)), !h4.isBuffer(r))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r);
      if (t === undefined && (t = 0), e === undefined && (e = r ? r.length : 0), n === undefined && (n = 0), o2 === undefined && (o2 = this.length), t < 0 || e > r.length || n < 0 || o2 > this.length)
        throw new RangeError("out of range index");
      if (n >= o2 && t >= e)
        return 0;
      if (n >= o2)
        return -1;
      if (t >= e)
        return 1;
      if (t >>>= 0, e >>>= 0, n >>>= 0, o2 >>>= 0, this === r)
        return 0;
      let u3 = o2 - n, f2 = e - t, c2 = Math.min(u3, f2), l3 = this.slice(n, o2), s3 = r.slice(t, e);
      for (let p4 = 0;p4 < c2; ++p4)
        if (l3[p4] !== s3[p4]) {
          u3 = l3[p4], f2 = s3[p4];
          break;
        }
      return u3 < f2 ? -1 : f2 < u3 ? 1 : 0;
    };
    function fr(i, r, t, e, n) {
      if (i.length === 0)
        return -1;
      if (typeof t == "string" ? (e = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, J4(t) && (t = n ? 0 : i.length - 1), t < 0 && (t = i.length + t), t >= i.length) {
        if (n)
          return -1;
        t = i.length - 1;
      } else if (t < 0)
        if (n)
          t = 0;
        else
          return -1;
      if (typeof r == "string" && (r = h4.from(r, e)), h4.isBuffer(r))
        return r.length === 0 ? -1 : ir3(i, r, t, e, n);
      if (typeof r == "number")
        return r = r & 255, typeof Uint8Array.prototype.indexOf == "function" ? n ? Uint8Array.prototype.indexOf.call(i, r, t) : Uint8Array.prototype.lastIndexOf.call(i, r, t) : ir3(i, [r], t, e, n);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ir3(i, r, t, e, n) {
      let o2 = 1, u3 = i.length, f2 = r.length;
      if (e !== undefined && (e = String(e).toLowerCase(), e === "ucs2" || e === "ucs-2" || e === "utf16le" || e === "utf-16le")) {
        if (i.length < 2 || r.length < 2)
          return -1;
        o2 = 2, u3 /= 2, f2 /= 2, t /= 2;
      }
      function c2(s3, p4) {
        return o2 === 1 ? s3[p4] : s3.readUInt16BE(p4 * o2);
      }
      let l3;
      if (n) {
        let s3 = -1;
        for (l3 = t;l3 < u3; l3++)
          if (c2(i, l3) === c2(r, s3 === -1 ? 0 : l3 - s3)) {
            if (s3 === -1 && (s3 = l3), l3 - s3 + 1 === f2)
              return s3 * o2;
          } else
            s3 !== -1 && (l3 -= l3 - s3), s3 = -1;
      } else
        for (t + f2 > u3 && (t = u3 - f2), l3 = t;l3 >= 0; l3--) {
          let s3 = true;
          for (let p4 = 0;p4 < f2; p4++)
            if (c2(i, l3 + p4) !== c2(r, p4)) {
              s3 = false;
              break;
            }
          if (s3)
            return l3;
        }
      return -1;
    }
    h4.prototype.includes = function(r, t, e) {
      return this.indexOf(r, t, e) !== -1;
    };
    h4.prototype.indexOf = function(r, t, e) {
      return fr(this, r, t, e, true);
    };
    h4.prototype.lastIndexOf = function(r, t, e) {
      return fr(this, r, t, e, false);
    };
    function Gr3(i, r, t, e) {
      t = Number(t) || 0;
      let n = i.length - t;
      e ? (e = Number(e), e > n && (e = n)) : e = n;
      let o2 = r.length;
      e > o2 / 2 && (e = o2 / 2);
      let u3;
      for (u3 = 0;u3 < e; ++u3) {
        let f2 = parseInt(r.substr(u3 * 2, 2), 16);
        if (J4(f2))
          return u3;
        i[t + u3] = f2;
      }
      return u3;
    }
    function Yr(i, r, t, e) {
      return M4(H4(r, i.length - t), i, t, e);
    }
    function jr(i, r, t, e) {
      return M4(rt4(r), i, t, e);
    }
    function qr3(i, r, t, e) {
      return M4(xr2(r), i, t, e);
    }
    function Wr(i, r, t, e) {
      return M4(tt4(r, i.length - t), i, t, e);
    }
    h4.prototype.write = function(r, t, e, n) {
      if (t === undefined)
        n = "utf8", e = this.length, t = 0;
      else if (e === undefined && typeof t == "string")
        n = t, e = this.length, t = 0;
      else if (isFinite(t))
        t = t >>> 0, isFinite(e) ? (e = e >>> 0, n === undefined && (n = "utf8")) : (n = e, e = undefined);
      else
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      let o2 = this.length - t;
      if ((e === undefined || e > o2) && (e = o2), r.length > 0 && (e < 0 || t < 0) || t > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      let u3 = false;
      for (;; )
        switch (n) {
          case "hex":
            return Gr3(this, r, t, e);
          case "utf8":
          case "utf-8":
            return Yr(this, r, t, e);
          case "ascii":
          case "latin1":
          case "binary":
            return jr(this, r, t, e);
          case "base64":
            return qr3(this, r, t, e);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Wr(this, r, t, e);
          default:
            if (u3)
              throw new TypeError("Unknown encoding: " + n);
            n = ("" + n).toLowerCase(), u3 = true;
        }
    };
    h4.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    function Hr(i, r, t) {
      return r === 0 && t === i.length ? j5.fromByteArray(i) : j5.fromByteArray(i.slice(r, t));
    }
    function cr2(i, r, t) {
      t = Math.min(i.length, t);
      let e = [], n = r;
      for (;n < t; ) {
        let o2 = i[n], u3 = null, f2 = o2 > 239 ? 4 : o2 > 223 ? 3 : o2 > 191 ? 2 : 1;
        if (n + f2 <= t) {
          let c2, l3, s3, p4;
          switch (f2) {
            case 1:
              o2 < 128 && (u3 = o2);
              break;
            case 2:
              c2 = i[n + 1], (c2 & 192) === 128 && (p4 = (o2 & 31) << 6 | c2 & 63, p4 > 127 && (u3 = p4));
              break;
            case 3:
              c2 = i[n + 1], l3 = i[n + 2], (c2 & 192) === 128 && (l3 & 192) === 128 && (p4 = (o2 & 15) << 12 | (c2 & 63) << 6 | l3 & 63, p4 > 2047 && (p4 < 55296 || p4 > 57343) && (u3 = p4));
              break;
            case 4:
              c2 = i[n + 1], l3 = i[n + 2], s3 = i[n + 3], (c2 & 192) === 128 && (l3 & 192) === 128 && (s3 & 192) === 128 && (p4 = (o2 & 15) << 18 | (c2 & 63) << 12 | (l3 & 63) << 6 | s3 & 63, p4 > 65535 && p4 < 1114112 && (u3 = p4));
          }
        }
        u3 === null ? (u3 = 65533, f2 = 1) : u3 > 65535 && (u3 -= 65536, e.push(u3 >>> 10 & 1023 | 55296), u3 = 56320 | u3 & 1023), e.push(u3), n += f2;
      }
      return Xr(e);
    }
    var er2 = 4096;
    function Xr(i) {
      let r = i.length;
      if (r <= er2)
        return String.fromCharCode.apply(String, i);
      let t = "", e = 0;
      for (;e < r; )
        t += String.fromCharCode.apply(String, i.slice(e, e += er2));
      return t;
    }
    function Vr(i, r, t) {
      let e = "";
      t = Math.min(i.length, t);
      for (let n = r;n < t; ++n)
        e += String.fromCharCode(i[n] & 127);
      return e;
    }
    function zr(i, r, t) {
      let e = "";
      t = Math.min(i.length, t);
      for (let n = r;n < t; ++n)
        e += String.fromCharCode(i[n]);
      return e;
    }
    function Jr2(i, r, t) {
      let e = i.length;
      (!r || r < 0) && (r = 0), (!t || t < 0 || t > e) && (t = e);
      let n = "";
      for (let o2 = r;o2 < t; ++o2)
        n += it2[i[o2]];
      return n;
    }
    function Kr3(i, r, t) {
      let e = i.slice(r, t), n = "";
      for (let o2 = 0;o2 < e.length - 1; o2 += 2)
        n += String.fromCharCode(e[o2] + e[o2 + 1] * 256);
      return n;
    }
    h4.prototype.slice = function(r, t) {
      let e = this.length;
      r = ~~r, t = t === undefined ? e : ~~t, r < 0 ? (r += e, r < 0 && (r = 0)) : r > e && (r = e), t < 0 ? (t += e, t < 0 && (t = 0)) : t > e && (t = e), t < r && (t = r);
      let n = this.subarray(r, t);
      return Object.setPrototypeOf(n, h4.prototype), n;
    };
    function a3(i, r, t) {
      if (i % 1 !== 0 || i < 0)
        throw new RangeError("offset is not uint");
      if (i + r > t)
        throw new RangeError("Trying to access beyond buffer length");
    }
    h4.prototype.readUintLE = h4.prototype.readUIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = this[r], o2 = 1, u3 = 0;
      for (;++u3 < t && (o2 *= 256); )
        n += this[r + u3] * o2;
      return n;
    };
    h4.prototype.readUintBE = h4.prototype.readUIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = this[r + --t], o2 = 1;
      for (;t > 0 && (o2 *= 256); )
        n += this[r + --t] * o2;
      return n;
    };
    h4.prototype.readUint8 = h4.prototype.readUInt8 = function(r, t) {
      return r = r >>> 0, t || a3(r, 1, this.length), this[r];
    };
    h4.prototype.readUint16LE = h4.prototype.readUInt16LE = function(r, t) {
      return r = r >>> 0, t || a3(r, 2, this.length), this[r] | this[r + 1] << 8;
    };
    h4.prototype.readUint16BE = h4.prototype.readUInt16BE = function(r, t) {
      return r = r >>> 0, t || a3(r, 2, this.length), this[r] << 8 | this[r + 1];
    };
    h4.prototype.readUint32LE = h4.prototype.readUInt32LE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), (this[r] | this[r + 1] << 8 | this[r + 2] << 16) + this[r + 3] * 16777216;
    };
    h4.prototype.readUint32BE = h4.prototype.readUInt32BE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), this[r] * 16777216 + (this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3]);
    };
    h4.prototype.readBigUInt64LE = I5(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S3(r, this.length - 8);
      let n = t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24, o2 = this[++r] + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + e * 2 ** 24;
      return BigInt(n) + (BigInt(o2) << BigInt(32));
    });
    h4.prototype.readBigUInt64BE = I5(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S3(r, this.length - 8);
      let n = t * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r], o2 = this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e;
      return (BigInt(n) << BigInt(32)) + BigInt(o2);
    });
    h4.prototype.readIntLE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = this[r], o2 = 1, u3 = 0;
      for (;++u3 < t && (o2 *= 256); )
        n += this[r + u3] * o2;
      return o2 *= 128, n >= o2 && (n -= Math.pow(2, 8 * t)), n;
    };
    h4.prototype.readIntBE = function(r, t, e) {
      r = r >>> 0, t = t >>> 0, e || a3(r, t, this.length);
      let n = t, o2 = 1, u3 = this[r + --n];
      for (;n > 0 && (o2 *= 256); )
        u3 += this[r + --n] * o2;
      return o2 *= 128, u3 >= o2 && (u3 -= Math.pow(2, 8 * t)), u3;
    };
    h4.prototype.readInt8 = function(r, t) {
      return r = r >>> 0, t || a3(r, 1, this.length), this[r] & 128 ? (255 - this[r] + 1) * -1 : this[r];
    };
    h4.prototype.readInt16LE = function(r, t) {
      r = r >>> 0, t || a3(r, 2, this.length);
      let e = this[r] | this[r + 1] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h4.prototype.readInt16BE = function(r, t) {
      r = r >>> 0, t || a3(r, 2, this.length);
      let e = this[r + 1] | this[r] << 8;
      return e & 32768 ? e | 4294901760 : e;
    };
    h4.prototype.readInt32LE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), this[r] | this[r + 1] << 8 | this[r + 2] << 16 | this[r + 3] << 24;
    };
    h4.prototype.readInt32BE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), this[r] << 24 | this[r + 1] << 16 | this[r + 2] << 8 | this[r + 3];
    };
    h4.prototype.readBigInt64LE = I5(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S3(r, this.length - 8);
      let n = this[r + 4] + this[r + 5] * 2 ** 8 + this[r + 6] * 2 ** 16 + (e << 24);
      return (BigInt(n) << BigInt(32)) + BigInt(t + this[++r] * 2 ** 8 + this[++r] * 2 ** 16 + this[++r] * 2 ** 24);
    });
    h4.prototype.readBigInt64BE = I5(function(r) {
      r = r >>> 0, C3(r, "offset");
      let t = this[r], e = this[r + 7];
      (t === undefined || e === undefined) && S3(r, this.length - 8);
      let n = (t << 24) + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + this[++r];
      return (BigInt(n) << BigInt(32)) + BigInt(this[++r] * 2 ** 24 + this[++r] * 2 ** 16 + this[++r] * 2 ** 8 + e);
    });
    h4.prototype.readFloatLE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), T3.read(this, r, true, 23, 4);
    };
    h4.prototype.readFloatBE = function(r, t) {
      return r = r >>> 0, t || a3(r, 4, this.length), T3.read(this, r, false, 23, 4);
    };
    h4.prototype.readDoubleLE = function(r, t) {
      return r = r >>> 0, t || a3(r, 8, this.length), T3.read(this, r, true, 52, 8);
    };
    h4.prototype.readDoubleBE = function(r, t) {
      return r = r >>> 0, t || a3(r, 8, this.length), T3.read(this, r, false, 52, 8);
    };
    function x4(i, r, t, e, n, o2) {
      if (!h4.isBuffer(i))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (r > n || r < o2)
        throw new RangeError('"value" argument is out of bounds');
      if (t + e > i.length)
        throw new RangeError("Index out of range");
    }
    h4.prototype.writeUintLE = h4.prototype.writeUIntLE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n) {
        let f2 = Math.pow(2, 8 * e) - 1;
        x4(this, r, t, e, f2, 0);
      }
      let o2 = 1, u3 = 0;
      for (this[t] = r & 255;++u3 < e && (o2 *= 256); )
        this[t + u3] = r / o2 & 255;
      return t + e;
    };
    h4.prototype.writeUintBE = h4.prototype.writeUIntBE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, e = e >>> 0, !n) {
        let f2 = Math.pow(2, 8 * e) - 1;
        x4(this, r, t, e, f2, 0);
      }
      let o2 = e - 1, u3 = 1;
      for (this[t + o2] = r & 255;--o2 >= 0 && (u3 *= 256); )
        this[t + o2] = r / u3 & 255;
      return t + e;
    };
    h4.prototype.writeUint8 = h4.prototype.writeUInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 1, 255, 0), this[t] = r & 255, t + 1;
    };
    h4.prototype.writeUint16LE = h4.prototype.writeUInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 2, 65535, 0), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h4.prototype.writeUint16BE = h4.prototype.writeUInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 2, 65535, 0), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h4.prototype.writeUint32LE = h4.prototype.writeUInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 4, 4294967295, 0), this[t + 3] = r >>> 24, this[t + 2] = r >>> 16, this[t + 1] = r >>> 8, this[t] = r & 255, t + 4;
    };
    h4.prototype.writeUint32BE = h4.prototype.writeUInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 4, 4294967295, 0), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    function pr3(i, r, t, e, n) {
      wr(r, e, n, i, t, 7);
      let o2 = Number(r & BigInt(4294967295));
      i[t++] = o2, o2 = o2 >> 8, i[t++] = o2, o2 = o2 >> 8, i[t++] = o2, o2 = o2 >> 8, i[t++] = o2;
      let u3 = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t++] = u3, u3 = u3 >> 8, i[t++] = u3, u3 = u3 >> 8, i[t++] = u3, u3 = u3 >> 8, i[t++] = u3, t;
    }
    function sr(i, r, t, e, n) {
      wr(r, e, n, i, t, 7);
      let o2 = Number(r & BigInt(4294967295));
      i[t + 7] = o2, o2 = o2 >> 8, i[t + 6] = o2, o2 = o2 >> 8, i[t + 5] = o2, o2 = o2 >> 8, i[t + 4] = o2;
      let u3 = Number(r >> BigInt(32) & BigInt(4294967295));
      return i[t + 3] = u3, u3 = u3 >> 8, i[t + 2] = u3, u3 = u3 >> 8, i[t + 1] = u3, u3 = u3 >> 8, i[t] = u3, t + 8;
    }
    h4.prototype.writeBigUInt64LE = I5(function(r, t = 0) {
      return pr3(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h4.prototype.writeBigUInt64BE = I5(function(r, t = 0) {
      return sr(this, r, t, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    h4.prototype.writeIntLE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, !n) {
        let c2 = Math.pow(2, 8 * e - 1);
        x4(this, r, t, e, c2 - 1, -c2);
      }
      let o2 = 0, u3 = 1, f2 = 0;
      for (this[t] = r & 255;++o2 < e && (u3 *= 256); )
        r < 0 && f2 === 0 && this[t + o2 - 1] !== 0 && (f2 = 1), this[t + o2] = (r / u3 >> 0) - f2 & 255;
      return t + e;
    };
    h4.prototype.writeIntBE = function(r, t, e, n) {
      if (r = +r, t = t >>> 0, !n) {
        let c2 = Math.pow(2, 8 * e - 1);
        x4(this, r, t, e, c2 - 1, -c2);
      }
      let o2 = e - 1, u3 = 1, f2 = 0;
      for (this[t + o2] = r & 255;--o2 >= 0 && (u3 *= 256); )
        r < 0 && f2 === 0 && this[t + o2 + 1] !== 0 && (f2 = 1), this[t + o2] = (r / u3 >> 0) - f2 & 255;
      return t + e;
    };
    h4.prototype.writeInt8 = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 1, 127, -128), r < 0 && (r = 255 + r + 1), this[t] = r & 255, t + 1;
    };
    h4.prototype.writeInt16LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 2, 32767, -32768), this[t] = r & 255, this[t + 1] = r >>> 8, t + 2;
    };
    h4.prototype.writeInt16BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 2, 32767, -32768), this[t] = r >>> 8, this[t + 1] = r & 255, t + 2;
    };
    h4.prototype.writeInt32LE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 4, 2147483647, -2147483648), this[t] = r & 255, this[t + 1] = r >>> 8, this[t + 2] = r >>> 16, this[t + 3] = r >>> 24, t + 4;
    };
    h4.prototype.writeInt32BE = function(r, t, e) {
      return r = +r, t = t >>> 0, e || x4(this, r, t, 4, 2147483647, -2147483648), r < 0 && (r = 4294967295 + r + 1), this[t] = r >>> 24, this[t + 1] = r >>> 16, this[t + 2] = r >>> 8, this[t + 3] = r & 255, t + 4;
    };
    h4.prototype.writeBigInt64LE = I5(function(r, t = 0) {
      return pr3(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    h4.prototype.writeBigInt64BE = I5(function(r, t = 0) {
      return sr(this, r, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function lr(i, r, t, e, n, o2) {
      if (t + e > i.length)
        throw new RangeError("Index out of range");
      if (t < 0)
        throw new RangeError("Index out of range");
    }
    function ar3(i, r, t, e, n) {
      return r = +r, t = t >>> 0, n || lr(i, r, t, 4, 340282346638528860000000000000000000000, -340282346638528860000000000000000000000), T3.write(i, r, t, e, 23, 4), t + 4;
    }
    h4.prototype.writeFloatLE = function(r, t, e) {
      return ar3(this, r, t, true, e);
    };
    h4.prototype.writeFloatBE = function(r, t, e) {
      return ar3(this, r, t, false, e);
    };
    function yr2(i, r, t, e, n) {
      return r = +r, t = t >>> 0, n || lr(i, r, t, 8, 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000), T3.write(i, r, t, e, 52, 8), t + 8;
    }
    h4.prototype.writeDoubleLE = function(r, t, e) {
      return yr2(this, r, t, true, e);
    };
    h4.prototype.writeDoubleBE = function(r, t, e) {
      return yr2(this, r, t, false, e);
    };
    h4.prototype.copy = function(r, t, e, n) {
      if (!h4.isBuffer(r))
        throw new TypeError("argument should be a Buffer");
      if (e || (e = 0), !n && n !== 0 && (n = this.length), t >= r.length && (t = r.length), t || (t = 0), n > 0 && n < e && (n = e), n === e || r.length === 0 || this.length === 0)
        return 0;
      if (t < 0)
        throw new RangeError("targetStart out of bounds");
      if (e < 0 || e >= this.length)
        throw new RangeError("Index out of range");
      if (n < 0)
        throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), r.length - t < n - e && (n = r.length - t + e);
      let o2 = n - e;
      return this === r && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, e, n) : Uint8Array.prototype.set.call(r, this.subarray(e, n), t), o2;
    };
    h4.prototype.fill = function(r, t, e, n) {
      if (typeof r == "string") {
        if (typeof t == "string" ? (n = t, t = 0, e = this.length) : typeof e == "string" && (n = e, e = this.length), n !== undefined && typeof n != "string")
          throw new TypeError("encoding must be a string");
        if (typeof n == "string" && !h4.isEncoding(n))
          throw new TypeError("Unknown encoding: " + n);
        if (r.length === 1) {
          let u3 = r.charCodeAt(0);
          (n === "utf8" && u3 < 128 || n === "latin1") && (r = u3);
        }
      } else
        typeof r == "number" ? r = r & 255 : typeof r == "boolean" && (r = Number(r));
      if (t < 0 || this.length < t || this.length < e)
        throw new RangeError("Out of range index");
      if (e <= t)
        return this;
      t = t >>> 0, e = e === undefined ? this.length : e >>> 0, r || (r = 0);
      let o2;
      if (typeof r == "number")
        for (o2 = t;o2 < e; ++o2)
          this[o2] = r;
      else {
        let u3 = h4.isBuffer(r) ? r : h4.from(r, n), f2 = u3.length;
        if (f2 === 0)
          throw new TypeError('The value "' + r + '" is invalid for argument "value"');
        for (o2 = 0;o2 < e - t; ++o2)
          this[o2 + t] = u3[o2 % f2];
      }
      return this;
    };
    var R3 = {};
    function z(i, r, t) {
      R3[i] = class extends t {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: r.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${i}]`, this.stack, delete this.name;
        }
        get code() {
          return i;
        }
        set code(n) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: n, writable: true });
        }
        toString() {
          return `${this.name} [${i}]: ${this.message}`;
        }
      };
    }
    z("ERR_BUFFER_OUT_OF_BOUNDS", function(i) {
      return i ? `${i} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }, RangeError);
    z("ERR_INVALID_ARG_TYPE", function(i, r) {
      return `The "${i}" argument must be of type number. Received type ${typeof r}`;
    }, TypeError);
    z("ERR_OUT_OF_RANGE", function(i, r, t) {
      let e = `The value of "${i}" is out of range.`, n = t;
      return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? n = nr(String(t)) : typeof t == "bigint" && (n = String(t), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (n = nr(n)), n += "n"), e += ` It must be ${r}. Received ${n}`, e;
    }, RangeError);
    function nr(i) {
      let r = "", t = i.length, e = i[0] === "-" ? 1 : 0;
      for (;t >= e + 4; t -= 3)
        r = `_${i.slice(t - 3, t)}${r}`;
      return `${i.slice(0, t)}${r}`;
    }
    function Zr2(i, r, t) {
      C3(r, "offset"), (i[r] === undefined || i[r + t] === undefined) && S3(r, i.length - (t + 1));
    }
    function wr(i, r, t, e, n, o2) {
      if (i > t || i < r) {
        let u3 = typeof r == "bigint" ? "n" : "", f2;
        throw o2 > 3 ? r === 0 || r === BigInt(0) ? f2 = `>= 0${u3} and < 2${u3} ** ${(o2 + 1) * 8}${u3}` : f2 = `>= -(2${u3} ** ${(o2 + 1) * 8 - 1}${u3}) and < 2 ** ${(o2 + 1) * 8 - 1}${u3}` : f2 = `>= ${r}${u3} and <= ${t}${u3}`, new R3.ERR_OUT_OF_RANGE("value", f2, i);
      }
      Zr2(e, n, o2);
    }
    function C3(i, r) {
      if (typeof i != "number")
        throw new R3.ERR_INVALID_ARG_TYPE(r, "number", i);
    }
    function S3(i, r, t) {
      throw Math.floor(i) !== i ? (C3(i, t), new R3.ERR_OUT_OF_RANGE(t || "offset", "an integer", i)) : r < 0 ? new R3.ERR_BUFFER_OUT_OF_BOUNDS : new R3.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${r}`, i);
    }
    var Qr3 = /[^+/0-9A-Za-z-_]/g;
    function vr3(i) {
      if (i = i.split("=")[0], i = i.trim().replace(Qr3, ""), i.length < 2)
        return "";
      for (;i.length % 4 !== 0; )
        i = i + "=";
      return i;
    }
    function H4(i, r) {
      r = r || 1 / 0;
      let t, e = i.length, n = null, o2 = [];
      for (let u3 = 0;u3 < e; ++u3) {
        if (t = i.charCodeAt(u3), t > 55295 && t < 57344) {
          if (!n) {
            if (t > 56319) {
              (r -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            } else if (u3 + 1 === e) {
              (r -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            n = t;
            continue;
          }
          if (t < 56320) {
            (r -= 3) > -1 && o2.push(239, 191, 189), n = t;
            continue;
          }
          t = (n - 55296 << 10 | t - 56320) + 65536;
        } else
          n && (r -= 3) > -1 && o2.push(239, 191, 189);
        if (n = null, t < 128) {
          if ((r -= 1) < 0)
            break;
          o2.push(t);
        } else if (t < 2048) {
          if ((r -= 2) < 0)
            break;
          o2.push(t >> 6 | 192, t & 63 | 128);
        } else if (t < 65536) {
          if ((r -= 3) < 0)
            break;
          o2.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
        } else if (t < 1114112) {
          if ((r -= 4) < 0)
            break;
          o2.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
        } else
          throw new Error("Invalid code point");
      }
      return o2;
    }
    function rt4(i) {
      let r = [];
      for (let t = 0;t < i.length; ++t)
        r.push(i.charCodeAt(t) & 255);
      return r;
    }
    function tt4(i, r) {
      let t, e, n, o2 = [];
      for (let u3 = 0;u3 < i.length && !((r -= 2) < 0); ++u3)
        t = i.charCodeAt(u3), e = t >> 8, n = t % 256, o2.push(n), o2.push(e);
      return o2;
    }
    function xr2(i) {
      return j5.toByteArray(vr3(i));
    }
    function M4(i, r, t, e) {
      let n;
      for (n = 0;n < e && !(n + t >= r.length || n >= i.length); ++n)
        r[n + t] = i[n];
      return n;
    }
    function g4(i, r) {
      return i instanceof r || i != null && i.constructor != null && i.constructor.name != null && i.constructor.name === r.name;
    }
    function J4(i) {
      return i !== i;
    }
    var it2 = function() {
      let i = "0123456789abcdef", r = new Array(256);
      for (let t = 0;t < 16; ++t) {
        let e = t * 16;
        for (let n = 0;n < 16; ++n)
          r[e + n] = i[t] + i[n];
      }
      return r;
    }();
    function I5(i) {
      return typeof BigInt > "u" ? et4 : i;
    }
    function et4() {
      throw new Error("BigInt not supported");
    }
  });
  y4 = {};
  Ur2(y4, { Blob: () => ot3, Buffer: () => Er4.Buffer, File: () => ut2, atob: () => ht2, btoa: () => ft, constants: () => lt2, createObjectURL: () => ct2, default: () => Br2.Buffer, isAscii: () => pt2, isUtf8: () => st3, kMaxLength: () => nt3, kStringMaxLength: () => K5, resolveObjectURL: () => at2, transcode: () => yt2 });
  w3(y4, O3(b5()));
  Br2 = O3(b5());
  Er4 = O3(b5());
  K5 = 2 ** 32 - 1;
  ({ Blob: ot3, File: ut2, atob: ht2, btoa: ft } = globalThis);
  ({ createObjectURL: ct2 } = URL);
  lt2 = { __proto__: null, MAX_LENGTH: K5, MAX_STRING_LENGTH: K5, BYTES_PER_ELEMENT: 1 };
  export_Buffer = Er4.Buffer;
  export_default = Br2.Buffer;
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = (init_buffer(), __toCommonJS(exports_buffer));
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var Stream = (init_stream(), __toCommonJS(exports_stream));
  var util = (init_util(), __toCommonJS(exports_util));
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer2.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer2.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  }
  util.inherits(DataStream, Stream);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module.exports = DataStream;
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base643) {
    return base643.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer2.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer2.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o2 = offset;offset < o2 + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
  var Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
  var SlowBuffer = (init_buffer(), __toCommonJS(exports_buffer)).SlowBuffer;
  module.exports = bufferEq;
  function bufferEq(a3, b6) {
    if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b6)) {
      return false;
    }
    if (a3.length !== b6.length) {
      return false;
    }
    var c2 = 0;
    for (var i = 0;i < a3.length; i++) {
      c2 |= a3[i] ^ b6[i];
    }
    return c2 === 0;
  }
  bufferEq.install = function() {
    Buffer2.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer2.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer2.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = (init_util(), __toCommonJS(exports_util));
  var MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`;
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  function checkIsPublicKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer2.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base643) {
    return base643.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function toBase64(base64url3) {
    base64url3 = base64url3.toString();
    var padding = 4 - base64url3.length % 4;
    if (padding !== 4) {
      for (var i = 0;i < padding; ++i) {
        base64url3 += "=";
      }
    }
    return base64url3.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer2.isBuffer(obj) || typeof obj === "string";
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto2.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  }
  var bufferEqual;
  var timingSafeEqual = "timingSafeEqual" in crypto2 ? function timingSafeEqual(a3, b6) {
    if (a3.byteLength !== b6.byteLength) {
      return false;
    }
    return crypto2.timingSafeEqual(a3, b6);
  } : function timingSafeEqual(a3, b6) {
    if (!bufferEqual) {
      bufferEqual = require_buffer_equal_constant_time();
    }
    return bufferEqual(a3, b6);
  };
  function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return timingSafeEqual(Buffer2.from(signature), Buffer2.from(computedSig));
    };
  }
  function createKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  }
  function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto2.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto2.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  }
  function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  }
  function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign() {
      return "";
    };
  }
  function createNoneVerifier() {
    return function verify(thing, signature) {
      return signature === "";
    };
  }
  module.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
  var Buffer2 = (init_buffer(), __toCommonJS(exports_buffer)).Buffer;
  module.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer2.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = (init_stream(), __toCommonJS(exports_stream));
  var toString = require_tostring();
  var util = (init_util(), __toCommonJS(exports_util));
  function base64url3(string4, encoding) {
    return Buffer2.from(string4, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url3(toString(header), "binary");
    var encodedPayload = base64url3(toString(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  }
  util.inherits(SignStream, Stream);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
  var Buffer2 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream = (init_stream(), __toCommonJS(exports_stream));
  var toString = require_tostring();
  var util = (init_util(), __toCommonJS(exports_util));
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject2(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  }
  function safeJsonParse(thing) {
    if (isObject2(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e) {
      return;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer2.from(payload, "base64").toString(encoding);
  }
  function isValidJws(string4) {
    return JWS_REGEX.test(string4) && !!headerFromJWS(string4);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  }
  util.inherits(VerifyStream, Stream);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e) {
      this.readable = false;
      this.emit("error", e);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports.ALGORITHMS = ALGORITHMS;
  exports.sign = SignStream.sign;
  exports.verify = VerifyStream.verify;
  exports.decode = VerifyStream.decode;
  exports.isValid = VerifyStream.isValid;
  exports.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS((exports, module) => {
  var jws = require_jws();
  module.exports = function(jwt2, options) {
    options = options || {};
    var decoded = jws.decode(jwt2, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === "string") {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === "object") {
          payload = obj;
        }
      } catch (e) {}
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature
      };
    }
    return payload;
  };
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports, module) => {
  var JsonWebTokenError = function(message, error45) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message;
    if (error45)
      this.inner = error45;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  module.exports = JsonWebTokenError;
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = function(message, date5) {
    JsonWebTokenError.call(this, message);
    this.name = "NotBeforeError";
    this.date = date5;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  module.exports = NotBeforeError;
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var TokenExpiredError = function(message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  module.exports = TokenExpiredError;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s3 = 1000;
  var m4 = s3 * 60;
  var h4 = m4 * 60;
  var d4 = h4 * 24;
  var w4 = d4 * 7;
  var y5 = d4 * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse5(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse5(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y5;
      case "weeks":
      case "week":
      case "w":
        return n * w4;
      case "days":
      case "day":
      case "d":
        return n * d4;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h4;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m4;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s3;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d4) {
      return Math.round(ms / d4) + "d";
    }
    if (msAbs >= h4) {
      return Math.round(ms / h4) + "h";
    }
    if (msAbs >= m4) {
      return Math.round(ms / m4) + "m";
    }
    if (msAbs >= s3) {
      return Math.round(ms / s3) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d4) {
      return plural(ms, msAbs, d4, "day");
    }
    if (msAbs >= h4) {
      return plural(ms, msAbs, h4, "hour");
    }
    if (msAbs >= m4) {
      return plural(ms, msAbs, m4, "minute");
    }
    if (msAbs >= s3) {
      return plural(ms, msAbs, s3, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports, module) => {
  var ms = require_ms();
  module.exports = function(time3, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);
    if (typeof time3 === "string") {
      var milliseconds = ms(time3);
      if (typeof milliseconds === "undefined") {
        return;
      }
      return Math.floor(timestamp + milliseconds / 1000);
    } else if (typeof time3 === "number") {
      return timestamp + time3;
    } else {
      return;
    }
  };
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=15.7.0");
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=16.9.0");
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS((exports, module) => {
  var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
  var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
  var allowedAlgorithmsForKeys = {
    ec: ["ES256", "ES384", "ES512"],
    rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
    "rsa-pss": ["PS256", "PS384", "PS512"]
  };
  var allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
  };
  module.exports = function(algorithm, key) {
    if (!algorithm || !key)
      return;
    const keyType = key.asymmetricKeyType;
    if (!keyType)
      return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
      throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
      throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
      switch (keyType) {
        case "ec":
          const keyCurve = key.asymmetricKeyDetails.namedCurve;
          const allowedCurve = allowedCurves[algorithm];
          if (keyCurve !== allowedCurve) {
            throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
          }
          break;
        case "rsa-pss":
          if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
            const length = parseInt(algorithm.slice(-3), 10);
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
            }
            if (saltLength !== undefined && saltLength > length >> 3) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
            }
          }
          break;
      }
    }
  };
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = require_NotBeforeError();
  var TokenExpiredError = require_TokenExpiredError();
  var decode3 = require_decode();
  var timespan = require_timespan();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var { KeyObject, createSecretKey, createPublicKey } = (init_crypto(), __toCommonJS(exports_crypto));
  var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
  var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var HS_ALGS = ["HS256", "HS384", "HS512"];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  }
  module.exports = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    let done;
    if (callback) {
      done = callback;
    } else {
      done = function(err, data) {
        if (err)
          throw err;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
      return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== undefined && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
      return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
      return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
    if (!jwtString) {
      return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
      return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
      return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
      decodedToken = decode3(jwtString, { complete: true });
    } catch (err) {
      return done(err);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
      if (!callback) {
        return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function(header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function(err, secretOrPublicKey2) {
      if (err) {
        return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
      }
      const hasSignature = parts[2].trim() !== "";
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!hasSignature && !options.algorithms) {
        return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
      }
      if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
        try {
          secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
        } catch (_5) {
          try {
            secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
          } catch (_6) {
            return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
          }
        }
      }
      if (!options.algorithms) {
        if (secretOrPublicKey2.type === "secret") {
          options.algorithms = HS_ALGS;
        } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
          options.algorithms = RSA_KEY_ALGS;
        } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
          options.algorithms = EC_KEY_ALGS;
        } else {
          options.algorithms = PUB_KEY_ALGS;
        }
      }
      if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
      }
      let valid;
      try {
        valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
      } catch (e) {
        return done(e);
      }
      if (!valid) {
        return done(new JsonWebTokenError("invalid signature"));
      }
      const payload = decodedToken.payload;
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
        }
      }
      if (options.audience) {
        const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        const match = target.some(function(targetAudience) {
          return audiences.some(function(audience) {
            return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
          });
        });
        if (!match) {
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
        }
      }
      if (options.issuer) {
        const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === "undefined") {
          return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
        }
      }
      if (options.complete === true) {
        const signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature
        });
      }
      return done(null, payload);
    });
  };
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  function arrayMap(array2, iteratee) {
    var index = -1, length = array2 ? array2.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array2[index], index, array2);
    }
    return result;
  }
  function baseFindIndex(array2, predicate, fromIndex, fromRight) {
    var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array2[index], index, array2)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array2, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array2, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array2.length;
    while (++index < length) {
      if (array2[index] === value) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseValues(object2, props) {
    return arrayMap(props, function(key) {
      return object2[key];
    });
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  function keys(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  function values(object2) {
    return object2 ? baseValues(object2, keys(object2)) : [];
  }
  module.exports = includes;
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  module.exports = isBoolean;
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isInteger(value) {
    return typeof value == "number" && value == toInteger(value);
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  module.exports = isInteger;
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS((exports, module) => {
  var numberTag = "[object Number]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
  }
  module.exports = isNumber;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {}
    }
    return result;
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject2;
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS((exports, module) => {
  var stringTag = "[object String]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var isArray = Array.isArray;
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
  }
  module.exports = isString;
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS((exports, module) => {
  var FUNC_ERROR_TEXT = "Expected a function";
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function before(n, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = undefined;
      }
      return result;
    };
  }
  function once(func) {
    return before(2, func);
  }
  function isObject2(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject2(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject2(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  module.exports = once;
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS((exports, module) => {
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var jws = require_jws();
  var includes = require_lodash();
  var isBoolean = require_lodash2();
  var isInteger = require_lodash3();
  var isNumber = require_lodash4();
  var isPlainObject2 = require_lodash5();
  var isString = require_lodash6();
  var once = require_lodash7();
  var { KeyObject, createSecretKey, createPrivateKey } = (init_crypto(), __toCommonJS(exports_crypto));
  var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
  }
  var sign_options_schema = {
    expiresIn: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
    notBefore: { isValid: function(value) {
      return isInteger(value) || isString(value) && value;
    }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
    audience: { isValid: function(value) {
      return isString(value) || Array.isArray(value);
    }, message: '"audience" must be a string or array' },
    algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
    header: { isValid: isPlainObject2, message: '"header" must be an object' },
    encoding: { isValid: isString, message: '"encoding" must be a string' },
    issuer: { isValid: isString, message: '"issuer" must be a string' },
    subject: { isValid: isString, message: '"subject" must be a string' },
    jwtid: { isValid: isString, message: '"jwtid" must be a string' },
    noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
    keyid: { isValid: isString, message: '"keyid" must be a string' },
    mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
    allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
    allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
  };
  var registered_claims_schema = {
    iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
  };
  function validate(schema, allowUnknown, object2, parameterName) {
    if (!isPlainObject2(object2)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object2).forEach(function(key) {
      const validator = schema[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object2[key])) {
        throw new Error(validator.message);
      }
    });
  }
  function validateOptions(options) {
    return validate(sign_options_schema, false, options, "options");
  }
  function validatePayload(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
  }
  var options_to_payload = {
    audience: "aud",
    issuer: "iss",
    subject: "sub",
    jwtid: "jti"
  };
  var options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
  ];
  module.exports = function(payload, secretOrPrivateKey, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
      alg: options.algorithm || "HS256",
      typ: isObjectPayload ? "JWT" : undefined,
      kid: options.keyid
    }, options.header);
    function failure(err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (!secretOrPrivateKey && options.algorithm !== "none") {
      return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
      try {
        secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
      } catch (_5) {
        try {
          secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
        } catch (_6) {
          return failure(new Error("secretOrPrivateKey is not valid key material"));
        }
      }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
      return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
      if (secretOrPrivateKey.type !== "private") {
        return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== undefined && secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
        return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
    }
    if (typeof payload === "undefined") {
      return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error45) {
        return failure(error45);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      const invalid_options = options_for_objects.filter(function(opt) {
        return typeof options[opt] !== "undefined";
      });
      if (invalid_options.length > 0) {
        return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
      }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
      return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
      return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
      validateOptions(options);
    } catch (error45) {
      return failure(error45);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey(header.alg, secretOrPrivateKey);
      } catch (error45) {
        return failure(error45);
      }
    }
    const timestamp = payload.iat || Math.floor(Date.now() / 1000);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp;
    }
    if (typeof options.notBefore !== "undefined") {
      try {
        payload.nbf = timespan(options.notBefore, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.nbf === "undefined") {
        return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
      try {
        payload.exp = timespan(options.expiresIn, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.exp === "undefined") {
        return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    Object.keys(options_to_payload).forEach(function(key) {
      const claim = options_to_payload[key];
      if (typeof options[key] !== "undefined") {
        if (typeof payload[claim] !== "undefined") {
          return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
        }
        payload[claim] = options[key];
      }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
      callback = callback && once(callback);
      jws.createSign({
        header,
        privateKey: secretOrPrivateKey,
        payload,
        encoding
      }).once("error", callback).once("done", function(signature) {
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
        callback(null, signature);
      });
    } else {
      let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
      }
      return signature;
    }
  };
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports, module) => {
  module.exports = {
    decode: require_decode(),
    verify: require_verify(),
    sign: require_sign(),
    JsonWebTokenError: require_JsonWebTokenError(),
    NotBeforeError: require_NotBeforeError(),
    TokenExpiredError: require_TokenExpiredError()
  };
});

// node_modules/dotenv/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "dotenv",
    version: "17.2.3",
    description: "Loads environment variables from .env file",
    main: "lib/main.js",
    types: "lib/main.d.ts",
    exports: {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        default: "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    },
    scripts: {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      pretest: "npm run lint && npm run dts-check",
      test: "tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000",
      "test:coverage": "tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    },
    repository: {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    },
    homepage: "https://github.com/motdotla/dotenv#readme",
    funding: "https://dotenvx.com",
    keywords: [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ],
    readmeFilename: "README.md",
    license: "BSD-2-Clause",
    devDependencies: {
      "@types/node": "^18.11.3",
      decache: "^4.6.2",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-version": "^9.5.0",
      tap: "^19.2.0",
      typescript: "^4.8.4"
    },
    engines: {
      node: ">=12"
    },
    browser: {
      fs: false
    }
  };
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS((exports, module) => {
  var fs = (() => ({}));
  var path = (init_path(), __toCommonJS(exports_path));
  var os2 = (init_os(), __toCommonJS(exports_os));
  var crypto2 = (init_crypto(), __toCommonJS(exports_crypto));
  var packageJson = require_package();
  var version2 = packageJson.version;
  var TIPS = [
    "\uD83D\uDD10 encrypt with Dotenvx: https://dotenvx.com",
    "\uD83D\uDD10 prevent committing .env to code: https://dotenvx.com/precommit",
    "\uD83D\uDD10 prevent building .env in docker: https://dotenvx.com/prebuild",
    "\uD83D\uDCE1 add observability to secrets: https://dotenvx.com/ops",
    "\uD83D\uDC65 sync secrets across teammates & machines: https://dotenvx.com/ops",
    "\uD83D\uDDC2️ backup and recover secrets: https://dotenvx.com/ops",
    "✅ audit secrets and track compliance: https://dotenvx.com/ops",
    "\uD83D\uDD04 add secrets lifecycle management: https://dotenvx.com/ops",
    "\uD83D\uDD11 add access controls to secrets: https://dotenvx.com/ops",
    "\uD83D\uDEE0️  run anywhere with `dotenvx run -- yourcommand`",
    "⚙️  specify custom .env file path with { path: '/custom/path/.env' }",
    "⚙️  enable debug logging with { debug: true }",
    "⚙️  override existing env vars with { override: true }",
    "⚙️  suppress all logs with { quiet: true }",
    "⚙️  write to custom object with { processEnv: myObject }",
    "⚙️  load multiple .env files with { path: ['.env.local', '.env'] }"
  ];
  function _getRandomTip() {
    return TIPS[Math.floor(Math.random() * TIPS.length)];
  }
  function parseBoolean(value) {
    if (typeof value === "string") {
      return !["false", "0", "no", "off", ""].includes(value.toLowerCase());
    }
    return Boolean(value);
  }
  function supportsAnsi() {
    return process.stdout.isTTY;
  }
  function dim(text) {
    return supportsAnsi() ? `\x1B[2m${text}\x1B[0m` : text;
  }
  var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
  function parse5(src) {
    const obj = {};
    let lines = src.toString();
    lines = lines.replace(/\r\n?/mg, `
`);
    let match;
    while ((match = LINE.exec(lines)) != null) {
      const key = match[1];
      let value = match[2] || "";
      value = value.trim();
      const maybeQuote = value[0];
      value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
      if (maybeQuote === '"') {
        value = value.replace(/\\n/g, `
`);
        value = value.replace(/\\r/g, "\r");
      }
      obj[key] = value;
    }
    return obj;
  }
  function _parseVault(options) {
    options = options || {};
    const vaultPath = _vaultPath(options);
    options.path = vaultPath;
    const result = DotenvModule.configDotenv(options);
    if (!result.parsed) {
      const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
      err.code = "MISSING_DATA";
      throw err;
    }
    const keys = _dotenvKey(options).split(",");
    const length = keys.length;
    let decrypted;
    for (let i = 0;i < length; i++) {
      try {
        const key = keys[i].trim();
        const attrs = _instructions(result, key);
        decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
        break;
      } catch (error45) {
        if (i + 1 >= length) {
          throw error45;
        }
      }
    }
    return DotenvModule.parse(decrypted);
  }
  function _warn(message) {
    console.error(`[dotenv@${version2}][WARN] ${message}`);
  }
  function _debug(message) {
    console.log(`[dotenv@${version2}][DEBUG] ${message}`);
  }
  function _log(message) {
    console.log(`[dotenv@${version2}] ${message}`);
  }
  function _dotenvKey(options) {
    if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
      return options.DOTENV_KEY;
    }
    if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
      return process.env.DOTENV_KEY;
    }
    return "";
  }
  function _instructions(result, dotenvKey) {
    let uri;
    try {
      uri = new URL(dotenvKey);
    } catch (error45) {
      if (error45.code === "ERR_INVALID_URL") {
        const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      throw error45;
    }
    const key = uri.password;
    if (!key) {
      const err = new Error("INVALID_DOTENV_KEY: Missing key part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environment = uri.searchParams.get("environment");
    if (!environment) {
      const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
    const ciphertext = result.parsed[environmentKey];
    if (!ciphertext) {
      const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
      err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
      throw err;
    }
    return { ciphertext, key };
  }
  function _vaultPath(options) {
    let possibleVaultPath = null;
    if (options && options.path && options.path.length > 0) {
      if (Array.isArray(options.path)) {
        for (const filepath of options.path) {
          if (fs.existsSync(filepath)) {
            possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
          }
        }
      } else {
        possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
      }
    } else {
      possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
    }
    if (fs.existsSync(possibleVaultPath)) {
      return possibleVaultPath;
    }
    return null;
  }
  function _resolveHome(envPath) {
    return envPath[0] === "~" ? path.join(os2.homedir(), envPath.slice(1)) : envPath;
  }
  function _configVault(options) {
    const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || options && options.debug);
    const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (debug || !quiet) {
      _log("Loading env from encrypted .env.vault");
    }
    const parsed = DotenvModule._parseVault(options);
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    DotenvModule.populate(processEnv, parsed, options);
    return { parsed };
  }
  function configDotenv(options) {
    const dotenvPath = path.resolve(process.cwd(), ".env");
    let encoding = "utf8";
    let processEnv = process.env;
    if (options && options.processEnv != null) {
      processEnv = options.processEnv;
    }
    let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || options && options.debug);
    let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || options && options.quiet);
    if (options && options.encoding) {
      encoding = options.encoding;
    } else {
      if (debug) {
        _debug("No encoding is specified. UTF-8 is used by default");
      }
    }
    let optionPaths = [dotenvPath];
    if (options && options.path) {
      if (!Array.isArray(options.path)) {
        optionPaths = [_resolveHome(options.path)];
      } else {
        optionPaths = [];
        for (const filepath of options.path) {
          optionPaths.push(_resolveHome(filepath));
        }
      }
    }
    let lastError;
    const parsedAll = {};
    for (const path2 of optionPaths) {
      try {
        const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
        DotenvModule.populate(parsedAll, parsed, options);
      } catch (e) {
        if (debug) {
          _debug(`Failed to load ${path2} ${e.message}`);
        }
        lastError = e;
      }
    }
    const populated = DotenvModule.populate(processEnv, parsedAll, options);
    debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug);
    quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet);
    if (debug || !quiet) {
      const keysCount = Object.keys(populated).length;
      const shortPaths = [];
      for (const filePath of optionPaths) {
        try {
          const relative = path.relative(process.cwd(), filePath);
          shortPaths.push(relative);
        } catch (e) {
          if (debug) {
            _debug(`Failed to load ${filePath} ${e.message}`);
          }
          lastError = e;
        }
      }
      _log(`injecting env (${keysCount}) from ${shortPaths.join(",")} ${dim(`-- tip: ${_getRandomTip()}`)}`);
    }
    if (lastError) {
      return { parsed: parsedAll, error: lastError };
    } else {
      return { parsed: parsedAll };
    }
  }
  function config2(options) {
    if (_dotenvKey(options).length === 0) {
      return DotenvModule.configDotenv(options);
    }
    const vaultPath = _vaultPath(options);
    if (!vaultPath) {
      _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
      return DotenvModule.configDotenv(options);
    }
    return DotenvModule._configVault(options);
  }
  function decrypt(encrypted, keyStr) {
    const key = Buffer.from(keyStr.slice(-64), "hex");
    let ciphertext = Buffer.from(encrypted, "base64");
    const nonce = ciphertext.subarray(0, 12);
    const authTag = ciphertext.subarray(-16);
    ciphertext = ciphertext.subarray(12, -16);
    try {
      const aesgcm = crypto2.createDecipheriv("aes-256-gcm", key, nonce);
      aesgcm.setAuthTag(authTag);
      return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
    } catch (error45) {
      const isRange = error45 instanceof RangeError;
      const invalidKeyLength = error45.message === "Invalid key length";
      const decryptionFailed = error45.message === "Unsupported state or unable to authenticate data";
      if (isRange || invalidKeyLength) {
        const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      } else if (decryptionFailed) {
        const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
        err.code = "DECRYPTION_FAILED";
        throw err;
      } else {
        throw error45;
      }
    }
  }
  function populate(processEnv, parsed, options = {}) {
    const debug = Boolean(options && options.debug);
    const override = Boolean(options && options.override);
    const populated = {};
    if (typeof parsed !== "object") {
      const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
      err.code = "OBJECT_REQUIRED";
      throw err;
    }
    for (const key of Object.keys(parsed)) {
      if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
        if (override === true) {
          processEnv[key] = parsed[key];
          populated[key] = parsed[key];
        }
        if (debug) {
          if (override === true) {
            _debug(`"${key}" is already defined and WAS overwritten`);
          } else {
            _debug(`"${key}" is already defined and was NOT overwritten`);
          }
        }
      } else {
        processEnv[key] = parsed[key];
        populated[key] = parsed[key];
      }
    }
    return populated;
  }
  var DotenvModule = {
    configDotenv,
    _configVault,
    _parseVault,
    config: config2,
    decrypt,
    parse: parse5,
    populate
  };
  exports.configDotenv = DotenvModule.configDotenv;
  exports._configVault = DotenvModule._configVault;
  exports._parseVault = DotenvModule._parseVault;
  exports.config = DotenvModule.config;
  exports.decrypt = DotenvModule.decrypt;
  exports.parse = DotenvModule.parse;
  exports.populate = DotenvModule.populate;
  module.exports = DotenvModule;
});

// src/generated/prisma/runtime/index-browser.js
var require_index_browser = __commonJS((exports, module) => {
  var pe2 = Object.defineProperty;
  var Xe = Object.getOwnPropertyDescriptor;
  var Ke2 = Object.getOwnPropertyNames;
  var Qe2 = Object.prototype.hasOwnProperty;
  var Ye = (e) => {
    throw TypeError(e);
  };
  var Oe = (e, n) => {
    for (var i in n)
      pe2(e, i, { get: n[i], enumerable: true });
  };
  var xe = (e, n, i, t) => {
    if (n && typeof n == "object" || typeof n == "function")
      for (let r of Ke2(n))
        !Qe2.call(e, r) && r !== i && pe2(e, r, { get: () => n[r], enumerable: !(t = Xe(n, r)) || t.enumerable });
    return e;
  };
  var ze = (e) => xe(pe2({}, "__esModule", { value: true }), e);
  var ne = (e, n, i) => n.has(e) ? Ye("Cannot add the same private member more than once") : n instanceof WeakSet ? n.add(e) : n.set(e, i);
  var ii = {};
  Oe(ii, { Decimal: () => Je, Public: () => ge, getRuntime: () => _e3, makeStrictEnum: () => qe2, objectEnumValues: () => Ae2 });
  module.exports = ze(ii);
  var ge = {};
  Oe(ge, { validator: () => Re });
  function Re(...e) {
    return (n) => n;
  }
  var ie = Symbol();
  var me = new WeakMap;
  var we = class {
    constructor(n) {
      n === ie ? me.set(this, "Prisma.".concat(this._getName())) : me.set(this, "new Prisma.".concat(this._getNamespace(), ".").concat(this._getName(), "()"));
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return me.get(this);
    }
  };
  var G3 = class extends we {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var Ne;
  var J4 = class extends G3 {
    constructor() {
      super(...arguments);
      ne(this, Ne);
    }
  };
  Ne = new WeakMap;
  ke3(J4, "DbNull");
  var ve;
  var X5 = class extends G3 {
    constructor() {
      super(...arguments);
      ne(this, ve);
    }
  };
  ve = new WeakMap;
  ke3(X5, "JsonNull");
  var Ee;
  var K6 = class extends G3 {
    constructor() {
      super(...arguments);
      ne(this, Ee);
    }
  };
  Ee = new WeakMap;
  ke3(K6, "AnyNull");
  var Ae2 = { classes: { DbNull: J4, JsonNull: X5, AnyNull: K6 }, instances: { DbNull: new J4(ie), JsonNull: new X5(ie), AnyNull: new K6(ie) } };
  function ke3(e, n) {
    Object.defineProperty(e, "name", { value: n, configurable: true });
  }
  var ye = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  function qe2(e) {
    return new Proxy(e, { get(n, i) {
      if (i in n)
        return n[i];
      if (!ye.has(i))
        throw new TypeError("Invalid enum value: ".concat(String(i)));
    } });
  }
  var en = () => {
    var e, n;
    return ((n = (e = globalThis.process) == null ? undefined : e.release) == null ? undefined : n.name) === "node";
  };
  var nn = () => {
    var e, n;
    return !!globalThis.Bun || !!((n = (e = globalThis.process) == null ? undefined : e.versions) != null && n.bun);
  };
  var tn2 = () => !!globalThis.Deno;
  var rn3 = () => typeof globalThis.Netlify == "object";
  var sn2 = () => typeof globalThis.EdgeRuntime == "object";
  var on2 = () => {
    var e;
    return ((e = globalThis.navigator) == null ? undefined : e.userAgent) === "Cloudflare-Workers";
  };
  function un() {
    var i;
    return (i = [[rn3, "netlify"], [sn2, "edge-light"], [on2, "workerd"], [tn2, "deno"], [nn, "bun"], [en, "node"]].flatMap((t) => t[0]() ? [t[1]] : []).at(0)) != null ? i : "";
  }
  var fn = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
  function _e3() {
    let e = un();
    return { id: e, prettyName: fn[e] || e, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e) };
  }
  var V5 = 9000000000000000;
  var H4 = 1e9;
  var Se3 = "0123456789abcdef";
  var se2 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var oe3 = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var Me = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -V5, maxE: V5, crypto: false };
  var Le;
  var Z4;
  var w4 = true;
  var fe3 = "[DecimalError] ";
  var $3 = fe3 + "Invalid argument: ";
  var Ie2 = fe3 + "Precision limit exceeded";
  var Ze2 = fe3 + "crypto unavailable";
  var Ue = "[object Decimal]";
  var R3 = Math.floor;
  var C3 = Math.pow;
  var cn2 = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var ln = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var an2 = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var Be = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var D4 = 1e7;
  var m4 = 7;
  var dn = 9007199254740991;
  var hn2 = se2.length - 1;
  var Ce = oe3.length - 1;
  var h4 = { toStringTag: Ue };
  h4.absoluteValue = h4.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), p4(e);
  };
  h4.ceil = function() {
    return p4(new this.constructor(this), this.e + 1, 2);
  };
  h4.clampedTo = h4.clamp = function(e, n) {
    var i, t = this, r = t.constructor;
    if (e = new r(e), n = new r(n), !e.s || !n.s)
      return new r(NaN);
    if (e.gt(n))
      throw Error($3 + n);
    return i = t.cmp(e), i < 0 ? e : t.cmp(n) > 0 ? n : new r(t);
  };
  h4.comparedTo = h4.cmp = function(e) {
    var n, i, t, r, s3 = this, o2 = s3.d, u3 = (e = new s3.constructor(e)).d, c2 = s3.s, f2 = e.s;
    if (!o2 || !u3)
      return !c2 || !f2 ? NaN : c2 !== f2 ? c2 : o2 === u3 ? 0 : !o2 ^ c2 < 0 ? 1 : -1;
    if (!o2[0] || !u3[0])
      return o2[0] ? c2 : u3[0] ? -f2 : 0;
    if (c2 !== f2)
      return c2;
    if (s3.e !== e.e)
      return s3.e > e.e ^ c2 < 0 ? 1 : -1;
    for (t = o2.length, r = u3.length, n = 0, i = t < r ? t : r;n < i; ++n)
      if (o2[n] !== u3[n])
        return o2[n] > u3[n] ^ c2 < 0 ? 1 : -1;
    return t === r ? 0 : t > r ^ c2 < 0 ? 1 : -1;
  };
  h4.cosine = h4.cos = function() {
    var e, n, i = this, t = i.constructor;
    return i.d ? i.d[0] ? (e = t.precision, n = t.rounding, t.precision = e + Math.max(i.e, i.sd()) + m4, t.rounding = 1, i = pn3(t, We2(t, i)), t.precision = e, t.rounding = n, p4(Z4 == 2 || Z4 == 3 ? i.neg() : i, e, n, true)) : new t(1) : new t(NaN);
  };
  h4.cubeRoot = h4.cbrt = function() {
    var e, n, i, t, r, s3, o2, u3, c2, f2, l3 = this, a3 = l3.constructor;
    if (!l3.isFinite() || l3.isZero())
      return new a3(l3);
    for (w4 = false, s3 = l3.s * C3(l3.s * l3, 1 / 3), !s3 || Math.abs(s3) == 1 / 0 ? (i = b6(l3.d), e = l3.e, (s3 = (e - i.length + 1) % 3) && (i += s3 == 1 || s3 == -2 ? "0" : "00"), s3 = C3(i, 1 / 3), e = R3((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), s3 == 1 / 0 ? i = "5e" + e : (i = s3.toExponential(), i = i.slice(0, i.indexOf("e") + 1) + e), t = new a3(i), t.s = l3.s) : t = new a3(s3.toString()), o2 = (e = a3.precision) + 3;; )
      if (u3 = t, c2 = u3.times(u3).times(u3), f2 = c2.plus(l3), t = k5(f2.plus(l3).times(u3), f2.plus(c2), o2 + 2, 1), b6(u3.d).slice(0, o2) === (i = b6(t.d)).slice(0, o2))
        if (i = i.slice(o2 - 3, o2 + 1), i == "9999" || !r && i == "4999") {
          if (!r && (p4(u3, e + 1, 0), u3.times(u3).times(u3).eq(l3))) {
            t = u3;
            break;
          }
          o2 += 4, r = 1;
        } else {
          (!+i || !+i.slice(1) && i.charAt(0) == "5") && (p4(t, e + 1, 1), n = !t.times(t).times(t).eq(l3));
          break;
        }
    return w4 = true, p4(t, e, a3.rounding, n);
  };
  h4.decimalPlaces = h4.dp = function() {
    var e, n = this.d, i = NaN;
    if (n) {
      if (e = n.length - 1, i = (e - R3(this.e / m4)) * m4, e = n[e], e)
        for (;e % 10 == 0; e /= 10)
          i--;
      i < 0 && (i = 0);
    }
    return i;
  };
  h4.dividedBy = h4.div = function(e) {
    return k5(this, new this.constructor(e));
  };
  h4.dividedToIntegerBy = h4.divToInt = function(e) {
    var n = this, i = n.constructor;
    return p4(k5(n, new i(e), 0, 1, 1), i.precision, i.rounding);
  };
  h4.equals = h4.eq = function(e) {
    return this.cmp(e) === 0;
  };
  h4.floor = function() {
    return p4(new this.constructor(this), this.e + 1, 3);
  };
  h4.greaterThan = h4.gt = function(e) {
    return this.cmp(e) > 0;
  };
  h4.greaterThanOrEqualTo = h4.gte = function(e) {
    var n = this.cmp(e);
    return n == 1 || n === 0;
  };
  h4.hyperbolicCosine = h4.cosh = function() {
    var e, n, i, t, r, s3 = this, o2 = s3.constructor, u3 = new o2(1);
    if (!s3.isFinite())
      return new o2(s3.s ? 1 / 0 : NaN);
    if (s3.isZero())
      return u3;
    i = o2.precision, t = o2.rounding, o2.precision = i + Math.max(s3.e, s3.sd()) + 4, o2.rounding = 1, r = s3.d.length, r < 32 ? (e = Math.ceil(r / 3), n = (1 / le(4, e)).toString()) : (e = 16, n = "2.3283064365386962890625e-10"), s3 = j5(o2, 1, s3.times(n), new o2(1), true);
    for (var c2, f2 = e, l3 = new o2(8);f2--; )
      c2 = s3.times(s3), s3 = u3.minus(c2.times(l3.minus(c2.times(l3))));
    return p4(s3, o2.precision = i, o2.rounding = t, true);
  };
  h4.hyperbolicSine = h4.sinh = function() {
    var e, n, i, t, r = this, s3 = r.constructor;
    if (!r.isFinite() || r.isZero())
      return new s3(r);
    if (n = s3.precision, i = s3.rounding, s3.precision = n + Math.max(r.e, r.sd()) + 4, s3.rounding = 1, t = r.d.length, t < 3)
      r = j5(s3, 2, r, r, true);
    else {
      e = 1.4 * Math.sqrt(t), e = e > 16 ? 16 : e | 0, r = r.times(1 / le(5, e)), r = j5(s3, 2, r, r, true);
      for (var o2, u3 = new s3(5), c2 = new s3(16), f2 = new s3(20);e--; )
        o2 = r.times(r), r = r.times(u3.plus(o2.times(c2.times(o2).plus(f2))));
    }
    return s3.precision = n, s3.rounding = i, p4(r, n, i, true);
  };
  h4.hyperbolicTangent = h4.tanh = function() {
    var e, n, i = this, t = i.constructor;
    return i.isFinite() ? i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + 7, t.rounding = 1, k5(i.sinh(), i.cosh(), t.precision = e, t.rounding = n)) : new t(i.s);
  };
  h4.inverseCosine = h4.acos = function() {
    var e = this, n = e.constructor, i = e.abs().cmp(1), t = n.precision, r = n.rounding;
    return i !== -1 ? i === 0 ? e.isNeg() ? F3(n, t, r) : new n(0) : new n(NaN) : e.isZero() ? F3(n, t + 4, r).times(0.5) : (n.precision = t + 6, n.rounding = 1, e = new n(1).minus(e).div(e.plus(1)).sqrt().atan(), n.precision = t, n.rounding = r, e.times(2));
  };
  h4.inverseHyperbolicCosine = h4.acosh = function() {
    var e, n, i = this, t = i.constructor;
    return i.lte(1) ? new t(i.eq(1) ? 0 : NaN) : i.isFinite() ? (e = t.precision, n = t.rounding, t.precision = e + Math.max(Math.abs(i.e), i.sd()) + 4, t.rounding = 1, w4 = false, i = i.times(i).minus(1).sqrt().plus(i), w4 = true, t.precision = e, t.rounding = n, i.ln()) : new t(i);
  };
  h4.inverseHyperbolicSine = h4.asinh = function() {
    var e, n, i = this, t = i.constructor;
    return !i.isFinite() || i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + 2 * Math.max(Math.abs(i.e), i.sd()) + 6, t.rounding = 1, w4 = false, i = i.times(i).plus(1).sqrt().plus(i), w4 = true, t.precision = e, t.rounding = n, i.ln());
  };
  h4.inverseHyperbolicTangent = h4.atanh = function() {
    var e, n, i, t, r = this, s3 = r.constructor;
    return r.isFinite() ? r.e >= 0 ? new s3(r.abs().eq(1) ? r.s / 0 : r.isZero() ? r : NaN) : (e = s3.precision, n = s3.rounding, t = r.sd(), Math.max(t, e) < 2 * -r.e - 1 ? p4(new s3(r), e, n, true) : (s3.precision = i = t - r.e, r = k5(r.plus(1), new s3(1).minus(r), i + e, 1), s3.precision = e + 4, s3.rounding = 1, r = r.ln(), s3.precision = e, s3.rounding = n, r.times(0.5))) : new s3(NaN);
  };
  h4.inverseSine = h4.asin = function() {
    var e, n, i, t, r = this, s3 = r.constructor;
    return r.isZero() ? new s3(r) : (n = r.abs().cmp(1), i = s3.precision, t = s3.rounding, n !== -1 ? n === 0 ? (e = F3(s3, i + 4, t).times(0.5), e.s = r.s, e) : new s3(NaN) : (s3.precision = i + 6, s3.rounding = 1, r = r.div(new s3(1).minus(r.times(r)).sqrt().plus(1)).atan(), s3.precision = i, s3.rounding = t, r.times(2)));
  };
  h4.inverseTangent = h4.atan = function() {
    var e, n, i, t, r, s3, o2, u3, c2, f2 = this, l3 = f2.constructor, a3 = l3.precision, d4 = l3.rounding;
    if (f2.isFinite()) {
      if (f2.isZero())
        return new l3(f2);
      if (f2.abs().eq(1) && a3 + 4 <= Ce)
        return o2 = F3(l3, a3 + 4, d4).times(0.25), o2.s = f2.s, o2;
    } else {
      if (!f2.s)
        return new l3(NaN);
      if (a3 + 4 <= Ce)
        return o2 = F3(l3, a3 + 4, d4).times(0.5), o2.s = f2.s, o2;
    }
    for (l3.precision = u3 = a3 + 10, l3.rounding = 1, i = Math.min(28, u3 / m4 + 2 | 0), e = i;e; --e)
      f2 = f2.div(f2.times(f2).plus(1).sqrt().plus(1));
    for (w4 = false, n = Math.ceil(u3 / m4), t = 1, c2 = f2.times(f2), o2 = new l3(f2), r = f2;e !== -1; )
      if (r = r.times(c2), s3 = o2.minus(r.div(t += 2)), r = r.times(c2), o2 = s3.plus(r.div(t += 2)), o2.d[n] !== undefined)
        for (e = n;o2.d[e] === s3.d[e] && e--; )
          ;
    return i && (o2 = o2.times(2 << i - 1)), w4 = true, p4(o2, l3.precision = a3, l3.rounding = d4, true);
  };
  h4.isFinite = function() {
    return !!this.d;
  };
  h4.isInteger = h4.isInt = function() {
    return !!this.d && R3(this.e / m4) > this.d.length - 2;
  };
  h4.isNaN = function() {
    return !this.s;
  };
  h4.isNegative = h4.isNeg = function() {
    return this.s < 0;
  };
  h4.isPositive = h4.isPos = function() {
    return this.s > 0;
  };
  h4.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  h4.lessThan = h4.lt = function(e) {
    return this.cmp(e) < 0;
  };
  h4.lessThanOrEqualTo = h4.lte = function(e) {
    return this.cmp(e) < 1;
  };
  h4.logarithm = h4.log = function(e) {
    var n, i, t, r, s3, o2, u3, c2, f2 = this, l3 = f2.constructor, a3 = l3.precision, d4 = l3.rounding, g4 = 5;
    if (e == null)
      e = new l3(10), n = true;
    else {
      if (e = new l3(e), i = e.d, e.s < 0 || !i || !i[0] || e.eq(1))
        return new l3(NaN);
      n = e.eq(10);
    }
    if (i = f2.d, f2.s < 0 || !i || !i[0] || f2.eq(1))
      return new l3(i && !i[0] ? -1 / 0 : f2.s != 1 ? NaN : i ? 0 : 1 / 0);
    if (n)
      if (i.length > 1)
        s3 = true;
      else {
        for (r = i[0];r % 10 === 0; )
          r /= 10;
        s3 = r !== 1;
      }
    if (w4 = false, u3 = a3 + g4, o2 = B4(f2, u3), t = n ? ue4(l3, u3 + 10) : B4(e, u3), c2 = k5(o2, t, u3, 1), Q5(c2.d, r = a3, d4))
      do
        if (u3 += 10, o2 = B4(f2, u3), t = n ? ue4(l3, u3 + 10) : B4(e, u3), c2 = k5(o2, t, u3, 1), !s3) {
          +b6(c2.d).slice(r + 1, r + 15) + 1 == 100000000000000 && (c2 = p4(c2, a3 + 1, 0));
          break;
        }
      while (Q5(c2.d, r += 10, d4));
    return w4 = true, p4(c2, a3, d4);
  };
  h4.minus = h4.sub = function(e) {
    var n, i, t, r, s3, o2, u3, c2, f2, l3, a3, d4, g4 = this, v4 = g4.constructor;
    if (e = new v4(e), !g4.d || !e.d)
      return !g4.s || !e.s ? e = new v4(NaN) : g4.d ? e.s = -e.s : e = new v4(e.d || g4.s !== e.s ? g4 : NaN), e;
    if (g4.s != e.s)
      return e.s = -e.s, g4.plus(e);
    if (f2 = g4.d, d4 = e.d, u3 = v4.precision, c2 = v4.rounding, !f2[0] || !d4[0]) {
      if (d4[0])
        e.s = -e.s;
      else if (f2[0])
        e = new v4(g4);
      else
        return new v4(c2 === 3 ? -0 : 0);
      return w4 ? p4(e, u3, c2) : e;
    }
    if (i = R3(e.e / m4), l3 = R3(g4.e / m4), f2 = f2.slice(), s3 = l3 - i, s3) {
      for (a3 = s3 < 0, a3 ? (n = f2, s3 = -s3, o2 = d4.length) : (n = d4, i = l3, o2 = f2.length), t = Math.max(Math.ceil(u3 / m4), o2) + 2, s3 > t && (s3 = t, n.length = 1), n.reverse(), t = s3;t--; )
        n.push(0);
      n.reverse();
    } else {
      for (t = f2.length, o2 = d4.length, a3 = t < o2, a3 && (o2 = t), t = 0;t < o2; t++)
        if (f2[t] != d4[t]) {
          a3 = f2[t] < d4[t];
          break;
        }
      s3 = 0;
    }
    for (a3 && (n = f2, f2 = d4, d4 = n, e.s = -e.s), o2 = f2.length, t = d4.length - o2;t > 0; --t)
      f2[o2++] = 0;
    for (t = d4.length;t > s3; ) {
      if (f2[--t] < d4[t]) {
        for (r = t;r && f2[--r] === 0; )
          f2[r] = D4 - 1;
        --f2[r], f2[t] += D4;
      }
      f2[t] -= d4[t];
    }
    for (;f2[--o2] === 0; )
      f2.pop();
    for (;f2[0] === 0; f2.shift())
      --i;
    return f2[0] ? (e.d = f2, e.e = ce3(f2, i), w4 ? p4(e, u3, c2) : e) : new v4(c2 === 3 ? -0 : 0);
  };
  h4.modulo = h4.mod = function(e) {
    var n, i = this, t = i.constructor;
    return e = new t(e), !i.d || !e.s || e.d && !e.d[0] ? new t(NaN) : !e.d || i.d && !i.d[0] ? p4(new t(i), t.precision, t.rounding) : (w4 = false, t.modulo == 9 ? (n = k5(i, e.abs(), 0, 3, 1), n.s *= e.s) : n = k5(i, e, 0, t.modulo, 1), n = n.times(e), w4 = true, i.minus(n));
  };
  h4.naturalExponential = h4.exp = function() {
    return be(this);
  };
  h4.naturalLogarithm = h4.ln = function() {
    return B4(this);
  };
  h4.negated = h4.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, p4(e);
  };
  h4.plus = h4.add = function(e) {
    var n, i, t, r, s3, o2, u3, c2, f2, l3, a3 = this, d4 = a3.constructor;
    if (e = new d4(e), !a3.d || !e.d)
      return !a3.s || !e.s ? e = new d4(NaN) : a3.d || (e = new d4(e.d || a3.s === e.s ? a3 : NaN)), e;
    if (a3.s != e.s)
      return e.s = -e.s, a3.minus(e);
    if (f2 = a3.d, l3 = e.d, u3 = d4.precision, c2 = d4.rounding, !f2[0] || !l3[0])
      return l3[0] || (e = new d4(a3)), w4 ? p4(e, u3, c2) : e;
    if (s3 = R3(a3.e / m4), t = R3(e.e / m4), f2 = f2.slice(), r = s3 - t, r) {
      for (r < 0 ? (i = f2, r = -r, o2 = l3.length) : (i = l3, t = s3, o2 = f2.length), s3 = Math.ceil(u3 / m4), o2 = s3 > o2 ? s3 + 1 : o2 + 1, r > o2 && (r = o2, i.length = 1), i.reverse();r--; )
        i.push(0);
      i.reverse();
    }
    for (o2 = f2.length, r = l3.length, o2 - r < 0 && (r = o2, i = l3, l3 = f2, f2 = i), n = 0;r; )
      n = (f2[--r] = f2[r] + l3[r] + n) / D4 | 0, f2[r] %= D4;
    for (n && (f2.unshift(n), ++t), o2 = f2.length;f2[--o2] == 0; )
      f2.pop();
    return e.d = f2, e.e = ce3(f2, t), w4 ? p4(e, u3, c2) : e;
  };
  h4.precision = h4.sd = function(e) {
    var n, i = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error($3 + e);
    return i.d ? (n = $e2(i.d), e && i.e + 1 > n && (n = i.e + 1)) : n = NaN, n;
  };
  h4.round = function() {
    var e = this, n = e.constructor;
    return p4(new n(e), e.e + 1, n.rounding);
  };
  h4.sine = h4.sin = function() {
    var e, n, i = this, t = i.constructor;
    return i.isFinite() ? i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + Math.max(i.e, i.sd()) + m4, t.rounding = 1, i = mn(t, We2(t, i)), t.precision = e, t.rounding = n, p4(Z4 > 2 ? i.neg() : i, e, n, true)) : new t(NaN);
  };
  h4.squareRoot = h4.sqrt = function() {
    var e, n, i, t, r, s3, o2 = this, u3 = o2.d, c2 = o2.e, f2 = o2.s, l3 = o2.constructor;
    if (f2 !== 1 || !u3 || !u3[0])
      return new l3(!f2 || f2 < 0 && (!u3 || u3[0]) ? NaN : u3 ? o2 : 1 / 0);
    for (w4 = false, f2 = Math.sqrt(+o2), f2 == 0 || f2 == 1 / 0 ? (n = b6(u3), (n.length + c2) % 2 == 0 && (n += "0"), f2 = Math.sqrt(n), c2 = R3((c2 + 1) / 2) - (c2 < 0 || c2 % 2), f2 == 1 / 0 ? n = "5e" + c2 : (n = f2.toExponential(), n = n.slice(0, n.indexOf("e") + 1) + c2), t = new l3(n)) : t = new l3(f2.toString()), i = (c2 = l3.precision) + 3;; )
      if (s3 = t, t = s3.plus(k5(o2, s3, i + 2, 1)).times(0.5), b6(s3.d).slice(0, i) === (n = b6(t.d)).slice(0, i))
        if (n = n.slice(i - 3, i + 1), n == "9999" || !r && n == "4999") {
          if (!r && (p4(s3, c2 + 1, 0), s3.times(s3).eq(o2))) {
            t = s3;
            break;
          }
          i += 4, r = 1;
        } else {
          (!+n || !+n.slice(1) && n.charAt(0) == "5") && (p4(t, c2 + 1, 1), e = !t.times(t).eq(o2));
          break;
        }
    return w4 = true, p4(t, c2, l3.rounding, e);
  };
  h4.tangent = h4.tan = function() {
    var e, n, i = this, t = i.constructor;
    return i.isFinite() ? i.isZero() ? new t(i) : (e = t.precision, n = t.rounding, t.precision = e + 10, t.rounding = 1, i = i.sin(), i.s = 1, i = k5(i, new t(1).minus(i.times(i)).sqrt(), e + 10, 0), t.precision = e, t.rounding = n, p4(Z4 == 2 || Z4 == 4 ? i.neg() : i, e, n, true)) : new t(NaN);
  };
  h4.times = h4.mul = function(e) {
    var n, i, t, r, s3, o2, u3, c2, f2, l3 = this, a3 = l3.constructor, d4 = l3.d, g4 = (e = new a3(e)).d;
    if (e.s *= l3.s, !d4 || !d4[0] || !g4 || !g4[0])
      return new a3(!e.s || d4 && !d4[0] && !g4 || g4 && !g4[0] && !d4 ? NaN : !d4 || !g4 ? e.s / 0 : e.s * 0);
    for (i = R3(l3.e / m4) + R3(e.e / m4), c2 = d4.length, f2 = g4.length, c2 < f2 && (s3 = d4, d4 = g4, g4 = s3, o2 = c2, c2 = f2, f2 = o2), s3 = [], o2 = c2 + f2, t = o2;t--; )
      s3.push(0);
    for (t = f2;--t >= 0; ) {
      for (n = 0, r = c2 + t;r > t; )
        u3 = s3[r] + g4[t] * d4[r - t - 1] + n, s3[r--] = u3 % D4 | 0, n = u3 / D4 | 0;
      s3[r] = (s3[r] + n) % D4 | 0;
    }
    for (;!s3[--o2]; )
      s3.pop();
    return n ? ++i : s3.shift(), e.d = s3, e.e = ce3(s3, i), w4 ? p4(e, a3.precision, a3.rounding) : e;
  };
  h4.toBinary = function(e, n) {
    return Pe2(this, 2, e, n);
  };
  h4.toDecimalPlaces = h4.toDP = function(e, n) {
    var i = this, t = i.constructor;
    return i = new t(i), e === undefined ? i : (q2(e, 0, H4), n === undefined ? n = t.rounding : q2(n, 0, 8), p4(i, e + i.e + 1, n));
  };
  h4.toExponential = function(e, n) {
    var i, t = this, r = t.constructor;
    return e === undefined ? i = L4(t, true) : (q2(e, 0, H4), n === undefined ? n = r.rounding : q2(n, 0, 8), t = p4(new r(t), e + 1, n), i = L4(t, true, e + 1)), t.isNeg() && !t.isZero() ? "-" + i : i;
  };
  h4.toFixed = function(e, n) {
    var i, t, r = this, s3 = r.constructor;
    return e === undefined ? i = L4(r) : (q2(e, 0, H4), n === undefined ? n = s3.rounding : q2(n, 0, 8), t = p4(new s3(r), e + r.e + 1, n), i = L4(t, false, e + t.e + 1)), r.isNeg() && !r.isZero() ? "-" + i : i;
  };
  h4.toFraction = function(e) {
    var n, i, t, r, s3, o2, u3, c2, f2, l3, a3, d4, g4 = this, v4 = g4.d, N6 = g4.constructor;
    if (!v4)
      return new N6(g4);
    if (f2 = i = new N6(1), t = c2 = new N6(0), n = new N6(t), s3 = n.e = $e2(v4) - g4.e - 1, o2 = s3 % m4, n.d[0] = C3(10, o2 < 0 ? m4 + o2 : o2), e == null)
      e = s3 > 0 ? n : f2;
    else {
      if (u3 = new N6(e), !u3.isInt() || u3.lt(f2))
        throw Error($3 + u3);
      e = u3.gt(n) ? s3 > 0 ? n : f2 : u3;
    }
    for (w4 = false, u3 = new N6(b6(v4)), l3 = N6.precision, N6.precision = s3 = v4.length * m4 * 2;a3 = k5(u3, n, 0, 1, 1), r = i.plus(a3.times(t)), r.cmp(e) != 1; )
      i = t, t = r, r = f2, f2 = c2.plus(a3.times(r)), c2 = r, r = n, n = u3.minus(a3.times(r)), u3 = r;
    return r = k5(e.minus(i), t, 0, 1, 1), c2 = c2.plus(r.times(f2)), i = i.plus(r.times(t)), c2.s = f2.s = g4.s, d4 = k5(f2, t, s3, 1).minus(g4).abs().cmp(k5(c2, i, s3, 1).minus(g4).abs()) < 1 ? [f2, t] : [c2, i], N6.precision = l3, w4 = true, d4;
  };
  h4.toHexadecimal = h4.toHex = function(e, n) {
    return Pe2(this, 16, e, n);
  };
  h4.toNearest = function(e, n) {
    var i = this, t = i.constructor;
    if (i = new t(i), e == null) {
      if (!i.d)
        return i;
      e = new t(1), n = t.rounding;
    } else {
      if (e = new t(e), n === undefined ? n = t.rounding : q2(n, 0, 8), !i.d)
        return e.s ? i : e;
      if (!e.d)
        return e.s && (e.s = i.s), e;
    }
    return e.d[0] ? (w4 = false, i = k5(i, e, 0, n, 1).times(e), w4 = true, p4(i)) : (e.s = i.s, i = e), i;
  };
  h4.toNumber = function() {
    return +this;
  };
  h4.toOctal = function(e, n) {
    return Pe2(this, 8, e, n);
  };
  h4.toPower = h4.pow = function(e) {
    var n, i, t, r, s3, o2, u3 = this, c2 = u3.constructor, f2 = +(e = new c2(e));
    if (!u3.d || !e.d || !u3.d[0] || !e.d[0])
      return new c2(C3(+u3, f2));
    if (u3 = new c2(u3), u3.eq(1))
      return u3;
    if (t = c2.precision, s3 = c2.rounding, e.eq(1))
      return p4(u3, t, s3);
    if (n = R3(e.e / m4), n >= e.d.length - 1 && (i = f2 < 0 ? -f2 : f2) <= dn)
      return r = He3(c2, u3, i, t), e.s < 0 ? new c2(1).div(r) : p4(r, t, s3);
    if (o2 = u3.s, o2 < 0) {
      if (n < e.d.length - 1)
        return new c2(NaN);
      if ((e.d[n] & 1) == 0 && (o2 = 1), u3.e == 0 && u3.d[0] == 1 && u3.d.length == 1)
        return u3.s = o2, u3;
    }
    return i = C3(+u3, f2), n = i == 0 || !isFinite(i) ? R3(f2 * (Math.log("0." + b6(u3.d)) / Math.LN10 + u3.e + 1)) : new c2(i + "").e, n > c2.maxE + 1 || n < c2.minE - 1 ? new c2(n > 0 ? o2 / 0 : 0) : (w4 = false, c2.rounding = u3.s = 1, i = Math.min(12, (n + "").length), r = be(e.times(B4(u3, t + i)), t), r.d && (r = p4(r, t + 5, 1), Q5(r.d, t, s3) && (n = t + 10, r = p4(be(e.times(B4(u3, n + i)), n), n + 5, 1), +b6(r.d).slice(t + 1, t + 15) + 1 == 100000000000000 && (r = p4(r, t + 1, 0)))), r.s = o2, w4 = true, c2.rounding = s3, p4(r, t, s3));
  };
  h4.toPrecision = function(e, n) {
    var i, t = this, r = t.constructor;
    return e === undefined ? i = L4(t, t.e <= r.toExpNeg || t.e >= r.toExpPos) : (q2(e, 1, H4), n === undefined ? n = r.rounding : q2(n, 0, 8), t = p4(new r(t), e, n), i = L4(t, e <= t.e || t.e <= r.toExpNeg, e)), t.isNeg() && !t.isZero() ? "-" + i : i;
  };
  h4.toSignificantDigits = h4.toSD = function(e, n) {
    var i = this, t = i.constructor;
    return e === undefined ? (e = t.precision, n = t.rounding) : (q2(e, 1, H4), n === undefined ? n = t.rounding : q2(n, 0, 8)), p4(new t(i), e, n);
  };
  h4.toString = function() {
    var e = this, n = e.constructor, i = L4(e, e.e <= n.toExpNeg || e.e >= n.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + i : i;
  };
  h4.truncated = h4.trunc = function() {
    return p4(new this.constructor(this), this.e + 1, 1);
  };
  h4.valueOf = h4.toJSON = function() {
    var e = this, n = e.constructor, i = L4(e, e.e <= n.toExpNeg || e.e >= n.toExpPos);
    return e.isNeg() ? "-" + i : i;
  };
  function b6(e) {
    var n, i, t, r = e.length - 1, s3 = "", o2 = e[0];
    if (r > 0) {
      for (s3 += o2, n = 1;n < r; n++)
        t = e[n] + "", i = m4 - t.length, i && (s3 += U3(i)), s3 += t;
      o2 = e[n], t = o2 + "", i = m4 - t.length, i && (s3 += U3(i));
    } else if (o2 === 0)
      return "0";
    for (;o2 % 10 === 0; )
      o2 /= 10;
    return s3 + o2;
  }
  function q2(e, n, i) {
    if (e !== ~~e || e < n || e > i)
      throw Error($3 + e);
  }
  function Q5(e, n, i, t) {
    var r, s3, o2, u3;
    for (s3 = e[0];s3 >= 10; s3 /= 10)
      --n;
    return --n < 0 ? (n += m4, r = 0) : (r = Math.ceil((n + 1) / m4), n %= m4), s3 = C3(10, m4 - n), u3 = e[r] % s3 | 0, t == null ? n < 3 ? (n == 0 ? u3 = u3 / 100 | 0 : n == 1 && (u3 = u3 / 10 | 0), o2 = i < 4 && u3 == 99999 || i > 3 && u3 == 49999 || u3 == 50000 || u3 == 0) : o2 = (i < 4 && u3 + 1 == s3 || i > 3 && u3 + 1 == s3 / 2) && (e[r + 1] / s3 / 100 | 0) == C3(10, n - 2) - 1 || (u3 == s3 / 2 || u3 == 0) && (e[r + 1] / s3 / 100 | 0) == 0 : n < 4 ? (n == 0 ? u3 = u3 / 1000 | 0 : n == 1 ? u3 = u3 / 100 | 0 : n == 2 && (u3 = u3 / 10 | 0), o2 = (t || i < 4) && u3 == 9999 || !t && i > 3 && u3 == 4999) : o2 = ((t || i < 4) && u3 + 1 == s3 || !t && i > 3 && u3 + 1 == s3 / 2) && (e[r + 1] / s3 / 1000 | 0) == C3(10, n - 3) - 1, o2;
  }
  function te2(e, n, i) {
    for (var t, r = [0], s3, o2 = 0, u3 = e.length;o2 < u3; ) {
      for (s3 = r.length;s3--; )
        r[s3] *= n;
      for (r[0] += Se3.indexOf(e.charAt(o2++)), t = 0;t < r.length; t++)
        r[t] > i - 1 && (r[t + 1] === undefined && (r[t + 1] = 0), r[t + 1] += r[t] / i | 0, r[t] %= i);
    }
    return r.reverse();
  }
  function pn3(e, n) {
    var i, t, r;
    if (n.isZero())
      return n;
    t = n.d.length, t < 32 ? (i = Math.ceil(t / 3), r = (1 / le(4, i)).toString()) : (i = 16, r = "2.3283064365386962890625e-10"), e.precision += i, n = j5(e, 1, n.times(r), new e(1));
    for (var s3 = i;s3--; ) {
      var o2 = n.times(n);
      n = o2.times(o2).minus(o2).times(8).plus(1);
    }
    return e.precision -= i, n;
  }
  var k5 = function() {
    function e(t, r, s3) {
      var o2, u3 = 0, c2 = t.length;
      for (t = t.slice();c2--; )
        o2 = t[c2] * r + u3, t[c2] = o2 % s3 | 0, u3 = o2 / s3 | 0;
      return u3 && t.unshift(u3), t;
    }
    function n(t, r, s3, o2) {
      var u3, c2;
      if (s3 != o2)
        c2 = s3 > o2 ? 1 : -1;
      else
        for (u3 = c2 = 0;u3 < s3; u3++)
          if (t[u3] != r[u3]) {
            c2 = t[u3] > r[u3] ? 1 : -1;
            break;
          }
      return c2;
    }
    function i(t, r, s3, o2) {
      for (var u3 = 0;s3--; )
        t[s3] -= u3, u3 = t[s3] < r[s3] ? 1 : 0, t[s3] = u3 * o2 + t[s3] - r[s3];
      for (;!t[0] && t.length > 1; )
        t.shift();
    }
    return function(t, r, s3, o2, u3, c2) {
      var f2, l3, a3, d4, g4, v4, N6, A4, M4, _5, E7, P5, x4, I5, ae2, z, W, de, T3, y5, ee = t.constructor, he = t.s == r.s ? 1 : -1, O4 = t.d, S3 = r.d;
      if (!O4 || !O4[0] || !S3 || !S3[0])
        return new ee(!t.s || !r.s || (O4 ? S3 && O4[0] == S3[0] : !S3) ? NaN : O4 && O4[0] == 0 || !S3 ? he * 0 : he / 0);
      for (c2 ? (g4 = 1, l3 = t.e - r.e) : (c2 = D4, g4 = m4, l3 = R3(t.e / g4) - R3(r.e / g4)), T3 = S3.length, W = O4.length, M4 = new ee(he), _5 = M4.d = [], a3 = 0;S3[a3] == (O4[a3] || 0); a3++)
        ;
      if (S3[a3] > (O4[a3] || 0) && l3--, s3 == null ? (I5 = s3 = ee.precision, o2 = ee.rounding) : u3 ? I5 = s3 + (t.e - r.e) + 1 : I5 = s3, I5 < 0)
        _5.push(1), v4 = true;
      else {
        if (I5 = I5 / g4 + 2 | 0, a3 = 0, T3 == 1) {
          for (d4 = 0, S3 = S3[0], I5++;(a3 < W || d4) && I5--; a3++)
            ae2 = d4 * c2 + (O4[a3] || 0), _5[a3] = ae2 / S3 | 0, d4 = ae2 % S3 | 0;
          v4 = d4 || a3 < W;
        } else {
          for (d4 = c2 / (S3[0] + 1) | 0, d4 > 1 && (S3 = e(S3, d4, c2), O4 = e(O4, d4, c2), T3 = S3.length, W = O4.length), z = T3, E7 = O4.slice(0, T3), P5 = E7.length;P5 < T3; )
            E7[P5++] = 0;
          y5 = S3.slice(), y5.unshift(0), de = S3[0], S3[1] >= c2 / 2 && ++de;
          do
            d4 = 0, f2 = n(S3, E7, T3, P5), f2 < 0 ? (x4 = E7[0], T3 != P5 && (x4 = x4 * c2 + (E7[1] || 0)), d4 = x4 / de | 0, d4 > 1 ? (d4 >= c2 && (d4 = c2 - 1), N6 = e(S3, d4, c2), A4 = N6.length, P5 = E7.length, f2 = n(N6, E7, A4, P5), f2 == 1 && (d4--, i(N6, T3 < A4 ? y5 : S3, A4, c2))) : (d4 == 0 && (f2 = d4 = 1), N6 = S3.slice()), A4 = N6.length, A4 < P5 && N6.unshift(0), i(E7, N6, P5, c2), f2 == -1 && (P5 = E7.length, f2 = n(S3, E7, T3, P5), f2 < 1 && (d4++, i(E7, T3 < P5 ? y5 : S3, P5, c2))), P5 = E7.length) : f2 === 0 && (d4++, E7 = [0]), _5[a3++] = d4, f2 && E7[0] ? E7[P5++] = O4[z] || 0 : (E7 = [O4[z]], P5 = 1);
          while ((z++ < W || E7[0] !== undefined) && I5--);
          v4 = E7[0] !== undefined;
        }
        _5[0] || _5.shift();
      }
      if (g4 == 1)
        M4.e = l3, Le = v4;
      else {
        for (a3 = 1, d4 = _5[0];d4 >= 10; d4 /= 10)
          a3++;
        M4.e = a3 + l3 * g4 - 1, p4(M4, u3 ? s3 + M4.e + 1 : s3, o2, v4);
      }
      return M4;
    };
  }();
  function p4(e, n, i, t) {
    var r, s3, o2, u3, c2, f2, l3, a3, d4, g4 = e.constructor;
    e:
      if (n != null) {
        if (a3 = e.d, !a3)
          return e;
        for (r = 1, u3 = a3[0];u3 >= 10; u3 /= 10)
          r++;
        if (s3 = n - r, s3 < 0)
          s3 += m4, o2 = n, l3 = a3[d4 = 0], c2 = l3 / C3(10, r - o2 - 1) % 10 | 0;
        else if (d4 = Math.ceil((s3 + 1) / m4), u3 = a3.length, d4 >= u3)
          if (t) {
            for (;u3++ <= d4; )
              a3.push(0);
            l3 = c2 = 0, r = 1, s3 %= m4, o2 = s3 - m4 + 1;
          } else
            break e;
        else {
          for (l3 = u3 = a3[d4], r = 1;u3 >= 10; u3 /= 10)
            r++;
          s3 %= m4, o2 = s3 - m4 + r, c2 = o2 < 0 ? 0 : l3 / C3(10, r - o2 - 1) % 10 | 0;
        }
        if (t = t || n < 0 || a3[d4 + 1] !== undefined || (o2 < 0 ? l3 : l3 % C3(10, r - o2 - 1)), f2 = i < 4 ? (c2 || t) && (i == 0 || i == (e.s < 0 ? 3 : 2)) : c2 > 5 || c2 == 5 && (i == 4 || t || i == 6 && (s3 > 0 ? o2 > 0 ? l3 / C3(10, r - o2) : 0 : a3[d4 - 1]) % 10 & 1 || i == (e.s < 0 ? 8 : 7)), n < 1 || !a3[0])
          return a3.length = 0, f2 ? (n -= e.e + 1, a3[0] = C3(10, (m4 - n % m4) % m4), e.e = -n || 0) : a3[0] = e.e = 0, e;
        if (s3 == 0 ? (a3.length = d4, u3 = 1, d4--) : (a3.length = d4 + 1, u3 = C3(10, m4 - s3), a3[d4] = o2 > 0 ? (l3 / C3(10, r - o2) % C3(10, o2) | 0) * u3 : 0), f2)
          for (;; )
            if (d4 == 0) {
              for (s3 = 1, o2 = a3[0];o2 >= 10; o2 /= 10)
                s3++;
              for (o2 = a3[0] += u3, u3 = 1;o2 >= 10; o2 /= 10)
                u3++;
              s3 != u3 && (e.e++, a3[0] == D4 && (a3[0] = 1));
              break;
            } else {
              if (a3[d4] += u3, a3[d4] != D4)
                break;
              a3[d4--] = 0, u3 = 1;
            }
        for (s3 = a3.length;a3[--s3] === 0; )
          a3.pop();
      }
    return w4 && (e.e > g4.maxE ? (e.d = null, e.e = NaN) : e.e < g4.minE && (e.e = 0, e.d = [0])), e;
  }
  function L4(e, n, i) {
    if (!e.isFinite())
      return je(e);
    var t, r = e.e, s3 = b6(e.d), o2 = s3.length;
    return n ? (i && (t = i - o2) > 0 ? s3 = s3.charAt(0) + "." + s3.slice(1) + U3(t) : o2 > 1 && (s3 = s3.charAt(0) + "." + s3.slice(1)), s3 = s3 + (e.e < 0 ? "e" : "e+") + e.e) : r < 0 ? (s3 = "0." + U3(-r - 1) + s3, i && (t = i - o2) > 0 && (s3 += U3(t))) : r >= o2 ? (s3 += U3(r + 1 - o2), i && (t = i - r - 1) > 0 && (s3 = s3 + "." + U3(t))) : ((t = r + 1) < o2 && (s3 = s3.slice(0, t) + "." + s3.slice(t)), i && (t = i - o2) > 0 && (r + 1 === o2 && (s3 += "."), s3 += U3(t))), s3;
  }
  function ce3(e, n) {
    var i = e[0];
    for (n *= m4;i >= 10; i /= 10)
      n++;
    return n;
  }
  function ue4(e, n, i) {
    if (n > hn2)
      throw w4 = true, i && (e.precision = i), Error(Ie2);
    return p4(new e(se2), n, 1, true);
  }
  function F3(e, n, i) {
    if (n > Ce)
      throw Error(Ie2);
    return p4(new e(oe3), n, i, true);
  }
  function $e2(e) {
    var n = e.length - 1, i = n * m4 + 1;
    if (n = e[n], n) {
      for (;n % 10 == 0; n /= 10)
        i--;
      for (n = e[0];n >= 10; n /= 10)
        i++;
    }
    return i;
  }
  function U3(e) {
    for (var n = "";e--; )
      n += "0";
    return n;
  }
  function He3(e, n, i, t) {
    var r, s3 = new e(1), o2 = Math.ceil(t / m4 + 4);
    for (w4 = false;; ) {
      if (i % 2 && (s3 = s3.times(n), De(s3.d, o2) && (r = true)), i = R3(i / 2), i === 0) {
        i = s3.d.length - 1, r && s3.d[i] === 0 && ++s3.d[i];
        break;
      }
      n = n.times(n), De(n.d, o2);
    }
    return w4 = true, s3;
  }
  function Te2(e) {
    return e.d[e.d.length - 1] & 1;
  }
  function Ve(e, n, i) {
    for (var t, r, s3 = new e(n[0]), o2 = 0;++o2 < n.length; ) {
      if (r = new e(n[o2]), !r.s) {
        s3 = r;
        break;
      }
      t = s3.cmp(r), (t === i || t === 0 && s3.s === i) && (s3 = r);
    }
    return s3;
  }
  function be(e, n) {
    var i, t, r, s3, o2, u3, c2, f2 = 0, l3 = 0, a3 = 0, d4 = e.constructor, g4 = d4.rounding, v4 = d4.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new d4(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
    for (n == null ? (w4 = false, c2 = v4) : c2 = n, u3 = new d4(0.03125);e.e > -2; )
      e = e.times(u3), a3 += 5;
    for (t = Math.log(C3(2, a3)) / Math.LN10 * 2 + 5 | 0, c2 += t, i = s3 = o2 = new d4(1), d4.precision = c2;; ) {
      if (s3 = p4(s3.times(e), c2, 1), i = i.times(++l3), u3 = o2.plus(k5(s3, i, c2, 1)), b6(u3.d).slice(0, c2) === b6(o2.d).slice(0, c2)) {
        for (r = a3;r--; )
          o2 = p4(o2.times(o2), c2, 1);
        if (n == null)
          if (f2 < 3 && Q5(o2.d, c2 - t, g4, f2))
            d4.precision = c2 += 10, i = s3 = u3 = new d4(1), l3 = 0, f2++;
          else
            return p4(o2, d4.precision = v4, g4, w4 = true);
        else
          return d4.precision = v4, o2;
      }
      o2 = u3;
    }
  }
  function B4(e, n) {
    var i, t, r, s3, o2, u3, c2, f2, l3, a3, d4, g4 = 1, v4 = 10, N6 = e, A4 = N6.d, M4 = N6.constructor, _5 = M4.rounding, E7 = M4.precision;
    if (N6.s < 0 || !A4 || !A4[0] || !N6.e && A4[0] == 1 && A4.length == 1)
      return new M4(A4 && !A4[0] ? -1 / 0 : N6.s != 1 ? NaN : A4 ? 0 : N6);
    if (n == null ? (w4 = false, l3 = E7) : l3 = n, M4.precision = l3 += v4, i = b6(A4), t = i.charAt(0), Math.abs(s3 = N6.e) < 1500000000000000) {
      for (;t < 7 && t != 1 || t == 1 && i.charAt(1) > 3; )
        N6 = N6.times(e), i = b6(N6.d), t = i.charAt(0), g4++;
      s3 = N6.e, t > 1 ? (N6 = new M4("0." + i), s3++) : N6 = new M4(t + "." + i.slice(1));
    } else
      return f2 = ue4(M4, l3 + 2, E7).times(s3 + ""), N6 = B4(new M4(t + "." + i.slice(1)), l3 - v4).plus(f2), M4.precision = E7, n == null ? p4(N6, E7, _5, w4 = true) : N6;
    for (a3 = N6, c2 = o2 = N6 = k5(N6.minus(1), N6.plus(1), l3, 1), d4 = p4(N6.times(N6), l3, 1), r = 3;; ) {
      if (o2 = p4(o2.times(d4), l3, 1), f2 = c2.plus(k5(o2, new M4(r), l3, 1)), b6(f2.d).slice(0, l3) === b6(c2.d).slice(0, l3))
        if (c2 = c2.times(2), s3 !== 0 && (c2 = c2.plus(ue4(M4, l3 + 2, E7).times(s3 + ""))), c2 = k5(c2, new M4(g4), l3, 1), n == null)
          if (Q5(c2.d, l3 - v4, _5, u3))
            M4.precision = l3 += v4, f2 = o2 = N6 = k5(a3.minus(1), a3.plus(1), l3, 1), d4 = p4(N6.times(N6), l3, 1), r = u3 = 1;
          else
            return p4(c2, M4.precision = E7, _5, w4 = true);
        else
          return M4.precision = E7, c2;
      c2 = f2, r += 2;
    }
  }
  function je(e) {
    return String(e.s * e.s / 0);
  }
  function re2(e, n) {
    var i, t, r;
    for ((i = n.indexOf(".")) > -1 && (n = n.replace(".", "")), (t = n.search(/e/i)) > 0 ? (i < 0 && (i = t), i += +n.slice(t + 1), n = n.substring(0, t)) : i < 0 && (i = n.length), t = 0;n.charCodeAt(t) === 48; t++)
      ;
    for (r = n.length;n.charCodeAt(r - 1) === 48; --r)
      ;
    if (n = n.slice(t, r), n) {
      if (r -= t, e.e = i = i - t - 1, e.d = [], t = (i + 1) % m4, i < 0 && (t += m4), t < r) {
        for (t && e.d.push(+n.slice(0, t)), r -= m4;t < r; )
          e.d.push(+n.slice(t, t += m4));
        n = n.slice(t), t = m4 - n.length;
      } else
        t -= r;
      for (;t--; )
        n += "0";
      e.d.push(+n), w4 && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  }
  function gn(e, n) {
    var i, t, r, s3, o2, u3, c2, f2, l3;
    if (n.indexOf("_") > -1) {
      if (n = n.replace(/(\d)_(?=\d)/g, "$1"), Be.test(n))
        return re2(e, n);
    } else if (n === "Infinity" || n === "NaN")
      return +n || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (ln.test(n))
      i = 16, n = n.toLowerCase();
    else if (cn2.test(n))
      i = 2;
    else if (an2.test(n))
      i = 8;
    else
      throw Error($3 + n);
    for (s3 = n.search(/p/i), s3 > 0 ? (c2 = +n.slice(s3 + 1), n = n.substring(2, s3)) : n = n.slice(2), s3 = n.indexOf("."), o2 = s3 >= 0, t = e.constructor, o2 && (n = n.replace(".", ""), u3 = n.length, s3 = u3 - s3, r = He3(t, new t(i), s3, s3 * 2)), f2 = te2(n, i, D4), l3 = f2.length - 1, s3 = l3;f2[s3] === 0; --s3)
      f2.pop();
    return s3 < 0 ? new t(e.s * 0) : (e.e = ce3(f2, l3), e.d = f2, w4 = false, o2 && (e = k5(e, r, u3 * 4)), c2 && (e = e.times(Math.abs(c2) < 54 ? C3(2, c2) : Y5.pow(2, c2))), w4 = true, e);
  }
  function mn(e, n) {
    var i, t = n.d.length;
    if (t < 3)
      return n.isZero() ? n : j5(e, 2, n, n);
    i = 1.4 * Math.sqrt(t), i = i > 16 ? 16 : i | 0, n = n.times(1 / le(5, i)), n = j5(e, 2, n, n);
    for (var r, s3 = new e(5), o2 = new e(16), u3 = new e(20);i--; )
      r = n.times(n), n = n.times(s3.plus(r.times(o2.times(r).minus(u3))));
    return n;
  }
  function j5(e, n, i, t, r) {
    var s3, o2, u3, c2, f2 = 1, l3 = e.precision, a3 = Math.ceil(l3 / m4);
    for (w4 = false, c2 = i.times(i), u3 = new e(t);; ) {
      if (o2 = k5(u3.times(c2), new e(n++ * n++), l3, 1), u3 = r ? t.plus(o2) : t.minus(o2), t = k5(o2.times(c2), new e(n++ * n++), l3, 1), o2 = u3.plus(t), o2.d[a3] !== undefined) {
        for (s3 = a3;o2.d[s3] === u3.d[s3] && s3--; )
          ;
        if (s3 == -1)
          break;
      }
      s3 = u3, u3 = t, t = o2, o2 = s3, f2++;
    }
    return w4 = true, o2.d.length = a3 + 1, o2;
  }
  function le(e, n) {
    for (var i = e;--n; )
      i *= e;
    return i;
  }
  function We2(e, n) {
    var i, t = n.s < 0, r = F3(e, e.precision, 1), s3 = r.times(0.5);
    if (n = n.abs(), n.lte(s3))
      return Z4 = t ? 4 : 1, n;
    if (i = n.divToInt(r), i.isZero())
      Z4 = t ? 3 : 2;
    else {
      if (n = n.minus(i.times(r)), n.lte(s3))
        return Z4 = Te2(i) ? t ? 2 : 3 : t ? 4 : 1, n;
      Z4 = Te2(i) ? t ? 1 : 4 : t ? 3 : 2;
    }
    return n.minus(r).abs();
  }
  function Pe2(e, n, i, t) {
    var r, s3, o2, u3, c2, f2, l3, a3, d4, g4 = e.constructor, v4 = i !== undefined;
    if (v4 ? (q2(i, 1, H4), t === undefined ? t = g4.rounding : q2(t, 0, 8)) : (i = g4.precision, t = g4.rounding), !e.isFinite())
      l3 = je(e);
    else {
      for (l3 = L4(e), o2 = l3.indexOf("."), v4 ? (r = 2, n == 16 ? i = i * 4 - 3 : n == 8 && (i = i * 3 - 2)) : r = n, o2 >= 0 && (l3 = l3.replace(".", ""), d4 = new g4(1), d4.e = l3.length - o2, d4.d = te2(L4(d4), 10, r), d4.e = d4.d.length), a3 = te2(l3, 10, r), s3 = c2 = a3.length;a3[--c2] == 0; )
        a3.pop();
      if (!a3[0])
        l3 = v4 ? "0p+0" : "0";
      else {
        if (o2 < 0 ? s3-- : (e = new g4(e), e.d = a3, e.e = s3, e = k5(e, d4, i, t, 0, r), a3 = e.d, s3 = e.e, f2 = Le), o2 = a3[i], u3 = r / 2, f2 = f2 || a3[i + 1] !== undefined, f2 = t < 4 ? (o2 !== undefined || f2) && (t === 0 || t === (e.s < 0 ? 3 : 2)) : o2 > u3 || o2 === u3 && (t === 4 || f2 || t === 6 && a3[i - 1] & 1 || t === (e.s < 0 ? 8 : 7)), a3.length = i, f2)
          for (;++a3[--i] > r - 1; )
            a3[i] = 0, i || (++s3, a3.unshift(1));
        for (c2 = a3.length;!a3[c2 - 1]; --c2)
          ;
        for (o2 = 0, l3 = "";o2 < c2; o2++)
          l3 += Se3.charAt(a3[o2]);
        if (v4) {
          if (c2 > 1)
            if (n == 16 || n == 8) {
              for (o2 = n == 16 ? 4 : 3, --c2;c2 % o2; c2++)
                l3 += "0";
              for (a3 = te2(l3, r, n), c2 = a3.length;!a3[c2 - 1]; --c2)
                ;
              for (o2 = 1, l3 = "1.";o2 < c2; o2++)
                l3 += Se3.charAt(a3[o2]);
            } else
              l3 = l3.charAt(0) + "." + l3.slice(1);
          l3 = l3 + (s3 < 0 ? "p" : "p+") + s3;
        } else if (s3 < 0) {
          for (;++s3; )
            l3 = "0" + l3;
          l3 = "0." + l3;
        } else if (++s3 > c2)
          for (s3 -= c2;s3--; )
            l3 += "0";
        else
          s3 < c2 && (l3 = l3.slice(0, s3) + "." + l3.slice(s3));
      }
      l3 = (n == 16 ? "0x" : n == 2 ? "0b" : n == 8 ? "0o" : "") + l3;
    }
    return e.s < 0 ? "-" + l3 : l3;
  }
  function De(e, n) {
    if (e.length > n)
      return e.length = n, true;
  }
  function wn(e) {
    return new this(e).abs();
  }
  function Nn2(e) {
    return new this(e).acos();
  }
  function vn(e) {
    return new this(e).acosh();
  }
  function En(e, n) {
    return new this(e).plus(n);
  }
  function kn2(e) {
    return new this(e).asin();
  }
  function Sn2(e) {
    return new this(e).asinh();
  }
  function Mn(e) {
    return new this(e).atan();
  }
  function Cn(e) {
    return new this(e).atanh();
  }
  function bn(e, n) {
    e = new this(e), n = new this(n);
    var i, t = this.precision, r = this.rounding, s3 = t + 4;
    return !e.s || !n.s ? i = new this(NaN) : !e.d && !n.d ? (i = F3(this, s3, 1).times(n.s > 0 ? 0.25 : 0.75), i.s = e.s) : !n.d || e.isZero() ? (i = n.s < 0 ? F3(this, t, r) : new this(0), i.s = e.s) : !e.d || n.isZero() ? (i = F3(this, s3, 1).times(0.5), i.s = e.s) : n.s < 0 ? (this.precision = s3, this.rounding = 1, i = this.atan(k5(e, n, s3, 1)), n = F3(this, s3, 1), this.precision = t, this.rounding = r, i = e.s < 0 ? i.minus(n) : i.plus(n)) : i = this.atan(k5(e, n, s3, 1)), i;
  }
  function Pn(e) {
    return new this(e).cbrt();
  }
  function On2(e) {
    return p4(e = new this(e), e.e + 1, 2);
  }
  function Rn(e, n, i) {
    return new this(e).clamp(n, i);
  }
  function An(e) {
    if (!e || typeof e != "object")
      throw Error(fe3 + "Object expected");
    var n, i, t, r = e.defaults === true, s3 = ["precision", 1, H4, "rounding", 0, 8, "toExpNeg", -V5, 0, "toExpPos", 0, V5, "maxE", 0, V5, "minE", -V5, 0, "modulo", 0, 9];
    for (n = 0;n < s3.length; n += 3)
      if (i = s3[n], r && (this[i] = Me[i]), (t = e[i]) !== undefined)
        if (R3(t) === t && t >= s3[n + 1] && t <= s3[n + 2])
          this[i] = t;
        else
          throw Error($3 + i + ": " + t);
    if (i = "crypto", r && (this[i] = Me[i]), (t = e[i]) !== undefined)
      if (t === true || t === false || t === 0 || t === 1)
        if (t)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[i] = true;
          else
            throw Error(Ze2);
        else
          this[i] = false;
      else
        throw Error($3 + i + ": " + t);
    return this;
  }
  function qn(e) {
    return new this(e).cos();
  }
  function _n2(e) {
    return new this(e).cosh();
  }
  function Ge(e) {
    var n, i, t;
    function r(s3) {
      var o2, u3, c2, f2 = this;
      if (!(f2 instanceof r))
        return new r(s3);
      if (f2.constructor = r, Fe(s3)) {
        f2.s = s3.s, w4 ? !s3.d || s3.e > r.maxE ? (f2.e = NaN, f2.d = null) : s3.e < r.minE ? (f2.e = 0, f2.d = [0]) : (f2.e = s3.e, f2.d = s3.d.slice()) : (f2.e = s3.e, f2.d = s3.d ? s3.d.slice() : s3.d);
        return;
      }
      if (c2 = typeof s3, c2 === "number") {
        if (s3 === 0) {
          f2.s = 1 / s3 < 0 ? -1 : 1, f2.e = 0, f2.d = [0];
          return;
        }
        if (s3 < 0 ? (s3 = -s3, f2.s = -1) : f2.s = 1, s3 === ~~s3 && s3 < 1e7) {
          for (o2 = 0, u3 = s3;u3 >= 10; u3 /= 10)
            o2++;
          w4 ? o2 > r.maxE ? (f2.e = NaN, f2.d = null) : o2 < r.minE ? (f2.e = 0, f2.d = [0]) : (f2.e = o2, f2.d = [s3]) : (f2.e = o2, f2.d = [s3]);
          return;
        }
        if (s3 * 0 !== 0) {
          s3 || (f2.s = NaN), f2.e = NaN, f2.d = null;
          return;
        }
        return re2(f2, s3.toString());
      }
      if (c2 === "string")
        return (u3 = s3.charCodeAt(0)) === 45 ? (s3 = s3.slice(1), f2.s = -1) : (u3 === 43 && (s3 = s3.slice(1)), f2.s = 1), Be.test(s3) ? re2(f2, s3) : gn(f2, s3);
      if (c2 === "bigint")
        return s3 < 0 ? (s3 = -s3, f2.s = -1) : f2.s = 1, re2(f2, s3.toString());
      throw Error($3 + s3);
    }
    if (r.prototype = h4, r.ROUND_UP = 0, r.ROUND_DOWN = 1, r.ROUND_CEIL = 2, r.ROUND_FLOOR = 3, r.ROUND_HALF_UP = 4, r.ROUND_HALF_DOWN = 5, r.ROUND_HALF_EVEN = 6, r.ROUND_HALF_CEIL = 7, r.ROUND_HALF_FLOOR = 8, r.EUCLID = 9, r.config = r.set = An, r.clone = Ge, r.isDecimal = Fe, r.abs = wn, r.acos = Nn2, r.acosh = vn, r.add = En, r.asin = kn2, r.asinh = Sn2, r.atan = Mn, r.atanh = Cn, r.atan2 = bn, r.cbrt = Pn, r.ceil = On2, r.clamp = Rn, r.cos = qn, r.cosh = _n2, r.div = Tn, r.exp = Dn2, r.floor = Fn2, r.hypot = Ln3, r.ln = In, r.log = Zn, r.log10 = Bn2, r.log2 = Un, r.max = $n, r.min = Hn, r.mod = Vn, r.mul = jn2, r.pow = Wn, r.random = Gn, r.round = Jn, r.sign = Xn, r.sin = Kn, r.sinh = Qn, r.sqrt = Yn, r.sub = xn, r.sum = zn2, r.tan = yn2, r.tanh = ei, r.trunc = ni, e === undefined && (e = {}), e && e.defaults !== true)
      for (t = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], n = 0;n < t.length; )
        e.hasOwnProperty(i = t[n++]) || (e[i] = this[i]);
    return r.config(e), r;
  }
  function Tn(e, n) {
    return new this(e).div(n);
  }
  function Dn2(e) {
    return new this(e).exp();
  }
  function Fn2(e) {
    return p4(e = new this(e), e.e + 1, 3);
  }
  function Ln3() {
    var e, n, i = new this(0);
    for (w4 = false, e = 0;e < arguments.length; )
      if (n = new this(arguments[e++]), n.d)
        i.d && (i = i.plus(n.times(n)));
      else {
        if (n.s)
          return w4 = true, new this(1 / 0);
        i = n;
      }
    return w4 = true, i.sqrt();
  }
  function Fe(e) {
    return e instanceof Y5 || e && e.toStringTag === Ue || false;
  }
  function In(e) {
    return new this(e).ln();
  }
  function Zn(e, n) {
    return new this(e).log(n);
  }
  function Un(e) {
    return new this(e).log(2);
  }
  function Bn2(e) {
    return new this(e).log(10);
  }
  function $n() {
    return Ve(this, arguments, -1);
  }
  function Hn() {
    return Ve(this, arguments, 1);
  }
  function Vn(e, n) {
    return new this(e).mod(n);
  }
  function jn2(e, n) {
    return new this(e).mul(n);
  }
  function Wn(e, n) {
    return new this(e).pow(n);
  }
  function Gn(e) {
    var n, i, t, r, s3 = 0, o2 = new this(1), u3 = [];
    if (e === undefined ? e = this.precision : q2(e, 1, H4), t = Math.ceil(e / m4), this.crypto)
      if (crypto.getRandomValues)
        for (n = crypto.getRandomValues(new Uint32Array(t));s3 < t; )
          r = n[s3], r >= 4290000000 ? n[s3] = crypto.getRandomValues(new Uint32Array(1))[0] : u3[s3++] = r % 1e7;
      else if (crypto.randomBytes) {
        for (n = crypto.randomBytes(t *= 4);s3 < t; )
          r = n[s3] + (n[s3 + 1] << 8) + (n[s3 + 2] << 16) + ((n[s3 + 3] & 127) << 24), r >= 2140000000 ? crypto.randomBytes(4).copy(n, s3) : (u3.push(r % 1e7), s3 += 4);
        s3 = t / 4;
      } else
        throw Error(Ze2);
    else
      for (;s3 < t; )
        u3[s3++] = Math.random() * 1e7 | 0;
    for (t = u3[--s3], e %= m4, t && e && (r = C3(10, m4 - e), u3[s3] = (t / r | 0) * r);u3[s3] === 0; s3--)
      u3.pop();
    if (s3 < 0)
      i = 0, u3 = [0];
    else {
      for (i = -1;u3[0] === 0; i -= m4)
        u3.shift();
      for (t = 1, r = u3[0];r >= 10; r /= 10)
        t++;
      t < m4 && (i -= m4 - t);
    }
    return o2.e = i, o2.d = u3, o2;
  }
  function Jn(e) {
    return p4(e = new this(e), e.e + 1, this.rounding);
  }
  function Xn(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  }
  function Kn(e) {
    return new this(e).sin();
  }
  function Qn(e) {
    return new this(e).sinh();
  }
  function Yn(e) {
    return new this(e).sqrt();
  }
  function xn(e, n) {
    return new this(e).sub(n);
  }
  function zn2() {
    var e = 0, n = arguments, i = new this(n[e]);
    for (w4 = false;i.s && ++e < n.length; )
      i = i.plus(n[e]);
    return w4 = true, p4(i, this.precision, this.rounding);
  }
  function yn2(e) {
    return new this(e).tan();
  }
  function ei(e) {
    return new this(e).tanh();
  }
  function ni(e) {
    return p4(e = new this(e), e.e + 1, 1);
  }
  h4[Symbol.for("nodejs.util.inspect.custom")] = h4.toString;
  h4[Symbol.toStringTag] = "Decimal";
  var Y5 = h4.constructor = Ge(Me);
  se2 = new Y5(se2);
  oe3 = new Y5(oe3);
  var Je = Y5;
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.5.0
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// src/generated/prisma/index-browser.js
var require_index_browser2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    Decimal: Decimal2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Public: Public2,
    getRuntime: getRuntime2,
    skip
  } = require_index_browser();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "6.16.3",
    engine: "bb420e667c1820a8c05a38023385f6cc7ef8e83a"
  };
  Prisma.PrismaClientKnownRequestError = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`PrismaClientKnownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.PrismaClientUnknownRequestError = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`PrismaClientUnknownRequestError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.PrismaClientRustPanicError = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`PrismaClientRustPanicError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.PrismaClientInitializationError = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`PrismaClientInitializationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.PrismaClientValidationError = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`PrismaClientValidationError is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.Decimal = Decimal2;
  Prisma.sql = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`sqltag is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.empty = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`empty is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.join = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`join is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.raw = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`raw is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`Extensions.getExtensionContext is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.defineExtension = () => {
    const runtimeName = getRuntime2().prettyName;
    throw new Error(`Extensions.defineExtension is unable to run in this browser environment, or has been bundled for the browser (running in ${runtimeName}).
In case this error is unexpected for you, please report it in https://pris.ly/prisma-prisma-bug-report`);
  };
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.CredentialScalarFieldEnum = {
    userId: "userId",
    username: "username",
    hash: "hash",
    createdAt: "createdAt",
    updatedAt: "updatedAt"
  };
  exports.Prisma.RefreshTokenScalarFieldEnum = {
    token: "token",
    refreshCount: "refreshCount",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    expiredAt: "expiredAt",
    userId: "userId"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Prisma.ModelName = {
    Credential: "Credential",
    RefreshToken: "RefreshToken"
  };

  class PrismaClient {
    constructor() {
      return new Proxy(this, {
        get(target, prop) {
          let message;
          const runtime = getRuntime2();
          if (runtime.isEdge) {
            message = `PrismaClient is not configured to run in ${runtime.prettyName}. In order to run Prisma Client on edge runtime, either:
- Use Prisma Accelerate: https://pris.ly/d/accelerate
- Use Driver Adapters: https://pris.ly/d/driver-adapters
`;
          } else {
            message = "PrismaClient is unable to run in this browser environment, or has been bundled for the browser (running in `" + runtime.prettyName + "`).";
          }
          message += `
If this is unexpected, please open an issue: https://pris.ly/prisma-prisma-bug-report`;
          throw new Error(message);
        }
      });
    }
  }
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
});

// src/generated/prisma/default.js
var require_default = __commonJS((exports, module) => {
  module.exports = { ...require_index_browser2() };
});

// src/infrastructure/http/server.ts
var import_fastify = __toESM(require_fastify(), 1);
var import_fastify_plugin = __toESM(require_plugin2(), 1);
var import_cors = __toESM(require_cors(), 1);
var import_sensible = __toESM(require_sensible(), 1);

// node_modules/zod/v4/classic/external.js
var exports_external = {};
__export(exports_external, {
  xid: () => xid2,
  void: () => _void2,
  uuidv7: () => uuidv7,
  uuidv6: () => uuidv6,
  uuidv4: () => uuidv4,
  uuid: () => uuid2,
  util: () => exports_util2,
  url: () => url,
  uppercase: () => _uppercase,
  unknown: () => unknown,
  union: () => union,
  undefined: () => _undefined3,
  ulid: () => ulid2,
  uint64: () => uint64,
  uint32: () => uint32,
  tuple: () => tuple,
  trim: () => _trim,
  treeifyError: () => treeifyError,
  transform: () => transform,
  toUpperCase: () => _toUpperCase,
  toLowerCase: () => _toLowerCase,
  toJSONSchema: () => toJSONSchema,
  templateLiteral: () => templateLiteral,
  symbol: () => symbol,
  superRefine: () => superRefine,
  success: () => success,
  stringbool: () => stringbool,
  stringFormat: () => stringFormat,
  string: () => string2,
  strictObject: () => strictObject,
  startsWith: () => _startsWith,
  size: () => _size,
  setErrorMap: () => setErrorMap,
  set: () => set,
  safeParseAsync: () => safeParseAsync2,
  safeParse: () => safeParse2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeEncode: () => safeEncode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeDecode: () => safeDecode2,
  registry: () => registry,
  regexes: () => exports_regexes,
  regex: () => _regex,
  refine: () => refine,
  record: () => record,
  readonly: () => readonly,
  property: () => _property,
  promise: () => promise,
  prettifyError: () => prettifyError,
  preprocess: () => preprocess,
  prefault: () => prefault,
  positive: () => _positive,
  pipe: () => pipe,
  partialRecord: () => partialRecord,
  parseAsync: () => parseAsync2,
  parse: () => parse3,
  overwrite: () => _overwrite,
  optional: () => optional,
  object: () => object,
  number: () => number2,
  nullish: () => nullish2,
  nullable: () => nullable,
  null: () => _null3,
  normalize: () => _normalize,
  nonpositive: () => _nonpositive,
  nonoptional: () => nonoptional,
  nonnegative: () => _nonnegative,
  never: () => never,
  negative: () => _negative,
  nativeEnum: () => nativeEnum,
  nanoid: () => nanoid2,
  nan: () => nan,
  multipleOf: () => _multipleOf,
  minSize: () => _minSize,
  minLength: () => _minLength,
  mime: () => _mime,
  maxSize: () => _maxSize,
  maxLength: () => _maxLength,
  map: () => map,
  lte: () => _lte,
  lt: () => _lt,
  lowercase: () => _lowercase,
  looseObject: () => looseObject,
  locales: () => exports_locales,
  literal: () => literal,
  length: () => _length,
  lazy: () => lazy,
  ksuid: () => ksuid2,
  keyof: () => keyof,
  jwt: () => jwt,
  json: () => json,
  iso: () => exports_iso,
  ipv6: () => ipv62,
  ipv4: () => ipv42,
  intersection: () => intersection,
  int64: () => int64,
  int32: () => int32,
  int: () => int,
  instanceof: () => _instanceof,
  includes: () => _includes,
  httpUrl: () => httpUrl,
  hostname: () => hostname2,
  hex: () => hex2,
  hash: () => hash,
  guid: () => guid2,
  gte: () => _gte,
  gt: () => _gt,
  globalRegistry: () => globalRegistry,
  getErrorMap: () => getErrorMap,
  function: () => _function,
  formatError: () => formatError,
  float64: () => float64,
  float32: () => float32,
  flattenError: () => flattenError,
  file: () => file,
  enum: () => _enum2,
  endsWith: () => _endsWith,
  encodeAsync: () => encodeAsync2,
  encode: () => encode2,
  emoji: () => emoji2,
  email: () => email2,
  e164: () => e1642,
  discriminatedUnion: () => discriminatedUnion,
  decodeAsync: () => decodeAsync2,
  decode: () => decode2,
  date: () => date3,
  custom: () => custom,
  cuid2: () => cuid22,
  cuid: () => cuid3,
  core: () => exports_core2,
  config: () => config,
  coerce: () => exports_coerce,
  codec: () => codec,
  clone: () => clone,
  cidrv6: () => cidrv62,
  cidrv4: () => cidrv42,
  check: () => check,
  catch: () => _catch2,
  boolean: () => boolean2,
  bigint: () => bigint2,
  base64url: () => base64url2,
  base64: () => base642,
  array: () => array,
  any: () => any,
  _function: () => _function,
  _default: () => _default2,
  _ZodString: () => _ZodString,
  ZodXID: () => ZodXID,
  ZodVoid: () => ZodVoid,
  ZodUnknown: () => ZodUnknown,
  ZodUnion: () => ZodUnion,
  ZodUndefined: () => ZodUndefined,
  ZodUUID: () => ZodUUID,
  ZodURL: () => ZodURL,
  ZodULID: () => ZodULID,
  ZodType: () => ZodType,
  ZodTuple: () => ZodTuple,
  ZodTransform: () => ZodTransform,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodSymbol: () => ZodSymbol,
  ZodSuccess: () => ZodSuccess,
  ZodStringFormat: () => ZodStringFormat,
  ZodString: () => ZodString,
  ZodSet: () => ZodSet,
  ZodRecord: () => ZodRecord,
  ZodRealError: () => ZodRealError,
  ZodReadonly: () => ZodReadonly,
  ZodPromise: () => ZodPromise,
  ZodPrefault: () => ZodPrefault,
  ZodPipe: () => ZodPipe,
  ZodOptional: () => ZodOptional,
  ZodObject: () => ZodObject,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodNumber: () => ZodNumber,
  ZodNullable: () => ZodNullable,
  ZodNull: () => ZodNull,
  ZodNonOptional: () => ZodNonOptional,
  ZodNever: () => ZodNever,
  ZodNanoID: () => ZodNanoID,
  ZodNaN: () => ZodNaN,
  ZodMap: () => ZodMap,
  ZodLiteral: () => ZodLiteral,
  ZodLazy: () => ZodLazy,
  ZodKSUID: () => ZodKSUID,
  ZodJWT: () => ZodJWT,
  ZodIssueCode: () => ZodIssueCode,
  ZodIntersection: () => ZodIntersection,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate,
  ZodIPv6: () => ZodIPv6,
  ZodIPv4: () => ZodIPv4,
  ZodGUID: () => ZodGUID,
  ZodFunction: () => ZodFunction,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFile: () => ZodFile,
  ZodError: () => ZodError,
  ZodEnum: () => ZodEnum,
  ZodEmoji: () => ZodEmoji,
  ZodEmail: () => ZodEmail,
  ZodE164: () => ZodE164,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodDefault: () => ZodDefault,
  ZodDate: () => ZodDate,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodCustom: () => ZodCustom,
  ZodCodec: () => ZodCodec,
  ZodCatch: () => ZodCatch,
  ZodCUID2: () => ZodCUID2,
  ZodCUID: () => ZodCUID,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodBoolean: () => ZodBoolean,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBigInt: () => ZodBigInt,
  ZodBase64URL: () => ZodBase64URL,
  ZodBase64: () => ZodBase64,
  ZodArray: () => ZodArray,
  ZodAny: () => ZodAny,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  $output: () => $output,
  $input: () => $input,
  $brand: () => $brand
});

// node_modules/zod/v4/core/index.js
var exports_core2 = {};
__export(exports_core2, {
  version: () => version,
  util: () => exports_util2,
  treeifyError: () => treeifyError,
  toJSONSchema: () => toJSONSchema,
  toDotPath: () => toDotPath,
  safeParseAsync: () => safeParseAsync,
  safeParse: () => safeParse,
  safeEncodeAsync: () => safeEncodeAsync,
  safeEncode: () => safeEncode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeDecode: () => safeDecode,
  registry: () => registry,
  regexes: () => exports_regexes,
  prettifyError: () => prettifyError,
  parseAsync: () => parseAsync,
  parse: () => parse,
  locales: () => exports_locales,
  isValidJWT: () => isValidJWT,
  isValidBase64URL: () => isValidBase64URL,
  isValidBase64: () => isValidBase64,
  globalRegistry: () => globalRegistry,
  globalConfig: () => globalConfig,
  formatError: () => formatError,
  flattenError: () => flattenError,
  encodeAsync: () => encodeAsync,
  encode: () => encode,
  decodeAsync: () => decodeAsync,
  decode: () => decode,
  config: () => config,
  clone: () => clone,
  _xid: () => _xid,
  _void: () => _void,
  _uuidv7: () => _uuidv7,
  _uuidv6: () => _uuidv6,
  _uuidv4: () => _uuidv4,
  _uuid: () => _uuid,
  _url: () => _url,
  _uppercase: () => _uppercase,
  _unknown: () => _unknown,
  _union: () => _union,
  _undefined: () => _undefined2,
  _ulid: () => _ulid,
  _uint64: () => _uint64,
  _uint32: () => _uint32,
  _tuple: () => _tuple,
  _trim: () => _trim,
  _transform: () => _transform,
  _toUpperCase: () => _toUpperCase,
  _toLowerCase: () => _toLowerCase,
  _templateLiteral: () => _templateLiteral,
  _symbol: () => _symbol,
  _superRefine: () => _superRefine,
  _success: () => _success,
  _stringbool: () => _stringbool,
  _stringFormat: () => _stringFormat,
  _string: () => _string,
  _startsWith: () => _startsWith,
  _size: () => _size,
  _set: () => _set,
  _safeParseAsync: () => _safeParseAsync,
  _safeParse: () => _safeParse,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeEncode: () => _safeEncode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeDecode: () => _safeDecode,
  _regex: () => _regex,
  _refine: () => _refine,
  _record: () => _record,
  _readonly: () => _readonly,
  _property: () => _property,
  _promise: () => _promise,
  _positive: () => _positive,
  _pipe: () => _pipe,
  _parseAsync: () => _parseAsync,
  _parse: () => _parse,
  _overwrite: () => _overwrite,
  _optional: () => _optional,
  _number: () => _number,
  _nullable: () => _nullable,
  _null: () => _null2,
  _normalize: () => _normalize,
  _nonpositive: () => _nonpositive,
  _nonoptional: () => _nonoptional,
  _nonnegative: () => _nonnegative,
  _never: () => _never,
  _negative: () => _negative,
  _nativeEnum: () => _nativeEnum,
  _nanoid: () => _nanoid,
  _nan: () => _nan,
  _multipleOf: () => _multipleOf,
  _minSize: () => _minSize,
  _minLength: () => _minLength,
  _min: () => _gte,
  _mime: () => _mime,
  _maxSize: () => _maxSize,
  _maxLength: () => _maxLength,
  _max: () => _lte,
  _map: () => _map,
  _lte: () => _lte,
  _lt: () => _lt,
  _lowercase: () => _lowercase,
  _literal: () => _literal,
  _length: () => _length,
  _lazy: () => _lazy,
  _ksuid: () => _ksuid,
  _jwt: () => _jwt,
  _isoTime: () => _isoTime,
  _isoDuration: () => _isoDuration,
  _isoDateTime: () => _isoDateTime,
  _isoDate: () => _isoDate,
  _ipv6: () => _ipv6,
  _ipv4: () => _ipv4,
  _intersection: () => _intersection,
  _int64: () => _int64,
  _int32: () => _int32,
  _int: () => _int,
  _includes: () => _includes,
  _guid: () => _guid,
  _gte: () => _gte,
  _gt: () => _gt,
  _float64: () => _float64,
  _float32: () => _float32,
  _file: () => _file,
  _enum: () => _enum,
  _endsWith: () => _endsWith,
  _encodeAsync: () => _encodeAsync,
  _encode: () => _encode,
  _emoji: () => _emoji2,
  _email: () => _email,
  _e164: () => _e164,
  _discriminatedUnion: () => _discriminatedUnion,
  _default: () => _default,
  _decodeAsync: () => _decodeAsync,
  _decode: () => _decode,
  _date: () => _date,
  _custom: () => _custom,
  _cuid2: () => _cuid2,
  _cuid: () => _cuid,
  _coercedString: () => _coercedString,
  _coercedNumber: () => _coercedNumber,
  _coercedDate: () => _coercedDate,
  _coercedBoolean: () => _coercedBoolean,
  _coercedBigint: () => _coercedBigint,
  _cidrv6: () => _cidrv6,
  _cidrv4: () => _cidrv4,
  _check: () => _check,
  _catch: () => _catch,
  _boolean: () => _boolean,
  _bigint: () => _bigint,
  _base64url: () => _base64url,
  _base64: () => _base64,
  _array: () => _array,
  _any: () => _any,
  TimePrecision: () => TimePrecision,
  NEVER: () => NEVER,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  JSONSchema: () => exports_json_schema,
  Doc: () => Doc,
  $output: () => $output,
  $input: () => $input,
  $constructor: () => $constructor,
  $brand: () => $brand,
  $ZodXID: () => $ZodXID,
  $ZodVoid: () => $ZodVoid,
  $ZodUnknown: () => $ZodUnknown,
  $ZodUnion: () => $ZodUnion,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUUID: () => $ZodUUID,
  $ZodURL: () => $ZodURL,
  $ZodULID: () => $ZodULID,
  $ZodType: () => $ZodType,
  $ZodTuple: () => $ZodTuple,
  $ZodTransform: () => $ZodTransform,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodSymbol: () => $ZodSymbol,
  $ZodSuccess: () => $ZodSuccess,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodString: () => $ZodString,
  $ZodSet: () => $ZodSet,
  $ZodRegistry: () => $ZodRegistry,
  $ZodRecord: () => $ZodRecord,
  $ZodRealError: () => $ZodRealError,
  $ZodReadonly: () => $ZodReadonly,
  $ZodPromise: () => $ZodPromise,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPipe: () => $ZodPipe,
  $ZodOptional: () => $ZodOptional,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodObject: () => $ZodObject,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodNumber: () => $ZodNumber,
  $ZodNullable: () => $ZodNullable,
  $ZodNull: () => $ZodNull,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNever: () => $ZodNever,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNaN: () => $ZodNaN,
  $ZodMap: () => $ZodMap,
  $ZodLiteral: () => $ZodLiteral,
  $ZodLazy: () => $ZodLazy,
  $ZodKSUID: () => $ZodKSUID,
  $ZodJWT: () => $ZodJWT,
  $ZodIntersection: () => $ZodIntersection,
  $ZodISOTime: () => $ZodISOTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODate: () => $ZodISODate,
  $ZodIPv6: () => $ZodIPv6,
  $ZodIPv4: () => $ZodIPv4,
  $ZodGUID: () => $ZodGUID,
  $ZodFunction: () => $ZodFunction,
  $ZodFile: () => $ZodFile,
  $ZodError: () => $ZodError,
  $ZodEnum: () => $ZodEnum,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEmail: () => $ZodEmail,
  $ZodE164: () => $ZodE164,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodDefault: () => $ZodDefault,
  $ZodDate: () => $ZodDate,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodCustom: () => $ZodCustom,
  $ZodCodec: () => $ZodCodec,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheck: () => $ZodCheck,
  $ZodCatch: () => $ZodCatch,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCUID: () => $ZodCUID,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodBoolean: () => $ZodBoolean,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBase64: () => $ZodBase64,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodArray: () => $ZodArray,
  $ZodAny: () => $ZodAny
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = new Set);
    inst._zod.traits.add(name);
    initializer(inst, def);
    for (const k5 in _5.prototype) {
      if (!(k5 in inst))
        Object.defineProperty(inst, k5, { value: _5.prototype[k5].bind(inst) });
    }
    inst._zod.constr = _5;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;

  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _5(def) {
    var _a;
    const inst = params?.Parent ? new Definition : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_5, "init", { value: init });
  Object.defineProperty(_5, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_5, "name", { value: name });
  return _5;
}
var $brand = Symbol("zod_brand");

class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}

class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
}
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
// node_modules/zod/v4/core/util.js
var exports_util2 = {};
__export(exports_util2, {
  unwrapMessage: () => unwrapMessage,
  uint8ArrayToHex: () => uint8ArrayToHex,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  stringifyPrimitive: () => stringifyPrimitive,
  shallowClone: () => shallowClone,
  safeExtend: () => safeExtend,
  required: () => required,
  randomString: () => randomString,
  propertyKeyTypes: () => propertyKeyTypes,
  promiseAllObject: () => promiseAllObject,
  primitiveTypes: () => primitiveTypes,
  prefixIssues: () => prefixIssues,
  pick: () => pick,
  partial: () => partial,
  optionalKeys: () => optionalKeys,
  omit: () => omit,
  objectClone: () => objectClone,
  numKeys: () => numKeys,
  nullish: () => nullish,
  normalizeParams: () => normalizeParams,
  mergeDefs: () => mergeDefs,
  merge: () => merge,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  joinValues: () => joinValues,
  issue: () => issue,
  isPlainObject: () => isPlainObject,
  isObject: () => isObject,
  hexToUint8Array: () => hexToUint8Array,
  getSizableOrigin: () => getSizableOrigin,
  getParsedType: () => getParsedType,
  getLengthableOrigin: () => getLengthableOrigin,
  getEnumValues: () => getEnumValues,
  getElementAtPath: () => getElementAtPath,
  floatSafeRemainder: () => floatSafeRemainder,
  finalizeIssue: () => finalizeIssue,
  extend: () => extend,
  escapeRegex: () => escapeRegex,
  esc: () => esc,
  defineLazy: () => defineLazy,
  createTransparentProxy: () => createTransparentProxy,
  cloneDef: () => cloneDef,
  clone: () => clone,
  cleanRegex: () => cleanRegex,
  cleanEnum: () => cleanEnum,
  captureStackTrace: () => captureStackTrace,
  cached: () => cached,
  base64urlToUint8Array: () => base64urlToUint8Array,
  base64ToUint8Array: () => base64ToUint8Array,
  assignProp: () => assignProp,
  assertNotEqual: () => assertNotEqual,
  assertNever: () => assertNever,
  assertIs: () => assertIs,
  assertEqual: () => assertEqual,
  assert: () => assert,
  allowsEval: () => allowsEval,
  aborted: () => aborted,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  Class: () => Class,
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error;
}
function assert(_5) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v2) => typeof v2 === "number");
  const values = Object.entries(entries).filter(([k5, _5]) => numericValues.indexOf(+k5) === -1).map(([_5, v2]) => v2);
  return values;
}
function joinValues(array, separator = "|") {
  return array.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_5, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        return;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v2) {
      Object.defineProperty(object, key, {
        value: v2
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0;i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0;i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F3 = Function;
    new F3("");
    return true;
  } catch (_5) {
    return false;
  }
});
function isPlainObject(o2) {
  if (isObject(o2) === false)
    return false;
  const ctor = o2.constructor;
  if (ctor === undefined)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o2) {
  if (isPlainObject(o2))
    return { ...o2 };
  if (Array.isArray(o2))
    return [...o2];
  return o2;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = new Set(["string", "number", "symbol"]);
var primitiveTypes = new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl3 = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl3._zod.parent = inst;
  return cl3;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_5, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_5, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_5, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_5, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_5) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_5, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_5, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k5) => {
    return shape[k5]._zod.optin === "optional" && shape[k5]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-340282346638528860000000000000000000000, 340282346638528860000000000000000000000],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a3, b5) {
  const def = mergeDefs(a3._zod.def, {
    get shape() {
      const _shape = { ...a3._zod.def.shape, ...b5._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b5._zod.def.catchall;
    },
    checks: []
  });
  return clone(a3, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class ? new Class({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x4, startIndex = 0) {
  if (x4.aborted === true)
    return true;
  for (let i = startIndex;i < x4.issues.length; i++) {
    if (x4.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k5, _5]) => {
    return Number.isNaN(Number.parseInt(k5, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0;i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0;i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base64.length % 4) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0;i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b5) => b5.toString(16).padStart(2, "0")).join("");
}

class Class {
  constructor(..._args) {}
}

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error2, path = []) => {
    var _a, _b;
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error) {
  const lines = [];
  const issues = [...error.issues].sort((a3, b5) => (a3.path ?? []).length - (b5.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`✖ ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  → at ${toDotPath(issue2.path)}`);
  }
  return lines.join(`
`);
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError;
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = /* @__PURE__ */ _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = /* @__PURE__ */ _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
// node_modules/zod/v4/core/regexes.js
var exports_regexes = {};
__export(exports_regexes, {
  xid: () => xid,
  uuid7: () => uuid7,
  uuid6: () => uuid6,
  uuid4: () => uuid4,
  uuid: () => uuid,
  uppercase: () => uppercase,
  unicodeEmail: () => unicodeEmail,
  undefined: () => _undefined,
  ulid: () => ulid,
  time: () => time,
  string: () => string,
  sha512_hex: () => sha512_hex,
  sha512_base64url: () => sha512_base64url,
  sha512_base64: () => sha512_base64,
  sha384_hex: () => sha384_hex,
  sha384_base64url: () => sha384_base64url,
  sha384_base64: () => sha384_base64,
  sha256_hex: () => sha256_hex,
  sha256_base64url: () => sha256_base64url,
  sha256_base64: () => sha256_base64,
  sha1_hex: () => sha1_hex,
  sha1_base64url: () => sha1_base64url,
  sha1_base64: () => sha1_base64,
  rfc5322Email: () => rfc5322Email,
  number: () => number,
  null: () => _null,
  nanoid: () => nanoid,
  md5_hex: () => md5_hex,
  md5_base64url: () => md5_base64url,
  md5_base64: () => md5_base64,
  lowercase: () => lowercase,
  ksuid: () => ksuid,
  ipv6: () => ipv6,
  ipv4: () => ipv4,
  integer: () => integer,
  idnEmail: () => idnEmail,
  html5Email: () => html5Email,
  hostname: () => hostname,
  hex: () => hex,
  guid: () => guid,
  extendedDuration: () => extendedDuration,
  emoji: () => emoji,
  email: () => email,
  e164: () => e164,
  duration: () => duration,
  domain: () => domain,
  datetime: () => datetime,
  date: () => date,
  cuid2: () => cuid2,
  cuid: () => cuid,
  cidrv6: () => cidrv6,
  cidrv4: () => cidrv4,
  browserEmail: () => browserEmail,
  boolean: () => boolean,
  bigint: () => bigint,
  base64url: () => base64url,
  base64: () => base64
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version) => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = /* @__PURE__ */ uuid(4);
var uuid6 = /* @__PURE__ */ uuid(6);
var uuid7 = /* @__PURE__ */ uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time2 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time2}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
var md5_base64url = /* @__PURE__ */ fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
var sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
var sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
var sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
var sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== undefined;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set);
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {});
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = new Set);
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split(`
`).filter((x4) => x4);
    const minIndent = Math.min(...lines.map((x4) => x4.length - x4.trimStart().length));
    const dedented = lines.map((x4) => x4.slice(minIndent)).map((x4) => " ".repeat(this.indent * 2) + x4);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F3 = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x4) => `  ${x4}`)];
    return new F3(...args, lines.join(`
`));
  }
}

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 1,
  patch: 11
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _5 = ch._zod.check(payload);
        if (_5 instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError;
        }
        if (asyncResult || _5 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _5;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError;
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_5) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _5) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_6) {}
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v2 = versionMap[def.version];
    if (v2 === undefined)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v2));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_5) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error;
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error;
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error;
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error;
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_5) {}
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : undefined : undefined;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_5) {}
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_5) {}
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = new Set([undefined]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {}
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0;i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k5 of keys) {
    if (!def.shape?.[k5]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k5}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!desc?.get) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set);
        for (const v2 of field.values)
          propValues[key].add(v2);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k5 = esc(key);
      return `shape[${k5}]._zod.run({ value: input[${k5}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k5 = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k5}, ...iss.path] : [${k5}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k5} in input) {
            newResult[${k5}] = undefined;
          }
        } else {
          newResult[${k5}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : undefined);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o2) => o2._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o2) => o2._zod.pattern)) {
      const patterns = def.options.map((o2) => o2._zod.pattern);
      return new RegExp(`^(${patterns.map((p4) => cleanRegex(p4.source)).join("|")})$`);
    }
    return;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k5, v2] of Object.entries(pv)) {
        if (!propValues[k5])
          propValues[k5] = new Set;
        for (const val of v2) {
          propValues[k5].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = new Map;
    for (const o2 of opts) {
      const values = o2._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o2)}"`);
      for (const v2 of values) {
        if (map.has(v2)) {
          throw new Error(`Duplicate discriminator value "${String(v2)}"`);
        }
        map.set(v2, o2);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a3, b5) {
  if (a3 === b5) {
    return { valid: true, data: a3 };
  }
  if (a3 instanceof Date && b5 instanceof Date && +a3 === +b5) {
    return { valid: true, data: a3 };
  }
  if (isPlainObject(a3) && isPlainObject(b5)) {
    const bKeys = Object.keys(b5);
    const sharedKeys = Object.keys(a3).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a3, ...b5 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a3[key], b5[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a3) && Array.isArray(b5)) {
    if (a3.length !== b5.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0;index < a3.length; index++) {
      const itemA = a3[index];
      const itemB = b5[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = new Map;
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = new Set;
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k5) => propertyKeyTypes.has(typeof k5)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2 ? escapeRegex(o2.toString()) : String(o2)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError;
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v2 = def.innerType._zod.values;
    return v2 ? new Set([...v2].filter((x4) => x4 !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F3 = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F3({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F3({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F3 = inst.constructor;
    return new F3({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _5) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      path: [...inst._zod.def.path ?? []],
      continue: !inst._zod.def.abort
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
// node_modules/zod/v4/locales/index.js
var exports_locales = {};
__export(exports_locales, {
  zhTW: () => zh_TW_default,
  zhCN: () => zh_CN_default,
  yo: () => yo_default,
  vi: () => vi_default,
  ur: () => ur_default,
  uk: () => uk_default,
  ua: () => ua_default,
  tr: () => tr_default,
  th: () => th_default,
  ta: () => ta_default,
  sv: () => sv_default,
  sl: () => sl_default,
  ru: () => ru_default,
  pt: () => pt_default,
  ps: () => ps_default,
  pl: () => pl_default,
  ota: () => ota_default,
  no: () => no_default,
  nl: () => nl_default,
  ms: () => ms_default,
  mk: () => mk_default,
  lt: () => lt_default,
  ko: () => ko_default,
  km: () => km_default,
  kh: () => kh_default,
  ka: () => ka_default,
  ja: () => ja_default,
  it: () => it_default,
  is: () => is_default,
  id: () => id_default,
  hu: () => hu_default,
  he: () => he_default,
  frCA: () => fr_CA_default,
  fr: () => fr_default,
  fi: () => fi_default,
  fa: () => fa_default,
  es: () => es_default,
  eo: () => eo_default,
  en: () => en_default,
  de: () => de_default,
  da: () => da_default,
  cs: () => cs_default,
  ca: () => ca_default,
  be: () => be_default,
  az: () => az_default,
  ar: () => ar_default
});

// node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${issue2.expected}، ولكن تم إدخال ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `مدخلات غير مقبولة: يفترض إدخال ${stringifyPrimitive(issue2.values[0])}`;
        return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
        return `أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `نَص غير مقبول: يجب أن يبدأ بـ "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue2.divisor}`;
      case "unrecognized_keys":
        return `معرف${issue2.keys.length > 1 ? "ات" : ""} غريب${issue2.keys.length > 1 ? "ة" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${issue2.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${issue2.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}
// node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${issue2.expected}, daxil olan ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanlış dəyər: gözlənilən ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
        if (_issue.format === "ends_with")
          return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
        if (_issue.format === "includes")
          return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
        if (_issue.format === "regex")
          return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
        return `Yanlış ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${issue2.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${issue2.origin} daxilində yanlış dəyər`;
      default:
        return `Yanlış dəyər`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}
// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "лік";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масіў";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${issue2.expected}, атрымана ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Няправільны ўвод: чакалася ${stringifyPrimitive(issue2.values[0])}`;
        return `Няправільны варыянт: чакаўся адзін з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна быць ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта малы: чакалася, што ${issue2.origin} павінна ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Занадта малы: чакалася, што ${issue2.origin} павінна быць ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
        return `Няправільны ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${issue2.keys.length > 1 ? "ключы" : "ключ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${issue2.origin}`;
      default:
        return `Няправільны ўвод`;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}
// node_modules/zod/v4/locales/ca.js
var error4 = () => {
  const Sizable = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invàlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opció invàlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a màxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingués ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mínim" : "més de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingués ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invàlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
        return `Format invàlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      case "invalid_element":
        return `Element invàlid a ${issue2.origin}`;
      default:
        return `Entrada invàlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error4()
  };
}
// node_modules/zod/v4/locales/cs.js
var error5 = () => {
  const Sizable = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "číslo";
      }
      case "string": {
        return "řetězec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${issue2.expected}, obdrženo ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatný vstup: očekáváno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatná možnost: očekávána jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
        return `Neplatný formát ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${issue2.origin}`;
      default:
        return `Neplatný vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error5()
  };
}
// node_modules/zod/v4/locales/da.js
var error6 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "sæt",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslæt",
    date: "ISO-dato",
    time: "ISO-klokkeslæt",
    duration: "ISO-varighed",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig værdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af følgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal være deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøgle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig værdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error6()
  };
}
// node_modules/zod/v4/locales/de.js
var error7 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungültige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungültige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungültiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungültig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${issue2.origin}`;
      default:
        return `Ungültige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error7()
  };
}
// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error8 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error8()
  };
}
// node_modules/zod/v4/locales/eo.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${issue2.expected}, riceviĝis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiĝis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiĝis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiĝis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiĝis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciĝi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiĝi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} ŝlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error9()
  };
}
// node_modules/zod/v4/locales/es.js
var error10 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "número",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "número grande",
    symbol: "símbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "función",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeración",
    union: "unión",
    literal: "literal",
    promise: "promesa",
    void: "vacío",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType3(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opción inválida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado pequeño: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeño: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inválida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
        return `Inválido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada inválida`;
    }
  };
};
function es_default() {
  return {
    localeError: error10()
  };
}
// node_modules/zod/v4/locales/fa.js
var error11 = () => {
  const Sizable = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرایه";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${issue2.expected} می‌بود، ${parsedType3(issue2.input)} دریافت شد`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ورودی نامعتبر: می‌بایست ${stringifyPrimitive(issue2.values[0])} می‌بود`;
        }
        return `گزینه نامعتبر: می‌بایست یکی از ${joinValues(issue2.values, "|")} می‌بود`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
        }
        return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} باشد`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} باشد`;
        }
        return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
        }
        if (_issue.format === "ends_with") {
          return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
        }
        if (_issue.format === "includes") {
          return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
        }
        if (_issue.format === "regex") {
          return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${issue2.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${issue2.keys.length > 1 ? "های" : ""} ناشناس: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${issue2.origin}`;
      case "invalid_union":
        return `ورودی نامعتبر`;
      case "invalid_element":
        return `مقدار نامعتبر در ${issue2.origin}`;
      default:
        return `ورودی نامعتبر`;
    }
  };
};
function fa_default() {
  return {
    localeError: error11()
  };
}
// node_modules/zod/v4/locales/fi.js
var error12 = () => {
  const Sizable = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syöte: täytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: täytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon täytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon täytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syöte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error12()
  };
}
// node_modules/zod/v4/locales/fr.js
var error13 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : ${issue2.expected} attendu, ${parsedType3(issue2.input)} reçu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit être ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit être ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error13()
  };
}
// node_modules/zod/v4/locales/fr-CA.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${issue2.expected}, reçu ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "≤" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "≥" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error14()
  };
}
// node_modules/zod/v4/locales/he.js
var error15 = () => {
  const Sizable = {
    string: { unit: "אותיות", verb: "לכלול" },
    file: { unit: "בייטים", verb: "לכלול" },
    array: { unit: "פריטים", verb: "לכלול" },
    set: { unit: "פריטים", verb: "לכלול" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "קלט",
    email: "כתובת אימייל",
    url: "כתובת רשת",
    emoji: "אימוג'י",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "תאריך וזמן ISO",
    date: "תאריך ISO",
    time: "זמן ISO",
    duration: "משך זמן ISO",
    ipv4: "כתובת IPv4",
    ipv6: "כתובת IPv6",
    cidrv4: "טווח IPv4",
    cidrv6: "טווח IPv6",
    base64: "מחרוזת בבסיס 64",
    base64url: "מחרוזת בבסיס 64 לכתובות רשת",
    json_string: "מחרוזת JSON",
    e164: "מספר E.164",
    jwt: "JWT",
    template_literal: "קלט"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `קלט לא תקין: צריך ${issue2.expected}, התקבל ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `קלט לא תקין: צריך ${stringifyPrimitive(issue2.values[0])}`;
        return `קלט לא תקין: צריך אחת מהאפשרויות  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `מחרוזת לא תקינה: חייבת להתחיל ב"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `מחרוזת לא תקינה: חייבת להסתיים ב "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `מחרוזת לא תקינה: חייבת לכלול "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} לא תקין`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${issue2.divisor}`;
      case "unrecognized_keys":
        return `מפתח${issue2.keys.length > 1 ? "ות" : ""} לא מזוה${issue2.keys.length > 1 ? "ים" : "ה"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `מפתח לא תקין ב${issue2.origin}`;
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${issue2.origin}`;
      default:
        return `קלט לא תקין`;
    }
  };
};
function he_default() {
  return {
    localeError: error15()
  };
}
// node_modules/zod/v4/locales/hu.js
var error16 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szám";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tömb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${issue2.expected}, a kapott érték ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Érvénytelen bemenet: a várt érték ${stringifyPrimitive(issue2.values[0])}`;
        return `Érvénytelen opció: valamelyik érték várt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Túl nagy: ${issue2.origin ?? "érték"} mérete túl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Túl nagy: a bemeneti érték ${issue2.origin ?? "érték"} túl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Túl kicsi: a bemeneti érték ${issue2.origin} mérete túl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Túl kicsi: a bemeneti érték ${issue2.origin} túl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
        if (_issue.format === "ends_with")
          return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
        if (_issue.format === "includes")
          return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
        return `Érvénytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${issue2.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${issue2.origin}`;
      default:
        return `Érvénytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error16()
  };
}
// node_modules/zod/v4/locales/id.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType3 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error17()
  };
}
// node_modules/zod/v4/locales/is.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "númer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error18 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "að hafa" },
    file: { unit: "bæti", verb: "að hafa" },
    array: { unit: "hluti", verb: "að hafa" },
    set: { unit: "hluti", verb: "að hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefslóð",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tími",
    date: "ISO dagsetning",
    time: "ISO tími",
    duration: "ISO tímalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tölugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi: Þú slóst inn ${parsedType3(issue2.input)} þar sem á að vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert ráð fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `Ógilt val: má vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of stórt: gert er ráð fyrir að ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of stórt: gert er ráð fyrir að ${issue2.origin ?? "gildi"} sé ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of lítið: gert er ráð fyrir að ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lítið: gert er ráð fyrir að ${issue2.origin} sé ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ógildur strengur: verður að byrja á "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ógildur strengur: verður að enda á "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ógildur strengur: verður að innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ógildur strengur: verður að fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Röng tala: verður að vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Óþekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill í ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi í ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error18()
  };
}
// node_modules/zod/v4/locales/it.js
var error19 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error19()
  };
}
// node_modules/zod/v4/locales/ja.js
var error20 = () => {
  const Sizable = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "数値";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "配列";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無効な入力: ${issue2.expected}が期待されましたが、${parsedType4(issue2.input)}が入力されました`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無効な入力: ${stringifyPrimitive(issue2.values[0])}が期待されました`;
        return `無効な選択: ${joinValues(issue2.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const adj = issue2.inclusive ? "以下である" : "より小さい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${sizing.unit ?? "要素"}${adj}必要があります`;
        return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${adj}必要があります`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "以上である" : "より大きい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${sizing.unit}${adj}必要があります`;
        return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${adj}必要があります`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
        if (_issue.format === "ends_with")
          return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
        if (_issue.format === "includes")
          return `無効な文字列: "${_issue.includes}"を含む必要があります`;
        if (_issue.format === "regex")
          return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
        return `無効な${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${issue2.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${issue2.keys.length > 1 ? "群" : ""}: ${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${issue2.origin}内の無効な値`;
      default:
        return `無効な入力`;
    }
  };
};
function ja_default() {
  return {
    localeError: error20()
  };
}
// node_modules/zod/v4/locales/ka.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "რიცხვი";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "მასივი";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "სტრინგი",
    boolean: "ბულეანი",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "ფუნქცია"
  };
  return typeMap[t] ?? t;
};
var error21 = () => {
  const Sizable = {
    string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" },
    file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" },
    array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" },
    set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "შეყვანა",
    email: "ელ-ფოსტის მისამართი",
    url: "URL",
    emoji: "ემოჯი",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "თარიღი-დრო",
    date: "თარიღი",
    time: "დრო",
    duration: "ხანგრძლივობა",
    ipv4: "IPv4 მისამართი",
    ipv6: "IPv6 მისამართი",
    cidrv4: "IPv4 დიაპაზონი",
    cidrv6: "IPv6 დიაპაზონი",
    base64: "base64-კოდირებული სტრინგი",
    base64url: "base64url-კოდირებული სტრინგი",
    json_string: "JSON სტრინგი",
    e164: "E.164 ნომერი",
    jwt: "JWT",
    template_literal: "შეყვანა"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `არასწორი შეყვანა: მოსალოდნელი ${issue2.expected}, მიღებული ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `არასწორი შეყვანა: მოსალოდნელი ${stringifyPrimitive(issue2.values[0])}`;
        return `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${joinValues(issue2.values, "|")}-დან`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ზედმეტად დიდი: მოსალოდნელი ${issue2.origin ?? "მნიშვნელობა"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `ზედმეტად დიდი: მოსალოდნელი ${issue2.origin ?? "მნიშვნელობა"} იყოს ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ზედმეტად პატარა: მოსალოდნელი ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `ზედმეტად პატარა: მოსალოდნელი ${issue2.origin} იყოს ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `არასწორი სტრინგი: უნდა იწყებოდეს "${_issue.prefix}"-ით`;
        }
        if (_issue.format === "ends_with")
          return `არასწორი სტრინგი: უნდა მთავრდებოდეს "${_issue.suffix}"-ით`;
        if (_issue.format === "includes")
          return `არასწორი სტრინგი: უნდა შეიცავდეს "${_issue.includes}"-ს`;
        if (_issue.format === "regex")
          return `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${_issue.pattern}`;
        return `არასწორი ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `არასწორი რიცხვი: უნდა იყოს ${issue2.divisor}-ის ჯერადი`;
      case "unrecognized_keys":
        return `უცნობი გასაღებ${issue2.keys.length > 1 ? "ები" : "ი"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `არასწორი გასაღები ${issue2.origin}-ში`;
      case "invalid_union":
        return "არასწორი შეყვანა";
      case "invalid_element":
        return `არასწორი მნიშვნელობა ${issue2.origin}-ში`;
      default:
        return `არასწორი შეყვანა`;
    }
  };
};
function ka_default() {
  return {
    localeError: error21()
  };
}
// node_modules/zod/v4/locales/km.js
var error22 = () => {
  const Sizable = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "អារេ (Array)";
        }
        if (data === null) {
          return "គ្មានតម្លៃ (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${issue2.expected} ប៉ុន្តែទទួលបាន ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${stringifyPrimitive(issue2.values[0])}`;
        return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "ធាតុ"}`;
        return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;
        return `មិនត្រឹមត្រូវ៖ ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue2.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      case "invalid_union":
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      default:
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
    }
  };
};
function km_default() {
  return {
    localeError: error22()
  };
}

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
// node_modules/zod/v4/locales/ko.js
var error23 = () => {
  const Sizable = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType5 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${issue2.expected}, 받은 타입은 ${parsedType5(issue2.input)}입니다`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `잘못된 입력: 값은 ${stringifyPrimitive(issue2.values[0])} 이어야 합니다`;
        return `잘못된 옵션: ${joinValues(issue2.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const adj = issue2.inclusive ? "이하" : "미만";
        const suffix = adj === "미만" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing)
          return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "이상" : "초과";
        const suffix = adj === "이상" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = sizing?.unit ?? "요소";
        if (sizing) {
          return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
        }
        if (_issue.format === "ends_with")
          return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
        if (_issue.format === "includes")
          return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
        if (_issue.format === "regex")
          return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
        return `잘못된 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${issue2.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${issue2.origin}`;
      case "invalid_union":
        return `잘못된 입력`;
      case "invalid_element":
        return `잘못된 값: ${issue2.origin}`;
      default:
        return `잘못된 입력`;
    }
  };
};
function ko_default() {
  return {
    localeError: error23()
  };
}
// node_modules/zod/v4/locales/lt.js
var parsedType5 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
};
var parsedTypeFromType = (t, data = undefined) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skaičius";
    }
    case "bigint": {
      return "sveikasis skaičius";
    }
    case "string": {
      return "eilutė";
    }
    case "boolean": {
      return "loginė reikšmė";
    }
    case "undefined":
    case "void": {
      return "neapibrėžta reikšmė";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === undefined)
        return "nežinomas objektas";
      if (data === null)
        return "nulinė reikšmė";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    case "null": {
      return "nulinė reikšmė";
    }
  }
  return t;
};
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number2) {
  const abs = Math.abs(number2);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error24 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simbolių"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne ilgesnė kaip",
          notInclusive: "turi būti trumpesnė kaip"
        },
        bigger: {
          inclusive: "turi būti ne trumpesnė kaip",
          notInclusive: "turi būti ilgesnė kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "baitų"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne didesnis kaip",
          notInclusive: "turi būti mažesnis kaip"
        },
        bigger: {
          inclusive: "turi būti ne mažesnis kaip",
          notInclusive: "turi būti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "įvestis",
    email: "el. pašto adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukmė",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 užkoduota eilutė",
    base64url: "base64url užkoduota eilutė",
    json_string: "JSON eilutė",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "įvestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType5(issue2.input)}, o tikėtasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo būti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo būti vienas iš ${joinValues(issue2.values, "|")} pasirinkimų`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "mažesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi būti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing?.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "elementų"}`;
        const adj = issue2.inclusive ? "ne mažesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi būti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilutė privalo prasidėti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilutė privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilutė privalo įtraukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilutė privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaičius privalo būti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpažint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga įvestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikšmė")} turi klaidingą įvestį`;
      }
      default:
        return "Klaidinga įvestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error24()
  };
}
// node_modules/zod/v4/locales/mk.js
var error25 = () => {
  const Sizable = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "број";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "низа";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${issue2.expected}, примено ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Грешана опција: се очекува една ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да има ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементи"}`;
        return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да биде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Премногу мал: се очекува ${issue2.origin} да има ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Премногу мал: се очекува ${issue2.origin} да биде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${issue2.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${issue2.origin}`;
      default:
        return `Грешен внес`;
    }
  };
};
function mk_default() {
  return {
    localeError: error25()
  };
}
// node_modules/zod/v4/locales/ms.js
var error26 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error26()
  };
}
// node_modules/zod/v4/locales/nl.js
var error27 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht één van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error27()
  };
}
// node_modules/zod/v4/locales/no.js
var error28 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: må starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: må ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: må inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error28()
  };
}
// node_modules/zod/v4/locales/ota.js
var error29 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${issue2.expected}, alınan ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fâsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fâsit tercih: mûteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
        return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
        }
        return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
        if (_issue.format === "ends_with")
          return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
        if (_issue.format === "regex")
          return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
        return `Fâsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${issue2.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${issue2.origin} için tanınmayan kıymet var.`;
      default:
        return `Kıymet tanınamadı.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error29()
  };
}
// node_modules/zod/v4/locales/ps.js
var error30 = () => {
  const Sizable = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "ارې";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${issue2.expected} وای, مګر ${parsedType6(issue2.input)} ترلاسه شو`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ناسم ورودي: باید ${stringifyPrimitive(issue2.values[0])} وای`;
        }
        return `ناسم انتخاب: باید یو له ${joinValues(issue2.values, "|")} څخه وای`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصرونه"} ولري`;
        }
        return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} وي`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} ولري`;
        }
        return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ناسم متن: باید د "${_issue.prefix}" سره پیل شي`;
        }
        if (_issue.format === "ends_with") {
          return `ناسم متن: باید د "${_issue.suffix}" سره پای ته ورسيږي`;
        }
        if (_issue.format === "includes") {
          return `ناسم متن: باید "${_issue.includes}" ولري`;
        }
        if (_issue.format === "regex") {
          return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${issue2.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${issue2.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${issue2.origin} کې`;
      case "invalid_union":
        return `ناسمه ورودي`;
      case "invalid_element":
        return `ناسم عنصر په ${issue2.origin} کې`;
      default:
        return `ناسمه ورودي`;
    }
  };
};
function ps_default() {
  return {
    localeError: error30()
  };
}
// node_modules/zod/v4/locales/pl.js
var error31 = () => {
  const Sizable = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidłowe dane wejściowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za duża wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt duż(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za mała wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt mał(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
        return `Nieprawidłow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${issue2.origin}`;
      default:
        return `Nieprawidłowe dane wejściowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error31()
  };
}
// node_modules/zod/v4/locales/pt.js
var error32 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "número";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${issue2.expected}, recebido ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opção inválida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inválido: deve começar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inválido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inválido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${issue2.origin}`;
      default:
        return `Campo inválido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error32()
  };
}
// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error33 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "массив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${issue2.expected}, получено ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неверный ввод: ожидалось ${stringifyPrimitive(issue2.values[0])}`;
        return `Неверный вариант: ожидалось одно из ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет иметь ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет иметь ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неверная строка: должна содержать "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
        return `Неверный ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${issue2.keys.length > 1 ? "ые" : "ый"} ключ${issue2.keys.length > 1 ? "и" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${issue2.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${issue2.origin}`;
      default:
        return `Неверные входные данные`;
    }
  };
};
function ru_default() {
  return {
    localeError: error33()
  };
}
// node_modules/zod/v4/locales/sl.js
var error34 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "število";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${issue2.expected}, prejeto ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pričakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna možnost: pričakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pričakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pričakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i ključi" : " ključ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error34()
  };
}
// node_modules/zod/v4/locales/sv.js
var error35 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${issue2.expected}, fick ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: förväntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: förväntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För stor(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `För stor(t): förväntat ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig sträng: måste börja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig sträng: måste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig sträng: måste innehålla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig sträng: måste matcha mönstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${issue2.origin ?? "värdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error35()
  };
}
// node_modules/zod/v4/locales/ta.js
var error36 = () => {
  const Sizable = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "எண் அல்லாதது" : "எண்";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "அணி";
        }
        if (data === null) {
          return "வெறுமை";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue2.expected}, பெறப்பட்டது ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${stringifyPrimitive(issue2.values[0])}`;
        return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${joinValues(issue2.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
        }
        return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`;
        }
        return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
        if (_issue.format === "ends_with")
          return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
        if (_issue.format === "includes")
          return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
        if (_issue.format === "regex")
          return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
        return `தவறான ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${issue2.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${issue2.keys.length > 1 ? "கள்" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${issue2.origin} இல் தவறான மதிப்பு`;
      default:
        return `தவறான உள்ளீடு`;
    }
  };
};
function ta_default() {
  return {
    localeError: error36()
  };
}
// node_modules/zod/v4/locales/th.js
var error37 = () => {
  const Sizable = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType6 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "อาร์เรย์ (Array)";
        }
        if (data === null) {
          return "ไม่มีค่า (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue2.expected} แต่ได้รับ ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ค่าไม่ถูกต้อง: ควรเป็น ${stringifyPrimitive(issue2.values[0])}`;
        return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "ไม่เกิน" : "น้อยกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
        return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "อย่างน้อย" : "มากกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
        if (_issue.format === "regex")
          return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
        return `รูปแบบไม่ถูกต้อง: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue2.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${issue2.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${issue2.origin}`;
      default:
        return `ข้อมูลไม่ถูกต้อง`;
    }
  };
};
function th_default() {
  return {
    localeError: error37()
  };
}
// node_modules/zod/v4/locales/tr.js
var parsedType6 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error38 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${issue2.expected}, alınan ${parsedType6(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geçersiz değer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "öğe"}`;
        return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
        if (_issue.format === "ends_with")
          return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geçersiz metin: "${_issue.includes}" içermeli`;
        if (_issue.format === "regex")
          return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
        return `Geçersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${issue2.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${issue2.origin} içinde geçersiz değer`;
      default:
        return `Geçersiz değer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error38()
  };
}
// node_modules/zod/v4/locales/uk.js
var error39 = () => {
  const Sizable = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "масив";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${issue2.expected}, отримано ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неправильні вхідні дані: очікується ${stringifyPrimitive(issue2.values[0])}`;
        return `Неправильна опція: очікується одне з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементів"}`;
        return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} буде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Занадто мале: очікується, що ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Занадто мале: очікується, що ${issue2.origin} буде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неправильний рядок: повинен містити "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
        return `Неправильний ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${issue2.keys.length > 1 ? "і" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${issue2.origin}`;
      default:
        return `Неправильні вхідні дані`;
    }
  };
};
function uk_default() {
  return {
    localeError: error39()
  };
}

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
// node_modules/zod/v4/locales/ur.js
var error40 = () => {
  const Sizable = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "نمبر";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "آرے";
        }
        if (data === null) {
          return "نل";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${issue2.expected} متوقع تھا، ${parsedType7(issue2.input)} موصول ہوا`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `غلط ان پٹ: ${stringifyPrimitive(issue2.values[0])} متوقع تھا`;
        return `غلط آپشن: ${joinValues(issue2.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کے ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
        return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کا ${adj}${issue2.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `بہت چھوٹا: ${issue2.origin} کے ${adj}${issue2.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
        }
        return `بہت چھوٹا: ${issue2.origin} کا ${adj}${issue2.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
        }
        if (_issue.format === "ends_with")
          return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
        if (_issue.format === "includes")
          return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
        if (_issue.format === "regex")
          return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
        return `غلط ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${issue2.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${issue2.keys.length > 1 ? "ز" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `${issue2.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${issue2.origin} میں غلط ویلیو`;
      default:
        return `غلط ان پٹ`;
    }
  };
};
function ur_default() {
  return {
    localeError: error40()
  };
}
// node_modules/zod/v4/locales/vi.js
var error41 = () => {
  const Sizable = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "số";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mảng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${issue2.expected}, nhận được ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Đầu vào không hợp lệ: mong đợi ${stringifyPrimitive(issue2.values[0])}`;
        return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
        return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Quá nhỏ: mong đợi ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Quá nhỏ: mong đợi ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${issue2.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${issue2.origin}`;
      default:
        return `Đầu vào không hợp lệ`;
    }
  };
};
function vi_default() {
  return {
    localeError: error41()
  };
}
// node_modules/zod/v4/locales/zh-CN.js
var error42 = () => {
  const Sizable = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "非数字(NaN)" : "数字";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "数组";
        }
        if (data === null) {
          return "空值(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `无效输入：期望 ${issue2.expected}，实际接收 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `无效输入：期望 ${stringifyPrimitive(issue2.values[0])}`;
        return `无效选项：期望以下之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "个元素"}`;
        return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `无效字符串：必须以 "${_issue.prefix}" 开头`;
        if (_issue.format === "ends_with")
          return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
        if (_issue.format === "includes")
          return `无效字符串：必须包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
        return `无效${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${issue2.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${issue2.origin} 中包含无效值(value)`;
      default:
        return `无效输入`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error42()
  };
}
// node_modules/zod/v4/locales/zh-TW.js
var error43 = () => {
  const Sizable = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${issue2.expected}，但收到 ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無效的輸入值：預期為 ${stringifyPrimitive(issue2.values[0])}`;
        return `無效的選項：預期為以下其中之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "個元素"}`;
        return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
        }
        if (_issue.format === "ends_with")
          return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
        if (_issue.format === "includes")
          return `無效的字串：必須包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `無效的字串：必須符合格式 ${_issue.pattern}`;
        return `無效的 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${issue2.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${issue2.keys.length > 1 ? "們" : ""}：${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${issue2.origin} 中有無效的值`;
      default:
        return `無效的輸入值`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error43()
  };
}
// node_modules/zod/v4/locales/yo.js
var error44 = () => {
  const Sizable = {
    string: { unit: "àmi", verb: "ní" },
    file: { unit: "bytes", verb: "ní" },
    array: { unit: "nkan", verb: "ní" },
    set: { unit: "nkan", verb: "ní" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType7 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nọ́mbà";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akopọ";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ẹ̀rọ ìbáwọlé",
    email: "àdírẹ́sì ìmẹ́lì",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "àkókò ISO",
    date: "ọjọ́ ISO",
    time: "àkókò ISO",
    duration: "àkókò tó pé ISO",
    ipv4: "àdírẹ́sì IPv4",
    ipv6: "àdírẹ́sì IPv6",
    cidrv4: "àgbègbè IPv4",
    cidrv6: "àgbègbè IPv6",
    base64: "ọ̀rọ̀ tí a kọ́ ní base64",
    base64url: "ọ̀rọ̀ base64url",
    json_string: "ọ̀rọ̀ JSON",
    e164: "nọ́mbà E.164",
    jwt: "JWT",
    template_literal: "ẹ̀rọ ìbáwọlé"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ìbáwọlé aṣìṣe: a ní láti fi ${issue2.expected}, àmọ̀ a rí ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ìbáwọlé aṣìṣe: a ní láti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tó pọ̀ jù: a ní láti jẹ́ pé ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `Tó pọ̀ jù: a ní láti jẹ́ ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kéré ju: a ní láti jẹ́ pé ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kéré ju: a ní láti jẹ́ ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${_issue.pattern}`;
        return `Aṣìṣe: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Bọtìnì àìmọ̀: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Bọtìnì aṣìṣe nínú ${issue2.origin}`;
      case "invalid_union":
        return "Ìbáwọlé aṣìṣe";
      case "invalid_element":
        return `Iye aṣìṣe nínú ${issue2.origin}`;
      default:
        return "Ìbáwọlé aṣìṣe";
    }
  };
};
function yo_default() {
  return {
    localeError: error44()
  };
}
// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");

class $ZodRegistry {
  constructor() {
    this._map = new WeakMap;
    this._idmap = new Map;
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new WeakMap;
    this._idmap = new Map;
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p4 = schema._zod.parent;
    if (p4) {
      const pm2 = { ...this.get(p4) ?? {} };
      delete pm2.id;
      const f2 = { ...pm2, ...this._map.get(schema) };
      return Object.keys(f2).length ? f2 : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
function registry() {
  return new $ZodRegistry;
}
var globalRegistry = /* @__PURE__ */ registry();
// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [v2, v2])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
    falsyArray = falsyArray.map((v2) => typeof v2 === "string" ? v2.toLowerCase() : v2);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
// node_modules/zod/v4/core/to-json-schema.js
class JSONSchemaGenerator {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {});
    this.io = params?.io ?? "output";
    this.seen = new Map;
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.minimum = exclusiveMinimum;
                json.exclusiveMinimum = true;
              } else {
                json.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.maximum = exclusiveMaximum;
                json.exclusiveMaximum = true;
              } else {
                json.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v2 = def.shape[key]._zod;
              if (this.io === "input") {
                return v2.optin === undefined;
              } else {
                return v2.optout === undefined;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            const options = def.options.map((x4, i) => this.process(x4, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            json.anyOf = options;
            break;
          }
          case "intersection": {
            const json = _json;
            const a3 = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b5 = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => ("allOf" in val) && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a3) ? a3.allOf : [a3],
              ...isSimpleIntersection(b5) ? b5.allOf : [b5]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x4, i) => this.process(x4, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
              if (rest) {
                json.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json.items.anyOf.push(rest);
              }
              json.minItems = prefixItems.length;
              if (!rest) {
                json.maxItems = prefixItems.length;
              }
            } else {
              json.items = prefixItems;
              if (rest) {
                json.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v2) => typeof v2 === "number"))
              json.type = "number";
            if (values.every((v2) => typeof v2 === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === undefined) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {}
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {} else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json.enum = [val];
              } else {
                json.const = val;
              }
            } else {
              if (vals.every((v2) => typeof v2 === "number"))
                json.type = "number";
              if (vals.every((v2) => typeof v2 === "string"))
                json.type = "string";
              if (vals.every((v2) => typeof v2 === "boolean"))
                json.type = "string";
              if (vals.every((v2) => v2 === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== undefined)
              file.minLength = minimum;
            if (maximum !== undefined)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m4) => {
                  const mFile = { ...file, contentMediaType: m4 };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(undefined);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {}
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      external: _params?.external ?? undefined
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error("Cycle detected: " + `#/${seen.cycle?.join("/")}/<root>` + '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {} else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {} else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
}
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_5, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: new Set };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    case "function": {
      return false;
    }
    default:
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}
// node_modules/zod/v4/core/json-schema.js
var exports_json_schema = {};
// node_modules/zod/v4/classic/iso.js
var exports_iso = {};
__export(exports_iso, {
  time: () => time2,
  duration: () => duration2,
  datetime: () => datetime2,
  date: () => date2,
  ZodISOTime: () => ZodISOTime,
  ZodISODuration: () => ZodISODuration,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODate: () => ZodISODate
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse3 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
var encode2 = /* @__PURE__ */ _encode(ZodRealError);
var decode2 = /* @__PURE__ */ _decode(ZodRealError);
var encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
var decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
var safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
var safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
var safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks2) => {
    return inst.clone(exports_util2.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks2.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }));
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl3 = inst.clone();
    globalRegistry.add(cl3, { description });
    return cl3;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl3 = inst.clone();
    globalRegistry.add(cl3, args[0]);
    return cl3;
  };
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: exports_regexes.domain,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", exports_regexes.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", exports_regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = exports_regexes[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c2 = inst._zod.bag;
  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  exports_util2.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = (incoming) => {
    return exports_util2.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return exports_util2.safeExtend(inst, incoming);
  };
  inst.merge = (other) => exports_util2.merge(inst, other);
  inst.pick = (mask) => exports_util2.pick(inst, mask);
  inst.omit = (mask) => exports_util2.omit(inst, mask);
  inst.partial = (...args) => exports_util2.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => exports_util2.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...exports_util2.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...exports_util2.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...exports_util2.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k5 = clone(keyType);
  k5._zod.values = undefined;
  return new ZodRecord({
    type: "record",
    keyType: k5,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...exports_util2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v2) => [v2, v2])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...exports_util2.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(exports_util2.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(exports_util2.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : exports_util2.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...exports_util2.normalizeParams(params)
  });
}
var ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...exports_util2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
// node_modules/zod/v4/classic/coerce.js
var exports_coerce = {};
__export(exports_coerce, {
  string: () => string3,
  number: () => number3,
  date: () => date4,
  boolean: () => boolean3,
  bigint: () => bigint3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());
// src/shared/errors.ts
class AppError extends Error {
  statusCode;
  constructor(message, statusCode = 400) {
    super(message);
    this.statusCode = statusCode;
  }
}

class UnauthorizedError extends AppError {
  constructor(message = "Unauthorized") {
    super(message, 401);
  }
}

class ConflictError extends AppError {
  constructor(message = "Conflict") {
    super(message, 409);
  }
}

// src/shared/password.ts
var import_bcrypt = __toESM(require_bcrypt(), 1);
var SALT_ROUNDS = 10;
async function hashPassword(plain) {
  return import_bcrypt.default.hash(plain, SALT_ROUNDS);
}
async function verifyPassword(plain, hash2) {
  return import_bcrypt.default.compare(plain, hash2);
}

// src/application/use-cases/RegisterUser.ts
class RegisterUserUseCase {
  credentials;
  constructor(credentials) {
    this.credentials = credentials;
  }
  async execute(input) {
    const existing = await this.credentials.findByUsername(input.username);
    if (existing) {
      throw new ConflictError("Username already exists");
    }
    const hash2 = await hashPassword(input.password);
    const cred = await this.credentials.create(input.username, hash2);
    return { userId: cred.userId, username: cred.username };
  }
}

// src/shared/jwt.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);

// config/env.ts
var import_dotenv = __toESM(require_main(), 1);
import_dotenv.default.config();
var env = {
  port: parseInt(process.env.PORT || "3000", 10),
  jwtAccessSecret: process.env.JWT_ACCESS_SECRET || "",
  jwtRefreshSecret: process.env.JWT_REFRESH_SECRET || "",
  jwtAccessTtl: process.env.JWT_ACCESS_TTL || "15m",
  jwtRefreshTtl: process.env.JWT_REFRESH_TTL || "30d",
  databaseUrl: process.env.DATABASE_URL || ""
};
Object.entries(env).forEach(([key, value]) => {
  if (!value || value === "") {
    console.error(`[env] ${key} is not set`);
    process.exit(1);
  }
});

// src/shared/jwt.ts
function signAccessToken(payload) {
  return import_jsonwebtoken.default.sign(payload, env.jwtAccessSecret, { expiresIn: env.jwtAccessTtl });
}
function signRefreshToken(payload) {
  return import_jsonwebtoken.default.sign(payload, env.jwtRefreshSecret, { expiresIn: env.jwtRefreshTtl });
}
function verifyAccessToken(token) {
  return import_jsonwebtoken.default.verify(token, env.jwtAccessSecret);
}
function verifyRefreshToken(token) {
  return import_jsonwebtoken.default.verify(token, env.jwtRefreshSecret);
}

// src/application/use-cases/LoginUser.ts
class LoginUserUseCase {
  credentials;
  refreshTokens;
  constructor(credentials, refreshTokens) {
    this.credentials = credentials;
    this.refreshTokens = refreshTokens;
  }
  async execute(input) {
    const cred = await this.credentials.findByUsername(input.username);
    if (!cred)
      throw new UnauthorizedError("Invalid credentials");
    const ok = await verifyPassword(input.password, cred.hash);
    if (!ok)
      throw new UnauthorizedError("Invalid credentials");
    const payload = { userId: cred.userId };
    const accessToken = signAccessToken(payload);
    const refreshToken = signRefreshToken(payload);
    await this.refreshTokens.create(cred.userId, refreshToken, null);
    return { accessToken, refreshToken };
  }
}

// src/application/use-cases/RefreshTokens.ts
class RefreshTokensUseCase {
  refreshTokens;
  constructor(refreshTokens) {
    this.refreshTokens = refreshTokens;
  }
  async execute(input) {
    const stored = await this.refreshTokens.findByToken(input.refreshToken);
    if (!stored)
      throw new UnauthorizedError("Invalid refresh token");
    try {
      const { userId } = verifyRefreshToken(input.refreshToken);
      await this.refreshTokens.incrementRefreshCount(input.refreshToken);
      const newAccess = signAccessToken({ userId });
      return { accessToken: newAccess };
    } catch (e) {
      console.log(e);
      throw new UnauthorizedError("Invalid or expired refresh token");
    }
  }
}

// src/application/use-cases/LogoutUser.ts
class LogoutUserUseCase {
  refreshTokens;
  constructor(refreshTokens) {
    this.refreshTokens = refreshTokens;
  }
  async execute(input) {
    if (input.refreshToken) {
      await this.refreshTokens.deleteByToken(input.refreshToken);
      return;
    }
    if (input.userId) {
      await this.refreshTokens.deleteAllForUser(input.userId);
    }
  }
}

// src/application/use-cases/TokenIntrospection.ts
class TokenIntrospectionUseCase {
  async execute(input) {
    try {
      if (!input.authHeader)
        throw new Error("empty auth header");
      if (!input.authHeader.startsWith("Bearer "))
        throw new Error("auth token is not Bearer");
      const accessToken = input.authHeader.split(" ")[1];
      if (!input.authHeader.startsWith("Bearer "))
        throw new Error("Bearer token not found");
      verifyAccessToken(accessToken);
      return { active: true };
    } catch (e) {
      return { active: false };
    }
  }
}

// src/infrastructure/prisma/prismaClient.ts
var import_prisma = __toESM(require_default(), 1);
var prisma = new import_prisma.PrismaClient({
  log: ["query", "info", "warn", "error"]
});

// src/domain/entities/Credential.ts
class CredentialEntity {
  userId;
  username;
  hash;
  createdAt;
  updatedAt;
  constructor(props) {
    this.userId = props.userId;
    this.username = props.username;
    this.hash = props.hash;
    this.createdAt = props.createdAt;
    this.updatedAt = props.updatedAt;
  }
}

// src/infrastructure/prisma/repositories/PrismaCredentialRepository.ts
class PrismaCredentialRepository {
  async findByUsername(username) {
    const row = await prisma.credential.findUnique({ where: { username } });
    if (!row)
      return null;
    return new CredentialEntity({
      userId: row.userId,
      username: row.username,
      hash: row.hash,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt
    });
  }
  async findByUserId(userId) {
    const row = await prisma.credential.findUnique({ where: { userId } });
    if (!row)
      return null;
    return new CredentialEntity({
      userId: row.userId,
      username: row.username,
      hash: row.hash,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt
    });
  }
  async create(username, hash2) {
    const row = await prisma.credential.create({ data: { username, hash: hash2 } });
    return new CredentialEntity({
      userId: row.userId,
      username: row.username,
      hash: row.hash,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt
    });
  }
}

// src/domain/entities/RefreshToken.ts
class RefreshTokenEntity {
  token;
  userId;
  refreshCount;
  createdAt;
  updatedAt;
  expiredAt;
  constructor(props) {
    this.token = props.token;
    this.userId = props.userId;
    this.refreshCount = props.refreshCount;
    this.createdAt = props.createdAt;
    this.updatedAt = props.updatedAt;
    this.expiredAt = props.expiredAt;
  }
}

// src/infrastructure/prisma/repositories/PrismaRefreshTokenRepository.ts
class PrismaRefreshTokenRepository {
  async create(userId, token, expiredAt) {
    const row = await prisma.refreshToken.create({
      data: { token, userId, expiredAt: expiredAt ?? null }
    });
    return new RefreshTokenEntity({
      token: row.token,
      userId: row.userId,
      refreshCount: row.refreshCount,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
      expiredAt: row.expiredAt
    });
  }
  async findByToken(token) {
    const row = await prisma.refreshToken.findUnique({ where: { token } });
    if (!row)
      return null;
    return new RefreshTokenEntity({
      token: row.token,
      userId: row.userId,
      refreshCount: row.refreshCount,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
      expiredAt: row.expiredAt
    });
  }
  async incrementRefreshCount(token) {
    const row = await prisma.refreshToken.update({
      where: { token },
      data: { refreshCount: { increment: 1 } }
    });
    return new RefreshTokenEntity({
      token: row.token,
      userId: row.userId,
      refreshCount: row.refreshCount,
      createdAt: row.createdAt,
      updatedAt: row.updatedAt,
      expiredAt: row.expiredAt
    });
  }
  async deleteByToken(token) {
    await prisma.refreshToken.delete({ where: { token } });
  }
  async deleteAllForUser(userId) {
    await prisma.refreshToken.deleteMany({ where: { userId } });
  }
}

// src/infrastructure/http/auth.routes.ts
async function authRoutes(app) {
  const credentialRepo = new PrismaCredentialRepository;
  const refreshRepo = new PrismaRefreshTokenRepository;
  app.get("/token-introspection", async (request, reply) => {
    const authHeader = request.headers.authorization;
    const useCase = new TokenIntrospectionUseCase;
    try {
      const result = await useCase.execute({ authHeader });
      return reply.send(result);
    } catch (err) {
      if (err instanceof AppError)
        return reply.code(err.statusCode).send({ message: err.message });
      throw err;
    }
  });
  app.post("/register", async (request, reply) => {
    const schema = exports_external.object({ username: exports_external.string().min(3), password: exports_external.string().min(6) });
    const { username, password } = schema.parse(request.body);
    const useCase = new RegisterUserUseCase(credentialRepo);
    try {
      const result = await useCase.execute({ username, password });
      return reply.code(201).send(result);
    } catch (err) {
      if (err instanceof AppError)
        return reply.code(err.statusCode).send({ message: err.message });
      throw err;
    }
  });
  app.post("/login", async (request, reply) => {
    const schema = exports_external.object({ username: exports_external.string(), password: exports_external.string() });
    const { username, password } = schema.parse(request.body);
    const useCase = new LoginUserUseCase(credentialRepo, refreshRepo);
    try {
      const tokens = await useCase.execute({ username, password });
      return reply.send(tokens);
    } catch (err) {
      if (err instanceof AppError)
        return reply.code(err.statusCode).send({ message: err.message });
      throw err;
    }
  });
  app.post("/refresh", async (request, reply) => {
    const schema = exports_external.object({ refreshToken: exports_external.string() });
    const { refreshToken } = schema.parse(request.body);
    const useCase = new RefreshTokensUseCase(refreshRepo);
    try {
      const tokens = await useCase.execute({ refreshToken });
      return reply.send(tokens);
    } catch (err) {
      if (err instanceof AppError)
        return reply.code(err.statusCode).send({ message: err.message });
      throw err;
    }
  });
  app.post("/logout", async (request, reply) => {
    const schema = exports_external.object({ refreshToken: exports_external.string().optional(), userId: exports_external.string().optional() });
    const { refreshToken, userId } = schema.parse(request.body ?? {});
    const useCase = new LogoutUserUseCase(refreshRepo);
    await useCase.execute({ refreshToken, userId });
    return reply.code(204).send();
  });
}

// src/infrastructure/http/server.ts
init_url();
function buildApp() {
  const app = import_fastify.default({ logger: true });
  app.register(import_fastify_plugin.default(async (instance) => {
    await instance.register(import_cors.default, { origin: true, credentials: true });
    await instance.register(import_sensible.default);
  }));
  app.register(authRoutes, { prefix: "/api/v1/auth" });
  app.setErrorHandler((error45, request, reply) => {
    request.log.error(error45);
    return reply.code(500).send({ message: "Internal Server Error" });
  });
  return app;
}
async function start() {
  const app = buildApp();
  await app.listen({ port: env.port, host: "0.0.0.0" });
}
var isMain = (() => {
  try {
    return ot.fileURLToPath(import.meta.url) === process.argv[1];
  } catch {
    return false;
  }
})();
if (isMain) {
  start().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
export {
  start,
  buildApp
};
